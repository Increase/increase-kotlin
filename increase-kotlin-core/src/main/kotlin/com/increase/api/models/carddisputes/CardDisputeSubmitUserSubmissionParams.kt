// File generated from our OpenAPI spec by Stainless.

package com.increase.api.models.carddisputes

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.increase.api.core.Enum
import com.increase.api.core.ExcludeMissing
import com.increase.api.core.JsonField
import com.increase.api.core.JsonMissing
import com.increase.api.core.JsonValue
import com.increase.api.core.Params
import com.increase.api.core.checkKnown
import com.increase.api.core.checkRequired
import com.increase.api.core.http.Headers
import com.increase.api.core.http.QueryParams
import com.increase.api.core.toImmutable
import com.increase.api.errors.IncreaseInvalidDataException
import java.time.LocalDate
import java.util.Collections
import java.util.Objects

/** Submit a User Submission for a Card Dispute */
class CardDisputeSubmitUserSubmissionParams
private constructor(
    private val cardDisputeId: String?,
    private val body: Body,
    private val additionalHeaders: Headers,
    private val additionalQueryParams: QueryParams,
) : Params {

    /** The identifier of the Card Dispute to submit a user submission for. */
    fun cardDisputeId(): String? = cardDisputeId

    /**
     * The network of the Card Dispute. Details specific to the network are required under the
     * sub-object with the same identifier as the network.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun network(): Network = body.network()

    /**
     * The adjusted monetary amount of the part of the transaction that is being disputed. This is
     * optional and will default to the most recent amount provided. If provided, the amount must be
     * less than or equal to the amount of the transaction.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun amount(): Long? = body.amount()

    /**
     * The files to be attached to the user submission.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun attachmentFiles(): List<AttachmentFile>? = body.attachmentFiles()

    /**
     * The Visa-specific parameters for the dispute. Required if and only if `network` is `visa`.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun visa(): Visa? = body.visa()

    /**
     * Returns the raw JSON value of [network].
     *
     * Unlike [network], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _network(): JsonField<Network> = body._network()

    /**
     * Returns the raw JSON value of [amount].
     *
     * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _amount(): JsonField<Long> = body._amount()

    /**
     * Returns the raw JSON value of [attachmentFiles].
     *
     * Unlike [attachmentFiles], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _attachmentFiles(): JsonField<List<AttachmentFile>> = body._attachmentFiles()

    /**
     * Returns the raw JSON value of [visa].
     *
     * Unlike [visa], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _visa(): JsonField<Visa> = body._visa()

    fun _additionalBodyProperties(): Map<String, JsonValue> = body._additionalProperties()

    /** Additional headers to send with the request. */
    fun _additionalHeaders(): Headers = additionalHeaders

    /** Additional query param to send with the request. */
    fun _additionalQueryParams(): QueryParams = additionalQueryParams

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of
         * [CardDisputeSubmitUserSubmissionParams].
         *
         * The following fields are required:
         * ```kotlin
         * .network()
         * ```
         */
        fun builder() = Builder()
    }

    /** A builder for [CardDisputeSubmitUserSubmissionParams]. */
    class Builder internal constructor() {

        private var cardDisputeId: String? = null
        private var body: Body.Builder = Body.builder()
        private var additionalHeaders: Headers.Builder = Headers.builder()
        private var additionalQueryParams: QueryParams.Builder = QueryParams.builder()

        internal fun from(
            cardDisputeSubmitUserSubmissionParams: CardDisputeSubmitUserSubmissionParams
        ) = apply {
            cardDisputeId = cardDisputeSubmitUserSubmissionParams.cardDisputeId
            body = cardDisputeSubmitUserSubmissionParams.body.toBuilder()
            additionalHeaders = cardDisputeSubmitUserSubmissionParams.additionalHeaders.toBuilder()
            additionalQueryParams =
                cardDisputeSubmitUserSubmissionParams.additionalQueryParams.toBuilder()
        }

        /** The identifier of the Card Dispute to submit a user submission for. */
        fun cardDisputeId(cardDisputeId: String?) = apply { this.cardDisputeId = cardDisputeId }

        /**
         * Sets the entire request body.
         *
         * This is generally only useful if you are already constructing the body separately.
         * Otherwise, it's more convenient to use the top-level setters instead:
         * - [network]
         * - [amount]
         * - [attachmentFiles]
         * - [visa]
         */
        fun body(body: Body) = apply { this.body = body.toBuilder() }

        /**
         * The network of the Card Dispute. Details specific to the network are required under the
         * sub-object with the same identifier as the network.
         */
        fun network(network: Network) = apply { body.network(network) }

        /**
         * Sets [Builder.network] to an arbitrary JSON value.
         *
         * You should usually call [Builder.network] with a well-typed [Network] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun network(network: JsonField<Network>) = apply { body.network(network) }

        /**
         * The adjusted monetary amount of the part of the transaction that is being disputed. This
         * is optional and will default to the most recent amount provided. If provided, the amount
         * must be less than or equal to the amount of the transaction.
         */
        fun amount(amount: Long) = apply { body.amount(amount) }

        /**
         * Sets [Builder.amount] to an arbitrary JSON value.
         *
         * You should usually call [Builder.amount] with a well-typed [Long] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun amount(amount: JsonField<Long>) = apply { body.amount(amount) }

        /** The files to be attached to the user submission. */
        fun attachmentFiles(attachmentFiles: List<AttachmentFile>) = apply {
            body.attachmentFiles(attachmentFiles)
        }

        /**
         * Sets [Builder.attachmentFiles] to an arbitrary JSON value.
         *
         * You should usually call [Builder.attachmentFiles] with a well-typed
         * `List<AttachmentFile>` value instead. This method is primarily for setting the field to
         * an undocumented or not yet supported value.
         */
        fun attachmentFiles(attachmentFiles: JsonField<List<AttachmentFile>>) = apply {
            body.attachmentFiles(attachmentFiles)
        }

        /**
         * Adds a single [AttachmentFile] to [attachmentFiles].
         *
         * @throws IllegalStateException if the field was previously set to a non-list.
         */
        fun addAttachmentFile(attachmentFile: AttachmentFile) = apply {
            body.addAttachmentFile(attachmentFile)
        }

        /**
         * The Visa-specific parameters for the dispute. Required if and only if `network` is
         * `visa`.
         */
        fun visa(visa: Visa) = apply { body.visa(visa) }

        /**
         * Sets [Builder.visa] to an arbitrary JSON value.
         *
         * You should usually call [Builder.visa] with a well-typed [Visa] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun visa(visa: JsonField<Visa>) = apply { body.visa(visa) }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            body.additionalProperties(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            body.putAdditionalProperty(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                body.putAllAdditionalProperties(additionalBodyProperties)
            }

        fun removeAdditionalBodyProperty(key: String) = apply { body.removeAdditionalProperty(key) }

        fun removeAllAdditionalBodyProperties(keys: Set<String>) = apply {
            body.removeAllAdditionalProperties(keys)
        }

        fun additionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.put(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replace(name, value)
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replace(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.remove(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            additionalHeaders.removeAll(names)
        }

        fun additionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.put(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.putAll(additionalQueryParams)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.putAll(additionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replace(key, value)
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replace(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.replaceAll(additionalQueryParams)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.replaceAll(additionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply { additionalQueryParams.remove(key) }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            additionalQueryParams.removeAll(keys)
        }

        /**
         * Returns an immutable instance of [CardDisputeSubmitUserSubmissionParams].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```kotlin
         * .network()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): CardDisputeSubmitUserSubmissionParams =
            CardDisputeSubmitUserSubmissionParams(
                cardDisputeId,
                body.build(),
                additionalHeaders.build(),
                additionalQueryParams.build(),
            )
    }

    fun _body(): Body = body

    fun _pathParam(index: Int): String =
        when (index) {
            0 -> cardDisputeId ?: ""
            else -> ""
        }

    override fun _headers(): Headers = additionalHeaders

    override fun _queryParams(): QueryParams = additionalQueryParams

    class Body
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val network: JsonField<Network>,
        private val amount: JsonField<Long>,
        private val attachmentFiles: JsonField<List<AttachmentFile>>,
        private val visa: JsonField<Visa>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("network") @ExcludeMissing network: JsonField<Network> = JsonMissing.of(),
            @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("attachment_files")
            @ExcludeMissing
            attachmentFiles: JsonField<List<AttachmentFile>> = JsonMissing.of(),
            @JsonProperty("visa") @ExcludeMissing visa: JsonField<Visa> = JsonMissing.of(),
        ) : this(network, amount, attachmentFiles, visa, mutableMapOf())

        /**
         * The network of the Card Dispute. Details specific to the network are required under the
         * sub-object with the same identifier as the network.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun network(): Network = network.getRequired("network")

        /**
         * The adjusted monetary amount of the part of the transaction that is being disputed. This
         * is optional and will default to the most recent amount provided. If provided, the amount
         * must be less than or equal to the amount of the transaction.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun amount(): Long? = amount.getNullable("amount")

        /**
         * The files to be attached to the user submission.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun attachmentFiles(): List<AttachmentFile>? =
            attachmentFiles.getNullable("attachment_files")

        /**
         * The Visa-specific parameters for the dispute. Required if and only if `network` is
         * `visa`.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun visa(): Visa? = visa.getNullable("visa")

        /**
         * Returns the raw JSON value of [network].
         *
         * Unlike [network], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("network") @ExcludeMissing fun _network(): JsonField<Network> = network

        /**
         * Returns the raw JSON value of [amount].
         *
         * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

        /**
         * Returns the raw JSON value of [attachmentFiles].
         *
         * Unlike [attachmentFiles], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("attachment_files")
        @ExcludeMissing
        fun _attachmentFiles(): JsonField<List<AttachmentFile>> = attachmentFiles

        /**
         * Returns the raw JSON value of [visa].
         *
         * Unlike [visa], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("visa") @ExcludeMissing fun _visa(): JsonField<Visa> = visa

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Body].
             *
             * The following fields are required:
             * ```kotlin
             * .network()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Body]. */
        class Builder internal constructor() {

            private var network: JsonField<Network>? = null
            private var amount: JsonField<Long> = JsonMissing.of()
            private var attachmentFiles: JsonField<MutableList<AttachmentFile>>? = null
            private var visa: JsonField<Visa> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(body: Body) = apply {
                network = body.network
                amount = body.amount
                attachmentFiles = body.attachmentFiles.map { it.toMutableList() }
                visa = body.visa
                additionalProperties = body.additionalProperties.toMutableMap()
            }

            /**
             * The network of the Card Dispute. Details specific to the network are required under
             * the sub-object with the same identifier as the network.
             */
            fun network(network: Network) = network(JsonField.of(network))

            /**
             * Sets [Builder.network] to an arbitrary JSON value.
             *
             * You should usually call [Builder.network] with a well-typed [Network] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun network(network: JsonField<Network>) = apply { this.network = network }

            /**
             * The adjusted monetary amount of the part of the transaction that is being disputed.
             * This is optional and will default to the most recent amount provided. If provided,
             * the amount must be less than or equal to the amount of the transaction.
             */
            fun amount(amount: Long) = amount(JsonField.of(amount))

            /**
             * Sets [Builder.amount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.amount] with a well-typed [Long] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

            /** The files to be attached to the user submission. */
            fun attachmentFiles(attachmentFiles: List<AttachmentFile>) =
                attachmentFiles(JsonField.of(attachmentFiles))

            /**
             * Sets [Builder.attachmentFiles] to an arbitrary JSON value.
             *
             * You should usually call [Builder.attachmentFiles] with a well-typed
             * `List<AttachmentFile>` value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun attachmentFiles(attachmentFiles: JsonField<List<AttachmentFile>>) = apply {
                this.attachmentFiles = attachmentFiles.map { it.toMutableList() }
            }

            /**
             * Adds a single [AttachmentFile] to [attachmentFiles].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addAttachmentFile(attachmentFile: AttachmentFile) = apply {
                attachmentFiles =
                    (attachmentFiles ?: JsonField.of(mutableListOf())).also {
                        checkKnown("attachmentFiles", it).add(attachmentFile)
                    }
            }

            /**
             * The Visa-specific parameters for the dispute. Required if and only if `network` is
             * `visa`.
             */
            fun visa(visa: Visa) = visa(JsonField.of(visa))

            /**
             * Sets [Builder.visa] to an arbitrary JSON value.
             *
             * You should usually call [Builder.visa] with a well-typed [Visa] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun visa(visa: JsonField<Visa>) = apply { this.visa = visa }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Body].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .network()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Body =
                Body(
                    checkRequired("network", network),
                    amount,
                    (attachmentFiles ?: JsonMissing.of()).map { it.toImmutable() },
                    visa,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Body = apply {
            if (validated) {
                return@apply
            }

            network().validate()
            amount()
            attachmentFiles()?.forEach { it.validate() }
            visa()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (network.asKnown()?.validity() ?: 0) +
                (if (amount.asKnown() == null) 0 else 1) +
                (attachmentFiles.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (visa.asKnown()?.validity() ?: 0)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Body &&
                network == other.network &&
                amount == other.amount &&
                attachmentFiles == other.attachmentFiles &&
                visa == other.visa &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(network, amount, attachmentFiles, visa, additionalProperties)
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Body{network=$network, amount=$amount, attachmentFiles=$attachmentFiles, visa=$visa, additionalProperties=$additionalProperties}"
    }

    /**
     * The network of the Card Dispute. Details specific to the network are required under the
     * sub-object with the same identifier as the network.
     */
    class Network @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            /** Visa */
            val VISA = of("visa")

            fun of(value: String) = Network(JsonField.of(value))
        }

        /** An enum containing [Network]'s known values. */
        enum class Known {
            /** Visa */
            VISA
        }

        /**
         * An enum containing [Network]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Network] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            /** Visa */
            VISA,
            /** An enum member indicating that [Network] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                VISA -> Value.VISA
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws IncreaseInvalidDataException if this class instance's value is a not a known
         *   member.
         */
        fun known(): Known =
            when (this) {
                VISA -> Known.VISA
                else -> throw IncreaseInvalidDataException("Unknown Network: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws IncreaseInvalidDataException if this class instance's value does not have the
         *   expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): Network = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Network && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    class AttachmentFile
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val fileId: JsonField<String>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("file_id") @ExcludeMissing fileId: JsonField<String> = JsonMissing.of()
        ) : this(fileId, mutableMapOf())

        /**
         * The ID of the file to be attached. The file must have a `purpose` of
         * `card_dispute_attachment`.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun fileId(): String = fileId.getRequired("file_id")

        /**
         * Returns the raw JSON value of [fileId].
         *
         * Unlike [fileId], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("file_id") @ExcludeMissing fun _fileId(): JsonField<String> = fileId

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [AttachmentFile].
             *
             * The following fields are required:
             * ```kotlin
             * .fileId()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [AttachmentFile]. */
        class Builder internal constructor() {

            private var fileId: JsonField<String>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(attachmentFile: AttachmentFile) = apply {
                fileId = attachmentFile.fileId
                additionalProperties = attachmentFile.additionalProperties.toMutableMap()
            }

            /**
             * The ID of the file to be attached. The file must have a `purpose` of
             * `card_dispute_attachment`.
             */
            fun fileId(fileId: String) = fileId(JsonField.of(fileId))

            /**
             * Sets [Builder.fileId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fileId] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fileId(fileId: JsonField<String>) = apply { this.fileId = fileId }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [AttachmentFile].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .fileId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): AttachmentFile =
                AttachmentFile(checkRequired("fileId", fileId), additionalProperties.toMutableMap())
        }

        private var validated: Boolean = false

        fun validate(): AttachmentFile = apply {
            if (validated) {
                return@apply
            }

            fileId()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = (if (fileId.asKnown() == null) 0 else 1)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is AttachmentFile &&
                fileId == other.fileId &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy { Objects.hash(fileId, additionalProperties) }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "AttachmentFile{fileId=$fileId, additionalProperties=$additionalProperties}"
    }

    /**
     * The Visa-specific parameters for the dispute. Required if and only if `network` is `visa`.
     */
    class Visa
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val category: JsonField<Category>,
        private val chargeback: JsonField<Chargeback>,
        private val merchantPrearbitrationDecline: JsonField<MerchantPrearbitrationDecline>,
        private val userPrearbitration: JsonField<UserPrearbitration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("category")
            @ExcludeMissing
            category: JsonField<Category> = JsonMissing.of(),
            @JsonProperty("chargeback")
            @ExcludeMissing
            chargeback: JsonField<Chargeback> = JsonMissing.of(),
            @JsonProperty("merchant_prearbitration_decline")
            @ExcludeMissing
            merchantPrearbitrationDecline: JsonField<MerchantPrearbitrationDecline> =
                JsonMissing.of(),
            @JsonProperty("user_prearbitration")
            @ExcludeMissing
            userPrearbitration: JsonField<UserPrearbitration> = JsonMissing.of(),
        ) : this(
            category,
            chargeback,
            merchantPrearbitrationDecline,
            userPrearbitration,
            mutableMapOf(),
        )

        /**
         * The category of the user submission. Details specific to the category are required under
         * the sub-object with the same identifier as the category.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun category(): Category = category.getRequired("category")

        /**
         * The chargeback details for the user submission. Required if and only if `category` is
         * `chargeback`.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun chargeback(): Chargeback? = chargeback.getNullable("chargeback")

        /**
         * The merchant pre-arbitration decline details for the user submission. Required if and
         * only if `category` is `merchant_prearbitration_decline`.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun merchantPrearbitrationDecline(): MerchantPrearbitrationDecline? =
            merchantPrearbitrationDecline.getNullable("merchant_prearbitration_decline")

        /**
         * The user pre-arbitration details for the user submission. Required if and only if
         * `category` is `user_prearbitration`.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun userPrearbitration(): UserPrearbitration? =
            userPrearbitration.getNullable("user_prearbitration")

        /**
         * Returns the raw JSON value of [category].
         *
         * Unlike [category], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("category") @ExcludeMissing fun _category(): JsonField<Category> = category

        /**
         * Returns the raw JSON value of [chargeback].
         *
         * Unlike [chargeback], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("chargeback")
        @ExcludeMissing
        fun _chargeback(): JsonField<Chargeback> = chargeback

        /**
         * Returns the raw JSON value of [merchantPrearbitrationDecline].
         *
         * Unlike [merchantPrearbitrationDecline], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("merchant_prearbitration_decline")
        @ExcludeMissing
        fun _merchantPrearbitrationDecline(): JsonField<MerchantPrearbitrationDecline> =
            merchantPrearbitrationDecline

        /**
         * Returns the raw JSON value of [userPrearbitration].
         *
         * Unlike [userPrearbitration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("user_prearbitration")
        @ExcludeMissing
        fun _userPrearbitration(): JsonField<UserPrearbitration> = userPrearbitration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Visa].
             *
             * The following fields are required:
             * ```kotlin
             * .category()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Visa]. */
        class Builder internal constructor() {

            private var category: JsonField<Category>? = null
            private var chargeback: JsonField<Chargeback> = JsonMissing.of()
            private var merchantPrearbitrationDecline: JsonField<MerchantPrearbitrationDecline> =
                JsonMissing.of()
            private var userPrearbitration: JsonField<UserPrearbitration> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(visa: Visa) = apply {
                category = visa.category
                chargeback = visa.chargeback
                merchantPrearbitrationDecline = visa.merchantPrearbitrationDecline
                userPrearbitration = visa.userPrearbitration
                additionalProperties = visa.additionalProperties.toMutableMap()
            }

            /**
             * The category of the user submission. Details specific to the category are required
             * under the sub-object with the same identifier as the category.
             */
            fun category(category: Category) = category(JsonField.of(category))

            /**
             * Sets [Builder.category] to an arbitrary JSON value.
             *
             * You should usually call [Builder.category] with a well-typed [Category] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun category(category: JsonField<Category>) = apply { this.category = category }

            /**
             * The chargeback details for the user submission. Required if and only if `category` is
             * `chargeback`.
             */
            fun chargeback(chargeback: Chargeback) = chargeback(JsonField.of(chargeback))

            /**
             * Sets [Builder.chargeback] to an arbitrary JSON value.
             *
             * You should usually call [Builder.chargeback] with a well-typed [Chargeback] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun chargeback(chargeback: JsonField<Chargeback>) = apply {
                this.chargeback = chargeback
            }

            /**
             * The merchant pre-arbitration decline details for the user submission. Required if and
             * only if `category` is `merchant_prearbitration_decline`.
             */
            fun merchantPrearbitrationDecline(
                merchantPrearbitrationDecline: MerchantPrearbitrationDecline
            ) = merchantPrearbitrationDecline(JsonField.of(merchantPrearbitrationDecline))

            /**
             * Sets [Builder.merchantPrearbitrationDecline] to an arbitrary JSON value.
             *
             * You should usually call [Builder.merchantPrearbitrationDecline] with a well-typed
             * [MerchantPrearbitrationDecline] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun merchantPrearbitrationDecline(
                merchantPrearbitrationDecline: JsonField<MerchantPrearbitrationDecline>
            ) = apply { this.merchantPrearbitrationDecline = merchantPrearbitrationDecline }

            /**
             * The user pre-arbitration details for the user submission. Required if and only if
             * `category` is `user_prearbitration`.
             */
            fun userPrearbitration(userPrearbitration: UserPrearbitration) =
                userPrearbitration(JsonField.of(userPrearbitration))

            /**
             * Sets [Builder.userPrearbitration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.userPrearbitration] with a well-typed
             * [UserPrearbitration] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun userPrearbitration(userPrearbitration: JsonField<UserPrearbitration>) = apply {
                this.userPrearbitration = userPrearbitration
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Visa].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .category()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Visa =
                Visa(
                    checkRequired("category", category),
                    chargeback,
                    merchantPrearbitrationDecline,
                    userPrearbitration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Visa = apply {
            if (validated) {
                return@apply
            }

            category().validate()
            chargeback()?.validate()
            merchantPrearbitrationDecline()?.validate()
            userPrearbitration()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (category.asKnown()?.validity() ?: 0) +
                (chargeback.asKnown()?.validity() ?: 0) +
                (merchantPrearbitrationDecline.asKnown()?.validity() ?: 0) +
                (userPrearbitration.asKnown()?.validity() ?: 0)

        /**
         * The category of the user submission. Details specific to the category are required under
         * the sub-object with the same identifier as the category.
         */
        class Category @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                /** Chargeback. */
                val CHARGEBACK = of("chargeback")

                /** Merchant pre-arbitration decline. */
                val MERCHANT_PREARBITRATION_DECLINE = of("merchant_prearbitration_decline")

                /** User pre-arbitration. */
                val USER_PREARBITRATION = of("user_prearbitration")

                fun of(value: String) = Category(JsonField.of(value))
            }

            /** An enum containing [Category]'s known values. */
            enum class Known {
                /** Chargeback. */
                CHARGEBACK,
                /** Merchant pre-arbitration decline. */
                MERCHANT_PREARBITRATION_DECLINE,
                /** User pre-arbitration. */
                USER_PREARBITRATION,
            }

            /**
             * An enum containing [Category]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Category] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                /** Chargeback. */
                CHARGEBACK,
                /** Merchant pre-arbitration decline. */
                MERCHANT_PREARBITRATION_DECLINE,
                /** User pre-arbitration. */
                USER_PREARBITRATION,
                /**
                 * An enum member indicating that [Category] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    CHARGEBACK -> Value.CHARGEBACK
                    MERCHANT_PREARBITRATION_DECLINE -> Value.MERCHANT_PREARBITRATION_DECLINE
                    USER_PREARBITRATION -> Value.USER_PREARBITRATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws IncreaseInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    CHARGEBACK -> Known.CHARGEBACK
                    MERCHANT_PREARBITRATION_DECLINE -> Known.MERCHANT_PREARBITRATION_DECLINE
                    USER_PREARBITRATION -> Known.USER_PREARBITRATION
                    else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws IncreaseInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Category = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Category && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * The chargeback details for the user submission. Required if and only if `category` is
         * `chargeback`.
         */
        class Chargeback
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val category: JsonField<Category>,
            private val authorization: JsonField<Authorization>,
            private val consumerCanceledMerchandise: JsonField<ConsumerCanceledMerchandise>,
            private val consumerCanceledRecurringTransaction:
                JsonField<ConsumerCanceledRecurringTransaction>,
            private val consumerCanceledServices: JsonField<ConsumerCanceledServices>,
            private val consumerCounterfeitMerchandise: JsonField<ConsumerCounterfeitMerchandise>,
            private val consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed>,
            private val consumerDamagedOrDefectiveMerchandise:
                JsonField<ConsumerDamagedOrDefectiveMerchandise>,
            private val consumerMerchandiseMisrepresentation:
                JsonField<ConsumerMerchandiseMisrepresentation>,
            private val consumerMerchandiseNotAsDescribed:
                JsonField<ConsumerMerchandiseNotAsDescribed>,
            private val consumerMerchandiseNotReceived: JsonField<ConsumerMerchandiseNotReceived>,
            private val consumerNonReceiptOfCash: JsonValue,
            private val consumerOriginalCreditTransactionNotAccepted:
                JsonField<ConsumerOriginalCreditTransactionNotAccepted>,
            private val consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise>,
            private val consumerQualityServices: JsonField<ConsumerQualityServices>,
            private val consumerServicesMisrepresentation:
                JsonField<ConsumerServicesMisrepresentation>,
            private val consumerServicesNotAsDescribed: JsonField<ConsumerServicesNotAsDescribed>,
            private val consumerServicesNotReceived: JsonField<ConsumerServicesNotReceived>,
            private val fraud: JsonField<Fraud>,
            private val processingError: JsonField<ProcessingError>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("category")
                @ExcludeMissing
                category: JsonField<Category> = JsonMissing.of(),
                @JsonProperty("authorization")
                @ExcludeMissing
                authorization: JsonField<Authorization> = JsonMissing.of(),
                @JsonProperty("consumer_canceled_merchandise")
                @ExcludeMissing
                consumerCanceledMerchandise: JsonField<ConsumerCanceledMerchandise> =
                    JsonMissing.of(),
                @JsonProperty("consumer_canceled_recurring_transaction")
                @ExcludeMissing
                consumerCanceledRecurringTransaction:
                    JsonField<ConsumerCanceledRecurringTransaction> =
                    JsonMissing.of(),
                @JsonProperty("consumer_canceled_services")
                @ExcludeMissing
                consumerCanceledServices: JsonField<ConsumerCanceledServices> = JsonMissing.of(),
                @JsonProperty("consumer_counterfeit_merchandise")
                @ExcludeMissing
                consumerCounterfeitMerchandise: JsonField<ConsumerCounterfeitMerchandise> =
                    JsonMissing.of(),
                @JsonProperty("consumer_credit_not_processed")
                @ExcludeMissing
                consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed> =
                    JsonMissing.of(),
                @JsonProperty("consumer_damaged_or_defective_merchandise")
                @ExcludeMissing
                consumerDamagedOrDefectiveMerchandise:
                    JsonField<ConsumerDamagedOrDefectiveMerchandise> =
                    JsonMissing.of(),
                @JsonProperty("consumer_merchandise_misrepresentation")
                @ExcludeMissing
                consumerMerchandiseMisrepresentation:
                    JsonField<ConsumerMerchandiseMisrepresentation> =
                    JsonMissing.of(),
                @JsonProperty("consumer_merchandise_not_as_described")
                @ExcludeMissing
                consumerMerchandiseNotAsDescribed: JsonField<ConsumerMerchandiseNotAsDescribed> =
                    JsonMissing.of(),
                @JsonProperty("consumer_merchandise_not_received")
                @ExcludeMissing
                consumerMerchandiseNotReceived: JsonField<ConsumerMerchandiseNotReceived> =
                    JsonMissing.of(),
                @JsonProperty("consumer_non_receipt_of_cash")
                @ExcludeMissing
                consumerNonReceiptOfCash: JsonValue = JsonMissing.of(),
                @JsonProperty("consumer_original_credit_transaction_not_accepted")
                @ExcludeMissing
                consumerOriginalCreditTransactionNotAccepted:
                    JsonField<ConsumerOriginalCreditTransactionNotAccepted> =
                    JsonMissing.of(),
                @JsonProperty("consumer_quality_merchandise")
                @ExcludeMissing
                consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise> =
                    JsonMissing.of(),
                @JsonProperty("consumer_quality_services")
                @ExcludeMissing
                consumerQualityServices: JsonField<ConsumerQualityServices> = JsonMissing.of(),
                @JsonProperty("consumer_services_misrepresentation")
                @ExcludeMissing
                consumerServicesMisrepresentation: JsonField<ConsumerServicesMisrepresentation> =
                    JsonMissing.of(),
                @JsonProperty("consumer_services_not_as_described")
                @ExcludeMissing
                consumerServicesNotAsDescribed: JsonField<ConsumerServicesNotAsDescribed> =
                    JsonMissing.of(),
                @JsonProperty("consumer_services_not_received")
                @ExcludeMissing
                consumerServicesNotReceived: JsonField<ConsumerServicesNotReceived> =
                    JsonMissing.of(),
                @JsonProperty("fraud") @ExcludeMissing fraud: JsonField<Fraud> = JsonMissing.of(),
                @JsonProperty("processing_error")
                @ExcludeMissing
                processingError: JsonField<ProcessingError> = JsonMissing.of(),
            ) : this(
                category,
                authorization,
                consumerCanceledMerchandise,
                consumerCanceledRecurringTransaction,
                consumerCanceledServices,
                consumerCounterfeitMerchandise,
                consumerCreditNotProcessed,
                consumerDamagedOrDefectiveMerchandise,
                consumerMerchandiseMisrepresentation,
                consumerMerchandiseNotAsDescribed,
                consumerMerchandiseNotReceived,
                consumerNonReceiptOfCash,
                consumerOriginalCreditTransactionNotAccepted,
                consumerQualityMerchandise,
                consumerQualityServices,
                consumerServicesMisrepresentation,
                consumerServicesNotAsDescribed,
                consumerServicesNotReceived,
                fraud,
                processingError,
                mutableMapOf(),
            )

            /**
             * Category.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun category(): Category = category.getRequired("category")

            /**
             * Authorization. Required if and only if `category` is `authorization`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun authorization(): Authorization? = authorization.getNullable("authorization")

            /**
             * Canceled merchandise. Required if and only if `category` is
             * `consumer_canceled_merchandise`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerCanceledMerchandise(): ConsumerCanceledMerchandise? =
                consumerCanceledMerchandise.getNullable("consumer_canceled_merchandise")

            /**
             * Canceled recurring transaction. Required if and only if `category` is
             * `consumer_canceled_recurring_transaction`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerCanceledRecurringTransaction(): ConsumerCanceledRecurringTransaction? =
                consumerCanceledRecurringTransaction.getNullable(
                    "consumer_canceled_recurring_transaction"
                )

            /**
             * Canceled services. Required if and only if `category` is
             * `consumer_canceled_services`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerCanceledServices(): ConsumerCanceledServices? =
                consumerCanceledServices.getNullable("consumer_canceled_services")

            /**
             * Counterfeit merchandise. Required if and only if `category` is
             * `consumer_counterfeit_merchandise`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerCounterfeitMerchandise(): ConsumerCounterfeitMerchandise? =
                consumerCounterfeitMerchandise.getNullable("consumer_counterfeit_merchandise")

            /**
             * Credit not processed. Required if and only if `category` is
             * `consumer_credit_not_processed`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerCreditNotProcessed(): ConsumerCreditNotProcessed? =
                consumerCreditNotProcessed.getNullable("consumer_credit_not_processed")

            /**
             * Damaged or defective merchandise. Required if and only if `category` is
             * `consumer_damaged_or_defective_merchandise`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerDamagedOrDefectiveMerchandise(): ConsumerDamagedOrDefectiveMerchandise? =
                consumerDamagedOrDefectiveMerchandise.getNullable(
                    "consumer_damaged_or_defective_merchandise"
                )

            /**
             * Merchandise misrepresentation. Required if and only if `category` is
             * `consumer_merchandise_misrepresentation`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerMerchandiseMisrepresentation(): ConsumerMerchandiseMisrepresentation? =
                consumerMerchandiseMisrepresentation.getNullable(
                    "consumer_merchandise_misrepresentation"
                )

            /**
             * Merchandise not as described. Required if and only if `category` is
             * `consumer_merchandise_not_as_described`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerMerchandiseNotAsDescribed(): ConsumerMerchandiseNotAsDescribed? =
                consumerMerchandiseNotAsDescribed.getNullable(
                    "consumer_merchandise_not_as_described"
                )

            /**
             * Merchandise not received. Required if and only if `category` is
             * `consumer_merchandise_not_received`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerMerchandiseNotReceived(): ConsumerMerchandiseNotReceived? =
                consumerMerchandiseNotReceived.getNullable("consumer_merchandise_not_received")

            /**
             * Non-receipt of cash. Required if and only if `category` is
             * `consumer_non_receipt_of_cash`.
             */
            @JsonProperty("consumer_non_receipt_of_cash")
            @ExcludeMissing
            fun _consumerNonReceiptOfCash(): JsonValue = consumerNonReceiptOfCash

            /**
             * Original Credit Transaction (OCT) not accepted. Required if and only if `category` is
             * `consumer_original_credit_transaction_not_accepted`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerOriginalCreditTransactionNotAccepted():
                ConsumerOriginalCreditTransactionNotAccepted? =
                consumerOriginalCreditTransactionNotAccepted.getNullable(
                    "consumer_original_credit_transaction_not_accepted"
                )

            /**
             * Merchandise quality issue. Required if and only if `category` is
             * `consumer_quality_merchandise`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerQualityMerchandise(): ConsumerQualityMerchandise? =
                consumerQualityMerchandise.getNullable("consumer_quality_merchandise")

            /**
             * Services quality issue. Required if and only if `category` is
             * `consumer_quality_services`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerQualityServices(): ConsumerQualityServices? =
                consumerQualityServices.getNullable("consumer_quality_services")

            /**
             * Services misrepresentation. Required if and only if `category` is
             * `consumer_services_misrepresentation`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerServicesMisrepresentation(): ConsumerServicesMisrepresentation? =
                consumerServicesMisrepresentation.getNullable("consumer_services_misrepresentation")

            /**
             * Services not as described. Required if and only if `category` is
             * `consumer_services_not_as_described`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerServicesNotAsDescribed(): ConsumerServicesNotAsDescribed? =
                consumerServicesNotAsDescribed.getNullable("consumer_services_not_as_described")

            /**
             * Services not received. Required if and only if `category` is
             * `consumer_services_not_received`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun consumerServicesNotReceived(): ConsumerServicesNotReceived? =
                consumerServicesNotReceived.getNullable("consumer_services_not_received")

            /**
             * Fraud. Required if and only if `category` is `fraud`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun fraud(): Fraud? = fraud.getNullable("fraud")

            /**
             * Processing error. Required if and only if `category` is `processing_error`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun processingError(): ProcessingError? =
                processingError.getNullable("processing_error")

            /**
             * Returns the raw JSON value of [category].
             *
             * Unlike [category], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("category")
            @ExcludeMissing
            fun _category(): JsonField<Category> = category

            /**
             * Returns the raw JSON value of [authorization].
             *
             * Unlike [authorization], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("authorization")
            @ExcludeMissing
            fun _authorization(): JsonField<Authorization> = authorization

            /**
             * Returns the raw JSON value of [consumerCanceledMerchandise].
             *
             * Unlike [consumerCanceledMerchandise], this method doesn't throw if the JSON field has
             * an unexpected type.
             */
            @JsonProperty("consumer_canceled_merchandise")
            @ExcludeMissing
            fun _consumerCanceledMerchandise(): JsonField<ConsumerCanceledMerchandise> =
                consumerCanceledMerchandise

            /**
             * Returns the raw JSON value of [consumerCanceledRecurringTransaction].
             *
             * Unlike [consumerCanceledRecurringTransaction], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("consumer_canceled_recurring_transaction")
            @ExcludeMissing
            fun _consumerCanceledRecurringTransaction():
                JsonField<ConsumerCanceledRecurringTransaction> =
                consumerCanceledRecurringTransaction

            /**
             * Returns the raw JSON value of [consumerCanceledServices].
             *
             * Unlike [consumerCanceledServices], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("consumer_canceled_services")
            @ExcludeMissing
            fun _consumerCanceledServices(): JsonField<ConsumerCanceledServices> =
                consumerCanceledServices

            /**
             * Returns the raw JSON value of [consumerCounterfeitMerchandise].
             *
             * Unlike [consumerCounterfeitMerchandise], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("consumer_counterfeit_merchandise")
            @ExcludeMissing
            fun _consumerCounterfeitMerchandise(): JsonField<ConsumerCounterfeitMerchandise> =
                consumerCounterfeitMerchandise

            /**
             * Returns the raw JSON value of [consumerCreditNotProcessed].
             *
             * Unlike [consumerCreditNotProcessed], this method doesn't throw if the JSON field has
             * an unexpected type.
             */
            @JsonProperty("consumer_credit_not_processed")
            @ExcludeMissing
            fun _consumerCreditNotProcessed(): JsonField<ConsumerCreditNotProcessed> =
                consumerCreditNotProcessed

            /**
             * Returns the raw JSON value of [consumerDamagedOrDefectiveMerchandise].
             *
             * Unlike [consumerDamagedOrDefectiveMerchandise], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("consumer_damaged_or_defective_merchandise")
            @ExcludeMissing
            fun _consumerDamagedOrDefectiveMerchandise():
                JsonField<ConsumerDamagedOrDefectiveMerchandise> =
                consumerDamagedOrDefectiveMerchandise

            /**
             * Returns the raw JSON value of [consumerMerchandiseMisrepresentation].
             *
             * Unlike [consumerMerchandiseMisrepresentation], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("consumer_merchandise_misrepresentation")
            @ExcludeMissing
            fun _consumerMerchandiseMisrepresentation():
                JsonField<ConsumerMerchandiseMisrepresentation> =
                consumerMerchandiseMisrepresentation

            /**
             * Returns the raw JSON value of [consumerMerchandiseNotAsDescribed].
             *
             * Unlike [consumerMerchandiseNotAsDescribed], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("consumer_merchandise_not_as_described")
            @ExcludeMissing
            fun _consumerMerchandiseNotAsDescribed(): JsonField<ConsumerMerchandiseNotAsDescribed> =
                consumerMerchandiseNotAsDescribed

            /**
             * Returns the raw JSON value of [consumerMerchandiseNotReceived].
             *
             * Unlike [consumerMerchandiseNotReceived], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("consumer_merchandise_not_received")
            @ExcludeMissing
            fun _consumerMerchandiseNotReceived(): JsonField<ConsumerMerchandiseNotReceived> =
                consumerMerchandiseNotReceived

            /**
             * Returns the raw JSON value of [consumerOriginalCreditTransactionNotAccepted].
             *
             * Unlike [consumerOriginalCreditTransactionNotAccepted], this method doesn't throw if
             * the JSON field has an unexpected type.
             */
            @JsonProperty("consumer_original_credit_transaction_not_accepted")
            @ExcludeMissing
            fun _consumerOriginalCreditTransactionNotAccepted():
                JsonField<ConsumerOriginalCreditTransactionNotAccepted> =
                consumerOriginalCreditTransactionNotAccepted

            /**
             * Returns the raw JSON value of [consumerQualityMerchandise].
             *
             * Unlike [consumerQualityMerchandise], this method doesn't throw if the JSON field has
             * an unexpected type.
             */
            @JsonProperty("consumer_quality_merchandise")
            @ExcludeMissing
            fun _consumerQualityMerchandise(): JsonField<ConsumerQualityMerchandise> =
                consumerQualityMerchandise

            /**
             * Returns the raw JSON value of [consumerQualityServices].
             *
             * Unlike [consumerQualityServices], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("consumer_quality_services")
            @ExcludeMissing
            fun _consumerQualityServices(): JsonField<ConsumerQualityServices> =
                consumerQualityServices

            /**
             * Returns the raw JSON value of [consumerServicesMisrepresentation].
             *
             * Unlike [consumerServicesMisrepresentation], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("consumer_services_misrepresentation")
            @ExcludeMissing
            fun _consumerServicesMisrepresentation(): JsonField<ConsumerServicesMisrepresentation> =
                consumerServicesMisrepresentation

            /**
             * Returns the raw JSON value of [consumerServicesNotAsDescribed].
             *
             * Unlike [consumerServicesNotAsDescribed], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("consumer_services_not_as_described")
            @ExcludeMissing
            fun _consumerServicesNotAsDescribed(): JsonField<ConsumerServicesNotAsDescribed> =
                consumerServicesNotAsDescribed

            /**
             * Returns the raw JSON value of [consumerServicesNotReceived].
             *
             * Unlike [consumerServicesNotReceived], this method doesn't throw if the JSON field has
             * an unexpected type.
             */
            @JsonProperty("consumer_services_not_received")
            @ExcludeMissing
            fun _consumerServicesNotReceived(): JsonField<ConsumerServicesNotReceived> =
                consumerServicesNotReceived

            /**
             * Returns the raw JSON value of [fraud].
             *
             * Unlike [fraud], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("fraud") @ExcludeMissing fun _fraud(): JsonField<Fraud> = fraud

            /**
             * Returns the raw JSON value of [processingError].
             *
             * Unlike [processingError], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("processing_error")
            @ExcludeMissing
            fun _processingError(): JsonField<ProcessingError> = processingError

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Chargeback].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .category()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [Chargeback]. */
            class Builder internal constructor() {

                private var category: JsonField<Category>? = null
                private var authorization: JsonField<Authorization> = JsonMissing.of()
                private var consumerCanceledMerchandise: JsonField<ConsumerCanceledMerchandise> =
                    JsonMissing.of()
                private var consumerCanceledRecurringTransaction:
                    JsonField<ConsumerCanceledRecurringTransaction> =
                    JsonMissing.of()
                private var consumerCanceledServices: JsonField<ConsumerCanceledServices> =
                    JsonMissing.of()
                private var consumerCounterfeitMerchandise:
                    JsonField<ConsumerCounterfeitMerchandise> =
                    JsonMissing.of()
                private var consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed> =
                    JsonMissing.of()
                private var consumerDamagedOrDefectiveMerchandise:
                    JsonField<ConsumerDamagedOrDefectiveMerchandise> =
                    JsonMissing.of()
                private var consumerMerchandiseMisrepresentation:
                    JsonField<ConsumerMerchandiseMisrepresentation> =
                    JsonMissing.of()
                private var consumerMerchandiseNotAsDescribed:
                    JsonField<ConsumerMerchandiseNotAsDescribed> =
                    JsonMissing.of()
                private var consumerMerchandiseNotReceived:
                    JsonField<ConsumerMerchandiseNotReceived> =
                    JsonMissing.of()
                private var consumerNonReceiptOfCash: JsonValue = JsonMissing.of()
                private var consumerOriginalCreditTransactionNotAccepted:
                    JsonField<ConsumerOriginalCreditTransactionNotAccepted> =
                    JsonMissing.of()
                private var consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise> =
                    JsonMissing.of()
                private var consumerQualityServices: JsonField<ConsumerQualityServices> =
                    JsonMissing.of()
                private var consumerServicesMisrepresentation:
                    JsonField<ConsumerServicesMisrepresentation> =
                    JsonMissing.of()
                private var consumerServicesNotAsDescribed:
                    JsonField<ConsumerServicesNotAsDescribed> =
                    JsonMissing.of()
                private var consumerServicesNotReceived: JsonField<ConsumerServicesNotReceived> =
                    JsonMissing.of()
                private var fraud: JsonField<Fraud> = JsonMissing.of()
                private var processingError: JsonField<ProcessingError> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(chargeback: Chargeback) = apply {
                    category = chargeback.category
                    authorization = chargeback.authorization
                    consumerCanceledMerchandise = chargeback.consumerCanceledMerchandise
                    consumerCanceledRecurringTransaction =
                        chargeback.consumerCanceledRecurringTransaction
                    consumerCanceledServices = chargeback.consumerCanceledServices
                    consumerCounterfeitMerchandise = chargeback.consumerCounterfeitMerchandise
                    consumerCreditNotProcessed = chargeback.consumerCreditNotProcessed
                    consumerDamagedOrDefectiveMerchandise =
                        chargeback.consumerDamagedOrDefectiveMerchandise
                    consumerMerchandiseMisrepresentation =
                        chargeback.consumerMerchandiseMisrepresentation
                    consumerMerchandiseNotAsDescribed = chargeback.consumerMerchandiseNotAsDescribed
                    consumerMerchandiseNotReceived = chargeback.consumerMerchandiseNotReceived
                    consumerNonReceiptOfCash = chargeback.consumerNonReceiptOfCash
                    consumerOriginalCreditTransactionNotAccepted =
                        chargeback.consumerOriginalCreditTransactionNotAccepted
                    consumerQualityMerchandise = chargeback.consumerQualityMerchandise
                    consumerQualityServices = chargeback.consumerQualityServices
                    consumerServicesMisrepresentation = chargeback.consumerServicesMisrepresentation
                    consumerServicesNotAsDescribed = chargeback.consumerServicesNotAsDescribed
                    consumerServicesNotReceived = chargeback.consumerServicesNotReceived
                    fraud = chargeback.fraud
                    processingError = chargeback.processingError
                    additionalProperties = chargeback.additionalProperties.toMutableMap()
                }

                /** Category. */
                fun category(category: Category) = category(JsonField.of(category))

                /**
                 * Sets [Builder.category] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.category] with a well-typed [Category] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun category(category: JsonField<Category>) = apply { this.category = category }

                /** Authorization. Required if and only if `category` is `authorization`. */
                fun authorization(authorization: Authorization) =
                    authorization(JsonField.of(authorization))

                /**
                 * Sets [Builder.authorization] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.authorization] with a well-typed [Authorization]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun authorization(authorization: JsonField<Authorization>) = apply {
                    this.authorization = authorization
                }

                /**
                 * Canceled merchandise. Required if and only if `category` is
                 * `consumer_canceled_merchandise`.
                 */
                fun consumerCanceledMerchandise(
                    consumerCanceledMerchandise: ConsumerCanceledMerchandise
                ) = consumerCanceledMerchandise(JsonField.of(consumerCanceledMerchandise))

                /**
                 * Sets [Builder.consumerCanceledMerchandise] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerCanceledMerchandise] with a well-typed
                 * [ConsumerCanceledMerchandise] value instead. This method is primarily for setting
                 * the field to an undocumented or not yet supported value.
                 */
                fun consumerCanceledMerchandise(
                    consumerCanceledMerchandise: JsonField<ConsumerCanceledMerchandise>
                ) = apply { this.consumerCanceledMerchandise = consumerCanceledMerchandise }

                /**
                 * Canceled recurring transaction. Required if and only if `category` is
                 * `consumer_canceled_recurring_transaction`.
                 */
                fun consumerCanceledRecurringTransaction(
                    consumerCanceledRecurringTransaction: ConsumerCanceledRecurringTransaction
                ) =
                    consumerCanceledRecurringTransaction(
                        JsonField.of(consumerCanceledRecurringTransaction)
                    )

                /**
                 * Sets [Builder.consumerCanceledRecurringTransaction] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerCanceledRecurringTransaction] with a
                 * well-typed [ConsumerCanceledRecurringTransaction] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerCanceledRecurringTransaction(
                    consumerCanceledRecurringTransaction:
                        JsonField<ConsumerCanceledRecurringTransaction>
                ) = apply {
                    this.consumerCanceledRecurringTransaction = consumerCanceledRecurringTransaction
                }

                /**
                 * Canceled services. Required if and only if `category` is
                 * `consumer_canceled_services`.
                 */
                fun consumerCanceledServices(consumerCanceledServices: ConsumerCanceledServices) =
                    consumerCanceledServices(JsonField.of(consumerCanceledServices))

                /**
                 * Sets [Builder.consumerCanceledServices] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerCanceledServices] with a well-typed
                 * [ConsumerCanceledServices] value instead. This method is primarily for setting
                 * the field to an undocumented or not yet supported value.
                 */
                fun consumerCanceledServices(
                    consumerCanceledServices: JsonField<ConsumerCanceledServices>
                ) = apply { this.consumerCanceledServices = consumerCanceledServices }

                /**
                 * Counterfeit merchandise. Required if and only if `category` is
                 * `consumer_counterfeit_merchandise`.
                 */
                fun consumerCounterfeitMerchandise(
                    consumerCounterfeitMerchandise: ConsumerCounterfeitMerchandise
                ) = consumerCounterfeitMerchandise(JsonField.of(consumerCounterfeitMerchandise))

                /**
                 * Sets [Builder.consumerCounterfeitMerchandise] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerCounterfeitMerchandise] with a
                 * well-typed [ConsumerCounterfeitMerchandise] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerCounterfeitMerchandise(
                    consumerCounterfeitMerchandise: JsonField<ConsumerCounterfeitMerchandise>
                ) = apply { this.consumerCounterfeitMerchandise = consumerCounterfeitMerchandise }

                /**
                 * Credit not processed. Required if and only if `category` is
                 * `consumer_credit_not_processed`.
                 */
                fun consumerCreditNotProcessed(
                    consumerCreditNotProcessed: ConsumerCreditNotProcessed
                ) = consumerCreditNotProcessed(JsonField.of(consumerCreditNotProcessed))

                /**
                 * Sets [Builder.consumerCreditNotProcessed] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerCreditNotProcessed] with a well-typed
                 * [ConsumerCreditNotProcessed] value instead. This method is primarily for setting
                 * the field to an undocumented or not yet supported value.
                 */
                fun consumerCreditNotProcessed(
                    consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed>
                ) = apply { this.consumerCreditNotProcessed = consumerCreditNotProcessed }

                /**
                 * Damaged or defective merchandise. Required if and only if `category` is
                 * `consumer_damaged_or_defective_merchandise`.
                 */
                fun consumerDamagedOrDefectiveMerchandise(
                    consumerDamagedOrDefectiveMerchandise: ConsumerDamagedOrDefectiveMerchandise
                ) =
                    consumerDamagedOrDefectiveMerchandise(
                        JsonField.of(consumerDamagedOrDefectiveMerchandise)
                    )

                /**
                 * Sets [Builder.consumerDamagedOrDefectiveMerchandise] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerDamagedOrDefectiveMerchandise] with a
                 * well-typed [ConsumerDamagedOrDefectiveMerchandise] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerDamagedOrDefectiveMerchandise(
                    consumerDamagedOrDefectiveMerchandise:
                        JsonField<ConsumerDamagedOrDefectiveMerchandise>
                ) = apply {
                    this.consumerDamagedOrDefectiveMerchandise =
                        consumerDamagedOrDefectiveMerchandise
                }

                /**
                 * Merchandise misrepresentation. Required if and only if `category` is
                 * `consumer_merchandise_misrepresentation`.
                 */
                fun consumerMerchandiseMisrepresentation(
                    consumerMerchandiseMisrepresentation: ConsumerMerchandiseMisrepresentation
                ) =
                    consumerMerchandiseMisrepresentation(
                        JsonField.of(consumerMerchandiseMisrepresentation)
                    )

                /**
                 * Sets [Builder.consumerMerchandiseMisrepresentation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerMerchandiseMisrepresentation] with a
                 * well-typed [ConsumerMerchandiseMisrepresentation] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerMerchandiseMisrepresentation(
                    consumerMerchandiseMisrepresentation:
                        JsonField<ConsumerMerchandiseMisrepresentation>
                ) = apply {
                    this.consumerMerchandiseMisrepresentation = consumerMerchandiseMisrepresentation
                }

                /**
                 * Merchandise not as described. Required if and only if `category` is
                 * `consumer_merchandise_not_as_described`.
                 */
                fun consumerMerchandiseNotAsDescribed(
                    consumerMerchandiseNotAsDescribed: ConsumerMerchandiseNotAsDescribed
                ) =
                    consumerMerchandiseNotAsDescribed(
                        JsonField.of(consumerMerchandiseNotAsDescribed)
                    )

                /**
                 * Sets [Builder.consumerMerchandiseNotAsDescribed] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerMerchandiseNotAsDescribed] with a
                 * well-typed [ConsumerMerchandiseNotAsDescribed] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerMerchandiseNotAsDescribed(
                    consumerMerchandiseNotAsDescribed: JsonField<ConsumerMerchandiseNotAsDescribed>
                ) = apply {
                    this.consumerMerchandiseNotAsDescribed = consumerMerchandiseNotAsDescribed
                }

                /**
                 * Merchandise not received. Required if and only if `category` is
                 * `consumer_merchandise_not_received`.
                 */
                fun consumerMerchandiseNotReceived(
                    consumerMerchandiseNotReceived: ConsumerMerchandiseNotReceived
                ) = consumerMerchandiseNotReceived(JsonField.of(consumerMerchandiseNotReceived))

                /**
                 * Sets [Builder.consumerMerchandiseNotReceived] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerMerchandiseNotReceived] with a
                 * well-typed [ConsumerMerchandiseNotReceived] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerMerchandiseNotReceived(
                    consumerMerchandiseNotReceived: JsonField<ConsumerMerchandiseNotReceived>
                ) = apply { this.consumerMerchandiseNotReceived = consumerMerchandiseNotReceived }

                /**
                 * Non-receipt of cash. Required if and only if `category` is
                 * `consumer_non_receipt_of_cash`.
                 */
                fun consumerNonReceiptOfCash(consumerNonReceiptOfCash: JsonValue) = apply {
                    this.consumerNonReceiptOfCash = consumerNonReceiptOfCash
                }

                /**
                 * Original Credit Transaction (OCT) not accepted. Required if and only if
                 * `category` is `consumer_original_credit_transaction_not_accepted`.
                 */
                fun consumerOriginalCreditTransactionNotAccepted(
                    consumerOriginalCreditTransactionNotAccepted:
                        ConsumerOriginalCreditTransactionNotAccepted
                ) =
                    consumerOriginalCreditTransactionNotAccepted(
                        JsonField.of(consumerOriginalCreditTransactionNotAccepted)
                    )

                /**
                 * Sets [Builder.consumerOriginalCreditTransactionNotAccepted] to an arbitrary JSON
                 * value.
                 *
                 * You should usually call [Builder.consumerOriginalCreditTransactionNotAccepted]
                 * with a well-typed [ConsumerOriginalCreditTransactionNotAccepted] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun consumerOriginalCreditTransactionNotAccepted(
                    consumerOriginalCreditTransactionNotAccepted:
                        JsonField<ConsumerOriginalCreditTransactionNotAccepted>
                ) = apply {
                    this.consumerOriginalCreditTransactionNotAccepted =
                        consumerOriginalCreditTransactionNotAccepted
                }

                /**
                 * Merchandise quality issue. Required if and only if `category` is
                 * `consumer_quality_merchandise`.
                 */
                fun consumerQualityMerchandise(
                    consumerQualityMerchandise: ConsumerQualityMerchandise
                ) = consumerQualityMerchandise(JsonField.of(consumerQualityMerchandise))

                /**
                 * Sets [Builder.consumerQualityMerchandise] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerQualityMerchandise] with a well-typed
                 * [ConsumerQualityMerchandise] value instead. This method is primarily for setting
                 * the field to an undocumented or not yet supported value.
                 */
                fun consumerQualityMerchandise(
                    consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise>
                ) = apply { this.consumerQualityMerchandise = consumerQualityMerchandise }

                /**
                 * Services quality issue. Required if and only if `category` is
                 * `consumer_quality_services`.
                 */
                fun consumerQualityServices(consumerQualityServices: ConsumerQualityServices) =
                    consumerQualityServices(JsonField.of(consumerQualityServices))

                /**
                 * Sets [Builder.consumerQualityServices] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerQualityServices] with a well-typed
                 * [ConsumerQualityServices] value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun consumerQualityServices(
                    consumerQualityServices: JsonField<ConsumerQualityServices>
                ) = apply { this.consumerQualityServices = consumerQualityServices }

                /**
                 * Services misrepresentation. Required if and only if `category` is
                 * `consumer_services_misrepresentation`.
                 */
                fun consumerServicesMisrepresentation(
                    consumerServicesMisrepresentation: ConsumerServicesMisrepresentation
                ) =
                    consumerServicesMisrepresentation(
                        JsonField.of(consumerServicesMisrepresentation)
                    )

                /**
                 * Sets [Builder.consumerServicesMisrepresentation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerServicesMisrepresentation] with a
                 * well-typed [ConsumerServicesMisrepresentation] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerServicesMisrepresentation(
                    consumerServicesMisrepresentation: JsonField<ConsumerServicesMisrepresentation>
                ) = apply {
                    this.consumerServicesMisrepresentation = consumerServicesMisrepresentation
                }

                /**
                 * Services not as described. Required if and only if `category` is
                 * `consumer_services_not_as_described`.
                 */
                fun consumerServicesNotAsDescribed(
                    consumerServicesNotAsDescribed: ConsumerServicesNotAsDescribed
                ) = consumerServicesNotAsDescribed(JsonField.of(consumerServicesNotAsDescribed))

                /**
                 * Sets [Builder.consumerServicesNotAsDescribed] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerServicesNotAsDescribed] with a
                 * well-typed [ConsumerServicesNotAsDescribed] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun consumerServicesNotAsDescribed(
                    consumerServicesNotAsDescribed: JsonField<ConsumerServicesNotAsDescribed>
                ) = apply { this.consumerServicesNotAsDescribed = consumerServicesNotAsDescribed }

                /**
                 * Services not received. Required if and only if `category` is
                 * `consumer_services_not_received`.
                 */
                fun consumerServicesNotReceived(
                    consumerServicesNotReceived: ConsumerServicesNotReceived
                ) = consumerServicesNotReceived(JsonField.of(consumerServicesNotReceived))

                /**
                 * Sets [Builder.consumerServicesNotReceived] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.consumerServicesNotReceived] with a well-typed
                 * [ConsumerServicesNotReceived] value instead. This method is primarily for setting
                 * the field to an undocumented or not yet supported value.
                 */
                fun consumerServicesNotReceived(
                    consumerServicesNotReceived: JsonField<ConsumerServicesNotReceived>
                ) = apply { this.consumerServicesNotReceived = consumerServicesNotReceived }

                /** Fraud. Required if and only if `category` is `fraud`. */
                fun fraud(fraud: Fraud) = fraud(JsonField.of(fraud))

                /**
                 * Sets [Builder.fraud] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.fraud] with a well-typed [Fraud] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun fraud(fraud: JsonField<Fraud>) = apply { this.fraud = fraud }

                /** Processing error. Required if and only if `category` is `processing_error`. */
                fun processingError(processingError: ProcessingError) =
                    processingError(JsonField.of(processingError))

                /**
                 * Sets [Builder.processingError] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.processingError] with a well-typed
                 * [ProcessingError] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun processingError(processingError: JsonField<ProcessingError>) = apply {
                    this.processingError = processingError
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Chargeback].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .category()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): Chargeback =
                    Chargeback(
                        checkRequired("category", category),
                        authorization,
                        consumerCanceledMerchandise,
                        consumerCanceledRecurringTransaction,
                        consumerCanceledServices,
                        consumerCounterfeitMerchandise,
                        consumerCreditNotProcessed,
                        consumerDamagedOrDefectiveMerchandise,
                        consumerMerchandiseMisrepresentation,
                        consumerMerchandiseNotAsDescribed,
                        consumerMerchandiseNotReceived,
                        consumerNonReceiptOfCash,
                        consumerOriginalCreditTransactionNotAccepted,
                        consumerQualityMerchandise,
                        consumerQualityServices,
                        consumerServicesMisrepresentation,
                        consumerServicesNotAsDescribed,
                        consumerServicesNotReceived,
                        fraud,
                        processingError,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): Chargeback = apply {
                if (validated) {
                    return@apply
                }

                category().validate()
                authorization()?.validate()
                consumerCanceledMerchandise()?.validate()
                consumerCanceledRecurringTransaction()?.validate()
                consumerCanceledServices()?.validate()
                consumerCounterfeitMerchandise()?.validate()
                consumerCreditNotProcessed()?.validate()
                consumerDamagedOrDefectiveMerchandise()?.validate()
                consumerMerchandiseMisrepresentation()?.validate()
                consumerMerchandiseNotAsDescribed()?.validate()
                consumerMerchandiseNotReceived()?.validate()
                consumerOriginalCreditTransactionNotAccepted()?.validate()
                consumerQualityMerchandise()?.validate()
                consumerQualityServices()?.validate()
                consumerServicesMisrepresentation()?.validate()
                consumerServicesNotAsDescribed()?.validate()
                consumerServicesNotReceived()?.validate()
                fraud()?.validate()
                processingError()?.validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (category.asKnown()?.validity() ?: 0) +
                    (authorization.asKnown()?.validity() ?: 0) +
                    (consumerCanceledMerchandise.asKnown()?.validity() ?: 0) +
                    (consumerCanceledRecurringTransaction.asKnown()?.validity() ?: 0) +
                    (consumerCanceledServices.asKnown()?.validity() ?: 0) +
                    (consumerCounterfeitMerchandise.asKnown()?.validity() ?: 0) +
                    (consumerCreditNotProcessed.asKnown()?.validity() ?: 0) +
                    (consumerDamagedOrDefectiveMerchandise.asKnown()?.validity() ?: 0) +
                    (consumerMerchandiseMisrepresentation.asKnown()?.validity() ?: 0) +
                    (consumerMerchandiseNotAsDescribed.asKnown()?.validity() ?: 0) +
                    (consumerMerchandiseNotReceived.asKnown()?.validity() ?: 0) +
                    (consumerOriginalCreditTransactionNotAccepted.asKnown()?.validity() ?: 0) +
                    (consumerQualityMerchandise.asKnown()?.validity() ?: 0) +
                    (consumerQualityServices.asKnown()?.validity() ?: 0) +
                    (consumerServicesMisrepresentation.asKnown()?.validity() ?: 0) +
                    (consumerServicesNotAsDescribed.asKnown()?.validity() ?: 0) +
                    (consumerServicesNotReceived.asKnown()?.validity() ?: 0) +
                    (fraud.asKnown()?.validity() ?: 0) +
                    (processingError.asKnown()?.validity() ?: 0)

            /** Category. */
            class Category @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Authorization. */
                    val AUTHORIZATION = of("authorization")

                    /** Consumer: canceled merchandise. */
                    val CONSUMER_CANCELED_MERCHANDISE = of("consumer_canceled_merchandise")

                    /** Consumer: canceled recurring transaction. */
                    val CONSUMER_CANCELED_RECURRING_TRANSACTION =
                        of("consumer_canceled_recurring_transaction")

                    /** Consumer: canceled services. */
                    val CONSUMER_CANCELED_SERVICES = of("consumer_canceled_services")

                    /** Consumer: counterfeit merchandise. */
                    val CONSUMER_COUNTERFEIT_MERCHANDISE = of("consumer_counterfeit_merchandise")

                    /** Consumer: credit not processed. */
                    val CONSUMER_CREDIT_NOT_PROCESSED = of("consumer_credit_not_processed")

                    /** Consumer: damaged or defective merchandise. */
                    val CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE =
                        of("consumer_damaged_or_defective_merchandise")

                    /** Consumer: merchandise misrepresentation. */
                    val CONSUMER_MERCHANDISE_MISREPRESENTATION =
                        of("consumer_merchandise_misrepresentation")

                    /** Consumer: merchandise not as described. */
                    val CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED =
                        of("consumer_merchandise_not_as_described")

                    /** Consumer: merchandise not received. */
                    val CONSUMER_MERCHANDISE_NOT_RECEIVED = of("consumer_merchandise_not_received")

                    /** Consumer: non-receipt of cash. */
                    val CONSUMER_NON_RECEIPT_OF_CASH = of("consumer_non_receipt_of_cash")

                    /** Consumer: Original Credit Transaction (OCT) not accepted. */
                    val CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED =
                        of("consumer_original_credit_transaction_not_accepted")

                    /** Consumer: merchandise quality issue. */
                    val CONSUMER_QUALITY_MERCHANDISE = of("consumer_quality_merchandise")

                    /** Consumer: services quality issue. */
                    val CONSUMER_QUALITY_SERVICES = of("consumer_quality_services")

                    /** Consumer: services misrepresentation. */
                    val CONSUMER_SERVICES_MISREPRESENTATION =
                        of("consumer_services_misrepresentation")

                    /** Consumer: services not as described. */
                    val CONSUMER_SERVICES_NOT_AS_DESCRIBED =
                        of("consumer_services_not_as_described")

                    /** Consumer: services not received. */
                    val CONSUMER_SERVICES_NOT_RECEIVED = of("consumer_services_not_received")

                    /** Fraud. */
                    val FRAUD = of("fraud")

                    /** Processing error. */
                    val PROCESSING_ERROR = of("processing_error")

                    fun of(value: String) = Category(JsonField.of(value))
                }

                /** An enum containing [Category]'s known values. */
                enum class Known {
                    /** Authorization. */
                    AUTHORIZATION,
                    /** Consumer: canceled merchandise. */
                    CONSUMER_CANCELED_MERCHANDISE,
                    /** Consumer: canceled recurring transaction. */
                    CONSUMER_CANCELED_RECURRING_TRANSACTION,
                    /** Consumer: canceled services. */
                    CONSUMER_CANCELED_SERVICES,
                    /** Consumer: counterfeit merchandise. */
                    CONSUMER_COUNTERFEIT_MERCHANDISE,
                    /** Consumer: credit not processed. */
                    CONSUMER_CREDIT_NOT_PROCESSED,
                    /** Consumer: damaged or defective merchandise. */
                    CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                    /** Consumer: merchandise misrepresentation. */
                    CONSUMER_MERCHANDISE_MISREPRESENTATION,
                    /** Consumer: merchandise not as described. */
                    CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                    /** Consumer: merchandise not received. */
                    CONSUMER_MERCHANDISE_NOT_RECEIVED,
                    /** Consumer: non-receipt of cash. */
                    CONSUMER_NON_RECEIPT_OF_CASH,
                    /** Consumer: Original Credit Transaction (OCT) not accepted. */
                    CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                    /** Consumer: merchandise quality issue. */
                    CONSUMER_QUALITY_MERCHANDISE,
                    /** Consumer: services quality issue. */
                    CONSUMER_QUALITY_SERVICES,
                    /** Consumer: services misrepresentation. */
                    CONSUMER_SERVICES_MISREPRESENTATION,
                    /** Consumer: services not as described. */
                    CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                    /** Consumer: services not received. */
                    CONSUMER_SERVICES_NOT_RECEIVED,
                    /** Fraud. */
                    FRAUD,
                    /** Processing error. */
                    PROCESSING_ERROR,
                }

                /**
                 * An enum containing [Category]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Category] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Authorization. */
                    AUTHORIZATION,
                    /** Consumer: canceled merchandise. */
                    CONSUMER_CANCELED_MERCHANDISE,
                    /** Consumer: canceled recurring transaction. */
                    CONSUMER_CANCELED_RECURRING_TRANSACTION,
                    /** Consumer: canceled services. */
                    CONSUMER_CANCELED_SERVICES,
                    /** Consumer: counterfeit merchandise. */
                    CONSUMER_COUNTERFEIT_MERCHANDISE,
                    /** Consumer: credit not processed. */
                    CONSUMER_CREDIT_NOT_PROCESSED,
                    /** Consumer: damaged or defective merchandise. */
                    CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                    /** Consumer: merchandise misrepresentation. */
                    CONSUMER_MERCHANDISE_MISREPRESENTATION,
                    /** Consumer: merchandise not as described. */
                    CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                    /** Consumer: merchandise not received. */
                    CONSUMER_MERCHANDISE_NOT_RECEIVED,
                    /** Consumer: non-receipt of cash. */
                    CONSUMER_NON_RECEIPT_OF_CASH,
                    /** Consumer: Original Credit Transaction (OCT) not accepted. */
                    CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                    /** Consumer: merchandise quality issue. */
                    CONSUMER_QUALITY_MERCHANDISE,
                    /** Consumer: services quality issue. */
                    CONSUMER_QUALITY_SERVICES,
                    /** Consumer: services misrepresentation. */
                    CONSUMER_SERVICES_MISREPRESENTATION,
                    /** Consumer: services not as described. */
                    CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                    /** Consumer: services not received. */
                    CONSUMER_SERVICES_NOT_RECEIVED,
                    /** Fraud. */
                    FRAUD,
                    /** Processing error. */
                    PROCESSING_ERROR,
                    /**
                     * An enum member indicating that [Category] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        AUTHORIZATION -> Value.AUTHORIZATION
                        CONSUMER_CANCELED_MERCHANDISE -> Value.CONSUMER_CANCELED_MERCHANDISE
                        CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                            Value.CONSUMER_CANCELED_RECURRING_TRANSACTION
                        CONSUMER_CANCELED_SERVICES -> Value.CONSUMER_CANCELED_SERVICES
                        CONSUMER_COUNTERFEIT_MERCHANDISE -> Value.CONSUMER_COUNTERFEIT_MERCHANDISE
                        CONSUMER_CREDIT_NOT_PROCESSED -> Value.CONSUMER_CREDIT_NOT_PROCESSED
                        CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                            Value.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                        CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                            Value.CONSUMER_MERCHANDISE_MISREPRESENTATION
                        CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                            Value.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                        CONSUMER_MERCHANDISE_NOT_RECEIVED -> Value.CONSUMER_MERCHANDISE_NOT_RECEIVED
                        CONSUMER_NON_RECEIPT_OF_CASH -> Value.CONSUMER_NON_RECEIPT_OF_CASH
                        CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                            Value.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                        CONSUMER_QUALITY_MERCHANDISE -> Value.CONSUMER_QUALITY_MERCHANDISE
                        CONSUMER_QUALITY_SERVICES -> Value.CONSUMER_QUALITY_SERVICES
                        CONSUMER_SERVICES_MISREPRESENTATION ->
                            Value.CONSUMER_SERVICES_MISREPRESENTATION
                        CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                            Value.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                        CONSUMER_SERVICES_NOT_RECEIVED -> Value.CONSUMER_SERVICES_NOT_RECEIVED
                        FRAUD -> Value.FRAUD
                        PROCESSING_ERROR -> Value.PROCESSING_ERROR
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        AUTHORIZATION -> Known.AUTHORIZATION
                        CONSUMER_CANCELED_MERCHANDISE -> Known.CONSUMER_CANCELED_MERCHANDISE
                        CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                            Known.CONSUMER_CANCELED_RECURRING_TRANSACTION
                        CONSUMER_CANCELED_SERVICES -> Known.CONSUMER_CANCELED_SERVICES
                        CONSUMER_COUNTERFEIT_MERCHANDISE -> Known.CONSUMER_COUNTERFEIT_MERCHANDISE
                        CONSUMER_CREDIT_NOT_PROCESSED -> Known.CONSUMER_CREDIT_NOT_PROCESSED
                        CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                            Known.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                        CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                            Known.CONSUMER_MERCHANDISE_MISREPRESENTATION
                        CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                            Known.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                        CONSUMER_MERCHANDISE_NOT_RECEIVED -> Known.CONSUMER_MERCHANDISE_NOT_RECEIVED
                        CONSUMER_NON_RECEIPT_OF_CASH -> Known.CONSUMER_NON_RECEIPT_OF_CASH
                        CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                            Known.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                        CONSUMER_QUALITY_MERCHANDISE -> Known.CONSUMER_QUALITY_MERCHANDISE
                        CONSUMER_QUALITY_SERVICES -> Known.CONSUMER_QUALITY_SERVICES
                        CONSUMER_SERVICES_MISREPRESENTATION ->
                            Known.CONSUMER_SERVICES_MISREPRESENTATION
                        CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                            Known.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                        CONSUMER_SERVICES_NOT_RECEIVED -> Known.CONSUMER_SERVICES_NOT_RECEIVED
                        FRAUD -> Known.FRAUD
                        PROCESSING_ERROR -> Known.PROCESSING_ERROR
                        else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Category = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Category && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /** Authorization. Required if and only if `category` is `authorization`. */
            class Authorization
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val accountStatus: JsonField<AccountStatus>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("account_status")
                    @ExcludeMissing
                    accountStatus: JsonField<AccountStatus> = JsonMissing.of()
                ) : this(accountStatus, mutableMapOf())

                /**
                 * Account status.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun accountStatus(): AccountStatus = accountStatus.getRequired("account_status")

                /**
                 * Returns the raw JSON value of [accountStatus].
                 *
                 * Unlike [accountStatus], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("account_status")
                @ExcludeMissing
                fun _accountStatus(): JsonField<AccountStatus> = accountStatus

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Authorization].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .accountStatus()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Authorization]. */
                class Builder internal constructor() {

                    private var accountStatus: JsonField<AccountStatus>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(authorization: Authorization) = apply {
                        accountStatus = authorization.accountStatus
                        additionalProperties = authorization.additionalProperties.toMutableMap()
                    }

                    /** Account status. */
                    fun accountStatus(accountStatus: AccountStatus) =
                        accountStatus(JsonField.of(accountStatus))

                    /**
                     * Sets [Builder.accountStatus] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.accountStatus] with a well-typed
                     * [AccountStatus] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun accountStatus(accountStatus: JsonField<AccountStatus>) = apply {
                        this.accountStatus = accountStatus
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Authorization].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .accountStatus()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Authorization =
                        Authorization(
                            checkRequired("accountStatus", accountStatus),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Authorization = apply {
                    if (validated) {
                        return@apply
                    }

                    accountStatus().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = (accountStatus.asKnown()?.validity() ?: 0)

                /** Account status. */
                class AccountStatus
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Account closed. */
                        val ACCOUNT_CLOSED = of("account_closed")

                        /** Credit problem. */
                        val CREDIT_PROBLEM = of("credit_problem")

                        /** Fraud. */
                        val FRAUD = of("fraud")

                        fun of(value: String) = AccountStatus(JsonField.of(value))
                    }

                    /** An enum containing [AccountStatus]'s known values. */
                    enum class Known {
                        /** Account closed. */
                        ACCOUNT_CLOSED,
                        /** Credit problem. */
                        CREDIT_PROBLEM,
                        /** Fraud. */
                        FRAUD,
                    }

                    /**
                     * An enum containing [AccountStatus]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [AccountStatus] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Account closed. */
                        ACCOUNT_CLOSED,
                        /** Credit problem. */
                        CREDIT_PROBLEM,
                        /** Fraud. */
                        FRAUD,
                        /**
                         * An enum member indicating that [AccountStatus] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ACCOUNT_CLOSED -> Value.ACCOUNT_CLOSED
                            CREDIT_PROBLEM -> Value.CREDIT_PROBLEM
                            FRAUD -> Value.FRAUD
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ACCOUNT_CLOSED -> Known.ACCOUNT_CLOSED
                            CREDIT_PROBLEM -> Known.CREDIT_PROBLEM
                            FRAUD -> Known.FRAUD
                            else ->
                                throw IncreaseInvalidDataException("Unknown AccountStatus: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): AccountStatus = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is AccountStatus && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Authorization &&
                        accountStatus == other.accountStatus &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(accountStatus, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Authorization{accountStatus=$accountStatus, additionalProperties=$additionalProperties}"
            }

            /**
             * Canceled merchandise. Required if and only if `category` is
             * `consumer_canceled_merchandise`.
             */
            class ConsumerCanceledMerchandise
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val purchaseExplanation: JsonField<String>,
                private val receivedOrExpectedAt: JsonField<LocalDate>,
                private val returnOutcome: JsonField<ReturnOutcome>,
                private val cardholderCancellation: JsonField<CardholderCancellation>,
                private val notReturned: JsonValue,
                private val returnAttempted: JsonField<ReturnAttempted>,
                private val returned: JsonField<Returned>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    purchaseExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("received_or_expected_at")
                    @ExcludeMissing
                    receivedOrExpectedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    cardholderCancellation: JsonField<CardholderCancellation> = JsonMissing.of(),
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    notReturned: JsonValue = JsonMissing.of(),
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                    @JsonProperty("returned")
                    @ExcludeMissing
                    returned: JsonField<Returned> = JsonMissing.of(),
                ) : this(
                    merchantResolutionAttempted,
                    purchaseExplanation,
                    receivedOrExpectedAt,
                    returnOutcome,
                    cardholderCancellation,
                    notReturned,
                    returnAttempted,
                    returned,
                    mutableMapOf(),
                )

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Purchase explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseExplanation(): String =
                    purchaseExplanation.getRequired("purchase_explanation")

                /**
                 * Received or expected at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedOrExpectedAt(): LocalDate =
                    receivedOrExpectedAt.getRequired("received_or_expected_at")

                /**
                 * Return outcome.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                /**
                 * Cardholder cancellation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun cardholderCancellation(): CardholderCancellation? =
                    cardholderCancellation.getNullable("cardholder_cancellation")

                /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                @JsonProperty("not_returned")
                @ExcludeMissing
                fun _notReturned(): JsonValue = notReturned

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returnAttempted(): ReturnAttempted? =
                    returnAttempted.getNullable("return_attempted")

                /**
                 * Returned. Required if and only if `return_outcome` is `returned`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returned(): Returned? = returned.getNullable("returned")

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [purchaseExplanation].
                 *
                 * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("purchase_explanation")
                @ExcludeMissing
                fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                /**
                 * Returns the raw JSON value of [receivedOrExpectedAt].
                 *
                 * Unlike [receivedOrExpectedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_or_expected_at")
                @ExcludeMissing
                fun _receivedOrExpectedAt(): JsonField<LocalDate> = receivedOrExpectedAt

                /**
                 * Returns the raw JSON value of [returnOutcome].
                 *
                 * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_outcome")
                @ExcludeMissing
                fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                /**
                 * Returns the raw JSON value of [cardholderCancellation].
                 *
                 * Unlike [cardholderCancellation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("cardholder_cancellation")
                @ExcludeMissing
                fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                    cardholderCancellation

                /**
                 * Returns the raw JSON value of [returnAttempted].
                 *
                 * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_attempted")
                @ExcludeMissing
                fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                /**
                 * Returns the raw JSON value of [returned].
                 *
                 * Unlike [returned], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("returned")
                @ExcludeMissing
                fun _returned(): JsonField<Returned> = returned

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerCanceledMerchandise].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .purchaseExplanation()
                     * .receivedOrExpectedAt()
                     * .returnOutcome()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerCanceledMerchandise]. */
                class Builder internal constructor() {

                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var purchaseExplanation: JsonField<String>? = null
                    private var receivedOrExpectedAt: JsonField<LocalDate>? = null
                    private var returnOutcome: JsonField<ReturnOutcome>? = null
                    private var cardholderCancellation: JsonField<CardholderCancellation> =
                        JsonMissing.of()
                    private var notReturned: JsonValue = JsonMissing.of()
                    private var returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of()
                    private var returned: JsonField<Returned> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(consumerCanceledMerchandise: ConsumerCanceledMerchandise) =
                        apply {
                            merchantResolutionAttempted =
                                consumerCanceledMerchandise.merchantResolutionAttempted
                            purchaseExplanation = consumerCanceledMerchandise.purchaseExplanation
                            receivedOrExpectedAt = consumerCanceledMerchandise.receivedOrExpectedAt
                            returnOutcome = consumerCanceledMerchandise.returnOutcome
                            cardholderCancellation =
                                consumerCanceledMerchandise.cardholderCancellation
                            notReturned = consumerCanceledMerchandise.notReturned
                            returnAttempted = consumerCanceledMerchandise.returnAttempted
                            returned = consumerCanceledMerchandise.returned
                            additionalProperties =
                                consumerCanceledMerchandise.additionalProperties.toMutableMap()
                        }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Purchase explanation. */
                    fun purchaseExplanation(purchaseExplanation: String) =
                        purchaseExplanation(JsonField.of(purchaseExplanation))

                    /**
                     * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseExplanation] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                        this.purchaseExplanation = purchaseExplanation
                    }

                    /** Received or expected at. */
                    fun receivedOrExpectedAt(receivedOrExpectedAt: LocalDate) =
                        receivedOrExpectedAt(JsonField.of(receivedOrExpectedAt))

                    /**
                     * Sets [Builder.receivedOrExpectedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedOrExpectedAt] with a well-typed
                     * [LocalDate] value instead. This method is primarily for setting the field to
                     * an undocumented or not yet supported value.
                     */
                    fun receivedOrExpectedAt(receivedOrExpectedAt: JsonField<LocalDate>) = apply {
                        this.receivedOrExpectedAt = receivedOrExpectedAt
                    }

                    /** Return outcome. */
                    fun returnOutcome(returnOutcome: ReturnOutcome) =
                        returnOutcome(JsonField.of(returnOutcome))

                    /**
                     * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnOutcome] with a well-typed
                     * [ReturnOutcome] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                        this.returnOutcome = returnOutcome
                    }

                    /** Cardholder cancellation. */
                    fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                        cardholderCancellation(JsonField.of(cardholderCancellation))

                    /**
                     * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderCancellation] with a well-typed
                     * [CardholderCancellation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun cardholderCancellation(
                        cardholderCancellation: JsonField<CardholderCancellation>
                    ) = apply { this.cardholderCancellation = cardholderCancellation }

                    /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                    fun notReturned(notReturned: JsonValue) = apply {
                        this.notReturned = notReturned
                    }

                    /**
                     * Return attempted. Required if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    fun returnAttempted(returnAttempted: ReturnAttempted) =
                        returnAttempted(JsonField.of(returnAttempted))

                    /**
                     * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnAttempted] with a well-typed
                     * [ReturnAttempted] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                        this.returnAttempted = returnAttempted
                    }

                    /** Returned. Required if and only if `return_outcome` is `returned`. */
                    fun returned(returned: Returned) = returned(JsonField.of(returned))

                    /**
                     * Sets [Builder.returned] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returned] with a well-typed [Returned] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun returned(returned: JsonField<Returned>) = apply { this.returned = returned }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerCanceledMerchandise].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .purchaseExplanation()
                     * .receivedOrExpectedAt()
                     * .returnOutcome()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerCanceledMerchandise =
                        ConsumerCanceledMerchandise(
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired("purchaseExplanation", purchaseExplanation),
                            checkRequired("receivedOrExpectedAt", receivedOrExpectedAt),
                            checkRequired("returnOutcome", returnOutcome),
                            cardholderCancellation,
                            notReturned,
                            returnAttempted,
                            returned,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerCanceledMerchandise = apply {
                    if (validated) {
                        return@apply
                    }

                    merchantResolutionAttempted().validate()
                    purchaseExplanation()
                    receivedOrExpectedAt()
                    returnOutcome().validate()
                    cardholderCancellation()?.validate()
                    returnAttempted()?.validate()
                    returned()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                        (if (receivedOrExpectedAt.asKnown() == null) 0 else 1) +
                        (returnOutcome.asKnown()?.validity() ?: 0) +
                        (cardholderCancellation.asKnown()?.validity() ?: 0) +
                        (returnAttempted.asKnown()?.validity() ?: 0) +
                        (returned.asKnown()?.validity() ?: 0)

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Return outcome. */
                class ReturnOutcome
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Not returned. */
                        val NOT_RETURNED = of("not_returned")

                        /** Returned. */
                        val RETURNED = of("returned")

                        /** Return attempted. */
                        val RETURN_ATTEMPTED = of("return_attempted")

                        fun of(value: String) = ReturnOutcome(JsonField.of(value))
                    }

                    /** An enum containing [ReturnOutcome]'s known values. */
                    enum class Known {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                    }

                    /**
                     * An enum containing [ReturnOutcome]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [ReturnOutcome] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                        /**
                         * An enum member indicating that [ReturnOutcome] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            NOT_RETURNED -> Value.NOT_RETURNED
                            RETURNED -> Value.RETURNED
                            RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            NOT_RETURNED -> Known.NOT_RETURNED
                            RETURNED -> Known.RETURNED
                            RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                            else ->
                                throw IncreaseInvalidDataException("Unknown ReturnOutcome: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): ReturnOutcome = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnOutcome && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Cardholder cancellation. */
                class CardholderCancellation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val canceledAt: JsonField<LocalDate>,
                    private val canceledPriorToShipDate: JsonField<CanceledPriorToShipDate>,
                    private val cancellationPolicyProvided: JsonField<CancellationPolicyProvided>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("canceled_prior_to_ship_date")
                        @ExcludeMissing
                        canceledPriorToShipDate: JsonField<CanceledPriorToShipDate> =
                            JsonMissing.of(),
                        @JsonProperty("cancellation_policy_provided")
                        @ExcludeMissing
                        cancellationPolicyProvided: JsonField<CancellationPolicyProvided> =
                            JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        canceledAt,
                        canceledPriorToShipDate,
                        cancellationPolicyProvided,
                        reason,
                        mutableMapOf(),
                    )

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Canceled prior to ship date.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledPriorToShipDate(): CanceledPriorToShipDate =
                        canceledPriorToShipDate.getRequired("canceled_prior_to_ship_date")

                    /**
                     * Cancellation policy provided.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cancellationPolicyProvided(): CancellationPolicyProvided =
                        cancellationPolicyProvided.getRequired("cancellation_policy_provided")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): String = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    /**
                     * Returns the raw JSON value of [canceledPriorToShipDate].
                     *
                     * Unlike [canceledPriorToShipDate], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("canceled_prior_to_ship_date")
                    @ExcludeMissing
                    fun _canceledPriorToShipDate(): JsonField<CanceledPriorToShipDate> =
                        canceledPriorToShipDate

                    /**
                     * Returns the raw JSON value of [cancellationPolicyProvided].
                     *
                     * Unlike [cancellationPolicyProvided], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("cancellation_policy_provided")
                    @ExcludeMissing
                    fun _cancellationPolicyProvided(): JsonField<CancellationPolicyProvided> =
                        cancellationPolicyProvided

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderCancellation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * .canceledPriorToShipDate()
                         * .cancellationPolicyProvided()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderCancellation]. */
                    class Builder internal constructor() {

                        private var canceledAt: JsonField<LocalDate>? = null
                        private var canceledPriorToShipDate: JsonField<CanceledPriorToShipDate>? =
                            null
                        private var cancellationPolicyProvided:
                            JsonField<CancellationPolicyProvided>? =
                            null
                        private var reason: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(cardholderCancellation: CardholderCancellation) = apply {
                            canceledAt = cardholderCancellation.canceledAt
                            canceledPriorToShipDate = cardholderCancellation.canceledPriorToShipDate
                            cancellationPolicyProvided =
                                cardholderCancellation.cancellationPolicyProvided
                            reason = cardholderCancellation.reason
                            additionalProperties =
                                cardholderCancellation.additionalProperties.toMutableMap()
                        }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        /** Canceled prior to ship date. */
                        fun canceledPriorToShipDate(
                            canceledPriorToShipDate: CanceledPriorToShipDate
                        ) = canceledPriorToShipDate(JsonField.of(canceledPriorToShipDate))

                        /**
                         * Sets [Builder.canceledPriorToShipDate] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledPriorToShipDate] with a
                         * well-typed [CanceledPriorToShipDate] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun canceledPriorToShipDate(
                            canceledPriorToShipDate: JsonField<CanceledPriorToShipDate>
                        ) = apply { this.canceledPriorToShipDate = canceledPriorToShipDate }

                        /** Cancellation policy provided. */
                        fun cancellationPolicyProvided(
                            cancellationPolicyProvided: CancellationPolicyProvided
                        ) = cancellationPolicyProvided(JsonField.of(cancellationPolicyProvided))

                        /**
                         * Sets [Builder.cancellationPolicyProvided] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cancellationPolicyProvided] with a
                         * well-typed [CancellationPolicyProvided] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cancellationPolicyProvided(
                            cancellationPolicyProvided: JsonField<CancellationPolicyProvided>
                        ) = apply { this.cancellationPolicyProvided = cancellationPolicyProvided }

                        /** Reason. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CardholderCancellation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * .canceledPriorToShipDate()
                         * .cancellationPolicyProvided()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderCancellation =
                            CardholderCancellation(
                                checkRequired("canceledAt", canceledAt),
                                checkRequired("canceledPriorToShipDate", canceledPriorToShipDate),
                                checkRequired(
                                    "cancellationPolicyProvided",
                                    cancellationPolicyProvided,
                                ),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderCancellation = apply {
                        if (validated) {
                            return@apply
                        }

                        canceledAt()
                        canceledPriorToShipDate().validate()
                        cancellationPolicyProvided().validate()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (canceledAt.asKnown() == null) 0 else 1) +
                            (canceledPriorToShipDate.asKnown()?.validity() ?: 0) +
                            (cancellationPolicyProvided.asKnown()?.validity() ?: 0) +
                            (if (reason.asKnown() == null) 0 else 1)

                    /** Canceled prior to ship date. */
                    class CanceledPriorToShipDate
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Canceled prior to ship date. */
                            val CANCELED_PRIOR_TO_SHIP_DATE = of("canceled_prior_to_ship_date")

                            /** Not canceled prior to ship date. */
                            val NOT_CANCELED_PRIOR_TO_SHIP_DATE =
                                of("not_canceled_prior_to_ship_date")

                            fun of(value: String) = CanceledPriorToShipDate(JsonField.of(value))
                        }

                        /** An enum containing [CanceledPriorToShipDate]'s known values. */
                        enum class Known {
                            /** Canceled prior to ship date. */
                            CANCELED_PRIOR_TO_SHIP_DATE,
                            /** Not canceled prior to ship date. */
                            NOT_CANCELED_PRIOR_TO_SHIP_DATE,
                        }

                        /**
                         * An enum containing [CanceledPriorToShipDate]'s known values, as well as
                         * an [_UNKNOWN] member.
                         *
                         * An instance of [CanceledPriorToShipDate] can contain an unknown value in
                         * a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Canceled prior to ship date. */
                            CANCELED_PRIOR_TO_SHIP_DATE,
                            /** Not canceled prior to ship date. */
                            NOT_CANCELED_PRIOR_TO_SHIP_DATE,
                            /**
                             * An enum member indicating that [CanceledPriorToShipDate] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                CANCELED_PRIOR_TO_SHIP_DATE -> Value.CANCELED_PRIOR_TO_SHIP_DATE
                                NOT_CANCELED_PRIOR_TO_SHIP_DATE ->
                                    Value.NOT_CANCELED_PRIOR_TO_SHIP_DATE
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                CANCELED_PRIOR_TO_SHIP_DATE -> Known.CANCELED_PRIOR_TO_SHIP_DATE
                                NOT_CANCELED_PRIOR_TO_SHIP_DATE ->
                                    Known.NOT_CANCELED_PRIOR_TO_SHIP_DATE
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CanceledPriorToShipDate: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CanceledPriorToShipDate = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CanceledPriorToShipDate && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Cancellation policy provided. */
                    class CancellationPolicyProvided
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not provided. */
                            val NOT_PROVIDED = of("not_provided")

                            /** Provided. */
                            val PROVIDED = of("provided")

                            fun of(value: String) = CancellationPolicyProvided(JsonField.of(value))
                        }

                        /** An enum containing [CancellationPolicyProvided]'s known values. */
                        enum class Known {
                            /** Not provided. */
                            NOT_PROVIDED,
                            /** Provided. */
                            PROVIDED,
                        }

                        /**
                         * An enum containing [CancellationPolicyProvided]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [CancellationPolicyProvided] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not provided. */
                            NOT_PROVIDED,
                            /** Provided. */
                            PROVIDED,
                            /**
                             * An enum member indicating that [CancellationPolicyProvided] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_PROVIDED -> Value.NOT_PROVIDED
                                PROVIDED -> Value.PROVIDED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_PROVIDED -> Known.NOT_PROVIDED
                                PROVIDED -> Known.PROVIDED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CancellationPolicyProvided: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CancellationPolicyProvided = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CancellationPolicyProvided && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderCancellation &&
                            canceledAt == other.canceledAt &&
                            canceledPriorToShipDate == other.canceledPriorToShipDate &&
                            cancellationPolicyProvided == other.cancellationPolicyProvided &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            canceledAt,
                            canceledPriorToShipDate,
                            cancellationPolicyProvided,
                            reason,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderCancellation{canceledAt=$canceledAt, canceledPriorToShipDate=$canceledPriorToShipDate, cancellationPolicyProvided=$cancellationPolicyProvided, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 */
                class ReturnAttempted
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val attemptExplanation: JsonField<String>,
                    private val attemptReason: JsonField<AttemptReason>,
                    private val attemptedAt: JsonField<LocalDate>,
                    private val merchandiseDisposition: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        attemptExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        attemptExplanation,
                        attemptReason,
                        attemptedAt,
                        merchandiseDisposition,
                        mutableMapOf(),
                    )

                    /**
                     * Attempt explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptExplanation(): String =
                        attemptExplanation.getRequired("attempt_explanation")

                    /**
                     * Attempt reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptReason(): AttemptReason = attemptReason.getRequired("attempt_reason")

                    /**
                     * Attempted at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                    /**
                     * Merchandise disposition.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchandiseDisposition(): String =
                        merchandiseDisposition.getRequired("merchandise_disposition")

                    /**
                     * Returns the raw JSON value of [attemptExplanation].
                     *
                     * Unlike [attemptExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("attempt_explanation")
                    @ExcludeMissing
                    fun _attemptExplanation(): JsonField<String> = attemptExplanation

                    /**
                     * Returns the raw JSON value of [attemptReason].
                     *
                     * Unlike [attemptReason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempt_reason")
                    @ExcludeMissing
                    fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                    /**
                     * Returns the raw JSON value of [attemptedAt].
                     *
                     * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempted_at")
                    @ExcludeMissing
                    fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                    /**
                     * Returns the raw JSON value of [merchandiseDisposition].
                     *
                     * Unlike [merchandiseDisposition], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchandise_disposition")
                    @ExcludeMissing
                    fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ReturnAttempted].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ReturnAttempted]. */
                    class Builder internal constructor() {

                        private var attemptExplanation: JsonField<String>? = null
                        private var attemptReason: JsonField<AttemptReason>? = null
                        private var attemptedAt: JsonField<LocalDate>? = null
                        private var merchandiseDisposition: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returnAttempted: ReturnAttempted) = apply {
                            attemptExplanation = returnAttempted.attemptExplanation
                            attemptReason = returnAttempted.attemptReason
                            attemptedAt = returnAttempted.attemptedAt
                            merchandiseDisposition = returnAttempted.merchandiseDisposition
                            additionalProperties =
                                returnAttempted.additionalProperties.toMutableMap()
                        }

                        /** Attempt explanation. */
                        fun attemptExplanation(attemptExplanation: String) =
                            attemptExplanation(JsonField.of(attemptExplanation))

                        /**
                         * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                            this.attemptExplanation = attemptExplanation
                        }

                        /** Attempt reason. */
                        fun attemptReason(attemptReason: AttemptReason) =
                            attemptReason(JsonField.of(attemptReason))

                        /**
                         * Sets [Builder.attemptReason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptReason] with a well-typed
                         * [AttemptReason] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                            this.attemptReason = attemptReason
                        }

                        /** Attempted at. */
                        fun attemptedAt(attemptedAt: LocalDate) =
                            attemptedAt(JsonField.of(attemptedAt))

                        /**
                         * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                            this.attemptedAt = attemptedAt
                        }

                        /** Merchandise disposition. */
                        fun merchandiseDisposition(merchandiseDisposition: String) =
                            merchandiseDisposition(JsonField.of(merchandiseDisposition))

                        /**
                         * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchandiseDisposition] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                            apply {
                                this.merchandiseDisposition = merchandiseDisposition
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ReturnAttempted].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ReturnAttempted =
                            ReturnAttempted(
                                checkRequired("attemptExplanation", attemptExplanation),
                                checkRequired("attemptReason", attemptReason),
                                checkRequired("attemptedAt", attemptedAt),
                                checkRequired("merchandiseDisposition", merchandiseDisposition),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ReturnAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        attemptExplanation()
                        attemptReason().validate()
                        attemptedAt()
                        merchandiseDisposition()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (attemptExplanation.asKnown() == null) 0 else 1) +
                            (attemptReason.asKnown()?.validity() ?: 0) +
                            (if (attemptedAt.asKnown() == null) 0 else 1) +
                            (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                    /** Attempt reason. */
                    class AttemptReason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Merchant not responding. */
                            val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                            /** No return authorization provided. */
                            val NO_RETURN_AUTHORIZATION_PROVIDED =
                                of("no_return_authorization_provided")

                            /** No return instructions. */
                            val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                            /** Requested not to return. */
                            val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                            /** Return not accepted. */
                            val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                            fun of(value: String) = AttemptReason(JsonField.of(value))
                        }

                        /** An enum containing [AttemptReason]'s known values. */
                        enum class Known {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AttemptReason]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AttemptReason] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AttemptReason] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AttemptReason: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AttemptReason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AttemptReason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnAttempted &&
                            attemptExplanation == other.attemptExplanation &&
                            attemptReason == other.attemptReason &&
                            attemptedAt == other.attemptedAt &&
                            merchandiseDisposition == other.merchandiseDisposition &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                }

                /** Returned. Required if and only if `return_outcome` is `returned`. */
                class Returned
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val returnMethod: JsonField<ReturnMethod>,
                    private val returnedAt: JsonField<LocalDate>,
                    private val merchantReceivedReturnAt: JsonField<LocalDate>,
                    private val otherExplanation: JsonField<String>,
                    private val trackingNumber: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        otherExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        trackingNumber: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        returnMethod,
                        returnedAt,
                        merchantReceivedReturnAt,
                        otherExplanation,
                        trackingNumber,
                        mutableMapOf(),
                    )

                    /**
                     * Return method.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                    /**
                     * Returned at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                    /**
                     * Merchant received return at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun merchantReceivedReturnAt(): LocalDate? =
                        merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                    /**
                     * Other explanation. Required if and only if the return method is `other`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun otherExplanation(): String? =
                        otherExplanation.getNullable("other_explanation")

                    /**
                     * Tracking number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun trackingNumber(): String? = trackingNumber.getNullable("tracking_number")

                    /**
                     * Returns the raw JSON value of [returnMethod].
                     *
                     * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_method")
                    @ExcludeMissing
                    fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                    /**
                     * Returns the raw JSON value of [returnedAt].
                     *
                     * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned_at")
                    @ExcludeMissing
                    fun _returnedAt(): JsonField<LocalDate> = returnedAt

                    /**
                     * Returns the raw JSON value of [merchantReceivedReturnAt].
                     *
                     * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_received_return_at")
                    @ExcludeMissing
                    fun _merchantReceivedReturnAt(): JsonField<LocalDate> = merchantReceivedReturnAt

                    /**
                     * Returns the raw JSON value of [otherExplanation].
                     *
                     * Unlike [otherExplanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("other_explanation")
                    @ExcludeMissing
                    fun _otherExplanation(): JsonField<String> = otherExplanation

                    /**
                     * Returns the raw JSON value of [trackingNumber].
                     *
                     * Unlike [trackingNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("tracking_number")
                    @ExcludeMissing
                    fun _trackingNumber(): JsonField<String> = trackingNumber

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Returned].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Returned]. */
                    class Builder internal constructor() {

                        private var returnMethod: JsonField<ReturnMethod>? = null
                        private var returnedAt: JsonField<LocalDate>? = null
                        private var merchantReceivedReturnAt: JsonField<LocalDate> =
                            JsonMissing.of()
                        private var otherExplanation: JsonField<String> = JsonMissing.of()
                        private var trackingNumber: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returned: Returned) = apply {
                            returnMethod = returned.returnMethod
                            returnedAt = returned.returnedAt
                            merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                            otherExplanation = returned.otherExplanation
                            trackingNumber = returned.trackingNumber
                            additionalProperties = returned.additionalProperties.toMutableMap()
                        }

                        /** Return method. */
                        fun returnMethod(returnMethod: ReturnMethod) =
                            returnMethod(JsonField.of(returnMethod))

                        /**
                         * Sets [Builder.returnMethod] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnMethod] with a well-typed
                         * [ReturnMethod] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                            this.returnMethod = returnMethod
                        }

                        /** Returned at. */
                        fun returnedAt(returnedAt: LocalDate) = returnedAt(JsonField.of(returnedAt))

                        /**
                         * Sets [Builder.returnedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                            this.returnedAt = returnedAt
                        }

                        /** Merchant received return at. */
                        fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate) =
                            merchantReceivedReturnAt(JsonField.of(merchantReceivedReturnAt))

                        /**
                         * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantReceivedReturnAt] with a
                         * well-typed [LocalDate] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun merchantReceivedReturnAt(
                            merchantReceivedReturnAt: JsonField<LocalDate>
                        ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         */
                        fun otherExplanation(otherExplanation: String) =
                            otherExplanation(JsonField.of(otherExplanation))

                        /**
                         * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                            this.otherExplanation = otherExplanation
                        }

                        /** Tracking number. */
                        fun trackingNumber(trackingNumber: String) =
                            trackingNumber(JsonField.of(trackingNumber))

                        /**
                         * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.trackingNumber] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                            this.trackingNumber = trackingNumber
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Returned].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Returned =
                            Returned(
                                checkRequired("returnMethod", returnMethod),
                                checkRequired("returnedAt", returnedAt),
                                merchantReceivedReturnAt,
                                otherExplanation,
                                trackingNumber,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Returned = apply {
                        if (validated) {
                            return@apply
                        }

                        returnMethod().validate()
                        returnedAt()
                        merchantReceivedReturnAt()
                        otherExplanation()
                        trackingNumber()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (returnMethod.asKnown()?.validity() ?: 0) +
                            (if (returnedAt.asKnown() == null) 0 else 1) +
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                            (if (otherExplanation.asKnown() == null) 0 else 1) +
                            (if (trackingNumber.asKnown() == null) 0 else 1)

                    /** Return method. */
                    class ReturnMethod
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** DHL. */
                            val DHL = of("dhl")

                            /** Face-to-face. */
                            val FACE_TO_FACE = of("face_to_face")

                            /** FedEx. */
                            val FEDEX = of("fedex")

                            /** Other. */
                            val OTHER = of("other")

                            /** Postal service. */
                            val POSTAL_SERVICE = of("postal_service")

                            /** UPS. */
                            val UPS = of("ups")

                            fun of(value: String) = ReturnMethod(JsonField.of(value))
                        }

                        /** An enum containing [ReturnMethod]'s known values. */
                        enum class Known {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                        }

                        /**
                         * An enum containing [ReturnMethod]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnMethod] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                            /**
                             * An enum member indicating that [ReturnMethod] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DHL -> Value.DHL
                                FACE_TO_FACE -> Value.FACE_TO_FACE
                                FEDEX -> Value.FEDEX
                                OTHER -> Value.OTHER
                                POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                UPS -> Value.UPS
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DHL -> Known.DHL
                                FACE_TO_FACE -> Known.FACE_TO_FACE
                                FEDEX -> Known.FEDEX
                                OTHER -> Known.OTHER
                                POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                UPS -> Known.UPS
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnMethod: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnMethod = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnMethod && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Returned &&
                            returnMethod == other.returnMethod &&
                            returnedAt == other.returnedAt &&
                            merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                            otherExplanation == other.otherExplanation &&
                            trackingNumber == other.trackingNumber &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            returnMethod,
                            returnedAt,
                            merchantReceivedReturnAt,
                            otherExplanation,
                            trackingNumber,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Returned{returnMethod=$returnMethod, returnedAt=$returnedAt, merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerCanceledMerchandise &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        purchaseExplanation == other.purchaseExplanation &&
                        receivedOrExpectedAt == other.receivedOrExpectedAt &&
                        returnOutcome == other.returnOutcome &&
                        cardholderCancellation == other.cardholderCancellation &&
                        notReturned == other.notReturned &&
                        returnAttempted == other.returnAttempted &&
                        returned == other.returned &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        merchantResolutionAttempted,
                        purchaseExplanation,
                        receivedOrExpectedAt,
                        returnOutcome,
                        cardholderCancellation,
                        notReturned,
                        returnAttempted,
                        returned,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerCanceledMerchandise{merchantResolutionAttempted=$merchantResolutionAttempted, purchaseExplanation=$purchaseExplanation, receivedOrExpectedAt=$receivedOrExpectedAt, returnOutcome=$returnOutcome, cardholderCancellation=$cardholderCancellation, notReturned=$notReturned, returnAttempted=$returnAttempted, returned=$returned, additionalProperties=$additionalProperties}"
            }

            /**
             * Canceled recurring transaction. Required if and only if `category` is
             * `consumer_canceled_recurring_transaction`.
             */
            class ConsumerCanceledRecurringTransaction
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cancellationTarget: JsonField<CancellationTarget>,
                private val merchantContactMethods: JsonField<MerchantContactMethods>,
                private val transactionOrAccountCanceledAt: JsonField<LocalDate>,
                private val otherFormOfPaymentExplanation: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cancellation_target")
                    @ExcludeMissing
                    cancellationTarget: JsonField<CancellationTarget> = JsonMissing.of(),
                    @JsonProperty("merchant_contact_methods")
                    @ExcludeMissing
                    merchantContactMethods: JsonField<MerchantContactMethods> = JsonMissing.of(),
                    @JsonProperty("transaction_or_account_canceled_at")
                    @ExcludeMissing
                    transactionOrAccountCanceledAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("other_form_of_payment_explanation")
                    @ExcludeMissing
                    otherFormOfPaymentExplanation: JsonField<String> = JsonMissing.of(),
                ) : this(
                    cancellationTarget,
                    merchantContactMethods,
                    transactionOrAccountCanceledAt,
                    otherFormOfPaymentExplanation,
                    mutableMapOf(),
                )

                /**
                 * Cancellation target.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun cancellationTarget(): CancellationTarget =
                    cancellationTarget.getRequired("cancellation_target")

                /**
                 * Merchant contact methods.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantContactMethods(): MerchantContactMethods =
                    merchantContactMethods.getRequired("merchant_contact_methods")

                /**
                 * Transaction or account canceled at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun transactionOrAccountCanceledAt(): LocalDate =
                    transactionOrAccountCanceledAt.getRequired("transaction_or_account_canceled_at")

                /**
                 * Other form of payment explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun otherFormOfPaymentExplanation(): String? =
                    otherFormOfPaymentExplanation.getNullable("other_form_of_payment_explanation")

                /**
                 * Returns the raw JSON value of [cancellationTarget].
                 *
                 * Unlike [cancellationTarget], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("cancellation_target")
                @ExcludeMissing
                fun _cancellationTarget(): JsonField<CancellationTarget> = cancellationTarget

                /**
                 * Returns the raw JSON value of [merchantContactMethods].
                 *
                 * Unlike [merchantContactMethods], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("merchant_contact_methods")
                @ExcludeMissing
                fun _merchantContactMethods(): JsonField<MerchantContactMethods> =
                    merchantContactMethods

                /**
                 * Returns the raw JSON value of [transactionOrAccountCanceledAt].
                 *
                 * Unlike [transactionOrAccountCanceledAt], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("transaction_or_account_canceled_at")
                @ExcludeMissing
                fun _transactionOrAccountCanceledAt(): JsonField<LocalDate> =
                    transactionOrAccountCanceledAt

                /**
                 * Returns the raw JSON value of [otherFormOfPaymentExplanation].
                 *
                 * Unlike [otherFormOfPaymentExplanation], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("other_form_of_payment_explanation")
                @ExcludeMissing
                fun _otherFormOfPaymentExplanation(): JsonField<String> =
                    otherFormOfPaymentExplanation

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerCanceledRecurringTransaction].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cancellationTarget()
                     * .merchantContactMethods()
                     * .transactionOrAccountCanceledAt()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerCanceledRecurringTransaction]. */
                class Builder internal constructor() {

                    private var cancellationTarget: JsonField<CancellationTarget>? = null
                    private var merchantContactMethods: JsonField<MerchantContactMethods>? = null
                    private var transactionOrAccountCanceledAt: JsonField<LocalDate>? = null
                    private var otherFormOfPaymentExplanation: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerCanceledRecurringTransaction: ConsumerCanceledRecurringTransaction
                    ) = apply {
                        cancellationTarget = consumerCanceledRecurringTransaction.cancellationTarget
                        merchantContactMethods =
                            consumerCanceledRecurringTransaction.merchantContactMethods
                        transactionOrAccountCanceledAt =
                            consumerCanceledRecurringTransaction.transactionOrAccountCanceledAt
                        otherFormOfPaymentExplanation =
                            consumerCanceledRecurringTransaction.otherFormOfPaymentExplanation
                        additionalProperties =
                            consumerCanceledRecurringTransaction.additionalProperties.toMutableMap()
                    }

                    /** Cancellation target. */
                    fun cancellationTarget(cancellationTarget: CancellationTarget) =
                        cancellationTarget(JsonField.of(cancellationTarget))

                    /**
                     * Sets [Builder.cancellationTarget] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cancellationTarget] with a well-typed
                     * [CancellationTarget] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun cancellationTarget(cancellationTarget: JsonField<CancellationTarget>) =
                        apply {
                            this.cancellationTarget = cancellationTarget
                        }

                    /** Merchant contact methods. */
                    fun merchantContactMethods(merchantContactMethods: MerchantContactMethods) =
                        merchantContactMethods(JsonField.of(merchantContactMethods))

                    /**
                     * Sets [Builder.merchantContactMethods] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantContactMethods] with a well-typed
                     * [MerchantContactMethods] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun merchantContactMethods(
                        merchantContactMethods: JsonField<MerchantContactMethods>
                    ) = apply { this.merchantContactMethods = merchantContactMethods }

                    /** Transaction or account canceled at. */
                    fun transactionOrAccountCanceledAt(transactionOrAccountCanceledAt: LocalDate) =
                        transactionOrAccountCanceledAt(JsonField.of(transactionOrAccountCanceledAt))

                    /**
                     * Sets [Builder.transactionOrAccountCanceledAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.transactionOrAccountCanceledAt] with a
                     * well-typed [LocalDate] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun transactionOrAccountCanceledAt(
                        transactionOrAccountCanceledAt: JsonField<LocalDate>
                    ) = apply {
                        this.transactionOrAccountCanceledAt = transactionOrAccountCanceledAt
                    }

                    /** Other form of payment explanation. */
                    fun otherFormOfPaymentExplanation(otherFormOfPaymentExplanation: String) =
                        otherFormOfPaymentExplanation(JsonField.of(otherFormOfPaymentExplanation))

                    /**
                     * Sets [Builder.otherFormOfPaymentExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.otherFormOfPaymentExplanation] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun otherFormOfPaymentExplanation(
                        otherFormOfPaymentExplanation: JsonField<String>
                    ) = apply { this.otherFormOfPaymentExplanation = otherFormOfPaymentExplanation }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerCanceledRecurringTransaction].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cancellationTarget()
                     * .merchantContactMethods()
                     * .transactionOrAccountCanceledAt()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerCanceledRecurringTransaction =
                        ConsumerCanceledRecurringTransaction(
                            checkRequired("cancellationTarget", cancellationTarget),
                            checkRequired("merchantContactMethods", merchantContactMethods),
                            checkRequired(
                                "transactionOrAccountCanceledAt",
                                transactionOrAccountCanceledAt,
                            ),
                            otherFormOfPaymentExplanation,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerCanceledRecurringTransaction = apply {
                    if (validated) {
                        return@apply
                    }

                    cancellationTarget().validate()
                    merchantContactMethods().validate()
                    transactionOrAccountCanceledAt()
                    otherFormOfPaymentExplanation()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cancellationTarget.asKnown()?.validity() ?: 0) +
                        (merchantContactMethods.asKnown()?.validity() ?: 0) +
                        (if (transactionOrAccountCanceledAt.asKnown() == null) 0 else 1) +
                        (if (otherFormOfPaymentExplanation.asKnown() == null) 0 else 1)

                /** Cancellation target. */
                class CancellationTarget
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Account. */
                        val ACCOUNT = of("account")

                        /** Transaction. */
                        val TRANSACTION = of("transaction")

                        fun of(value: String) = CancellationTarget(JsonField.of(value))
                    }

                    /** An enum containing [CancellationTarget]'s known values. */
                    enum class Known {
                        /** Account. */
                        ACCOUNT,
                        /** Transaction. */
                        TRANSACTION,
                    }

                    /**
                     * An enum containing [CancellationTarget]'s known values, as well as an
                     * [_UNKNOWN] member.
                     *
                     * An instance of [CancellationTarget] can contain an unknown value in a couple
                     * of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Account. */
                        ACCOUNT,
                        /** Transaction. */
                        TRANSACTION,
                        /**
                         * An enum member indicating that [CancellationTarget] was instantiated with
                         * an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ACCOUNT -> Value.ACCOUNT
                            TRANSACTION -> Value.TRANSACTION
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ACCOUNT -> Known.ACCOUNT
                            TRANSACTION -> Known.TRANSACTION
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown CancellationTarget: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): CancellationTarget = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CancellationTarget && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Merchant contact methods. */
                class MerchantContactMethods
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val applicationName: JsonField<String>,
                    private val callCenterPhoneNumber: JsonField<String>,
                    private val emailAddress: JsonField<String>,
                    private val inPersonAddress: JsonField<String>,
                    private val mailingAddress: JsonField<String>,
                    private val textPhoneNumber: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("application_name")
                        @ExcludeMissing
                        applicationName: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("call_center_phone_number")
                        @ExcludeMissing
                        callCenterPhoneNumber: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("email_address")
                        @ExcludeMissing
                        emailAddress: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("in_person_address")
                        @ExcludeMissing
                        inPersonAddress: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("mailing_address")
                        @ExcludeMissing
                        mailingAddress: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("text_phone_number")
                        @ExcludeMissing
                        textPhoneNumber: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        applicationName,
                        callCenterPhoneNumber,
                        emailAddress,
                        inPersonAddress,
                        mailingAddress,
                        textPhoneNumber,
                        mutableMapOf(),
                    )

                    /**
                     * Application name.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun applicationName(): String? = applicationName.getNullable("application_name")

                    /**
                     * Call center phone number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun callCenterPhoneNumber(): String? =
                        callCenterPhoneNumber.getNullable("call_center_phone_number")

                    /**
                     * Email address.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun emailAddress(): String? = emailAddress.getNullable("email_address")

                    /**
                     * In person address.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun inPersonAddress(): String? =
                        inPersonAddress.getNullable("in_person_address")

                    /**
                     * Mailing address.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun mailingAddress(): String? = mailingAddress.getNullable("mailing_address")

                    /**
                     * Text phone number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun textPhoneNumber(): String? =
                        textPhoneNumber.getNullable("text_phone_number")

                    /**
                     * Returns the raw JSON value of [applicationName].
                     *
                     * Unlike [applicationName], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("application_name")
                    @ExcludeMissing
                    fun _applicationName(): JsonField<String> = applicationName

                    /**
                     * Returns the raw JSON value of [callCenterPhoneNumber].
                     *
                     * Unlike [callCenterPhoneNumber], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("call_center_phone_number")
                    @ExcludeMissing
                    fun _callCenterPhoneNumber(): JsonField<String> = callCenterPhoneNumber

                    /**
                     * Returns the raw JSON value of [emailAddress].
                     *
                     * Unlike [emailAddress], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("email_address")
                    @ExcludeMissing
                    fun _emailAddress(): JsonField<String> = emailAddress

                    /**
                     * Returns the raw JSON value of [inPersonAddress].
                     *
                     * Unlike [inPersonAddress], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("in_person_address")
                    @ExcludeMissing
                    fun _inPersonAddress(): JsonField<String> = inPersonAddress

                    /**
                     * Returns the raw JSON value of [mailingAddress].
                     *
                     * Unlike [mailingAddress], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("mailing_address")
                    @ExcludeMissing
                    fun _mailingAddress(): JsonField<String> = mailingAddress

                    /**
                     * Returns the raw JSON value of [textPhoneNumber].
                     *
                     * Unlike [textPhoneNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("text_phone_number")
                    @ExcludeMissing
                    fun _textPhoneNumber(): JsonField<String> = textPhoneNumber

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [MerchantContactMethods].
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [MerchantContactMethods]. */
                    class Builder internal constructor() {

                        private var applicationName: JsonField<String> = JsonMissing.of()
                        private var callCenterPhoneNumber: JsonField<String> = JsonMissing.of()
                        private var emailAddress: JsonField<String> = JsonMissing.of()
                        private var inPersonAddress: JsonField<String> = JsonMissing.of()
                        private var mailingAddress: JsonField<String> = JsonMissing.of()
                        private var textPhoneNumber: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(merchantContactMethods: MerchantContactMethods) = apply {
                            applicationName = merchantContactMethods.applicationName
                            callCenterPhoneNumber = merchantContactMethods.callCenterPhoneNumber
                            emailAddress = merchantContactMethods.emailAddress
                            inPersonAddress = merchantContactMethods.inPersonAddress
                            mailingAddress = merchantContactMethods.mailingAddress
                            textPhoneNumber = merchantContactMethods.textPhoneNumber
                            additionalProperties =
                                merchantContactMethods.additionalProperties.toMutableMap()
                        }

                        /** Application name. */
                        fun applicationName(applicationName: String) =
                            applicationName(JsonField.of(applicationName))

                        /**
                         * Sets [Builder.applicationName] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.applicationName] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun applicationName(applicationName: JsonField<String>) = apply {
                            this.applicationName = applicationName
                        }

                        /** Call center phone number. */
                        fun callCenterPhoneNumber(callCenterPhoneNumber: String) =
                            callCenterPhoneNumber(JsonField.of(callCenterPhoneNumber))

                        /**
                         * Sets [Builder.callCenterPhoneNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.callCenterPhoneNumber] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun callCenterPhoneNumber(callCenterPhoneNumber: JsonField<String>) =
                            apply {
                                this.callCenterPhoneNumber = callCenterPhoneNumber
                            }

                        /** Email address. */
                        fun emailAddress(emailAddress: String) =
                            emailAddress(JsonField.of(emailAddress))

                        /**
                         * Sets [Builder.emailAddress] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.emailAddress] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun emailAddress(emailAddress: JsonField<String>) = apply {
                            this.emailAddress = emailAddress
                        }

                        /** In person address. */
                        fun inPersonAddress(inPersonAddress: String) =
                            inPersonAddress(JsonField.of(inPersonAddress))

                        /**
                         * Sets [Builder.inPersonAddress] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.inPersonAddress] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun inPersonAddress(inPersonAddress: JsonField<String>) = apply {
                            this.inPersonAddress = inPersonAddress
                        }

                        /** Mailing address. */
                        fun mailingAddress(mailingAddress: String) =
                            mailingAddress(JsonField.of(mailingAddress))

                        /**
                         * Sets [Builder.mailingAddress] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.mailingAddress] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun mailingAddress(mailingAddress: JsonField<String>) = apply {
                            this.mailingAddress = mailingAddress
                        }

                        /** Text phone number. */
                        fun textPhoneNumber(textPhoneNumber: String) =
                            textPhoneNumber(JsonField.of(textPhoneNumber))

                        /**
                         * Sets [Builder.textPhoneNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.textPhoneNumber] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun textPhoneNumber(textPhoneNumber: JsonField<String>) = apply {
                            this.textPhoneNumber = textPhoneNumber
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [MerchantContactMethods].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         */
                        fun build(): MerchantContactMethods =
                            MerchantContactMethods(
                                applicationName,
                                callCenterPhoneNumber,
                                emailAddress,
                                inPersonAddress,
                                mailingAddress,
                                textPhoneNumber,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): MerchantContactMethods = apply {
                        if (validated) {
                            return@apply
                        }

                        applicationName()
                        callCenterPhoneNumber()
                        emailAddress()
                        inPersonAddress()
                        mailingAddress()
                        textPhoneNumber()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (applicationName.asKnown() == null) 0 else 1) +
                            (if (callCenterPhoneNumber.asKnown() == null) 0 else 1) +
                            (if (emailAddress.asKnown() == null) 0 else 1) +
                            (if (inPersonAddress.asKnown() == null) 0 else 1) +
                            (if (mailingAddress.asKnown() == null) 0 else 1) +
                            (if (textPhoneNumber.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantContactMethods &&
                            applicationName == other.applicationName &&
                            callCenterPhoneNumber == other.callCenterPhoneNumber &&
                            emailAddress == other.emailAddress &&
                            inPersonAddress == other.inPersonAddress &&
                            mailingAddress == other.mailingAddress &&
                            textPhoneNumber == other.textPhoneNumber &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            applicationName,
                            callCenterPhoneNumber,
                            emailAddress,
                            inPersonAddress,
                            mailingAddress,
                            textPhoneNumber,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "MerchantContactMethods{applicationName=$applicationName, callCenterPhoneNumber=$callCenterPhoneNumber, emailAddress=$emailAddress, inPersonAddress=$inPersonAddress, mailingAddress=$mailingAddress, textPhoneNumber=$textPhoneNumber, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerCanceledRecurringTransaction &&
                        cancellationTarget == other.cancellationTarget &&
                        merchantContactMethods == other.merchantContactMethods &&
                        transactionOrAccountCanceledAt == other.transactionOrAccountCanceledAt &&
                        otherFormOfPaymentExplanation == other.otherFormOfPaymentExplanation &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cancellationTarget,
                        merchantContactMethods,
                        transactionOrAccountCanceledAt,
                        otherFormOfPaymentExplanation,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerCanceledRecurringTransaction{cancellationTarget=$cancellationTarget, merchantContactMethods=$merchantContactMethods, transactionOrAccountCanceledAt=$transactionOrAccountCanceledAt, otherFormOfPaymentExplanation=$otherFormOfPaymentExplanation, additionalProperties=$additionalProperties}"
            }

            /**
             * Canceled services. Required if and only if `category` is
             * `consumer_canceled_services`.
             */
            class ConsumerCanceledServices
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cardholderCancellation: JsonField<CardholderCancellation>,
                private val contractedAt: JsonField<LocalDate>,
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val purchaseExplanation: JsonField<String>,
                private val serviceType: JsonField<ServiceType>,
                private val guaranteedReservation: JsonField<GuaranteedReservation>,
                private val other: JsonValue,
                private val timeshare: JsonValue,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    cardholderCancellation: JsonField<CardholderCancellation> = JsonMissing.of(),
                    @JsonProperty("contracted_at")
                    @ExcludeMissing
                    contractedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    purchaseExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("service_type")
                    @ExcludeMissing
                    serviceType: JsonField<ServiceType> = JsonMissing.of(),
                    @JsonProperty("guaranteed_reservation")
                    @ExcludeMissing
                    guaranteedReservation: JsonField<GuaranteedReservation> = JsonMissing.of(),
                    @JsonProperty("other") @ExcludeMissing other: JsonValue = JsonMissing.of(),
                    @JsonProperty("timeshare")
                    @ExcludeMissing
                    timeshare: JsonValue = JsonMissing.of(),
                ) : this(
                    cardholderCancellation,
                    contractedAt,
                    merchantResolutionAttempted,
                    purchaseExplanation,
                    serviceType,
                    guaranteedReservation,
                    other,
                    timeshare,
                    mutableMapOf(),
                )

                /**
                 * Cardholder cancellation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun cardholderCancellation(): CardholderCancellation =
                    cardholderCancellation.getRequired("cardholder_cancellation")

                /**
                 * Contracted at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun contractedAt(): LocalDate = contractedAt.getRequired("contracted_at")

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Purchase explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseExplanation(): String =
                    purchaseExplanation.getRequired("purchase_explanation")

                /**
                 * Service type.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun serviceType(): ServiceType = serviceType.getRequired("service_type")

                /**
                 * Guaranteed reservation explanation. Required if and only if `service_type` is
                 * `guaranteed_reservation`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun guaranteedReservation(): GuaranteedReservation? =
                    guaranteedReservation.getNullable("guaranteed_reservation")

                /**
                 * Other service type explanation. Required if and only if `service_type` is
                 * `other`.
                 */
                @JsonProperty("other") @ExcludeMissing fun _other(): JsonValue = other

                /** Timeshare explanation. Required if and only if `service_type` is `timeshare`. */
                @JsonProperty("timeshare") @ExcludeMissing fun _timeshare(): JsonValue = timeshare

                /**
                 * Returns the raw JSON value of [cardholderCancellation].
                 *
                 * Unlike [cardholderCancellation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("cardholder_cancellation")
                @ExcludeMissing
                fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                    cardholderCancellation

                /**
                 * Returns the raw JSON value of [contractedAt].
                 *
                 * Unlike [contractedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("contracted_at")
                @ExcludeMissing
                fun _contractedAt(): JsonField<LocalDate> = contractedAt

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [purchaseExplanation].
                 *
                 * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("purchase_explanation")
                @ExcludeMissing
                fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                /**
                 * Returns the raw JSON value of [serviceType].
                 *
                 * Unlike [serviceType], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("service_type")
                @ExcludeMissing
                fun _serviceType(): JsonField<ServiceType> = serviceType

                /**
                 * Returns the raw JSON value of [guaranteedReservation].
                 *
                 * Unlike [guaranteedReservation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("guaranteed_reservation")
                @ExcludeMissing
                fun _guaranteedReservation(): JsonField<GuaranteedReservation> =
                    guaranteedReservation

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerCanceledServices].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .contractedAt()
                     * .merchantResolutionAttempted()
                     * .purchaseExplanation()
                     * .serviceType()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerCanceledServices]. */
                class Builder internal constructor() {

                    private var cardholderCancellation: JsonField<CardholderCancellation>? = null
                    private var contractedAt: JsonField<LocalDate>? = null
                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var purchaseExplanation: JsonField<String>? = null
                    private var serviceType: JsonField<ServiceType>? = null
                    private var guaranteedReservation: JsonField<GuaranteedReservation> =
                        JsonMissing.of()
                    private var other: JsonValue = JsonMissing.of()
                    private var timeshare: JsonValue = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(consumerCanceledServices: ConsumerCanceledServices) = apply {
                        cardholderCancellation = consumerCanceledServices.cardholderCancellation
                        contractedAt = consumerCanceledServices.contractedAt
                        merchantResolutionAttempted =
                            consumerCanceledServices.merchantResolutionAttempted
                        purchaseExplanation = consumerCanceledServices.purchaseExplanation
                        serviceType = consumerCanceledServices.serviceType
                        guaranteedReservation = consumerCanceledServices.guaranteedReservation
                        other = consumerCanceledServices.other
                        timeshare = consumerCanceledServices.timeshare
                        additionalProperties =
                            consumerCanceledServices.additionalProperties.toMutableMap()
                    }

                    /** Cardholder cancellation. */
                    fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                        cardholderCancellation(JsonField.of(cardholderCancellation))

                    /**
                     * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderCancellation] with a well-typed
                     * [CardholderCancellation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun cardholderCancellation(
                        cardholderCancellation: JsonField<CardholderCancellation>
                    ) = apply { this.cardholderCancellation = cardholderCancellation }

                    /** Contracted at. */
                    fun contractedAt(contractedAt: LocalDate) =
                        contractedAt(JsonField.of(contractedAt))

                    /**
                     * Sets [Builder.contractedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.contractedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun contractedAt(contractedAt: JsonField<LocalDate>) = apply {
                        this.contractedAt = contractedAt
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Purchase explanation. */
                    fun purchaseExplanation(purchaseExplanation: String) =
                        purchaseExplanation(JsonField.of(purchaseExplanation))

                    /**
                     * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseExplanation] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                        this.purchaseExplanation = purchaseExplanation
                    }

                    /** Service type. */
                    fun serviceType(serviceType: ServiceType) =
                        serviceType(JsonField.of(serviceType))

                    /**
                     * Sets [Builder.serviceType] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.serviceType] with a well-typed [ServiceType]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun serviceType(serviceType: JsonField<ServiceType>) = apply {
                        this.serviceType = serviceType
                    }

                    /**
                     * Guaranteed reservation explanation. Required if and only if `service_type` is
                     * `guaranteed_reservation`.
                     */
                    fun guaranteedReservation(guaranteedReservation: GuaranteedReservation) =
                        guaranteedReservation(JsonField.of(guaranteedReservation))

                    /**
                     * Sets [Builder.guaranteedReservation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.guaranteedReservation] with a well-typed
                     * [GuaranteedReservation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun guaranteedReservation(
                        guaranteedReservation: JsonField<GuaranteedReservation>
                    ) = apply { this.guaranteedReservation = guaranteedReservation }

                    /**
                     * Other service type explanation. Required if and only if `service_type` is
                     * `other`.
                     */
                    fun other(other: JsonValue) = apply { this.other = other }

                    /**
                     * Timeshare explanation. Required if and only if `service_type` is `timeshare`.
                     */
                    fun timeshare(timeshare: JsonValue) = apply { this.timeshare = timeshare }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerCanceledServices].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .contractedAt()
                     * .merchantResolutionAttempted()
                     * .purchaseExplanation()
                     * .serviceType()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerCanceledServices =
                        ConsumerCanceledServices(
                            checkRequired("cardholderCancellation", cardholderCancellation),
                            checkRequired("contractedAt", contractedAt),
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired("purchaseExplanation", purchaseExplanation),
                            checkRequired("serviceType", serviceType),
                            guaranteedReservation,
                            other,
                            timeshare,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerCanceledServices = apply {
                    if (validated) {
                        return@apply
                    }

                    cardholderCancellation().validate()
                    contractedAt()
                    merchantResolutionAttempted().validate()
                    purchaseExplanation()
                    serviceType().validate()
                    guaranteedReservation()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cardholderCancellation.asKnown()?.validity() ?: 0) +
                        (if (contractedAt.asKnown() == null) 0 else 1) +
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                        (serviceType.asKnown()?.validity() ?: 0) +
                        (guaranteedReservation.asKnown()?.validity() ?: 0)

                /** Cardholder cancellation. */
                class CardholderCancellation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val canceledAt: JsonField<LocalDate>,
                    private val cancellationPolicyProvided: JsonField<CancellationPolicyProvided>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("cancellation_policy_provided")
                        @ExcludeMissing
                        cancellationPolicyProvided: JsonField<CancellationPolicyProvided> =
                            JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(canceledAt, cancellationPolicyProvided, reason, mutableMapOf())

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Cancellation policy provided.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cancellationPolicyProvided(): CancellationPolicyProvided =
                        cancellationPolicyProvided.getRequired("cancellation_policy_provided")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): String = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    /**
                     * Returns the raw JSON value of [cancellationPolicyProvided].
                     *
                     * Unlike [cancellationPolicyProvided], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("cancellation_policy_provided")
                    @ExcludeMissing
                    fun _cancellationPolicyProvided(): JsonField<CancellationPolicyProvided> =
                        cancellationPolicyProvided

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderCancellation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * .cancellationPolicyProvided()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderCancellation]. */
                    class Builder internal constructor() {

                        private var canceledAt: JsonField<LocalDate>? = null
                        private var cancellationPolicyProvided:
                            JsonField<CancellationPolicyProvided>? =
                            null
                        private var reason: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(cardholderCancellation: CardholderCancellation) = apply {
                            canceledAt = cardholderCancellation.canceledAt
                            cancellationPolicyProvided =
                                cardholderCancellation.cancellationPolicyProvided
                            reason = cardholderCancellation.reason
                            additionalProperties =
                                cardholderCancellation.additionalProperties.toMutableMap()
                        }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        /** Cancellation policy provided. */
                        fun cancellationPolicyProvided(
                            cancellationPolicyProvided: CancellationPolicyProvided
                        ) = cancellationPolicyProvided(JsonField.of(cancellationPolicyProvided))

                        /**
                         * Sets [Builder.cancellationPolicyProvided] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cancellationPolicyProvided] with a
                         * well-typed [CancellationPolicyProvided] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cancellationPolicyProvided(
                            cancellationPolicyProvided: JsonField<CancellationPolicyProvided>
                        ) = apply { this.cancellationPolicyProvided = cancellationPolicyProvided }

                        /** Reason. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CardholderCancellation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * .cancellationPolicyProvided()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderCancellation =
                            CardholderCancellation(
                                checkRequired("canceledAt", canceledAt),
                                checkRequired(
                                    "cancellationPolicyProvided",
                                    cancellationPolicyProvided,
                                ),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderCancellation = apply {
                        if (validated) {
                            return@apply
                        }

                        canceledAt()
                        cancellationPolicyProvided().validate()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (canceledAt.asKnown() == null) 0 else 1) +
                            (cancellationPolicyProvided.asKnown()?.validity() ?: 0) +
                            (if (reason.asKnown() == null) 0 else 1)

                    /** Cancellation policy provided. */
                    class CancellationPolicyProvided
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not provided. */
                            val NOT_PROVIDED = of("not_provided")

                            /** Provided. */
                            val PROVIDED = of("provided")

                            fun of(value: String) = CancellationPolicyProvided(JsonField.of(value))
                        }

                        /** An enum containing [CancellationPolicyProvided]'s known values. */
                        enum class Known {
                            /** Not provided. */
                            NOT_PROVIDED,
                            /** Provided. */
                            PROVIDED,
                        }

                        /**
                         * An enum containing [CancellationPolicyProvided]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [CancellationPolicyProvided] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not provided. */
                            NOT_PROVIDED,
                            /** Provided. */
                            PROVIDED,
                            /**
                             * An enum member indicating that [CancellationPolicyProvided] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_PROVIDED -> Value.NOT_PROVIDED
                                PROVIDED -> Value.PROVIDED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_PROVIDED -> Known.NOT_PROVIDED
                                PROVIDED -> Known.PROVIDED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CancellationPolicyProvided: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CancellationPolicyProvided = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CancellationPolicyProvided && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderCancellation &&
                            canceledAt == other.canceledAt &&
                            cancellationPolicyProvided == other.cancellationPolicyProvided &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            canceledAt,
                            cancellationPolicyProvided,
                            reason,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderCancellation{canceledAt=$canceledAt, cancellationPolicyProvided=$cancellationPolicyProvided, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Service type. */
                class ServiceType
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Guaranteed reservation. */
                        val GUARANTEED_RESERVATION = of("guaranteed_reservation")

                        /** Other. */
                        val OTHER = of("other")

                        /** Timeshare. */
                        val TIMESHARE = of("timeshare")

                        fun of(value: String) = ServiceType(JsonField.of(value))
                    }

                    /** An enum containing [ServiceType]'s known values. */
                    enum class Known {
                        /** Guaranteed reservation. */
                        GUARANTEED_RESERVATION,
                        /** Other. */
                        OTHER,
                        /** Timeshare. */
                        TIMESHARE,
                    }

                    /**
                     * An enum containing [ServiceType]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [ServiceType] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Guaranteed reservation. */
                        GUARANTEED_RESERVATION,
                        /** Other. */
                        OTHER,
                        /** Timeshare. */
                        TIMESHARE,
                        /**
                         * An enum member indicating that [ServiceType] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            GUARANTEED_RESERVATION -> Value.GUARANTEED_RESERVATION
                            OTHER -> Value.OTHER
                            TIMESHARE -> Value.TIMESHARE
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            GUARANTEED_RESERVATION -> Known.GUARANTEED_RESERVATION
                            OTHER -> Known.OTHER
                            TIMESHARE -> Known.TIMESHARE
                            else ->
                                throw IncreaseInvalidDataException("Unknown ServiceType: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): ServiceType = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ServiceType && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Guaranteed reservation explanation. Required if and only if `service_type` is
                 * `guaranteed_reservation`.
                 */
                class GuaranteedReservation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<Explanation>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<Explanation> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun explanation(): Explanation = explanation.getRequired("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<Explanation> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [GuaranteedReservation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [GuaranteedReservation]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<Explanation>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(guaranteedReservation: GuaranteedReservation) = apply {
                            explanation = guaranteedReservation.explanation
                            additionalProperties =
                                guaranteedReservation.additionalProperties.toMutableMap()
                        }

                        /** Explanation. */
                        fun explanation(explanation: Explanation) =
                            explanation(JsonField.of(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed
                         * [Explanation] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<Explanation>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [GuaranteedReservation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): GuaranteedReservation =
                            GuaranteedReservation(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): GuaranteedReservation = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation().validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (explanation.asKnown()?.validity() ?: 0)

                    /** Explanation. */
                    class Explanation
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Cardholder canceled prior to service. */
                            val CARDHOLDER_CANCELED_PRIOR_TO_SERVICE =
                                of("cardholder_canceled_prior_to_service")

                            /** Cardholder cancellation attempt within 24 hours of confirmation. */
                            val CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION =
                                of(
                                    "cardholder_cancellation_attempt_within_24_hours_of_confirmation"
                                )

                            /** Merchant billed for no-show. */
                            val MERCHANT_BILLED_NO_SHOW = of("merchant_billed_no_show")

                            fun of(value: String) = Explanation(JsonField.of(value))
                        }

                        /** An enum containing [Explanation]'s known values. */
                        enum class Known {
                            /** Cardholder canceled prior to service. */
                            CARDHOLDER_CANCELED_PRIOR_TO_SERVICE,
                            /** Cardholder cancellation attempt within 24 hours of confirmation. */
                            CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION,
                            /** Merchant billed for no-show. */
                            MERCHANT_BILLED_NO_SHOW,
                        }

                        /**
                         * An enum containing [Explanation]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [Explanation] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Cardholder canceled prior to service. */
                            CARDHOLDER_CANCELED_PRIOR_TO_SERVICE,
                            /** Cardholder cancellation attempt within 24 hours of confirmation. */
                            CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION,
                            /** Merchant billed for no-show. */
                            MERCHANT_BILLED_NO_SHOW,
                            /**
                             * An enum member indicating that [Explanation] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                CARDHOLDER_CANCELED_PRIOR_TO_SERVICE ->
                                    Value.CARDHOLDER_CANCELED_PRIOR_TO_SERVICE
                                CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION ->
                                    Value
                                        .CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION
                                MERCHANT_BILLED_NO_SHOW -> Value.MERCHANT_BILLED_NO_SHOW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                CARDHOLDER_CANCELED_PRIOR_TO_SERVICE ->
                                    Known.CARDHOLDER_CANCELED_PRIOR_TO_SERVICE
                                CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION ->
                                    Known
                                        .CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION
                                MERCHANT_BILLED_NO_SHOW -> Known.MERCHANT_BILLED_NO_SHOW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown Explanation: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): Explanation = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Explanation && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is GuaranteedReservation &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "GuaranteedReservation{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerCanceledServices &&
                        cardholderCancellation == other.cardholderCancellation &&
                        contractedAt == other.contractedAt &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        purchaseExplanation == other.purchaseExplanation &&
                        serviceType == other.serviceType &&
                        guaranteedReservation == other.guaranteedReservation &&
                        this.other == other.other &&
                        timeshare == other.timeshare &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cardholderCancellation,
                        contractedAt,
                        merchantResolutionAttempted,
                        purchaseExplanation,
                        serviceType,
                        guaranteedReservation,
                        other,
                        timeshare,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerCanceledServices{cardholderCancellation=$cardholderCancellation, contractedAt=$contractedAt, merchantResolutionAttempted=$merchantResolutionAttempted, purchaseExplanation=$purchaseExplanation, serviceType=$serviceType, guaranteedReservation=$guaranteedReservation, other=$other, timeshare=$timeshare, additionalProperties=$additionalProperties}"
            }

            /**
             * Counterfeit merchandise. Required if and only if `category` is
             * `consumer_counterfeit_merchandise`.
             */
            class ConsumerCounterfeitMerchandise
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val counterfeitExplanation: JsonField<String>,
                private val dispositionExplanation: JsonField<String>,
                private val orderExplanation: JsonField<String>,
                private val receivedAt: JsonField<LocalDate>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("counterfeit_explanation")
                    @ExcludeMissing
                    counterfeitExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("disposition_explanation")
                    @ExcludeMissing
                    dispositionExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("order_explanation")
                    @ExcludeMissing
                    orderExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                ) : this(
                    counterfeitExplanation,
                    dispositionExplanation,
                    orderExplanation,
                    receivedAt,
                    mutableMapOf(),
                )

                /**
                 * Counterfeit explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun counterfeitExplanation(): String =
                    counterfeitExplanation.getRequired("counterfeit_explanation")

                /**
                 * Disposition explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun dispositionExplanation(): String =
                    dispositionExplanation.getRequired("disposition_explanation")

                /**
                 * Order explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun orderExplanation(): String = orderExplanation.getRequired("order_explanation")

                /**
                 * Received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                /**
                 * Returns the raw JSON value of [counterfeitExplanation].
                 *
                 * Unlike [counterfeitExplanation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("counterfeit_explanation")
                @ExcludeMissing
                fun _counterfeitExplanation(): JsonField<String> = counterfeitExplanation

                /**
                 * Returns the raw JSON value of [dispositionExplanation].
                 *
                 * Unlike [dispositionExplanation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("disposition_explanation")
                @ExcludeMissing
                fun _dispositionExplanation(): JsonField<String> = dispositionExplanation

                /**
                 * Returns the raw JSON value of [orderExplanation].
                 *
                 * Unlike [orderExplanation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("order_explanation")
                @ExcludeMissing
                fun _orderExplanation(): JsonField<String> = orderExplanation

                /**
                 * Returns the raw JSON value of [receivedAt].
                 *
                 * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_at")
                @ExcludeMissing
                fun _receivedAt(): JsonField<LocalDate> = receivedAt

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerCounterfeitMerchandise].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .counterfeitExplanation()
                     * .dispositionExplanation()
                     * .orderExplanation()
                     * .receivedAt()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerCounterfeitMerchandise]. */
                class Builder internal constructor() {

                    private var counterfeitExplanation: JsonField<String>? = null
                    private var dispositionExplanation: JsonField<String>? = null
                    private var orderExplanation: JsonField<String>? = null
                    private var receivedAt: JsonField<LocalDate>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerCounterfeitMerchandise: ConsumerCounterfeitMerchandise
                    ) = apply {
                        counterfeitExplanation =
                            consumerCounterfeitMerchandise.counterfeitExplanation
                        dispositionExplanation =
                            consumerCounterfeitMerchandise.dispositionExplanation
                        orderExplanation = consumerCounterfeitMerchandise.orderExplanation
                        receivedAt = consumerCounterfeitMerchandise.receivedAt
                        additionalProperties =
                            consumerCounterfeitMerchandise.additionalProperties.toMutableMap()
                    }

                    /** Counterfeit explanation. */
                    fun counterfeitExplanation(counterfeitExplanation: String) =
                        counterfeitExplanation(JsonField.of(counterfeitExplanation))

                    /**
                     * Sets [Builder.counterfeitExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.counterfeitExplanation] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun counterfeitExplanation(counterfeitExplanation: JsonField<String>) = apply {
                        this.counterfeitExplanation = counterfeitExplanation
                    }

                    /** Disposition explanation. */
                    fun dispositionExplanation(dispositionExplanation: String) =
                        dispositionExplanation(JsonField.of(dispositionExplanation))

                    /**
                     * Sets [Builder.dispositionExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.dispositionExplanation] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun dispositionExplanation(dispositionExplanation: JsonField<String>) = apply {
                        this.dispositionExplanation = dispositionExplanation
                    }

                    /** Order explanation. */
                    fun orderExplanation(orderExplanation: String) =
                        orderExplanation(JsonField.of(orderExplanation))

                    /**
                     * Sets [Builder.orderExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.orderExplanation] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun orderExplanation(orderExplanation: JsonField<String>) = apply {
                        this.orderExplanation = orderExplanation
                    }

                    /** Received at. */
                    fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                    /**
                     * Sets [Builder.receivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                        this.receivedAt = receivedAt
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerCounterfeitMerchandise].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .counterfeitExplanation()
                     * .dispositionExplanation()
                     * .orderExplanation()
                     * .receivedAt()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerCounterfeitMerchandise =
                        ConsumerCounterfeitMerchandise(
                            checkRequired("counterfeitExplanation", counterfeitExplanation),
                            checkRequired("dispositionExplanation", dispositionExplanation),
                            checkRequired("orderExplanation", orderExplanation),
                            checkRequired("receivedAt", receivedAt),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerCounterfeitMerchandise = apply {
                    if (validated) {
                        return@apply
                    }

                    counterfeitExplanation()
                    dispositionExplanation()
                    orderExplanation()
                    receivedAt()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (counterfeitExplanation.asKnown() == null) 0 else 1) +
                        (if (dispositionExplanation.asKnown() == null) 0 else 1) +
                        (if (orderExplanation.asKnown() == null) 0 else 1) +
                        (if (receivedAt.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerCounterfeitMerchandise &&
                        counterfeitExplanation == other.counterfeitExplanation &&
                        dispositionExplanation == other.dispositionExplanation &&
                        orderExplanation == other.orderExplanation &&
                        receivedAt == other.receivedAt &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        counterfeitExplanation,
                        dispositionExplanation,
                        orderExplanation,
                        receivedAt,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerCounterfeitMerchandise{counterfeitExplanation=$counterfeitExplanation, dispositionExplanation=$dispositionExplanation, orderExplanation=$orderExplanation, receivedAt=$receivedAt, additionalProperties=$additionalProperties}"
            }

            /**
             * Credit not processed. Required if and only if `category` is
             * `consumer_credit_not_processed`.
             */
            class ConsumerCreditNotProcessed
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val canceledOrReturnedAt: JsonField<LocalDate>,
                private val creditExpectedAt: JsonField<LocalDate>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("canceled_or_returned_at")
                    @ExcludeMissing
                    canceledOrReturnedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("credit_expected_at")
                    @ExcludeMissing
                    creditExpectedAt: JsonField<LocalDate> = JsonMissing.of(),
                ) : this(canceledOrReturnedAt, creditExpectedAt, mutableMapOf())

                /**
                 * Canceled or returned at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun canceledOrReturnedAt(): LocalDate? =
                    canceledOrReturnedAt.getNullable("canceled_or_returned_at")

                /**
                 * Credit expected at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun creditExpectedAt(): LocalDate? =
                    creditExpectedAt.getNullable("credit_expected_at")

                /**
                 * Returns the raw JSON value of [canceledOrReturnedAt].
                 *
                 * Unlike [canceledOrReturnedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("canceled_or_returned_at")
                @ExcludeMissing
                fun _canceledOrReturnedAt(): JsonField<LocalDate> = canceledOrReturnedAt

                /**
                 * Returns the raw JSON value of [creditExpectedAt].
                 *
                 * Unlike [creditExpectedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("credit_expected_at")
                @ExcludeMissing
                fun _creditExpectedAt(): JsonField<LocalDate> = creditExpectedAt

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerCreditNotProcessed].
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerCreditNotProcessed]. */
                class Builder internal constructor() {

                    private var canceledOrReturnedAt: JsonField<LocalDate> = JsonMissing.of()
                    private var creditExpectedAt: JsonField<LocalDate> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(consumerCreditNotProcessed: ConsumerCreditNotProcessed) =
                        apply {
                            canceledOrReturnedAt = consumerCreditNotProcessed.canceledOrReturnedAt
                            creditExpectedAt = consumerCreditNotProcessed.creditExpectedAt
                            additionalProperties =
                                consumerCreditNotProcessed.additionalProperties.toMutableMap()
                        }

                    /** Canceled or returned at. */
                    fun canceledOrReturnedAt(canceledOrReturnedAt: LocalDate) =
                        canceledOrReturnedAt(JsonField.of(canceledOrReturnedAt))

                    /**
                     * Sets [Builder.canceledOrReturnedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.canceledOrReturnedAt] with a well-typed
                     * [LocalDate] value instead. This method is primarily for setting the field to
                     * an undocumented or not yet supported value.
                     */
                    fun canceledOrReturnedAt(canceledOrReturnedAt: JsonField<LocalDate>) = apply {
                        this.canceledOrReturnedAt = canceledOrReturnedAt
                    }

                    /** Credit expected at. */
                    fun creditExpectedAt(creditExpectedAt: LocalDate) =
                        creditExpectedAt(JsonField.of(creditExpectedAt))

                    /**
                     * Sets [Builder.creditExpectedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.creditExpectedAt] with a well-typed
                     * [LocalDate] value instead. This method is primarily for setting the field to
                     * an undocumented or not yet supported value.
                     */
                    fun creditExpectedAt(creditExpectedAt: JsonField<LocalDate>) = apply {
                        this.creditExpectedAt = creditExpectedAt
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerCreditNotProcessed].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     */
                    fun build(): ConsumerCreditNotProcessed =
                        ConsumerCreditNotProcessed(
                            canceledOrReturnedAt,
                            creditExpectedAt,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerCreditNotProcessed = apply {
                    if (validated) {
                        return@apply
                    }

                    canceledOrReturnedAt()
                    creditExpectedAt()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (canceledOrReturnedAt.asKnown() == null) 0 else 1) +
                        (if (creditExpectedAt.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerCreditNotProcessed &&
                        canceledOrReturnedAt == other.canceledOrReturnedAt &&
                        creditExpectedAt == other.creditExpectedAt &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(canceledOrReturnedAt, creditExpectedAt, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerCreditNotProcessed{canceledOrReturnedAt=$canceledOrReturnedAt, creditExpectedAt=$creditExpectedAt, additionalProperties=$additionalProperties}"
            }

            /**
             * Damaged or defective merchandise. Required if and only if `category` is
             * `consumer_damaged_or_defective_merchandise`.
             */
            class ConsumerDamagedOrDefectiveMerchandise
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val orderAndIssueExplanation: JsonField<String>,
                private val receivedAt: JsonField<LocalDate>,
                private val returnOutcome: JsonField<ReturnOutcome>,
                private val notReturned: JsonValue,
                private val returnAttempted: JsonField<ReturnAttempted>,
                private val returned: JsonField<Returned>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("order_and_issue_explanation")
                    @ExcludeMissing
                    orderAndIssueExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    notReturned: JsonValue = JsonMissing.of(),
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                    @JsonProperty("returned")
                    @ExcludeMissing
                    returned: JsonField<Returned> = JsonMissing.of(),
                ) : this(
                    merchantResolutionAttempted,
                    orderAndIssueExplanation,
                    receivedAt,
                    returnOutcome,
                    notReturned,
                    returnAttempted,
                    returned,
                    mutableMapOf(),
                )

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Order and issue explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun orderAndIssueExplanation(): String =
                    orderAndIssueExplanation.getRequired("order_and_issue_explanation")

                /**
                 * Received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                /**
                 * Return outcome.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                @JsonProperty("not_returned")
                @ExcludeMissing
                fun _notReturned(): JsonValue = notReturned

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returnAttempted(): ReturnAttempted? =
                    returnAttempted.getNullable("return_attempted")

                /**
                 * Returned. Required if and only if `return_outcome` is `returned`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returned(): Returned? = returned.getNullable("returned")

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [orderAndIssueExplanation].
                 *
                 * Unlike [orderAndIssueExplanation], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("order_and_issue_explanation")
                @ExcludeMissing
                fun _orderAndIssueExplanation(): JsonField<String> = orderAndIssueExplanation

                /**
                 * Returns the raw JSON value of [receivedAt].
                 *
                 * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_at")
                @ExcludeMissing
                fun _receivedAt(): JsonField<LocalDate> = receivedAt

                /**
                 * Returns the raw JSON value of [returnOutcome].
                 *
                 * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_outcome")
                @ExcludeMissing
                fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                /**
                 * Returns the raw JSON value of [returnAttempted].
                 *
                 * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_attempted")
                @ExcludeMissing
                fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                /**
                 * Returns the raw JSON value of [returned].
                 *
                 * Unlike [returned], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("returned")
                @ExcludeMissing
                fun _returned(): JsonField<Returned> = returned

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerDamagedOrDefectiveMerchandise].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .orderAndIssueExplanation()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerDamagedOrDefectiveMerchandise]. */
                class Builder internal constructor() {

                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var orderAndIssueExplanation: JsonField<String>? = null
                    private var receivedAt: JsonField<LocalDate>? = null
                    private var returnOutcome: JsonField<ReturnOutcome>? = null
                    private var notReturned: JsonValue = JsonMissing.of()
                    private var returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of()
                    private var returned: JsonField<Returned> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerDamagedOrDefectiveMerchandise: ConsumerDamagedOrDefectiveMerchandise
                    ) = apply {
                        merchantResolutionAttempted =
                            consumerDamagedOrDefectiveMerchandise.merchantResolutionAttempted
                        orderAndIssueExplanation =
                            consumerDamagedOrDefectiveMerchandise.orderAndIssueExplanation
                        receivedAt = consumerDamagedOrDefectiveMerchandise.receivedAt
                        returnOutcome = consumerDamagedOrDefectiveMerchandise.returnOutcome
                        notReturned = consumerDamagedOrDefectiveMerchandise.notReturned
                        returnAttempted = consumerDamagedOrDefectiveMerchandise.returnAttempted
                        returned = consumerDamagedOrDefectiveMerchandise.returned
                        additionalProperties =
                            consumerDamagedOrDefectiveMerchandise.additionalProperties
                                .toMutableMap()
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Order and issue explanation. */
                    fun orderAndIssueExplanation(orderAndIssueExplanation: String) =
                        orderAndIssueExplanation(JsonField.of(orderAndIssueExplanation))

                    /**
                     * Sets [Builder.orderAndIssueExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.orderAndIssueExplanation] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun orderAndIssueExplanation(orderAndIssueExplanation: JsonField<String>) =
                        apply {
                            this.orderAndIssueExplanation = orderAndIssueExplanation
                        }

                    /** Received at. */
                    fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                    /**
                     * Sets [Builder.receivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                        this.receivedAt = receivedAt
                    }

                    /** Return outcome. */
                    fun returnOutcome(returnOutcome: ReturnOutcome) =
                        returnOutcome(JsonField.of(returnOutcome))

                    /**
                     * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnOutcome] with a well-typed
                     * [ReturnOutcome] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                        this.returnOutcome = returnOutcome
                    }

                    /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                    fun notReturned(notReturned: JsonValue) = apply {
                        this.notReturned = notReturned
                    }

                    /**
                     * Return attempted. Required if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    fun returnAttempted(returnAttempted: ReturnAttempted) =
                        returnAttempted(JsonField.of(returnAttempted))

                    /**
                     * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnAttempted] with a well-typed
                     * [ReturnAttempted] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                        this.returnAttempted = returnAttempted
                    }

                    /** Returned. Required if and only if `return_outcome` is `returned`. */
                    fun returned(returned: Returned) = returned(JsonField.of(returned))

                    /**
                     * Sets [Builder.returned] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returned] with a well-typed [Returned] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun returned(returned: JsonField<Returned>) = apply { this.returned = returned }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerDamagedOrDefectiveMerchandise].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .orderAndIssueExplanation()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerDamagedOrDefectiveMerchandise =
                        ConsumerDamagedOrDefectiveMerchandise(
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired("orderAndIssueExplanation", orderAndIssueExplanation),
                            checkRequired("receivedAt", receivedAt),
                            checkRequired("returnOutcome", returnOutcome),
                            notReturned,
                            returnAttempted,
                            returned,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerDamagedOrDefectiveMerchandise = apply {
                    if (validated) {
                        return@apply
                    }

                    merchantResolutionAttempted().validate()
                    orderAndIssueExplanation()
                    receivedAt()
                    returnOutcome().validate()
                    returnAttempted()?.validate()
                    returned()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (orderAndIssueExplanation.asKnown() == null) 0 else 1) +
                        (if (receivedAt.asKnown() == null) 0 else 1) +
                        (returnOutcome.asKnown()?.validity() ?: 0) +
                        (returnAttempted.asKnown()?.validity() ?: 0) +
                        (returned.asKnown()?.validity() ?: 0)

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Return outcome. */
                class ReturnOutcome
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Not returned. */
                        val NOT_RETURNED = of("not_returned")

                        /** Returned. */
                        val RETURNED = of("returned")

                        /** Return attempted. */
                        val RETURN_ATTEMPTED = of("return_attempted")

                        fun of(value: String) = ReturnOutcome(JsonField.of(value))
                    }

                    /** An enum containing [ReturnOutcome]'s known values. */
                    enum class Known {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                    }

                    /**
                     * An enum containing [ReturnOutcome]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [ReturnOutcome] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                        /**
                         * An enum member indicating that [ReturnOutcome] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            NOT_RETURNED -> Value.NOT_RETURNED
                            RETURNED -> Value.RETURNED
                            RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            NOT_RETURNED -> Known.NOT_RETURNED
                            RETURNED -> Known.RETURNED
                            RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                            else ->
                                throw IncreaseInvalidDataException("Unknown ReturnOutcome: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): ReturnOutcome = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnOutcome && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 */
                class ReturnAttempted
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val attemptExplanation: JsonField<String>,
                    private val attemptReason: JsonField<AttemptReason>,
                    private val attemptedAt: JsonField<LocalDate>,
                    private val merchandiseDisposition: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        attemptExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        attemptExplanation,
                        attemptReason,
                        attemptedAt,
                        merchandiseDisposition,
                        mutableMapOf(),
                    )

                    /**
                     * Attempt explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptExplanation(): String =
                        attemptExplanation.getRequired("attempt_explanation")

                    /**
                     * Attempt reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptReason(): AttemptReason = attemptReason.getRequired("attempt_reason")

                    /**
                     * Attempted at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                    /**
                     * Merchandise disposition.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchandiseDisposition(): String =
                        merchandiseDisposition.getRequired("merchandise_disposition")

                    /**
                     * Returns the raw JSON value of [attemptExplanation].
                     *
                     * Unlike [attemptExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("attempt_explanation")
                    @ExcludeMissing
                    fun _attemptExplanation(): JsonField<String> = attemptExplanation

                    /**
                     * Returns the raw JSON value of [attemptReason].
                     *
                     * Unlike [attemptReason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempt_reason")
                    @ExcludeMissing
                    fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                    /**
                     * Returns the raw JSON value of [attemptedAt].
                     *
                     * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempted_at")
                    @ExcludeMissing
                    fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                    /**
                     * Returns the raw JSON value of [merchandiseDisposition].
                     *
                     * Unlike [merchandiseDisposition], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchandise_disposition")
                    @ExcludeMissing
                    fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ReturnAttempted].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ReturnAttempted]. */
                    class Builder internal constructor() {

                        private var attemptExplanation: JsonField<String>? = null
                        private var attemptReason: JsonField<AttemptReason>? = null
                        private var attemptedAt: JsonField<LocalDate>? = null
                        private var merchandiseDisposition: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returnAttempted: ReturnAttempted) = apply {
                            attemptExplanation = returnAttempted.attemptExplanation
                            attemptReason = returnAttempted.attemptReason
                            attemptedAt = returnAttempted.attemptedAt
                            merchandiseDisposition = returnAttempted.merchandiseDisposition
                            additionalProperties =
                                returnAttempted.additionalProperties.toMutableMap()
                        }

                        /** Attempt explanation. */
                        fun attemptExplanation(attemptExplanation: String) =
                            attemptExplanation(JsonField.of(attemptExplanation))

                        /**
                         * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                            this.attemptExplanation = attemptExplanation
                        }

                        /** Attempt reason. */
                        fun attemptReason(attemptReason: AttemptReason) =
                            attemptReason(JsonField.of(attemptReason))

                        /**
                         * Sets [Builder.attemptReason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptReason] with a well-typed
                         * [AttemptReason] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                            this.attemptReason = attemptReason
                        }

                        /** Attempted at. */
                        fun attemptedAt(attemptedAt: LocalDate) =
                            attemptedAt(JsonField.of(attemptedAt))

                        /**
                         * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                            this.attemptedAt = attemptedAt
                        }

                        /** Merchandise disposition. */
                        fun merchandiseDisposition(merchandiseDisposition: String) =
                            merchandiseDisposition(JsonField.of(merchandiseDisposition))

                        /**
                         * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchandiseDisposition] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                            apply {
                                this.merchandiseDisposition = merchandiseDisposition
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ReturnAttempted].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ReturnAttempted =
                            ReturnAttempted(
                                checkRequired("attemptExplanation", attemptExplanation),
                                checkRequired("attemptReason", attemptReason),
                                checkRequired("attemptedAt", attemptedAt),
                                checkRequired("merchandiseDisposition", merchandiseDisposition),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ReturnAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        attemptExplanation()
                        attemptReason().validate()
                        attemptedAt()
                        merchandiseDisposition()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (attemptExplanation.asKnown() == null) 0 else 1) +
                            (attemptReason.asKnown()?.validity() ?: 0) +
                            (if (attemptedAt.asKnown() == null) 0 else 1) +
                            (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                    /** Attempt reason. */
                    class AttemptReason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Merchant not responding. */
                            val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                            /** No return authorization provided. */
                            val NO_RETURN_AUTHORIZATION_PROVIDED =
                                of("no_return_authorization_provided")

                            /** No return instructions. */
                            val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                            /** Requested not to return. */
                            val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                            /** Return not accepted. */
                            val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                            fun of(value: String) = AttemptReason(JsonField.of(value))
                        }

                        /** An enum containing [AttemptReason]'s known values. */
                        enum class Known {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AttemptReason]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AttemptReason] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AttemptReason] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AttemptReason: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AttemptReason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AttemptReason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnAttempted &&
                            attemptExplanation == other.attemptExplanation &&
                            attemptReason == other.attemptReason &&
                            attemptedAt == other.attemptedAt &&
                            merchandiseDisposition == other.merchandiseDisposition &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                }

                /** Returned. Required if and only if `return_outcome` is `returned`. */
                class Returned
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val returnMethod: JsonField<ReturnMethod>,
                    private val returnedAt: JsonField<LocalDate>,
                    private val merchantReceivedReturnAt: JsonField<LocalDate>,
                    private val otherExplanation: JsonField<String>,
                    private val trackingNumber: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        otherExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        trackingNumber: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        returnMethod,
                        returnedAt,
                        merchantReceivedReturnAt,
                        otherExplanation,
                        trackingNumber,
                        mutableMapOf(),
                    )

                    /**
                     * Return method.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                    /**
                     * Returned at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                    /**
                     * Merchant received return at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun merchantReceivedReturnAt(): LocalDate? =
                        merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                    /**
                     * Other explanation. Required if and only if the return method is `other`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun otherExplanation(): String? =
                        otherExplanation.getNullable("other_explanation")

                    /**
                     * Tracking number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun trackingNumber(): String? = trackingNumber.getNullable("tracking_number")

                    /**
                     * Returns the raw JSON value of [returnMethod].
                     *
                     * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_method")
                    @ExcludeMissing
                    fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                    /**
                     * Returns the raw JSON value of [returnedAt].
                     *
                     * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned_at")
                    @ExcludeMissing
                    fun _returnedAt(): JsonField<LocalDate> = returnedAt

                    /**
                     * Returns the raw JSON value of [merchantReceivedReturnAt].
                     *
                     * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_received_return_at")
                    @ExcludeMissing
                    fun _merchantReceivedReturnAt(): JsonField<LocalDate> = merchantReceivedReturnAt

                    /**
                     * Returns the raw JSON value of [otherExplanation].
                     *
                     * Unlike [otherExplanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("other_explanation")
                    @ExcludeMissing
                    fun _otherExplanation(): JsonField<String> = otherExplanation

                    /**
                     * Returns the raw JSON value of [trackingNumber].
                     *
                     * Unlike [trackingNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("tracking_number")
                    @ExcludeMissing
                    fun _trackingNumber(): JsonField<String> = trackingNumber

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Returned].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Returned]. */
                    class Builder internal constructor() {

                        private var returnMethod: JsonField<ReturnMethod>? = null
                        private var returnedAt: JsonField<LocalDate>? = null
                        private var merchantReceivedReturnAt: JsonField<LocalDate> =
                            JsonMissing.of()
                        private var otherExplanation: JsonField<String> = JsonMissing.of()
                        private var trackingNumber: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returned: Returned) = apply {
                            returnMethod = returned.returnMethod
                            returnedAt = returned.returnedAt
                            merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                            otherExplanation = returned.otherExplanation
                            trackingNumber = returned.trackingNumber
                            additionalProperties = returned.additionalProperties.toMutableMap()
                        }

                        /** Return method. */
                        fun returnMethod(returnMethod: ReturnMethod) =
                            returnMethod(JsonField.of(returnMethod))

                        /**
                         * Sets [Builder.returnMethod] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnMethod] with a well-typed
                         * [ReturnMethod] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                            this.returnMethod = returnMethod
                        }

                        /** Returned at. */
                        fun returnedAt(returnedAt: LocalDate) = returnedAt(JsonField.of(returnedAt))

                        /**
                         * Sets [Builder.returnedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                            this.returnedAt = returnedAt
                        }

                        /** Merchant received return at. */
                        fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate) =
                            merchantReceivedReturnAt(JsonField.of(merchantReceivedReturnAt))

                        /**
                         * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantReceivedReturnAt] with a
                         * well-typed [LocalDate] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun merchantReceivedReturnAt(
                            merchantReceivedReturnAt: JsonField<LocalDate>
                        ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         */
                        fun otherExplanation(otherExplanation: String) =
                            otherExplanation(JsonField.of(otherExplanation))

                        /**
                         * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                            this.otherExplanation = otherExplanation
                        }

                        /** Tracking number. */
                        fun trackingNumber(trackingNumber: String) =
                            trackingNumber(JsonField.of(trackingNumber))

                        /**
                         * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.trackingNumber] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                            this.trackingNumber = trackingNumber
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Returned].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Returned =
                            Returned(
                                checkRequired("returnMethod", returnMethod),
                                checkRequired("returnedAt", returnedAt),
                                merchantReceivedReturnAt,
                                otherExplanation,
                                trackingNumber,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Returned = apply {
                        if (validated) {
                            return@apply
                        }

                        returnMethod().validate()
                        returnedAt()
                        merchantReceivedReturnAt()
                        otherExplanation()
                        trackingNumber()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (returnMethod.asKnown()?.validity() ?: 0) +
                            (if (returnedAt.asKnown() == null) 0 else 1) +
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                            (if (otherExplanation.asKnown() == null) 0 else 1) +
                            (if (trackingNumber.asKnown() == null) 0 else 1)

                    /** Return method. */
                    class ReturnMethod
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** DHL. */
                            val DHL = of("dhl")

                            /** Face-to-face. */
                            val FACE_TO_FACE = of("face_to_face")

                            /** FedEx. */
                            val FEDEX = of("fedex")

                            /** Other. */
                            val OTHER = of("other")

                            /** Postal service. */
                            val POSTAL_SERVICE = of("postal_service")

                            /** UPS. */
                            val UPS = of("ups")

                            fun of(value: String) = ReturnMethod(JsonField.of(value))
                        }

                        /** An enum containing [ReturnMethod]'s known values. */
                        enum class Known {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                        }

                        /**
                         * An enum containing [ReturnMethod]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnMethod] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                            /**
                             * An enum member indicating that [ReturnMethod] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DHL -> Value.DHL
                                FACE_TO_FACE -> Value.FACE_TO_FACE
                                FEDEX -> Value.FEDEX
                                OTHER -> Value.OTHER
                                POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                UPS -> Value.UPS
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DHL -> Known.DHL
                                FACE_TO_FACE -> Known.FACE_TO_FACE
                                FEDEX -> Known.FEDEX
                                OTHER -> Known.OTHER
                                POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                UPS -> Known.UPS
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnMethod: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnMethod = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnMethod && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Returned &&
                            returnMethod == other.returnMethod &&
                            returnedAt == other.returnedAt &&
                            merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                            otherExplanation == other.otherExplanation &&
                            trackingNumber == other.trackingNumber &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            returnMethod,
                            returnedAt,
                            merchantReceivedReturnAt,
                            otherExplanation,
                            trackingNumber,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Returned{returnMethod=$returnMethod, returnedAt=$returnedAt, merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerDamagedOrDefectiveMerchandise &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        orderAndIssueExplanation == other.orderAndIssueExplanation &&
                        receivedAt == other.receivedAt &&
                        returnOutcome == other.returnOutcome &&
                        notReturned == other.notReturned &&
                        returnAttempted == other.returnAttempted &&
                        returned == other.returned &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        merchantResolutionAttempted,
                        orderAndIssueExplanation,
                        receivedAt,
                        returnOutcome,
                        notReturned,
                        returnAttempted,
                        returned,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerDamagedOrDefectiveMerchandise{merchantResolutionAttempted=$merchantResolutionAttempted, orderAndIssueExplanation=$orderAndIssueExplanation, receivedAt=$receivedAt, returnOutcome=$returnOutcome, notReturned=$notReturned, returnAttempted=$returnAttempted, returned=$returned, additionalProperties=$additionalProperties}"
            }

            /**
             * Merchandise misrepresentation. Required if and only if `category` is
             * `consumer_merchandise_misrepresentation`.
             */
            class ConsumerMerchandiseMisrepresentation
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val misrepresentationExplanation: JsonField<String>,
                private val purchaseExplanation: JsonField<String>,
                private val receivedAt: JsonField<LocalDate>,
                private val returnOutcome: JsonField<ReturnOutcome>,
                private val notReturned: JsonValue,
                private val returnAttempted: JsonField<ReturnAttempted>,
                private val returned: JsonField<Returned>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("misrepresentation_explanation")
                    @ExcludeMissing
                    misrepresentationExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    purchaseExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    notReturned: JsonValue = JsonMissing.of(),
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                    @JsonProperty("returned")
                    @ExcludeMissing
                    returned: JsonField<Returned> = JsonMissing.of(),
                ) : this(
                    merchantResolutionAttempted,
                    misrepresentationExplanation,
                    purchaseExplanation,
                    receivedAt,
                    returnOutcome,
                    notReturned,
                    returnAttempted,
                    returned,
                    mutableMapOf(),
                )

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Misrepresentation explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun misrepresentationExplanation(): String =
                    misrepresentationExplanation.getRequired("misrepresentation_explanation")

                /**
                 * Purchase explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseExplanation(): String =
                    purchaseExplanation.getRequired("purchase_explanation")

                /**
                 * Received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                /**
                 * Return outcome.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                @JsonProperty("not_returned")
                @ExcludeMissing
                fun _notReturned(): JsonValue = notReturned

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returnAttempted(): ReturnAttempted? =
                    returnAttempted.getNullable("return_attempted")

                /**
                 * Returned. Required if and only if `return_outcome` is `returned`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returned(): Returned? = returned.getNullable("returned")

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [misrepresentationExplanation].
                 *
                 * Unlike [misrepresentationExplanation], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("misrepresentation_explanation")
                @ExcludeMissing
                fun _misrepresentationExplanation(): JsonField<String> =
                    misrepresentationExplanation

                /**
                 * Returns the raw JSON value of [purchaseExplanation].
                 *
                 * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("purchase_explanation")
                @ExcludeMissing
                fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                /**
                 * Returns the raw JSON value of [receivedAt].
                 *
                 * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_at")
                @ExcludeMissing
                fun _receivedAt(): JsonField<LocalDate> = receivedAt

                /**
                 * Returns the raw JSON value of [returnOutcome].
                 *
                 * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_outcome")
                @ExcludeMissing
                fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                /**
                 * Returns the raw JSON value of [returnAttempted].
                 *
                 * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_attempted")
                @ExcludeMissing
                fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                /**
                 * Returns the raw JSON value of [returned].
                 *
                 * Unlike [returned], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("returned")
                @ExcludeMissing
                fun _returned(): JsonField<Returned> = returned

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerMerchandiseMisrepresentation].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .misrepresentationExplanation()
                     * .purchaseExplanation()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerMerchandiseMisrepresentation]. */
                class Builder internal constructor() {

                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var misrepresentationExplanation: JsonField<String>? = null
                    private var purchaseExplanation: JsonField<String>? = null
                    private var receivedAt: JsonField<LocalDate>? = null
                    private var returnOutcome: JsonField<ReturnOutcome>? = null
                    private var notReturned: JsonValue = JsonMissing.of()
                    private var returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of()
                    private var returned: JsonField<Returned> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerMerchandiseMisrepresentation: ConsumerMerchandiseMisrepresentation
                    ) = apply {
                        merchantResolutionAttempted =
                            consumerMerchandiseMisrepresentation.merchantResolutionAttempted
                        misrepresentationExplanation =
                            consumerMerchandiseMisrepresentation.misrepresentationExplanation
                        purchaseExplanation =
                            consumerMerchandiseMisrepresentation.purchaseExplanation
                        receivedAt = consumerMerchandiseMisrepresentation.receivedAt
                        returnOutcome = consumerMerchandiseMisrepresentation.returnOutcome
                        notReturned = consumerMerchandiseMisrepresentation.notReturned
                        returnAttempted = consumerMerchandiseMisrepresentation.returnAttempted
                        returned = consumerMerchandiseMisrepresentation.returned
                        additionalProperties =
                            consumerMerchandiseMisrepresentation.additionalProperties.toMutableMap()
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Misrepresentation explanation. */
                    fun misrepresentationExplanation(misrepresentationExplanation: String) =
                        misrepresentationExplanation(JsonField.of(misrepresentationExplanation))

                    /**
                     * Sets [Builder.misrepresentationExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.misrepresentationExplanation] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun misrepresentationExplanation(
                        misrepresentationExplanation: JsonField<String>
                    ) = apply { this.misrepresentationExplanation = misrepresentationExplanation }

                    /** Purchase explanation. */
                    fun purchaseExplanation(purchaseExplanation: String) =
                        purchaseExplanation(JsonField.of(purchaseExplanation))

                    /**
                     * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseExplanation] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                        this.purchaseExplanation = purchaseExplanation
                    }

                    /** Received at. */
                    fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                    /**
                     * Sets [Builder.receivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                        this.receivedAt = receivedAt
                    }

                    /** Return outcome. */
                    fun returnOutcome(returnOutcome: ReturnOutcome) =
                        returnOutcome(JsonField.of(returnOutcome))

                    /**
                     * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnOutcome] with a well-typed
                     * [ReturnOutcome] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                        this.returnOutcome = returnOutcome
                    }

                    /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                    fun notReturned(notReturned: JsonValue) = apply {
                        this.notReturned = notReturned
                    }

                    /**
                     * Return attempted. Required if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    fun returnAttempted(returnAttempted: ReturnAttempted) =
                        returnAttempted(JsonField.of(returnAttempted))

                    /**
                     * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnAttempted] with a well-typed
                     * [ReturnAttempted] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                        this.returnAttempted = returnAttempted
                    }

                    /** Returned. Required if and only if `return_outcome` is `returned`. */
                    fun returned(returned: Returned) = returned(JsonField.of(returned))

                    /**
                     * Sets [Builder.returned] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returned] with a well-typed [Returned] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun returned(returned: JsonField<Returned>) = apply { this.returned = returned }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerMerchandiseMisrepresentation].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .misrepresentationExplanation()
                     * .purchaseExplanation()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerMerchandiseMisrepresentation =
                        ConsumerMerchandiseMisrepresentation(
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired(
                                "misrepresentationExplanation",
                                misrepresentationExplanation,
                            ),
                            checkRequired("purchaseExplanation", purchaseExplanation),
                            checkRequired("receivedAt", receivedAt),
                            checkRequired("returnOutcome", returnOutcome),
                            notReturned,
                            returnAttempted,
                            returned,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerMerchandiseMisrepresentation = apply {
                    if (validated) {
                        return@apply
                    }

                    merchantResolutionAttempted().validate()
                    misrepresentationExplanation()
                    purchaseExplanation()
                    receivedAt()
                    returnOutcome().validate()
                    returnAttempted()?.validate()
                    returned()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (misrepresentationExplanation.asKnown() == null) 0 else 1) +
                        (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                        (if (receivedAt.asKnown() == null) 0 else 1) +
                        (returnOutcome.asKnown()?.validity() ?: 0) +
                        (returnAttempted.asKnown()?.validity() ?: 0) +
                        (returned.asKnown()?.validity() ?: 0)

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Return outcome. */
                class ReturnOutcome
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Not returned. */
                        val NOT_RETURNED = of("not_returned")

                        /** Returned. */
                        val RETURNED = of("returned")

                        /** Return attempted. */
                        val RETURN_ATTEMPTED = of("return_attempted")

                        fun of(value: String) = ReturnOutcome(JsonField.of(value))
                    }

                    /** An enum containing [ReturnOutcome]'s known values. */
                    enum class Known {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                    }

                    /**
                     * An enum containing [ReturnOutcome]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [ReturnOutcome] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                        /**
                         * An enum member indicating that [ReturnOutcome] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            NOT_RETURNED -> Value.NOT_RETURNED
                            RETURNED -> Value.RETURNED
                            RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            NOT_RETURNED -> Known.NOT_RETURNED
                            RETURNED -> Known.RETURNED
                            RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                            else ->
                                throw IncreaseInvalidDataException("Unknown ReturnOutcome: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): ReturnOutcome = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnOutcome && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 */
                class ReturnAttempted
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val attemptExplanation: JsonField<String>,
                    private val attemptReason: JsonField<AttemptReason>,
                    private val attemptedAt: JsonField<LocalDate>,
                    private val merchandiseDisposition: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        attemptExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        attemptExplanation,
                        attemptReason,
                        attemptedAt,
                        merchandiseDisposition,
                        mutableMapOf(),
                    )

                    /**
                     * Attempt explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptExplanation(): String =
                        attemptExplanation.getRequired("attempt_explanation")

                    /**
                     * Attempt reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptReason(): AttemptReason = attemptReason.getRequired("attempt_reason")

                    /**
                     * Attempted at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                    /**
                     * Merchandise disposition.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchandiseDisposition(): String =
                        merchandiseDisposition.getRequired("merchandise_disposition")

                    /**
                     * Returns the raw JSON value of [attemptExplanation].
                     *
                     * Unlike [attemptExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("attempt_explanation")
                    @ExcludeMissing
                    fun _attemptExplanation(): JsonField<String> = attemptExplanation

                    /**
                     * Returns the raw JSON value of [attemptReason].
                     *
                     * Unlike [attemptReason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempt_reason")
                    @ExcludeMissing
                    fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                    /**
                     * Returns the raw JSON value of [attemptedAt].
                     *
                     * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempted_at")
                    @ExcludeMissing
                    fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                    /**
                     * Returns the raw JSON value of [merchandiseDisposition].
                     *
                     * Unlike [merchandiseDisposition], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchandise_disposition")
                    @ExcludeMissing
                    fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ReturnAttempted].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ReturnAttempted]. */
                    class Builder internal constructor() {

                        private var attemptExplanation: JsonField<String>? = null
                        private var attemptReason: JsonField<AttemptReason>? = null
                        private var attemptedAt: JsonField<LocalDate>? = null
                        private var merchandiseDisposition: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returnAttempted: ReturnAttempted) = apply {
                            attemptExplanation = returnAttempted.attemptExplanation
                            attemptReason = returnAttempted.attemptReason
                            attemptedAt = returnAttempted.attemptedAt
                            merchandiseDisposition = returnAttempted.merchandiseDisposition
                            additionalProperties =
                                returnAttempted.additionalProperties.toMutableMap()
                        }

                        /** Attempt explanation. */
                        fun attemptExplanation(attemptExplanation: String) =
                            attemptExplanation(JsonField.of(attemptExplanation))

                        /**
                         * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                            this.attemptExplanation = attemptExplanation
                        }

                        /** Attempt reason. */
                        fun attemptReason(attemptReason: AttemptReason) =
                            attemptReason(JsonField.of(attemptReason))

                        /**
                         * Sets [Builder.attemptReason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptReason] with a well-typed
                         * [AttemptReason] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                            this.attemptReason = attemptReason
                        }

                        /** Attempted at. */
                        fun attemptedAt(attemptedAt: LocalDate) =
                            attemptedAt(JsonField.of(attemptedAt))

                        /**
                         * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                            this.attemptedAt = attemptedAt
                        }

                        /** Merchandise disposition. */
                        fun merchandiseDisposition(merchandiseDisposition: String) =
                            merchandiseDisposition(JsonField.of(merchandiseDisposition))

                        /**
                         * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchandiseDisposition] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                            apply {
                                this.merchandiseDisposition = merchandiseDisposition
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ReturnAttempted].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ReturnAttempted =
                            ReturnAttempted(
                                checkRequired("attemptExplanation", attemptExplanation),
                                checkRequired("attemptReason", attemptReason),
                                checkRequired("attemptedAt", attemptedAt),
                                checkRequired("merchandiseDisposition", merchandiseDisposition),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ReturnAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        attemptExplanation()
                        attemptReason().validate()
                        attemptedAt()
                        merchandiseDisposition()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (attemptExplanation.asKnown() == null) 0 else 1) +
                            (attemptReason.asKnown()?.validity() ?: 0) +
                            (if (attemptedAt.asKnown() == null) 0 else 1) +
                            (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                    /** Attempt reason. */
                    class AttemptReason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Merchant not responding. */
                            val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                            /** No return authorization provided. */
                            val NO_RETURN_AUTHORIZATION_PROVIDED =
                                of("no_return_authorization_provided")

                            /** No return instructions. */
                            val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                            /** Requested not to return. */
                            val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                            /** Return not accepted. */
                            val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                            fun of(value: String) = AttemptReason(JsonField.of(value))
                        }

                        /** An enum containing [AttemptReason]'s known values. */
                        enum class Known {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AttemptReason]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AttemptReason] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AttemptReason] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AttemptReason: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AttemptReason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AttemptReason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnAttempted &&
                            attemptExplanation == other.attemptExplanation &&
                            attemptReason == other.attemptReason &&
                            attemptedAt == other.attemptedAt &&
                            merchandiseDisposition == other.merchandiseDisposition &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                }

                /** Returned. Required if and only if `return_outcome` is `returned`. */
                class Returned
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val returnMethod: JsonField<ReturnMethod>,
                    private val returnedAt: JsonField<LocalDate>,
                    private val merchantReceivedReturnAt: JsonField<LocalDate>,
                    private val otherExplanation: JsonField<String>,
                    private val trackingNumber: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        otherExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        trackingNumber: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        returnMethod,
                        returnedAt,
                        merchantReceivedReturnAt,
                        otherExplanation,
                        trackingNumber,
                        mutableMapOf(),
                    )

                    /**
                     * Return method.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                    /**
                     * Returned at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                    /**
                     * Merchant received return at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun merchantReceivedReturnAt(): LocalDate? =
                        merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                    /**
                     * Other explanation. Required if and only if the return method is `other`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun otherExplanation(): String? =
                        otherExplanation.getNullable("other_explanation")

                    /**
                     * Tracking number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun trackingNumber(): String? = trackingNumber.getNullable("tracking_number")

                    /**
                     * Returns the raw JSON value of [returnMethod].
                     *
                     * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_method")
                    @ExcludeMissing
                    fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                    /**
                     * Returns the raw JSON value of [returnedAt].
                     *
                     * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned_at")
                    @ExcludeMissing
                    fun _returnedAt(): JsonField<LocalDate> = returnedAt

                    /**
                     * Returns the raw JSON value of [merchantReceivedReturnAt].
                     *
                     * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_received_return_at")
                    @ExcludeMissing
                    fun _merchantReceivedReturnAt(): JsonField<LocalDate> = merchantReceivedReturnAt

                    /**
                     * Returns the raw JSON value of [otherExplanation].
                     *
                     * Unlike [otherExplanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("other_explanation")
                    @ExcludeMissing
                    fun _otherExplanation(): JsonField<String> = otherExplanation

                    /**
                     * Returns the raw JSON value of [trackingNumber].
                     *
                     * Unlike [trackingNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("tracking_number")
                    @ExcludeMissing
                    fun _trackingNumber(): JsonField<String> = trackingNumber

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Returned].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Returned]. */
                    class Builder internal constructor() {

                        private var returnMethod: JsonField<ReturnMethod>? = null
                        private var returnedAt: JsonField<LocalDate>? = null
                        private var merchantReceivedReturnAt: JsonField<LocalDate> =
                            JsonMissing.of()
                        private var otherExplanation: JsonField<String> = JsonMissing.of()
                        private var trackingNumber: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returned: Returned) = apply {
                            returnMethod = returned.returnMethod
                            returnedAt = returned.returnedAt
                            merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                            otherExplanation = returned.otherExplanation
                            trackingNumber = returned.trackingNumber
                            additionalProperties = returned.additionalProperties.toMutableMap()
                        }

                        /** Return method. */
                        fun returnMethod(returnMethod: ReturnMethod) =
                            returnMethod(JsonField.of(returnMethod))

                        /**
                         * Sets [Builder.returnMethod] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnMethod] with a well-typed
                         * [ReturnMethod] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                            this.returnMethod = returnMethod
                        }

                        /** Returned at. */
                        fun returnedAt(returnedAt: LocalDate) = returnedAt(JsonField.of(returnedAt))

                        /**
                         * Sets [Builder.returnedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                            this.returnedAt = returnedAt
                        }

                        /** Merchant received return at. */
                        fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate) =
                            merchantReceivedReturnAt(JsonField.of(merchantReceivedReturnAt))

                        /**
                         * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantReceivedReturnAt] with a
                         * well-typed [LocalDate] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun merchantReceivedReturnAt(
                            merchantReceivedReturnAt: JsonField<LocalDate>
                        ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         */
                        fun otherExplanation(otherExplanation: String) =
                            otherExplanation(JsonField.of(otherExplanation))

                        /**
                         * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                            this.otherExplanation = otherExplanation
                        }

                        /** Tracking number. */
                        fun trackingNumber(trackingNumber: String) =
                            trackingNumber(JsonField.of(trackingNumber))

                        /**
                         * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.trackingNumber] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                            this.trackingNumber = trackingNumber
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Returned].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Returned =
                            Returned(
                                checkRequired("returnMethod", returnMethod),
                                checkRequired("returnedAt", returnedAt),
                                merchantReceivedReturnAt,
                                otherExplanation,
                                trackingNumber,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Returned = apply {
                        if (validated) {
                            return@apply
                        }

                        returnMethod().validate()
                        returnedAt()
                        merchantReceivedReturnAt()
                        otherExplanation()
                        trackingNumber()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (returnMethod.asKnown()?.validity() ?: 0) +
                            (if (returnedAt.asKnown() == null) 0 else 1) +
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                            (if (otherExplanation.asKnown() == null) 0 else 1) +
                            (if (trackingNumber.asKnown() == null) 0 else 1)

                    /** Return method. */
                    class ReturnMethod
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** DHL. */
                            val DHL = of("dhl")

                            /** Face-to-face. */
                            val FACE_TO_FACE = of("face_to_face")

                            /** FedEx. */
                            val FEDEX = of("fedex")

                            /** Other. */
                            val OTHER = of("other")

                            /** Postal service. */
                            val POSTAL_SERVICE = of("postal_service")

                            /** UPS. */
                            val UPS = of("ups")

                            fun of(value: String) = ReturnMethod(JsonField.of(value))
                        }

                        /** An enum containing [ReturnMethod]'s known values. */
                        enum class Known {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                        }

                        /**
                         * An enum containing [ReturnMethod]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnMethod] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                            /**
                             * An enum member indicating that [ReturnMethod] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DHL -> Value.DHL
                                FACE_TO_FACE -> Value.FACE_TO_FACE
                                FEDEX -> Value.FEDEX
                                OTHER -> Value.OTHER
                                POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                UPS -> Value.UPS
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DHL -> Known.DHL
                                FACE_TO_FACE -> Known.FACE_TO_FACE
                                FEDEX -> Known.FEDEX
                                OTHER -> Known.OTHER
                                POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                UPS -> Known.UPS
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnMethod: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnMethod = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnMethod && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Returned &&
                            returnMethod == other.returnMethod &&
                            returnedAt == other.returnedAt &&
                            merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                            otherExplanation == other.otherExplanation &&
                            trackingNumber == other.trackingNumber &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            returnMethod,
                            returnedAt,
                            merchantReceivedReturnAt,
                            otherExplanation,
                            trackingNumber,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Returned{returnMethod=$returnMethod, returnedAt=$returnedAt, merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerMerchandiseMisrepresentation &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        misrepresentationExplanation == other.misrepresentationExplanation &&
                        purchaseExplanation == other.purchaseExplanation &&
                        receivedAt == other.receivedAt &&
                        returnOutcome == other.returnOutcome &&
                        notReturned == other.notReturned &&
                        returnAttempted == other.returnAttempted &&
                        returned == other.returned &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        merchantResolutionAttempted,
                        misrepresentationExplanation,
                        purchaseExplanation,
                        receivedAt,
                        returnOutcome,
                        notReturned,
                        returnAttempted,
                        returned,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerMerchandiseMisrepresentation{merchantResolutionAttempted=$merchantResolutionAttempted, misrepresentationExplanation=$misrepresentationExplanation, purchaseExplanation=$purchaseExplanation, receivedAt=$receivedAt, returnOutcome=$returnOutcome, notReturned=$notReturned, returnAttempted=$returnAttempted, returned=$returned, additionalProperties=$additionalProperties}"
            }

            /**
             * Merchandise not as described. Required if and only if `category` is
             * `consumer_merchandise_not_as_described`.
             */
            class ConsumerMerchandiseNotAsDescribed
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val receivedAt: JsonField<LocalDate>,
                private val returnOutcome: JsonField<ReturnOutcome>,
                private val returnAttempted: JsonField<ReturnAttempted>,
                private val returned: JsonField<Returned>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                    @JsonProperty("returned")
                    @ExcludeMissing
                    returned: JsonField<Returned> = JsonMissing.of(),
                ) : this(
                    merchantResolutionAttempted,
                    receivedAt,
                    returnOutcome,
                    returnAttempted,
                    returned,
                    mutableMapOf(),
                )

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                /**
                 * Return outcome.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returnAttempted(): ReturnAttempted? =
                    returnAttempted.getNullable("return_attempted")

                /**
                 * Returned. Required if and only if `return_outcome` is `returned`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returned(): Returned? = returned.getNullable("returned")

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [receivedAt].
                 *
                 * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_at")
                @ExcludeMissing
                fun _receivedAt(): JsonField<LocalDate> = receivedAt

                /**
                 * Returns the raw JSON value of [returnOutcome].
                 *
                 * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_outcome")
                @ExcludeMissing
                fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                /**
                 * Returns the raw JSON value of [returnAttempted].
                 *
                 * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_attempted")
                @ExcludeMissing
                fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                /**
                 * Returns the raw JSON value of [returned].
                 *
                 * Unlike [returned], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("returned")
                @ExcludeMissing
                fun _returned(): JsonField<Returned> = returned

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerMerchandiseNotAsDescribed].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerMerchandiseNotAsDescribed]. */
                class Builder internal constructor() {

                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var receivedAt: JsonField<LocalDate>? = null
                    private var returnOutcome: JsonField<ReturnOutcome>? = null
                    private var returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of()
                    private var returned: JsonField<Returned> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerMerchandiseNotAsDescribed: ConsumerMerchandiseNotAsDescribed
                    ) = apply {
                        merchantResolutionAttempted =
                            consumerMerchandiseNotAsDescribed.merchantResolutionAttempted
                        receivedAt = consumerMerchandiseNotAsDescribed.receivedAt
                        returnOutcome = consumerMerchandiseNotAsDescribed.returnOutcome
                        returnAttempted = consumerMerchandiseNotAsDescribed.returnAttempted
                        returned = consumerMerchandiseNotAsDescribed.returned
                        additionalProperties =
                            consumerMerchandiseNotAsDescribed.additionalProperties.toMutableMap()
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Received at. */
                    fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                    /**
                     * Sets [Builder.receivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                        this.receivedAt = receivedAt
                    }

                    /** Return outcome. */
                    fun returnOutcome(returnOutcome: ReturnOutcome) =
                        returnOutcome(JsonField.of(returnOutcome))

                    /**
                     * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnOutcome] with a well-typed
                     * [ReturnOutcome] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                        this.returnOutcome = returnOutcome
                    }

                    /**
                     * Return attempted. Required if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    fun returnAttempted(returnAttempted: ReturnAttempted) =
                        returnAttempted(JsonField.of(returnAttempted))

                    /**
                     * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnAttempted] with a well-typed
                     * [ReturnAttempted] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                        this.returnAttempted = returnAttempted
                    }

                    /** Returned. Required if and only if `return_outcome` is `returned`. */
                    fun returned(returned: Returned) = returned(JsonField.of(returned))

                    /**
                     * Sets [Builder.returned] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returned] with a well-typed [Returned] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun returned(returned: JsonField<Returned>) = apply { this.returned = returned }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerMerchandiseNotAsDescribed].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .merchantResolutionAttempted()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerMerchandiseNotAsDescribed =
                        ConsumerMerchandiseNotAsDescribed(
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired("receivedAt", receivedAt),
                            checkRequired("returnOutcome", returnOutcome),
                            returnAttempted,
                            returned,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerMerchandiseNotAsDescribed = apply {
                    if (validated) {
                        return@apply
                    }

                    merchantResolutionAttempted().validate()
                    receivedAt()
                    returnOutcome().validate()
                    returnAttempted()?.validate()
                    returned()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (receivedAt.asKnown() == null) 0 else 1) +
                        (returnOutcome.asKnown()?.validity() ?: 0) +
                        (returnAttempted.asKnown()?.validity() ?: 0) +
                        (returned.asKnown()?.validity() ?: 0)

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Return outcome. */
                class ReturnOutcome
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Returned. */
                        val RETURNED = of("returned")

                        /** Return attempted. */
                        val RETURN_ATTEMPTED = of("return_attempted")

                        fun of(value: String) = ReturnOutcome(JsonField.of(value))
                    }

                    /** An enum containing [ReturnOutcome]'s known values. */
                    enum class Known {
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                    }

                    /**
                     * An enum containing [ReturnOutcome]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [ReturnOutcome] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                        /**
                         * An enum member indicating that [ReturnOutcome] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            RETURNED -> Value.RETURNED
                            RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            RETURNED -> Known.RETURNED
                            RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                            else ->
                                throw IncreaseInvalidDataException("Unknown ReturnOutcome: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): ReturnOutcome = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnOutcome && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 */
                class ReturnAttempted
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val attemptExplanation: JsonField<String>,
                    private val attemptReason: JsonField<AttemptReason>,
                    private val attemptedAt: JsonField<LocalDate>,
                    private val merchandiseDisposition: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        attemptExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        attemptExplanation,
                        attemptReason,
                        attemptedAt,
                        merchandiseDisposition,
                        mutableMapOf(),
                    )

                    /**
                     * Attempt explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptExplanation(): String =
                        attemptExplanation.getRequired("attempt_explanation")

                    /**
                     * Attempt reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptReason(): AttemptReason = attemptReason.getRequired("attempt_reason")

                    /**
                     * Attempted at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                    /**
                     * Merchandise disposition.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchandiseDisposition(): String =
                        merchandiseDisposition.getRequired("merchandise_disposition")

                    /**
                     * Returns the raw JSON value of [attemptExplanation].
                     *
                     * Unlike [attemptExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("attempt_explanation")
                    @ExcludeMissing
                    fun _attemptExplanation(): JsonField<String> = attemptExplanation

                    /**
                     * Returns the raw JSON value of [attemptReason].
                     *
                     * Unlike [attemptReason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempt_reason")
                    @ExcludeMissing
                    fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                    /**
                     * Returns the raw JSON value of [attemptedAt].
                     *
                     * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempted_at")
                    @ExcludeMissing
                    fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                    /**
                     * Returns the raw JSON value of [merchandiseDisposition].
                     *
                     * Unlike [merchandiseDisposition], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchandise_disposition")
                    @ExcludeMissing
                    fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ReturnAttempted].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ReturnAttempted]. */
                    class Builder internal constructor() {

                        private var attemptExplanation: JsonField<String>? = null
                        private var attemptReason: JsonField<AttemptReason>? = null
                        private var attemptedAt: JsonField<LocalDate>? = null
                        private var merchandiseDisposition: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returnAttempted: ReturnAttempted) = apply {
                            attemptExplanation = returnAttempted.attemptExplanation
                            attemptReason = returnAttempted.attemptReason
                            attemptedAt = returnAttempted.attemptedAt
                            merchandiseDisposition = returnAttempted.merchandiseDisposition
                            additionalProperties =
                                returnAttempted.additionalProperties.toMutableMap()
                        }

                        /** Attempt explanation. */
                        fun attemptExplanation(attemptExplanation: String) =
                            attemptExplanation(JsonField.of(attemptExplanation))

                        /**
                         * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                            this.attemptExplanation = attemptExplanation
                        }

                        /** Attempt reason. */
                        fun attemptReason(attemptReason: AttemptReason) =
                            attemptReason(JsonField.of(attemptReason))

                        /**
                         * Sets [Builder.attemptReason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptReason] with a well-typed
                         * [AttemptReason] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                            this.attemptReason = attemptReason
                        }

                        /** Attempted at. */
                        fun attemptedAt(attemptedAt: LocalDate) =
                            attemptedAt(JsonField.of(attemptedAt))

                        /**
                         * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                            this.attemptedAt = attemptedAt
                        }

                        /** Merchandise disposition. */
                        fun merchandiseDisposition(merchandiseDisposition: String) =
                            merchandiseDisposition(JsonField.of(merchandiseDisposition))

                        /**
                         * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchandiseDisposition] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                            apply {
                                this.merchandiseDisposition = merchandiseDisposition
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ReturnAttempted].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ReturnAttempted =
                            ReturnAttempted(
                                checkRequired("attemptExplanation", attemptExplanation),
                                checkRequired("attemptReason", attemptReason),
                                checkRequired("attemptedAt", attemptedAt),
                                checkRequired("merchandiseDisposition", merchandiseDisposition),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ReturnAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        attemptExplanation()
                        attemptReason().validate()
                        attemptedAt()
                        merchandiseDisposition()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (attemptExplanation.asKnown() == null) 0 else 1) +
                            (attemptReason.asKnown()?.validity() ?: 0) +
                            (if (attemptedAt.asKnown() == null) 0 else 1) +
                            (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                    /** Attempt reason. */
                    class AttemptReason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Merchant not responding. */
                            val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                            /** No return authorization provided. */
                            val NO_RETURN_AUTHORIZATION_PROVIDED =
                                of("no_return_authorization_provided")

                            /** No return instructions. */
                            val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                            /** Requested not to return. */
                            val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                            /** Return not accepted. */
                            val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                            fun of(value: String) = AttemptReason(JsonField.of(value))
                        }

                        /** An enum containing [AttemptReason]'s known values. */
                        enum class Known {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AttemptReason]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AttemptReason] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AttemptReason] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AttemptReason: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AttemptReason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AttemptReason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnAttempted &&
                            attemptExplanation == other.attemptExplanation &&
                            attemptReason == other.attemptReason &&
                            attemptedAt == other.attemptedAt &&
                            merchandiseDisposition == other.merchandiseDisposition &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                }

                /** Returned. Required if and only if `return_outcome` is `returned`. */
                class Returned
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val returnMethod: JsonField<ReturnMethod>,
                    private val returnedAt: JsonField<LocalDate>,
                    private val merchantReceivedReturnAt: JsonField<LocalDate>,
                    private val otherExplanation: JsonField<String>,
                    private val trackingNumber: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        otherExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        trackingNumber: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        returnMethod,
                        returnedAt,
                        merchantReceivedReturnAt,
                        otherExplanation,
                        trackingNumber,
                        mutableMapOf(),
                    )

                    /**
                     * Return method.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                    /**
                     * Returned at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                    /**
                     * Merchant received return at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun merchantReceivedReturnAt(): LocalDate? =
                        merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                    /**
                     * Other explanation. Required if and only if the return method is `other`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun otherExplanation(): String? =
                        otherExplanation.getNullable("other_explanation")

                    /**
                     * Tracking number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun trackingNumber(): String? = trackingNumber.getNullable("tracking_number")

                    /**
                     * Returns the raw JSON value of [returnMethod].
                     *
                     * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_method")
                    @ExcludeMissing
                    fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                    /**
                     * Returns the raw JSON value of [returnedAt].
                     *
                     * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned_at")
                    @ExcludeMissing
                    fun _returnedAt(): JsonField<LocalDate> = returnedAt

                    /**
                     * Returns the raw JSON value of [merchantReceivedReturnAt].
                     *
                     * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_received_return_at")
                    @ExcludeMissing
                    fun _merchantReceivedReturnAt(): JsonField<LocalDate> = merchantReceivedReturnAt

                    /**
                     * Returns the raw JSON value of [otherExplanation].
                     *
                     * Unlike [otherExplanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("other_explanation")
                    @ExcludeMissing
                    fun _otherExplanation(): JsonField<String> = otherExplanation

                    /**
                     * Returns the raw JSON value of [trackingNumber].
                     *
                     * Unlike [trackingNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("tracking_number")
                    @ExcludeMissing
                    fun _trackingNumber(): JsonField<String> = trackingNumber

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Returned].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Returned]. */
                    class Builder internal constructor() {

                        private var returnMethod: JsonField<ReturnMethod>? = null
                        private var returnedAt: JsonField<LocalDate>? = null
                        private var merchantReceivedReturnAt: JsonField<LocalDate> =
                            JsonMissing.of()
                        private var otherExplanation: JsonField<String> = JsonMissing.of()
                        private var trackingNumber: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returned: Returned) = apply {
                            returnMethod = returned.returnMethod
                            returnedAt = returned.returnedAt
                            merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                            otherExplanation = returned.otherExplanation
                            trackingNumber = returned.trackingNumber
                            additionalProperties = returned.additionalProperties.toMutableMap()
                        }

                        /** Return method. */
                        fun returnMethod(returnMethod: ReturnMethod) =
                            returnMethod(JsonField.of(returnMethod))

                        /**
                         * Sets [Builder.returnMethod] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnMethod] with a well-typed
                         * [ReturnMethod] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                            this.returnMethod = returnMethod
                        }

                        /** Returned at. */
                        fun returnedAt(returnedAt: LocalDate) = returnedAt(JsonField.of(returnedAt))

                        /**
                         * Sets [Builder.returnedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                            this.returnedAt = returnedAt
                        }

                        /** Merchant received return at. */
                        fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate) =
                            merchantReceivedReturnAt(JsonField.of(merchantReceivedReturnAt))

                        /**
                         * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantReceivedReturnAt] with a
                         * well-typed [LocalDate] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun merchantReceivedReturnAt(
                            merchantReceivedReturnAt: JsonField<LocalDate>
                        ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         */
                        fun otherExplanation(otherExplanation: String) =
                            otherExplanation(JsonField.of(otherExplanation))

                        /**
                         * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                            this.otherExplanation = otherExplanation
                        }

                        /** Tracking number. */
                        fun trackingNumber(trackingNumber: String) =
                            trackingNumber(JsonField.of(trackingNumber))

                        /**
                         * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.trackingNumber] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                            this.trackingNumber = trackingNumber
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Returned].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Returned =
                            Returned(
                                checkRequired("returnMethod", returnMethod),
                                checkRequired("returnedAt", returnedAt),
                                merchantReceivedReturnAt,
                                otherExplanation,
                                trackingNumber,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Returned = apply {
                        if (validated) {
                            return@apply
                        }

                        returnMethod().validate()
                        returnedAt()
                        merchantReceivedReturnAt()
                        otherExplanation()
                        trackingNumber()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (returnMethod.asKnown()?.validity() ?: 0) +
                            (if (returnedAt.asKnown() == null) 0 else 1) +
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                            (if (otherExplanation.asKnown() == null) 0 else 1) +
                            (if (trackingNumber.asKnown() == null) 0 else 1)

                    /** Return method. */
                    class ReturnMethod
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** DHL. */
                            val DHL = of("dhl")

                            /** Face-to-face. */
                            val FACE_TO_FACE = of("face_to_face")

                            /** FedEx. */
                            val FEDEX = of("fedex")

                            /** Other. */
                            val OTHER = of("other")

                            /** Postal service. */
                            val POSTAL_SERVICE = of("postal_service")

                            /** UPS. */
                            val UPS = of("ups")

                            fun of(value: String) = ReturnMethod(JsonField.of(value))
                        }

                        /** An enum containing [ReturnMethod]'s known values. */
                        enum class Known {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                        }

                        /**
                         * An enum containing [ReturnMethod]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnMethod] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                            /**
                             * An enum member indicating that [ReturnMethod] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DHL -> Value.DHL
                                FACE_TO_FACE -> Value.FACE_TO_FACE
                                FEDEX -> Value.FEDEX
                                OTHER -> Value.OTHER
                                POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                UPS -> Value.UPS
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DHL -> Known.DHL
                                FACE_TO_FACE -> Known.FACE_TO_FACE
                                FEDEX -> Known.FEDEX
                                OTHER -> Known.OTHER
                                POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                UPS -> Known.UPS
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnMethod: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnMethod = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnMethod && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Returned &&
                            returnMethod == other.returnMethod &&
                            returnedAt == other.returnedAt &&
                            merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                            otherExplanation == other.otherExplanation &&
                            trackingNumber == other.trackingNumber &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            returnMethod,
                            returnedAt,
                            merchantReceivedReturnAt,
                            otherExplanation,
                            trackingNumber,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Returned{returnMethod=$returnMethod, returnedAt=$returnedAt, merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerMerchandiseNotAsDescribed &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        receivedAt == other.receivedAt &&
                        returnOutcome == other.returnOutcome &&
                        returnAttempted == other.returnAttempted &&
                        returned == other.returned &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        merchantResolutionAttempted,
                        receivedAt,
                        returnOutcome,
                        returnAttempted,
                        returned,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerMerchandiseNotAsDescribed{merchantResolutionAttempted=$merchantResolutionAttempted, receivedAt=$receivedAt, returnOutcome=$returnOutcome, returnAttempted=$returnAttempted, returned=$returned, additionalProperties=$additionalProperties}"
            }

            /**
             * Merchandise not received. Required if and only if `category` is
             * `consumer_merchandise_not_received`.
             */
            class ConsumerMerchandiseNotReceived
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cancellationOutcome: JsonField<CancellationOutcome>,
                private val deliveryIssue: JsonField<DeliveryIssue>,
                private val lastExpectedReceiptAt: JsonField<LocalDate>,
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val purchaseInfoAndExplanation: JsonField<String>,
                private val cardholderCancellationPriorToExpectedReceipt:
                    JsonField<CardholderCancellationPriorToExpectedReceipt>,
                private val delayed: JsonField<Delayed>,
                private val deliveredToWrongLocation: JsonField<DeliveredToWrongLocation>,
                private val merchantCancellation: JsonField<MerchantCancellation>,
                private val noCancellation: JsonValue,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cancellation_outcome")
                    @ExcludeMissing
                    cancellationOutcome: JsonField<CancellationOutcome> = JsonMissing.of(),
                    @JsonProperty("delivery_issue")
                    @ExcludeMissing
                    deliveryIssue: JsonField<DeliveryIssue> = JsonMissing.of(),
                    @JsonProperty("last_expected_receipt_at")
                    @ExcludeMissing
                    lastExpectedReceiptAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("purchase_info_and_explanation")
                    @ExcludeMissing
                    purchaseInfoAndExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                    @ExcludeMissing
                    cardholderCancellationPriorToExpectedReceipt:
                        JsonField<CardholderCancellationPriorToExpectedReceipt> =
                        JsonMissing.of(),
                    @JsonProperty("delayed")
                    @ExcludeMissing
                    delayed: JsonField<Delayed> = JsonMissing.of(),
                    @JsonProperty("delivered_to_wrong_location")
                    @ExcludeMissing
                    deliveredToWrongLocation: JsonField<DeliveredToWrongLocation> =
                        JsonMissing.of(),
                    @JsonProperty("merchant_cancellation")
                    @ExcludeMissing
                    merchantCancellation: JsonField<MerchantCancellation> = JsonMissing.of(),
                    @JsonProperty("no_cancellation")
                    @ExcludeMissing
                    noCancellation: JsonValue = JsonMissing.of(),
                ) : this(
                    cancellationOutcome,
                    deliveryIssue,
                    lastExpectedReceiptAt,
                    merchantResolutionAttempted,
                    purchaseInfoAndExplanation,
                    cardholderCancellationPriorToExpectedReceipt,
                    delayed,
                    deliveredToWrongLocation,
                    merchantCancellation,
                    noCancellation,
                    mutableMapOf(),
                )

                /**
                 * Cancellation outcome.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun cancellationOutcome(): CancellationOutcome =
                    cancellationOutcome.getRequired("cancellation_outcome")

                /**
                 * Delivery issue.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun deliveryIssue(): DeliveryIssue = deliveryIssue.getRequired("delivery_issue")

                /**
                 * Last expected receipt at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun lastExpectedReceiptAt(): LocalDate =
                    lastExpectedReceiptAt.getRequired("last_expected_receipt_at")

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Purchase information and explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseInfoAndExplanation(): String =
                    purchaseInfoAndExplanation.getRequired("purchase_info_and_explanation")

                /**
                 * Cardholder cancellation prior to expected receipt. Required if and only if
                 * `cancellation_outcome` is `cardholder_cancellation_prior_to_expected_receipt`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun cardholderCancellationPriorToExpectedReceipt():
                    CardholderCancellationPriorToExpectedReceipt? =
                    cardholderCancellationPriorToExpectedReceipt.getNullable(
                        "cardholder_cancellation_prior_to_expected_receipt"
                    )

                /**
                 * Delayed. Required if and only if `delivery_issue` is `delayed`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun delayed(): Delayed? = delayed.getNullable("delayed")

                /**
                 * Delivered to wrong location. Required if and only if `delivery_issue` is
                 * `delivered_to_wrong_location`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun deliveredToWrongLocation(): DeliveredToWrongLocation? =
                    deliveredToWrongLocation.getNullable("delivered_to_wrong_location")

                /**
                 * Merchant cancellation. Required if and only if `cancellation_outcome` is
                 * `merchant_cancellation`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun merchantCancellation(): MerchantCancellation? =
                    merchantCancellation.getNullable("merchant_cancellation")

                /**
                 * No cancellation. Required if and only if `cancellation_outcome` is
                 * `no_cancellation`.
                 */
                @JsonProperty("no_cancellation")
                @ExcludeMissing
                fun _noCancellation(): JsonValue = noCancellation

                /**
                 * Returns the raw JSON value of [cancellationOutcome].
                 *
                 * Unlike [cancellationOutcome], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("cancellation_outcome")
                @ExcludeMissing
                fun _cancellationOutcome(): JsonField<CancellationOutcome> = cancellationOutcome

                /**
                 * Returns the raw JSON value of [deliveryIssue].
                 *
                 * Unlike [deliveryIssue], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("delivery_issue")
                @ExcludeMissing
                fun _deliveryIssue(): JsonField<DeliveryIssue> = deliveryIssue

                /**
                 * Returns the raw JSON value of [lastExpectedReceiptAt].
                 *
                 * Unlike [lastExpectedReceiptAt], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("last_expected_receipt_at")
                @ExcludeMissing
                fun _lastExpectedReceiptAt(): JsonField<LocalDate> = lastExpectedReceiptAt

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [purchaseInfoAndExplanation].
                 *
                 * Unlike [purchaseInfoAndExplanation], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("purchase_info_and_explanation")
                @ExcludeMissing
                fun _purchaseInfoAndExplanation(): JsonField<String> = purchaseInfoAndExplanation

                /**
                 * Returns the raw JSON value of [cardholderCancellationPriorToExpectedReceipt].
                 *
                 * Unlike [cardholderCancellationPriorToExpectedReceipt], this method doesn't throw
                 * if the JSON field has an unexpected type.
                 */
                @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                @ExcludeMissing
                fun _cardholderCancellationPriorToExpectedReceipt():
                    JsonField<CardholderCancellationPriorToExpectedReceipt> =
                    cardholderCancellationPriorToExpectedReceipt

                /**
                 * Returns the raw JSON value of [delayed].
                 *
                 * Unlike [delayed], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("delayed")
                @ExcludeMissing
                fun _delayed(): JsonField<Delayed> = delayed

                /**
                 * Returns the raw JSON value of [deliveredToWrongLocation].
                 *
                 * Unlike [deliveredToWrongLocation], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("delivered_to_wrong_location")
                @ExcludeMissing
                fun _deliveredToWrongLocation(): JsonField<DeliveredToWrongLocation> =
                    deliveredToWrongLocation

                /**
                 * Returns the raw JSON value of [merchantCancellation].
                 *
                 * Unlike [merchantCancellation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("merchant_cancellation")
                @ExcludeMissing
                fun _merchantCancellation(): JsonField<MerchantCancellation> = merchantCancellation

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerMerchandiseNotReceived].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cancellationOutcome()
                     * .deliveryIssue()
                     * .lastExpectedReceiptAt()
                     * .merchantResolutionAttempted()
                     * .purchaseInfoAndExplanation()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerMerchandiseNotReceived]. */
                class Builder internal constructor() {

                    private var cancellationOutcome: JsonField<CancellationOutcome>? = null
                    private var deliveryIssue: JsonField<DeliveryIssue>? = null
                    private var lastExpectedReceiptAt: JsonField<LocalDate>? = null
                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var purchaseInfoAndExplanation: JsonField<String>? = null
                    private var cardholderCancellationPriorToExpectedReceipt:
                        JsonField<CardholderCancellationPriorToExpectedReceipt> =
                        JsonMissing.of()
                    private var delayed: JsonField<Delayed> = JsonMissing.of()
                    private var deliveredToWrongLocation: JsonField<DeliveredToWrongLocation> =
                        JsonMissing.of()
                    private var merchantCancellation: JsonField<MerchantCancellation> =
                        JsonMissing.of()
                    private var noCancellation: JsonValue = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerMerchandiseNotReceived: ConsumerMerchandiseNotReceived
                    ) = apply {
                        cancellationOutcome = consumerMerchandiseNotReceived.cancellationOutcome
                        deliveryIssue = consumerMerchandiseNotReceived.deliveryIssue
                        lastExpectedReceiptAt = consumerMerchandiseNotReceived.lastExpectedReceiptAt
                        merchantResolutionAttempted =
                            consumerMerchandiseNotReceived.merchantResolutionAttempted
                        purchaseInfoAndExplanation =
                            consumerMerchandiseNotReceived.purchaseInfoAndExplanation
                        cardholderCancellationPriorToExpectedReceipt =
                            consumerMerchandiseNotReceived
                                .cardholderCancellationPriorToExpectedReceipt
                        delayed = consumerMerchandiseNotReceived.delayed
                        deliveredToWrongLocation =
                            consumerMerchandiseNotReceived.deliveredToWrongLocation
                        merchantCancellation = consumerMerchandiseNotReceived.merchantCancellation
                        noCancellation = consumerMerchandiseNotReceived.noCancellation
                        additionalProperties =
                            consumerMerchandiseNotReceived.additionalProperties.toMutableMap()
                    }

                    /** Cancellation outcome. */
                    fun cancellationOutcome(cancellationOutcome: CancellationOutcome) =
                        cancellationOutcome(JsonField.of(cancellationOutcome))

                    /**
                     * Sets [Builder.cancellationOutcome] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cancellationOutcome] with a well-typed
                     * [CancellationOutcome] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun cancellationOutcome(cancellationOutcome: JsonField<CancellationOutcome>) =
                        apply {
                            this.cancellationOutcome = cancellationOutcome
                        }

                    /** Delivery issue. */
                    fun deliveryIssue(deliveryIssue: DeliveryIssue) =
                        deliveryIssue(JsonField.of(deliveryIssue))

                    /**
                     * Sets [Builder.deliveryIssue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.deliveryIssue] with a well-typed
                     * [DeliveryIssue] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun deliveryIssue(deliveryIssue: JsonField<DeliveryIssue>) = apply {
                        this.deliveryIssue = deliveryIssue
                    }

                    /** Last expected receipt at. */
                    fun lastExpectedReceiptAt(lastExpectedReceiptAt: LocalDate) =
                        lastExpectedReceiptAt(JsonField.of(lastExpectedReceiptAt))

                    /**
                     * Sets [Builder.lastExpectedReceiptAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.lastExpectedReceiptAt] with a well-typed
                     * [LocalDate] value instead. This method is primarily for setting the field to
                     * an undocumented or not yet supported value.
                     */
                    fun lastExpectedReceiptAt(lastExpectedReceiptAt: JsonField<LocalDate>) = apply {
                        this.lastExpectedReceiptAt = lastExpectedReceiptAt
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Purchase information and explanation. */
                    fun purchaseInfoAndExplanation(purchaseInfoAndExplanation: String) =
                        purchaseInfoAndExplanation(JsonField.of(purchaseInfoAndExplanation))

                    /**
                     * Sets [Builder.purchaseInfoAndExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseInfoAndExplanation] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun purchaseInfoAndExplanation(purchaseInfoAndExplanation: JsonField<String>) =
                        apply {
                            this.purchaseInfoAndExplanation = purchaseInfoAndExplanation
                        }

                    /**
                     * Cardholder cancellation prior to expected receipt. Required if and only if
                     * `cancellation_outcome` is
                     * `cardholder_cancellation_prior_to_expected_receipt`.
                     */
                    fun cardholderCancellationPriorToExpectedReceipt(
                        cardholderCancellationPriorToExpectedReceipt:
                            CardholderCancellationPriorToExpectedReceipt
                    ) =
                        cardholderCancellationPriorToExpectedReceipt(
                            JsonField.of(cardholderCancellationPriorToExpectedReceipt)
                        )

                    /**
                     * Sets [Builder.cardholderCancellationPriorToExpectedReceipt] to an arbitrary
                     * JSON value.
                     *
                     * You should usually call
                     * [Builder.cardholderCancellationPriorToExpectedReceipt] with a well-typed
                     * [CardholderCancellationPriorToExpectedReceipt] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun cardholderCancellationPriorToExpectedReceipt(
                        cardholderCancellationPriorToExpectedReceipt:
                            JsonField<CardholderCancellationPriorToExpectedReceipt>
                    ) = apply {
                        this.cardholderCancellationPriorToExpectedReceipt =
                            cardholderCancellationPriorToExpectedReceipt
                    }

                    /** Delayed. Required if and only if `delivery_issue` is `delayed`. */
                    fun delayed(delayed: Delayed) = delayed(JsonField.of(delayed))

                    /**
                     * Sets [Builder.delayed] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.delayed] with a well-typed [Delayed] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun delayed(delayed: JsonField<Delayed>) = apply { this.delayed = delayed }

                    /**
                     * Delivered to wrong location. Required if and only if `delivery_issue` is
                     * `delivered_to_wrong_location`.
                     */
                    fun deliveredToWrongLocation(
                        deliveredToWrongLocation: DeliveredToWrongLocation
                    ) = deliveredToWrongLocation(JsonField.of(deliveredToWrongLocation))

                    /**
                     * Sets [Builder.deliveredToWrongLocation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.deliveredToWrongLocation] with a well-typed
                     * [DeliveredToWrongLocation] value instead. This method is primarily for
                     * setting the field to an undocumented or not yet supported value.
                     */
                    fun deliveredToWrongLocation(
                        deliveredToWrongLocation: JsonField<DeliveredToWrongLocation>
                    ) = apply { this.deliveredToWrongLocation = deliveredToWrongLocation }

                    /**
                     * Merchant cancellation. Required if and only if `cancellation_outcome` is
                     * `merchant_cancellation`.
                     */
                    fun merchantCancellation(merchantCancellation: MerchantCancellation) =
                        merchantCancellation(JsonField.of(merchantCancellation))

                    /**
                     * Sets [Builder.merchantCancellation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantCancellation] with a well-typed
                     * [MerchantCancellation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun merchantCancellation(
                        merchantCancellation: JsonField<MerchantCancellation>
                    ) = apply { this.merchantCancellation = merchantCancellation }

                    /**
                     * No cancellation. Required if and only if `cancellation_outcome` is
                     * `no_cancellation`.
                     */
                    fun noCancellation(noCancellation: JsonValue) = apply {
                        this.noCancellation = noCancellation
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerMerchandiseNotReceived].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cancellationOutcome()
                     * .deliveryIssue()
                     * .lastExpectedReceiptAt()
                     * .merchantResolutionAttempted()
                     * .purchaseInfoAndExplanation()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerMerchandiseNotReceived =
                        ConsumerMerchandiseNotReceived(
                            checkRequired("cancellationOutcome", cancellationOutcome),
                            checkRequired("deliveryIssue", deliveryIssue),
                            checkRequired("lastExpectedReceiptAt", lastExpectedReceiptAt),
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired("purchaseInfoAndExplanation", purchaseInfoAndExplanation),
                            cardholderCancellationPriorToExpectedReceipt,
                            delayed,
                            deliveredToWrongLocation,
                            merchantCancellation,
                            noCancellation,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerMerchandiseNotReceived = apply {
                    if (validated) {
                        return@apply
                    }

                    cancellationOutcome().validate()
                    deliveryIssue().validate()
                    lastExpectedReceiptAt()
                    merchantResolutionAttempted().validate()
                    purchaseInfoAndExplanation()
                    cardholderCancellationPriorToExpectedReceipt()?.validate()
                    delayed()?.validate()
                    deliveredToWrongLocation()?.validate()
                    merchantCancellation()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cancellationOutcome.asKnown()?.validity() ?: 0) +
                        (deliveryIssue.asKnown()?.validity() ?: 0) +
                        (if (lastExpectedReceiptAt.asKnown() == null) 0 else 1) +
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (purchaseInfoAndExplanation.asKnown() == null) 0 else 1) +
                        (cardholderCancellationPriorToExpectedReceipt.asKnown()?.validity() ?: 0) +
                        (delayed.asKnown()?.validity() ?: 0) +
                        (deliveredToWrongLocation.asKnown()?.validity() ?: 0) +
                        (merchantCancellation.asKnown()?.validity() ?: 0)

                /** Cancellation outcome. */
                class CancellationOutcome
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Cardholder cancellation prior to expected receipt. */
                        val CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT =
                            of("cardholder_cancellation_prior_to_expected_receipt")

                        /** Merchant cancellation. */
                        val MERCHANT_CANCELLATION = of("merchant_cancellation")

                        /** No cancellation. */
                        val NO_CANCELLATION = of("no_cancellation")

                        fun of(value: String) = CancellationOutcome(JsonField.of(value))
                    }

                    /** An enum containing [CancellationOutcome]'s known values. */
                    enum class Known {
                        /** Cardholder cancellation prior to expected receipt. */
                        CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                        /** Merchant cancellation. */
                        MERCHANT_CANCELLATION,
                        /** No cancellation. */
                        NO_CANCELLATION,
                    }

                    /**
                     * An enum containing [CancellationOutcome]'s known values, as well as an
                     * [_UNKNOWN] member.
                     *
                     * An instance of [CancellationOutcome] can contain an unknown value in a couple
                     * of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Cardholder cancellation prior to expected receipt. */
                        CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                        /** Merchant cancellation. */
                        MERCHANT_CANCELLATION,
                        /** No cancellation. */
                        NO_CANCELLATION,
                        /**
                         * An enum member indicating that [CancellationOutcome] was instantiated
                         * with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                Value.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                            MERCHANT_CANCELLATION -> Value.MERCHANT_CANCELLATION
                            NO_CANCELLATION -> Value.NO_CANCELLATION
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                Known.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                            MERCHANT_CANCELLATION -> Known.MERCHANT_CANCELLATION
                            NO_CANCELLATION -> Known.NO_CANCELLATION
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown CancellationOutcome: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): CancellationOutcome = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CancellationOutcome && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Delivery issue. */
                class DeliveryIssue
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Delayed. */
                        val DELAYED = of("delayed")

                        /** Delivered to wrong location. */
                        val DELIVERED_TO_WRONG_LOCATION = of("delivered_to_wrong_location")

                        fun of(value: String) = DeliveryIssue(JsonField.of(value))
                    }

                    /** An enum containing [DeliveryIssue]'s known values. */
                    enum class Known {
                        /** Delayed. */
                        DELAYED,
                        /** Delivered to wrong location. */
                        DELIVERED_TO_WRONG_LOCATION,
                    }

                    /**
                     * An enum containing [DeliveryIssue]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [DeliveryIssue] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Delayed. */
                        DELAYED,
                        /** Delivered to wrong location. */
                        DELIVERED_TO_WRONG_LOCATION,
                        /**
                         * An enum member indicating that [DeliveryIssue] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            DELAYED -> Value.DELAYED
                            DELIVERED_TO_WRONG_LOCATION -> Value.DELIVERED_TO_WRONG_LOCATION
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            DELAYED -> Known.DELAYED
                            DELIVERED_TO_WRONG_LOCATION -> Known.DELIVERED_TO_WRONG_LOCATION
                            else ->
                                throw IncreaseInvalidDataException("Unknown DeliveryIssue: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): DeliveryIssue = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DeliveryIssue && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Cardholder cancellation prior to expected receipt. Required if and only if
                 * `cancellation_outcome` is `cardholder_cancellation_prior_to_expected_receipt`.
                 */
                class CardholderCancellationPriorToExpectedReceipt
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val canceledAt: JsonField<LocalDate>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(canceledAt, reason, mutableMapOf())

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun reason(): String? = reason.getNullable("reason")

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderCancellationPriorToExpectedReceipt].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderCancellationPriorToExpectedReceipt]. */
                    class Builder internal constructor() {

                        private var canceledAt: JsonField<LocalDate>? = null
                        private var reason: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            cardholderCancellationPriorToExpectedReceipt:
                                CardholderCancellationPriorToExpectedReceipt
                        ) = apply {
                            canceledAt = cardholderCancellationPriorToExpectedReceipt.canceledAt
                            reason = cardholderCancellationPriorToExpectedReceipt.reason
                            additionalProperties =
                                cardholderCancellationPriorToExpectedReceipt.additionalProperties
                                    .toMutableMap()
                        }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        /** Reason. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of
                         * [CardholderCancellationPriorToExpectedReceipt].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderCancellationPriorToExpectedReceipt =
                            CardholderCancellationPriorToExpectedReceipt(
                                checkRequired("canceledAt", canceledAt),
                                reason,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderCancellationPriorToExpectedReceipt = apply {
                        if (validated) {
                            return@apply
                        }

                        canceledAt()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (canceledAt.asKnown() == null) 0 else 1) +
                            (if (reason.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderCancellationPriorToExpectedReceipt &&
                            canceledAt == other.canceledAt &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(canceledAt, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderCancellationPriorToExpectedReceipt{canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /** Delayed. Required if and only if `delivery_issue` is `delayed`. */
                class Delayed
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val returnOutcome: JsonField<ReturnOutcome>,
                    private val notReturned: JsonValue,
                    private val returnAttempted: JsonField<ReturnAttempted>,
                    private val returned: JsonField<Returned>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("return_outcome")
                        @ExcludeMissing
                        returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                        @JsonProperty("not_returned")
                        @ExcludeMissing
                        notReturned: JsonValue = JsonMissing.of(),
                        @JsonProperty("return_attempted")
                        @ExcludeMissing
                        returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                        @JsonProperty("returned")
                        @ExcludeMissing
                        returned: JsonField<Returned> = JsonMissing.of(),
                    ) : this(
                        explanation,
                        returnOutcome,
                        notReturned,
                        returnAttempted,
                        returned,
                        mutableMapOf(),
                    )

                    /**
                     * Explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun explanation(): String = explanation.getRequired("explanation")

                    /**
                     * Return outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                    /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    fun _notReturned(): JsonValue = notReturned

                    /**
                     * Return attempted. Required if and only if `return_outcome` is
                     * `return_attempted`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returnAttempted(): ReturnAttempted? =
                        returnAttempted.getNullable("return_attempted")

                    /**
                     * Returned. Required if and only if `return_outcome` is `returned`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returned(): Returned? = returned.getNullable("returned")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [returnOutcome].
                     *
                     * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                    /**
                     * Returns the raw JSON value of [returnAttempted].
                     *
                     * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                    /**
                     * Returns the raw JSON value of [returned].
                     *
                     * Unlike [returned], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned")
                    @ExcludeMissing
                    fun _returned(): JsonField<Returned> = returned

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Delayed].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .returnOutcome()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Delayed]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var returnOutcome: JsonField<ReturnOutcome>? = null
                        private var notReturned: JsonValue = JsonMissing.of()
                        private var returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of()
                        private var returned: JsonField<Returned> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(delayed: Delayed) = apply {
                            explanation = delayed.explanation
                            returnOutcome = delayed.returnOutcome
                            notReturned = delayed.notReturned
                            returnAttempted = delayed.returnAttempted
                            returned = delayed.returned
                            additionalProperties = delayed.additionalProperties.toMutableMap()
                        }

                        /** Explanation. */
                        fun explanation(explanation: String) =
                            explanation(JsonField.of(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** Return outcome. */
                        fun returnOutcome(returnOutcome: ReturnOutcome) =
                            returnOutcome(JsonField.of(returnOutcome))

                        /**
                         * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnOutcome] with a well-typed
                         * [ReturnOutcome] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                            this.returnOutcome = returnOutcome
                        }

                        /**
                         * Not returned. Required if and only if `return_outcome` is `not_returned`.
                         */
                        fun notReturned(notReturned: JsonValue) = apply {
                            this.notReturned = notReturned
                        }

                        /**
                         * Return attempted. Required if and only if `return_outcome` is
                         * `return_attempted`.
                         */
                        fun returnAttempted(returnAttempted: ReturnAttempted) =
                            returnAttempted(JsonField.of(returnAttempted))

                        /**
                         * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnAttempted] with a well-typed
                         * [ReturnAttempted] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                            this.returnAttempted = returnAttempted
                        }

                        /** Returned. Required if and only if `return_outcome` is `returned`. */
                        fun returned(returned: Returned) = returned(JsonField.of(returned))

                        /**
                         * Sets [Builder.returned] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returned] with a well-typed [Returned]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun returned(returned: JsonField<Returned>) = apply {
                            this.returned = returned
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Delayed].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .returnOutcome()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Delayed =
                            Delayed(
                                checkRequired("explanation", explanation),
                                checkRequired("returnOutcome", returnOutcome),
                                notReturned,
                                returnAttempted,
                                returned,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Delayed = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        returnOutcome().validate()
                        returnAttempted()?.validate()
                        returned()?.validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (explanation.asKnown() == null) 0 else 1) +
                            (returnOutcome.asKnown()?.validity() ?: 0) +
                            (returnAttempted.asKnown()?.validity() ?: 0) +
                            (returned.asKnown()?.validity() ?: 0)

                    /** Return outcome. */
                    class ReturnOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not returned. */
                            val NOT_RETURNED = of("not_returned")

                            /** Returned. */
                            val RETURNED = of("returned")

                            /** Return attempted. */
                            val RETURN_ATTEMPTED = of("return_attempted")

                            fun of(value: String) = ReturnOutcome(JsonField.of(value))
                        }

                        /** An enum containing [ReturnOutcome]'s known values. */
                        enum class Known {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                        }

                        /**
                         * An enum containing [ReturnOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnOutcome] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                            /**
                             * An enum member indicating that [ReturnOutcome] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_RETURNED -> Value.NOT_RETURNED
                                RETURNED -> Value.RETURNED
                                RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_RETURNED -> Known.NOT_RETURNED
                                RETURNED -> Known.RETURNED
                                RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Return attempted. Required if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    class ReturnAttempted
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val attemptedAt: JsonField<LocalDate>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("attempted_at")
                            @ExcludeMissing
                            attemptedAt: JsonField<LocalDate> = JsonMissing.of()
                        ) : this(attemptedAt, mutableMapOf())

                        /**
                         * Attempted at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                        /**
                         * Returns the raw JSON value of [attemptedAt].
                         *
                         * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [ReturnAttempted].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptedAt()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [ReturnAttempted]. */
                        class Builder internal constructor() {

                            private var attemptedAt: JsonField<LocalDate>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returnAttempted: ReturnAttempted) = apply {
                                attemptedAt = returnAttempted.attemptedAt
                                additionalProperties =
                                    returnAttempted.additionalProperties.toMutableMap()
                            }

                            /** Attempted at. */
                            fun attemptedAt(attemptedAt: LocalDate) =
                                attemptedAt(JsonField.of(attemptedAt))

                            /**
                             * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                                this.attemptedAt = attemptedAt
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [ReturnAttempted].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptedAt()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): ReturnAttempted =
                                ReturnAttempted(
                                    checkRequired("attemptedAt", attemptedAt),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): ReturnAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            attemptedAt()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = (if (attemptedAt.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnAttempted &&
                                attemptedAt == other.attemptedAt &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(attemptedAt, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "ReturnAttempted{attemptedAt=$attemptedAt, additionalProperties=$additionalProperties}"
                    }

                    /** Returned. Required if and only if `return_outcome` is `returned`. */
                    class Returned
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val merchantReceivedReturnAt: JsonField<LocalDate>,
                        private val returnedAt: JsonField<LocalDate>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("merchant_received_return_at")
                            @ExcludeMissing
                            merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("returned_at")
                            @ExcludeMissing
                            returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                        ) : this(merchantReceivedReturnAt, returnedAt, mutableMapOf())

                        /**
                         * Merchant received return at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun merchantReceivedReturnAt(): LocalDate =
                            merchantReceivedReturnAt.getRequired("merchant_received_return_at")

                        /**
                         * Returned at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                        /**
                         * Returns the raw JSON value of [merchantReceivedReturnAt].
                         *
                         * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        fun _merchantReceivedReturnAt(): JsonField<LocalDate> =
                            merchantReceivedReturnAt

                        /**
                         * Returns the raw JSON value of [returnedAt].
                         *
                         * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        fun _returnedAt(): JsonField<LocalDate> = returnedAt

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Returned].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .returnedAt()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Returned]. */
                        class Builder internal constructor() {

                            private var merchantReceivedReturnAt: JsonField<LocalDate>? = null
                            private var returnedAt: JsonField<LocalDate>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returned: Returned) = apply {
                                merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                                returnedAt = returned.returnedAt
                                additionalProperties = returned.additionalProperties.toMutableMap()
                            }

                            /** Merchant received return at. */
                            fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate) =
                                merchantReceivedReturnAt(JsonField.of(merchantReceivedReturnAt))

                            /**
                             * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchantReceivedReturnAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchantReceivedReturnAt(
                                merchantReceivedReturnAt: JsonField<LocalDate>
                            ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                            /** Returned at. */
                            fun returnedAt(returnedAt: LocalDate) =
                                returnedAt(JsonField.of(returnedAt))

                            /**
                             * Sets [Builder.returnedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                                this.returnedAt = returnedAt
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Returned].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .returnedAt()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Returned =
                                Returned(
                                    checkRequired(
                                        "merchantReceivedReturnAt",
                                        merchantReceivedReturnAt,
                                    ),
                                    checkRequired("returnedAt", returnedAt),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Returned = apply {
                            if (validated) {
                                return@apply
                            }

                            merchantReceivedReturnAt()
                            returnedAt()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                                (if (returnedAt.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Returned &&
                                merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                                returnedAt == other.returnedAt &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(merchantReceivedReturnAt, returnedAt, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Returned{merchantReceivedReturnAt=$merchantReceivedReturnAt, returnedAt=$returnedAt, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Delayed &&
                            explanation == other.explanation &&
                            returnOutcome == other.returnOutcome &&
                            notReturned == other.notReturned &&
                            returnAttempted == other.returnAttempted &&
                            returned == other.returned &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            explanation,
                            returnOutcome,
                            notReturned,
                            returnAttempted,
                            returned,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Delayed{explanation=$explanation, returnOutcome=$returnOutcome, notReturned=$notReturned, returnAttempted=$returnAttempted, returned=$returned, additionalProperties=$additionalProperties}"
                }

                /**
                 * Delivered to wrong location. Required if and only if `delivery_issue` is
                 * `delivered_to_wrong_location`.
                 */
                class DeliveredToWrongLocation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val agreedLocation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("agreed_location")
                        @ExcludeMissing
                        agreedLocation: JsonField<String> = JsonMissing.of()
                    ) : this(agreedLocation, mutableMapOf())

                    /**
                     * Agreed location.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun agreedLocation(): String = agreedLocation.getRequired("agreed_location")

                    /**
                     * Returns the raw JSON value of [agreedLocation].
                     *
                     * Unlike [agreedLocation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("agreed_location")
                    @ExcludeMissing
                    fun _agreedLocation(): JsonField<String> = agreedLocation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [DeliveredToWrongLocation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .agreedLocation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [DeliveredToWrongLocation]. */
                    class Builder internal constructor() {

                        private var agreedLocation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(deliveredToWrongLocation: DeliveredToWrongLocation) =
                            apply {
                                agreedLocation = deliveredToWrongLocation.agreedLocation
                                additionalProperties =
                                    deliveredToWrongLocation.additionalProperties.toMutableMap()
                            }

                        /** Agreed location. */
                        fun agreedLocation(agreedLocation: String) =
                            agreedLocation(JsonField.of(agreedLocation))

                        /**
                         * Sets [Builder.agreedLocation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.agreedLocation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun agreedLocation(agreedLocation: JsonField<String>) = apply {
                            this.agreedLocation = agreedLocation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [DeliveredToWrongLocation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .agreedLocation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): DeliveredToWrongLocation =
                            DeliveredToWrongLocation(
                                checkRequired("agreedLocation", agreedLocation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): DeliveredToWrongLocation = apply {
                        if (validated) {
                            return@apply
                        }

                        agreedLocation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (agreedLocation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DeliveredToWrongLocation &&
                            agreedLocation == other.agreedLocation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(agreedLocation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "DeliveredToWrongLocation{agreedLocation=$agreedLocation, additionalProperties=$additionalProperties}"
                }

                /**
                 * Merchant cancellation. Required if and only if `cancellation_outcome` is
                 * `merchant_cancellation`.
                 */
                class MerchantCancellation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val canceledAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of()
                    ) : this(canceledAt, mutableMapOf())

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [MerchantCancellation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [MerchantCancellation]. */
                    class Builder internal constructor() {

                        private var canceledAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(merchantCancellation: MerchantCancellation) = apply {
                            canceledAt = merchantCancellation.canceledAt
                            additionalProperties =
                                merchantCancellation.additionalProperties.toMutableMap()
                        }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [MerchantCancellation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): MerchantCancellation =
                            MerchantCancellation(
                                checkRequired("canceledAt", canceledAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): MerchantCancellation = apply {
                        if (validated) {
                            return@apply
                        }

                        canceledAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (canceledAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantCancellation &&
                            canceledAt == other.canceledAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(canceledAt, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "MerchantCancellation{canceledAt=$canceledAt, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerMerchandiseNotReceived &&
                        cancellationOutcome == other.cancellationOutcome &&
                        deliveryIssue == other.deliveryIssue &&
                        lastExpectedReceiptAt == other.lastExpectedReceiptAt &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        purchaseInfoAndExplanation == other.purchaseInfoAndExplanation &&
                        cardholderCancellationPriorToExpectedReceipt ==
                            other.cardholderCancellationPriorToExpectedReceipt &&
                        delayed == other.delayed &&
                        deliveredToWrongLocation == other.deliveredToWrongLocation &&
                        merchantCancellation == other.merchantCancellation &&
                        noCancellation == other.noCancellation &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cancellationOutcome,
                        deliveryIssue,
                        lastExpectedReceiptAt,
                        merchantResolutionAttempted,
                        purchaseInfoAndExplanation,
                        cardholderCancellationPriorToExpectedReceipt,
                        delayed,
                        deliveredToWrongLocation,
                        merchantCancellation,
                        noCancellation,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerMerchandiseNotReceived{cancellationOutcome=$cancellationOutcome, deliveryIssue=$deliveryIssue, lastExpectedReceiptAt=$lastExpectedReceiptAt, merchantResolutionAttempted=$merchantResolutionAttempted, purchaseInfoAndExplanation=$purchaseInfoAndExplanation, cardholderCancellationPriorToExpectedReceipt=$cardholderCancellationPriorToExpectedReceipt, delayed=$delayed, deliveredToWrongLocation=$deliveredToWrongLocation, merchantCancellation=$merchantCancellation, noCancellation=$noCancellation, additionalProperties=$additionalProperties}"
            }

            /**
             * Original Credit Transaction (OCT) not accepted. Required if and only if `category` is
             * `consumer_original_credit_transaction_not_accepted`.
             */
            class ConsumerOriginalCreditTransactionNotAccepted
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val explanation: JsonField<String>,
                private val reason: JsonField<Reason>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    explanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("reason")
                    @ExcludeMissing
                    reason: JsonField<Reason> = JsonMissing.of(),
                ) : this(explanation, reason, mutableMapOf())

                /**
                 * Explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun explanation(): String = explanation.getRequired("explanation")

                /**
                 * Reason.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun reason(): Reason = reason.getRequired("reason")

                /**
                 * Returns the raw JSON value of [explanation].
                 *
                 * Unlike [explanation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("explanation")
                @ExcludeMissing
                fun _explanation(): JsonField<String> = explanation

                /**
                 * Returns the raw JSON value of [reason].
                 *
                 * Unlike [reason], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<Reason> = reason

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerOriginalCreditTransactionNotAccepted].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .explanation()
                     * .reason()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerOriginalCreditTransactionNotAccepted]. */
                class Builder internal constructor() {

                    private var explanation: JsonField<String>? = null
                    private var reason: JsonField<Reason>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerOriginalCreditTransactionNotAccepted:
                            ConsumerOriginalCreditTransactionNotAccepted
                    ) = apply {
                        explanation = consumerOriginalCreditTransactionNotAccepted.explanation
                        reason = consumerOriginalCreditTransactionNotAccepted.reason
                        additionalProperties =
                            consumerOriginalCreditTransactionNotAccepted.additionalProperties
                                .toMutableMap()
                    }

                    /** Explanation. */
                    fun explanation(explanation: String) = explanation(JsonField.of(explanation))

                    /**
                     * Sets [Builder.explanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.explanation] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun explanation(explanation: JsonField<String>) = apply {
                        this.explanation = explanation
                    }

                    /** Reason. */
                    fun reason(reason: Reason) = reason(JsonField.of(reason))

                    /**
                     * Sets [Builder.reason] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.reason] with a well-typed [Reason] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of
                     * [ConsumerOriginalCreditTransactionNotAccepted].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .explanation()
                     * .reason()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerOriginalCreditTransactionNotAccepted =
                        ConsumerOriginalCreditTransactionNotAccepted(
                            checkRequired("explanation", explanation),
                            checkRequired("reason", reason),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerOriginalCreditTransactionNotAccepted = apply {
                    if (validated) {
                        return@apply
                    }

                    explanation()
                    reason().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (explanation.asKnown() == null) 0 else 1) +
                        (reason.asKnown()?.validity() ?: 0)

                /** Reason. */
                class Reason
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Prohibited by local laws or regulation. */
                        val PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION =
                            of("prohibited_by_local_laws_or_regulation")

                        /** Recipient refused. */
                        val RECIPIENT_REFUSED = of("recipient_refused")

                        fun of(value: String) = Reason(JsonField.of(value))
                    }

                    /** An enum containing [Reason]'s known values. */
                    enum class Known {
                        /** Prohibited by local laws or regulation. */
                        PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION,
                        /** Recipient refused. */
                        RECIPIENT_REFUSED,
                    }

                    /**
                     * An enum containing [Reason]'s known values, as well as an [_UNKNOWN] member.
                     *
                     * An instance of [Reason] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Prohibited by local laws or regulation. */
                        PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION,
                        /** Recipient refused. */
                        RECIPIENT_REFUSED,
                        /**
                         * An enum member indicating that [Reason] was instantiated with an unknown
                         * value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION ->
                                Value.PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION
                            RECIPIENT_REFUSED -> Value.RECIPIENT_REFUSED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION ->
                                Known.PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION
                            RECIPIENT_REFUSED -> Known.RECIPIENT_REFUSED
                            else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Reason = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Reason && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerOriginalCreditTransactionNotAccepted &&
                        explanation == other.explanation &&
                        reason == other.reason &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(explanation, reason, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerOriginalCreditTransactionNotAccepted{explanation=$explanation, reason=$reason, additionalProperties=$additionalProperties}"
            }

            /**
             * Merchandise quality issue. Required if and only if `category` is
             * `consumer_quality_merchandise`.
             */
            class ConsumerQualityMerchandise
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val expectedAt: JsonField<LocalDate>,
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val purchaseInfoAndQualityIssue: JsonField<String>,
                private val receivedAt: JsonField<LocalDate>,
                private val returnOutcome: JsonField<ReturnOutcome>,
                private val notReturned: JsonValue,
                private val ongoingNegotiations: JsonField<OngoingNegotiations>,
                private val returnAttempted: JsonField<ReturnAttempted>,
                private val returned: JsonField<Returned>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("expected_at")
                    @ExcludeMissing
                    expectedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("purchase_info_and_quality_issue")
                    @ExcludeMissing
                    purchaseInfoAndQualityIssue: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    notReturned: JsonValue = JsonMissing.of(),
                    @JsonProperty("ongoing_negotiations")
                    @ExcludeMissing
                    ongoingNegotiations: JsonField<OngoingNegotiations> = JsonMissing.of(),
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                    @JsonProperty("returned")
                    @ExcludeMissing
                    returned: JsonField<Returned> = JsonMissing.of(),
                ) : this(
                    expectedAt,
                    merchantResolutionAttempted,
                    purchaseInfoAndQualityIssue,
                    receivedAt,
                    returnOutcome,
                    notReturned,
                    ongoingNegotiations,
                    returnAttempted,
                    returned,
                    mutableMapOf(),
                )

                /**
                 * Expected at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun expectedAt(): LocalDate = expectedAt.getRequired("expected_at")

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Purchase information and quality issue.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseInfoAndQualityIssue(): String =
                    purchaseInfoAndQualityIssue.getRequired("purchase_info_and_quality_issue")

                /**
                 * Received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                /**
                 * Return outcome.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                @JsonProperty("not_returned")
                @ExcludeMissing
                fun _notReturned(): JsonValue = notReturned

                /**
                 * Ongoing negotiations. Exclude if there is no evidence of ongoing negotiations.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun ongoingNegotiations(): OngoingNegotiations? =
                    ongoingNegotiations.getNullable("ongoing_negotiations")

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returnAttempted(): ReturnAttempted? =
                    returnAttempted.getNullable("return_attempted")

                /**
                 * Returned. Required if and only if `return_outcome` is `returned`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun returned(): Returned? = returned.getNullable("returned")

                /**
                 * Returns the raw JSON value of [expectedAt].
                 *
                 * Unlike [expectedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("expected_at")
                @ExcludeMissing
                fun _expectedAt(): JsonField<LocalDate> = expectedAt

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [purchaseInfoAndQualityIssue].
                 *
                 * Unlike [purchaseInfoAndQualityIssue], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("purchase_info_and_quality_issue")
                @ExcludeMissing
                fun _purchaseInfoAndQualityIssue(): JsonField<String> = purchaseInfoAndQualityIssue

                /**
                 * Returns the raw JSON value of [receivedAt].
                 *
                 * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_at")
                @ExcludeMissing
                fun _receivedAt(): JsonField<LocalDate> = receivedAt

                /**
                 * Returns the raw JSON value of [returnOutcome].
                 *
                 * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_outcome")
                @ExcludeMissing
                fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                /**
                 * Returns the raw JSON value of [ongoingNegotiations].
                 *
                 * Unlike [ongoingNegotiations], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("ongoing_negotiations")
                @ExcludeMissing
                fun _ongoingNegotiations(): JsonField<OngoingNegotiations> = ongoingNegotiations

                /**
                 * Returns the raw JSON value of [returnAttempted].
                 *
                 * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("return_attempted")
                @ExcludeMissing
                fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                /**
                 * Returns the raw JSON value of [returned].
                 *
                 * Unlike [returned], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("returned")
                @ExcludeMissing
                fun _returned(): JsonField<Returned> = returned

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerQualityMerchandise].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .expectedAt()
                     * .merchantResolutionAttempted()
                     * .purchaseInfoAndQualityIssue()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerQualityMerchandise]. */
                class Builder internal constructor() {

                    private var expectedAt: JsonField<LocalDate>? = null
                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var purchaseInfoAndQualityIssue: JsonField<String>? = null
                    private var receivedAt: JsonField<LocalDate>? = null
                    private var returnOutcome: JsonField<ReturnOutcome>? = null
                    private var notReturned: JsonValue = JsonMissing.of()
                    private var ongoingNegotiations: JsonField<OngoingNegotiations> =
                        JsonMissing.of()
                    private var returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of()
                    private var returned: JsonField<Returned> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(consumerQualityMerchandise: ConsumerQualityMerchandise) =
                        apply {
                            expectedAt = consumerQualityMerchandise.expectedAt
                            merchantResolutionAttempted =
                                consumerQualityMerchandise.merchantResolutionAttempted
                            purchaseInfoAndQualityIssue =
                                consumerQualityMerchandise.purchaseInfoAndQualityIssue
                            receivedAt = consumerQualityMerchandise.receivedAt
                            returnOutcome = consumerQualityMerchandise.returnOutcome
                            notReturned = consumerQualityMerchandise.notReturned
                            ongoingNegotiations = consumerQualityMerchandise.ongoingNegotiations
                            returnAttempted = consumerQualityMerchandise.returnAttempted
                            returned = consumerQualityMerchandise.returned
                            additionalProperties =
                                consumerQualityMerchandise.additionalProperties.toMutableMap()
                        }

                    /** Expected at. */
                    fun expectedAt(expectedAt: LocalDate) = expectedAt(JsonField.of(expectedAt))

                    /**
                     * Sets [Builder.expectedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.expectedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun expectedAt(expectedAt: JsonField<LocalDate>) = apply {
                        this.expectedAt = expectedAt
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Purchase information and quality issue. */
                    fun purchaseInfoAndQualityIssue(purchaseInfoAndQualityIssue: String) =
                        purchaseInfoAndQualityIssue(JsonField.of(purchaseInfoAndQualityIssue))

                    /**
                     * Sets [Builder.purchaseInfoAndQualityIssue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseInfoAndQualityIssue] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun purchaseInfoAndQualityIssue(
                        purchaseInfoAndQualityIssue: JsonField<String>
                    ) = apply { this.purchaseInfoAndQualityIssue = purchaseInfoAndQualityIssue }

                    /** Received at. */
                    fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                    /**
                     * Sets [Builder.receivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                        this.receivedAt = receivedAt
                    }

                    /** Return outcome. */
                    fun returnOutcome(returnOutcome: ReturnOutcome) =
                        returnOutcome(JsonField.of(returnOutcome))

                    /**
                     * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnOutcome] with a well-typed
                     * [ReturnOutcome] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                        this.returnOutcome = returnOutcome
                    }

                    /** Not returned. Required if and only if `return_outcome` is `not_returned`. */
                    fun notReturned(notReturned: JsonValue) = apply {
                        this.notReturned = notReturned
                    }

                    /**
                     * Ongoing negotiations. Exclude if there is no evidence of ongoing
                     * negotiations.
                     */
                    fun ongoingNegotiations(ongoingNegotiations: OngoingNegotiations) =
                        ongoingNegotiations(JsonField.of(ongoingNegotiations))

                    /**
                     * Sets [Builder.ongoingNegotiations] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.ongoingNegotiations] with a well-typed
                     * [OngoingNegotiations] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun ongoingNegotiations(ongoingNegotiations: JsonField<OngoingNegotiations>) =
                        apply {
                            this.ongoingNegotiations = ongoingNegotiations
                        }

                    /**
                     * Return attempted. Required if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    fun returnAttempted(returnAttempted: ReturnAttempted) =
                        returnAttempted(JsonField.of(returnAttempted))

                    /**
                     * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returnAttempted] with a well-typed
                     * [ReturnAttempted] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                        this.returnAttempted = returnAttempted
                    }

                    /** Returned. Required if and only if `return_outcome` is `returned`. */
                    fun returned(returned: Returned) = returned(JsonField.of(returned))

                    /**
                     * Sets [Builder.returned] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.returned] with a well-typed [Returned] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun returned(returned: JsonField<Returned>) = apply { this.returned = returned }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerQualityMerchandise].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .expectedAt()
                     * .merchantResolutionAttempted()
                     * .purchaseInfoAndQualityIssue()
                     * .receivedAt()
                     * .returnOutcome()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerQualityMerchandise =
                        ConsumerQualityMerchandise(
                            checkRequired("expectedAt", expectedAt),
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired(
                                "purchaseInfoAndQualityIssue",
                                purchaseInfoAndQualityIssue,
                            ),
                            checkRequired("receivedAt", receivedAt),
                            checkRequired("returnOutcome", returnOutcome),
                            notReturned,
                            ongoingNegotiations,
                            returnAttempted,
                            returned,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerQualityMerchandise = apply {
                    if (validated) {
                        return@apply
                    }

                    expectedAt()
                    merchantResolutionAttempted().validate()
                    purchaseInfoAndQualityIssue()
                    receivedAt()
                    returnOutcome().validate()
                    ongoingNegotiations()?.validate()
                    returnAttempted()?.validate()
                    returned()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (expectedAt.asKnown() == null) 0 else 1) +
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (purchaseInfoAndQualityIssue.asKnown() == null) 0 else 1) +
                        (if (receivedAt.asKnown() == null) 0 else 1) +
                        (returnOutcome.asKnown()?.validity() ?: 0) +
                        (ongoingNegotiations.asKnown()?.validity() ?: 0) +
                        (returnAttempted.asKnown()?.validity() ?: 0) +
                        (returned.asKnown()?.validity() ?: 0)

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Return outcome. */
                class ReturnOutcome
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Not returned. */
                        val NOT_RETURNED = of("not_returned")

                        /** Returned. */
                        val RETURNED = of("returned")

                        /** Return attempted. */
                        val RETURN_ATTEMPTED = of("return_attempted")

                        fun of(value: String) = ReturnOutcome(JsonField.of(value))
                    }

                    /** An enum containing [ReturnOutcome]'s known values. */
                    enum class Known {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                    }

                    /**
                     * An enum containing [ReturnOutcome]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [ReturnOutcome] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Not returned. */
                        NOT_RETURNED,
                        /** Returned. */
                        RETURNED,
                        /** Return attempted. */
                        RETURN_ATTEMPTED,
                        /**
                         * An enum member indicating that [ReturnOutcome] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            NOT_RETURNED -> Value.NOT_RETURNED
                            RETURNED -> Value.RETURNED
                            RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            NOT_RETURNED -> Known.NOT_RETURNED
                            RETURNED -> Known.RETURNED
                            RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                            else ->
                                throw IncreaseInvalidDataException("Unknown ReturnOutcome: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): ReturnOutcome = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnOutcome && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Ongoing negotiations. Exclude if there is no evidence of ongoing negotiations.
                 */
                class OngoingNegotiations
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val issuerFirstNotifiedAt: JsonField<LocalDate>,
                    private val startedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("issuer_first_notified_at")
                        @ExcludeMissing
                        issuerFirstNotifiedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("started_at")
                        @ExcludeMissing
                        startedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(explanation, issuerFirstNotifiedAt, startedAt, mutableMapOf())

                    /**
                     * Explanation of the previous ongoing negotiations between the cardholder and
                     * merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun explanation(): String = explanation.getRequired("explanation")

                    /**
                     * Date the cardholder first notified the issuer of the dispute.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun issuerFirstNotifiedAt(): LocalDate =
                        issuerFirstNotifiedAt.getRequired("issuer_first_notified_at")

                    /**
                     * Started at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun startedAt(): LocalDate = startedAt.getRequired("started_at")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [issuerFirstNotifiedAt].
                     *
                     * Unlike [issuerFirstNotifiedAt], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("issuer_first_notified_at")
                    @ExcludeMissing
                    fun _issuerFirstNotifiedAt(): JsonField<LocalDate> = issuerFirstNotifiedAt

                    /**
                     * Returns the raw JSON value of [startedAt].
                     *
                     * Unlike [startedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("started_at")
                    @ExcludeMissing
                    fun _startedAt(): JsonField<LocalDate> = startedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [OngoingNegotiations].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .issuerFirstNotifiedAt()
                         * .startedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [OngoingNegotiations]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var issuerFirstNotifiedAt: JsonField<LocalDate>? = null
                        private var startedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(ongoingNegotiations: OngoingNegotiations) = apply {
                            explanation = ongoingNegotiations.explanation
                            issuerFirstNotifiedAt = ongoingNegotiations.issuerFirstNotifiedAt
                            startedAt = ongoingNegotiations.startedAt
                            additionalProperties =
                                ongoingNegotiations.additionalProperties.toMutableMap()
                        }

                        /**
                         * Explanation of the previous ongoing negotiations between the cardholder
                         * and merchant.
                         */
                        fun explanation(explanation: String) =
                            explanation(JsonField.of(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** Date the cardholder first notified the issuer of the dispute. */
                        fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: LocalDate) =
                            issuerFirstNotifiedAt(JsonField.of(issuerFirstNotifiedAt))

                        /**
                         * Sets [Builder.issuerFirstNotifiedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.issuerFirstNotifiedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: JsonField<LocalDate>) =
                            apply {
                                this.issuerFirstNotifiedAt = issuerFirstNotifiedAt
                            }

                        /** Started at. */
                        fun startedAt(startedAt: LocalDate) = startedAt(JsonField.of(startedAt))

                        /**
                         * Sets [Builder.startedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.startedAt] with a well-typed [LocalDate]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun startedAt(startedAt: JsonField<LocalDate>) = apply {
                            this.startedAt = startedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [OngoingNegotiations].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .issuerFirstNotifiedAt()
                         * .startedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): OngoingNegotiations =
                            OngoingNegotiations(
                                checkRequired("explanation", explanation),
                                checkRequired("issuerFirstNotifiedAt", issuerFirstNotifiedAt),
                                checkRequired("startedAt", startedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): OngoingNegotiations = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        issuerFirstNotifiedAt()
                        startedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (explanation.asKnown() == null) 0 else 1) +
                            (if (issuerFirstNotifiedAt.asKnown() == null) 0 else 1) +
                            (if (startedAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is OngoingNegotiations &&
                            explanation == other.explanation &&
                            issuerFirstNotifiedAt == other.issuerFirstNotifiedAt &&
                            startedAt == other.startedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            explanation,
                            issuerFirstNotifiedAt,
                            startedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "OngoingNegotiations{explanation=$explanation, issuerFirstNotifiedAt=$issuerFirstNotifiedAt, startedAt=$startedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Return attempted. Required if and only if `return_outcome` is `return_attempted`.
                 */
                class ReturnAttempted
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val attemptExplanation: JsonField<String>,
                    private val attemptReason: JsonField<AttemptReason>,
                    private val attemptedAt: JsonField<LocalDate>,
                    private val merchandiseDisposition: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        attemptExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        attemptExplanation,
                        attemptReason,
                        attemptedAt,
                        merchandiseDisposition,
                        mutableMapOf(),
                    )

                    /**
                     * Attempt explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptExplanation(): String =
                        attemptExplanation.getRequired("attempt_explanation")

                    /**
                     * Attempt reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptReason(): AttemptReason = attemptReason.getRequired("attempt_reason")

                    /**
                     * Attempted at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                    /**
                     * Merchandise disposition.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchandiseDisposition(): String =
                        merchandiseDisposition.getRequired("merchandise_disposition")

                    /**
                     * Returns the raw JSON value of [attemptExplanation].
                     *
                     * Unlike [attemptExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("attempt_explanation")
                    @ExcludeMissing
                    fun _attemptExplanation(): JsonField<String> = attemptExplanation

                    /**
                     * Returns the raw JSON value of [attemptReason].
                     *
                     * Unlike [attemptReason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempt_reason")
                    @ExcludeMissing
                    fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                    /**
                     * Returns the raw JSON value of [attemptedAt].
                     *
                     * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("attempted_at")
                    @ExcludeMissing
                    fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                    /**
                     * Returns the raw JSON value of [merchandiseDisposition].
                     *
                     * Unlike [merchandiseDisposition], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchandise_disposition")
                    @ExcludeMissing
                    fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ReturnAttempted].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ReturnAttempted]. */
                    class Builder internal constructor() {

                        private var attemptExplanation: JsonField<String>? = null
                        private var attemptReason: JsonField<AttemptReason>? = null
                        private var attemptedAt: JsonField<LocalDate>? = null
                        private var merchandiseDisposition: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returnAttempted: ReturnAttempted) = apply {
                            attemptExplanation = returnAttempted.attemptExplanation
                            attemptReason = returnAttempted.attemptReason
                            attemptedAt = returnAttempted.attemptedAt
                            merchandiseDisposition = returnAttempted.merchandiseDisposition
                            additionalProperties =
                                returnAttempted.additionalProperties.toMutableMap()
                        }

                        /** Attempt explanation. */
                        fun attemptExplanation(attemptExplanation: String) =
                            attemptExplanation(JsonField.of(attemptExplanation))

                        /**
                         * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                            this.attemptExplanation = attemptExplanation
                        }

                        /** Attempt reason. */
                        fun attemptReason(attemptReason: AttemptReason) =
                            attemptReason(JsonField.of(attemptReason))

                        /**
                         * Sets [Builder.attemptReason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptReason] with a well-typed
                         * [AttemptReason] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                            this.attemptReason = attemptReason
                        }

                        /** Attempted at. */
                        fun attemptedAt(attemptedAt: LocalDate) =
                            attemptedAt(JsonField.of(attemptedAt))

                        /**
                         * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.attemptedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                            this.attemptedAt = attemptedAt
                        }

                        /** Merchandise disposition. */
                        fun merchandiseDisposition(merchandiseDisposition: String) =
                            merchandiseDisposition(JsonField.of(merchandiseDisposition))

                        /**
                         * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchandiseDisposition] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                            apply {
                                this.merchandiseDisposition = merchandiseDisposition
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ReturnAttempted].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .attemptExplanation()
                         * .attemptReason()
                         * .attemptedAt()
                         * .merchandiseDisposition()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ReturnAttempted =
                            ReturnAttempted(
                                checkRequired("attemptExplanation", attemptExplanation),
                                checkRequired("attemptReason", attemptReason),
                                checkRequired("attemptedAt", attemptedAt),
                                checkRequired("merchandiseDisposition", merchandiseDisposition),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ReturnAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        attemptExplanation()
                        attemptReason().validate()
                        attemptedAt()
                        merchandiseDisposition()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (attemptExplanation.asKnown() == null) 0 else 1) +
                            (attemptReason.asKnown()?.validity() ?: 0) +
                            (if (attemptedAt.asKnown() == null) 0 else 1) +
                            (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                    /** Attempt reason. */
                    class AttemptReason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Merchant not responding. */
                            val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                            /** No return authorization provided. */
                            val NO_RETURN_AUTHORIZATION_PROVIDED =
                                of("no_return_authorization_provided")

                            /** No return instructions. */
                            val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                            /** Requested not to return. */
                            val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                            /** Return not accepted. */
                            val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                            fun of(value: String) = AttemptReason(JsonField.of(value))
                        }

                        /** An enum containing [AttemptReason]'s known values. */
                        enum class Known {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AttemptReason]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AttemptReason] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Merchant not responding. */
                            MERCHANT_NOT_RESPONDING,
                            /** No return authorization provided. */
                            NO_RETURN_AUTHORIZATION_PROVIDED,
                            /** No return instructions. */
                            NO_RETURN_INSTRUCTIONS,
                            /** Requested not to return. */
                            REQUESTED_NOT_TO_RETURN,
                            /** Return not accepted. */
                            RETURN_NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AttemptReason] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                NO_RETURN_AUTHORIZATION_PROVIDED ->
                                    Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AttemptReason: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AttemptReason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AttemptReason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReturnAttempted &&
                            attemptExplanation == other.attemptExplanation &&
                            attemptReason == other.attemptReason &&
                            attemptedAt == other.attemptedAt &&
                            merchandiseDisposition == other.merchandiseDisposition &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                }

                /** Returned. Required if and only if `return_outcome` is `returned`. */
                class Returned
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val returnMethod: JsonField<ReturnMethod>,
                    private val returnedAt: JsonField<LocalDate>,
                    private val merchantReceivedReturnAt: JsonField<LocalDate>,
                    private val otherExplanation: JsonField<String>,
                    private val trackingNumber: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        otherExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        trackingNumber: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        returnMethod,
                        returnedAt,
                        merchantReceivedReturnAt,
                        otherExplanation,
                        trackingNumber,
                        mutableMapOf(),
                    )

                    /**
                     * Return method.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                    /**
                     * Returned at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                    /**
                     * Merchant received return at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun merchantReceivedReturnAt(): LocalDate? =
                        merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                    /**
                     * Other explanation. Required if and only if the return method is `other`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun otherExplanation(): String? =
                        otherExplanation.getNullable("other_explanation")

                    /**
                     * Tracking number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun trackingNumber(): String? = trackingNumber.getNullable("tracking_number")

                    /**
                     * Returns the raw JSON value of [returnMethod].
                     *
                     * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_method")
                    @ExcludeMissing
                    fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                    /**
                     * Returns the raw JSON value of [returnedAt].
                     *
                     * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned_at")
                    @ExcludeMissing
                    fun _returnedAt(): JsonField<LocalDate> = returnedAt

                    /**
                     * Returns the raw JSON value of [merchantReceivedReturnAt].
                     *
                     * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_received_return_at")
                    @ExcludeMissing
                    fun _merchantReceivedReturnAt(): JsonField<LocalDate> = merchantReceivedReturnAt

                    /**
                     * Returns the raw JSON value of [otherExplanation].
                     *
                     * Unlike [otherExplanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("other_explanation")
                    @ExcludeMissing
                    fun _otherExplanation(): JsonField<String> = otherExplanation

                    /**
                     * Returns the raw JSON value of [trackingNumber].
                     *
                     * Unlike [trackingNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("tracking_number")
                    @ExcludeMissing
                    fun _trackingNumber(): JsonField<String> = trackingNumber

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Returned].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Returned]. */
                    class Builder internal constructor() {

                        private var returnMethod: JsonField<ReturnMethod>? = null
                        private var returnedAt: JsonField<LocalDate>? = null
                        private var merchantReceivedReturnAt: JsonField<LocalDate> =
                            JsonMissing.of()
                        private var otherExplanation: JsonField<String> = JsonMissing.of()
                        private var trackingNumber: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(returned: Returned) = apply {
                            returnMethod = returned.returnMethod
                            returnedAt = returned.returnedAt
                            merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                            otherExplanation = returned.otherExplanation
                            trackingNumber = returned.trackingNumber
                            additionalProperties = returned.additionalProperties.toMutableMap()
                        }

                        /** Return method. */
                        fun returnMethod(returnMethod: ReturnMethod) =
                            returnMethod(JsonField.of(returnMethod))

                        /**
                         * Sets [Builder.returnMethod] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnMethod] with a well-typed
                         * [ReturnMethod] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                            this.returnMethod = returnMethod
                        }

                        /** Returned at. */
                        fun returnedAt(returnedAt: LocalDate) = returnedAt(JsonField.of(returnedAt))

                        /**
                         * Sets [Builder.returnedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                            this.returnedAt = returnedAt
                        }

                        /** Merchant received return at. */
                        fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate) =
                            merchantReceivedReturnAt(JsonField.of(merchantReceivedReturnAt))

                        /**
                         * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantReceivedReturnAt] with a
                         * well-typed [LocalDate] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun merchantReceivedReturnAt(
                            merchantReceivedReturnAt: JsonField<LocalDate>
                        ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         */
                        fun otherExplanation(otherExplanation: String) =
                            otherExplanation(JsonField.of(otherExplanation))

                        /**
                         * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                            this.otherExplanation = otherExplanation
                        }

                        /** Tracking number. */
                        fun trackingNumber(trackingNumber: String) =
                            trackingNumber(JsonField.of(trackingNumber))

                        /**
                         * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.trackingNumber] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                            this.trackingNumber = trackingNumber
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Returned].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .returnMethod()
                         * .returnedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Returned =
                            Returned(
                                checkRequired("returnMethod", returnMethod),
                                checkRequired("returnedAt", returnedAt),
                                merchantReceivedReturnAt,
                                otherExplanation,
                                trackingNumber,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Returned = apply {
                        if (validated) {
                            return@apply
                        }

                        returnMethod().validate()
                        returnedAt()
                        merchantReceivedReturnAt()
                        otherExplanation()
                        trackingNumber()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (returnMethod.asKnown()?.validity() ?: 0) +
                            (if (returnedAt.asKnown() == null) 0 else 1) +
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                            (if (otherExplanation.asKnown() == null) 0 else 1) +
                            (if (trackingNumber.asKnown() == null) 0 else 1)

                    /** Return method. */
                    class ReturnMethod
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** DHL. */
                            val DHL = of("dhl")

                            /** Face-to-face. */
                            val FACE_TO_FACE = of("face_to_face")

                            /** FedEx. */
                            val FEDEX = of("fedex")

                            /** Other. */
                            val OTHER = of("other")

                            /** Postal service. */
                            val POSTAL_SERVICE = of("postal_service")

                            /** UPS. */
                            val UPS = of("ups")

                            fun of(value: String) = ReturnMethod(JsonField.of(value))
                        }

                        /** An enum containing [ReturnMethod]'s known values. */
                        enum class Known {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                        }

                        /**
                         * An enum containing [ReturnMethod]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnMethod] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** DHL. */
                            DHL,
                            /** Face-to-face. */
                            FACE_TO_FACE,
                            /** FedEx. */
                            FEDEX,
                            /** Other. */
                            OTHER,
                            /** Postal service. */
                            POSTAL_SERVICE,
                            /** UPS. */
                            UPS,
                            /**
                             * An enum member indicating that [ReturnMethod] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DHL -> Value.DHL
                                FACE_TO_FACE -> Value.FACE_TO_FACE
                                FEDEX -> Value.FEDEX
                                OTHER -> Value.OTHER
                                POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                UPS -> Value.UPS
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DHL -> Known.DHL
                                FACE_TO_FACE -> Known.FACE_TO_FACE
                                FEDEX -> Known.FEDEX
                                OTHER -> Known.OTHER
                                POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                UPS -> Known.UPS
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnMethod: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnMethod = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnMethod && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Returned &&
                            returnMethod == other.returnMethod &&
                            returnedAt == other.returnedAt &&
                            merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                            otherExplanation == other.otherExplanation &&
                            trackingNumber == other.trackingNumber &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            returnMethod,
                            returnedAt,
                            merchantReceivedReturnAt,
                            otherExplanation,
                            trackingNumber,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Returned{returnMethod=$returnMethod, returnedAt=$returnedAt, merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerQualityMerchandise &&
                        expectedAt == other.expectedAt &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        purchaseInfoAndQualityIssue == other.purchaseInfoAndQualityIssue &&
                        receivedAt == other.receivedAt &&
                        returnOutcome == other.returnOutcome &&
                        notReturned == other.notReturned &&
                        ongoingNegotiations == other.ongoingNegotiations &&
                        returnAttempted == other.returnAttempted &&
                        returned == other.returned &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        expectedAt,
                        merchantResolutionAttempted,
                        purchaseInfoAndQualityIssue,
                        receivedAt,
                        returnOutcome,
                        notReturned,
                        ongoingNegotiations,
                        returnAttempted,
                        returned,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerQualityMerchandise{expectedAt=$expectedAt, merchantResolutionAttempted=$merchantResolutionAttempted, purchaseInfoAndQualityIssue=$purchaseInfoAndQualityIssue, receivedAt=$receivedAt, returnOutcome=$returnOutcome, notReturned=$notReturned, ongoingNegotiations=$ongoingNegotiations, returnAttempted=$returnAttempted, returned=$returned, additionalProperties=$additionalProperties}"
            }

            /**
             * Services quality issue. Required if and only if `category` is
             * `consumer_quality_services`.
             */
            class ConsumerQualityServices
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cardholderCancellation: JsonField<CardholderCancellation>,
                private val nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                    JsonField<NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription>,
                private val purchaseInfoAndQualityIssue: JsonField<String>,
                private val servicesReceivedAt: JsonField<LocalDate>,
                private val cardholderPaidToHaveWorkRedone:
                    JsonField<CardholderPaidToHaveWorkRedone>,
                private val ongoingNegotiations: JsonField<OngoingNegotiations>,
                private val restaurantFoodRelated: JsonField<RestaurantFoodRelated>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    cardholderCancellation: JsonField<CardholderCancellation> = JsonMissing.of(),
                    @JsonProperty(
                        "non_fiat_currency_or_non_fungible_token_related_and_not_matching_description"
                    )
                    @ExcludeMissing
                    nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                        JsonField<
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                        > =
                        JsonMissing.of(),
                    @JsonProperty("purchase_info_and_quality_issue")
                    @ExcludeMissing
                    purchaseInfoAndQualityIssue: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("services_received_at")
                    @ExcludeMissing
                    servicesReceivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("cardholder_paid_to_have_work_redone")
                    @ExcludeMissing
                    cardholderPaidToHaveWorkRedone: JsonField<CardholderPaidToHaveWorkRedone> =
                        JsonMissing.of(),
                    @JsonProperty("ongoing_negotiations")
                    @ExcludeMissing
                    ongoingNegotiations: JsonField<OngoingNegotiations> = JsonMissing.of(),
                    @JsonProperty("restaurant_food_related")
                    @ExcludeMissing
                    restaurantFoodRelated: JsonField<RestaurantFoodRelated> = JsonMissing.of(),
                ) : this(
                    cardholderCancellation,
                    nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription,
                    purchaseInfoAndQualityIssue,
                    servicesReceivedAt,
                    cardholderPaidToHaveWorkRedone,
                    ongoingNegotiations,
                    restaurantFoodRelated,
                    mutableMapOf(),
                )

                /**
                 * Cardholder cancellation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun cardholderCancellation(): CardholderCancellation =
                    cardholderCancellation.getRequired("cardholder_cancellation")

                /**
                 * Non-fiat currency or non-fungible token related and not matching description.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription():
                    NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription =
                    nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription.getRequired(
                        "non_fiat_currency_or_non_fungible_token_related_and_not_matching_description"
                    )

                /**
                 * Purchase information and quality issue.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseInfoAndQualityIssue(): String =
                    purchaseInfoAndQualityIssue.getRequired("purchase_info_and_quality_issue")

                /**
                 * Services received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun servicesReceivedAt(): LocalDate =
                    servicesReceivedAt.getRequired("services_received_at")

                /**
                 * Cardholder paid to have work redone.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun cardholderPaidToHaveWorkRedone(): CardholderPaidToHaveWorkRedone? =
                    cardholderPaidToHaveWorkRedone.getNullable(
                        "cardholder_paid_to_have_work_redone"
                    )

                /**
                 * Ongoing negotiations. Exclude if there is no evidence of ongoing negotiations.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun ongoingNegotiations(): OngoingNegotiations? =
                    ongoingNegotiations.getNullable("ongoing_negotiations")

                /**
                 * Whether the dispute is related to the quality of food from an eating place or
                 * restaurant. Must be provided when Merchant Category Code (MCC) is 5812, 5813
                 * or 5814.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun restaurantFoodRelated(): RestaurantFoodRelated? =
                    restaurantFoodRelated.getNullable("restaurant_food_related")

                /**
                 * Returns the raw JSON value of [cardholderCancellation].
                 *
                 * Unlike [cardholderCancellation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("cardholder_cancellation")
                @ExcludeMissing
                fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                    cardholderCancellation

                /**
                 * Returns the raw JSON value of
                 * [nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription].
                 *
                 * Unlike [nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription], this
                 * method doesn't throw if the JSON field has an unexpected type.
                 */
                @JsonProperty(
                    "non_fiat_currency_or_non_fungible_token_related_and_not_matching_description"
                )
                @ExcludeMissing
                fun _nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription():
                    JsonField<NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription> =
                    nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription

                /**
                 * Returns the raw JSON value of [purchaseInfoAndQualityIssue].
                 *
                 * Unlike [purchaseInfoAndQualityIssue], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("purchase_info_and_quality_issue")
                @ExcludeMissing
                fun _purchaseInfoAndQualityIssue(): JsonField<String> = purchaseInfoAndQualityIssue

                /**
                 * Returns the raw JSON value of [servicesReceivedAt].
                 *
                 * Unlike [servicesReceivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("services_received_at")
                @ExcludeMissing
                fun _servicesReceivedAt(): JsonField<LocalDate> = servicesReceivedAt

                /**
                 * Returns the raw JSON value of [cardholderPaidToHaveWorkRedone].
                 *
                 * Unlike [cardholderPaidToHaveWorkRedone], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("cardholder_paid_to_have_work_redone")
                @ExcludeMissing
                fun _cardholderPaidToHaveWorkRedone(): JsonField<CardholderPaidToHaveWorkRedone> =
                    cardholderPaidToHaveWorkRedone

                /**
                 * Returns the raw JSON value of [ongoingNegotiations].
                 *
                 * Unlike [ongoingNegotiations], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("ongoing_negotiations")
                @ExcludeMissing
                fun _ongoingNegotiations(): JsonField<OngoingNegotiations> = ongoingNegotiations

                /**
                 * Returns the raw JSON value of [restaurantFoodRelated].
                 *
                 * Unlike [restaurantFoodRelated], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("restaurant_food_related")
                @ExcludeMissing
                fun _restaurantFoodRelated(): JsonField<RestaurantFoodRelated> =
                    restaurantFoodRelated

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerQualityServices].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription()
                     * .purchaseInfoAndQualityIssue()
                     * .servicesReceivedAt()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerQualityServices]. */
                class Builder internal constructor() {

                    private var cardholderCancellation: JsonField<CardholderCancellation>? = null
                    private var nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                        JsonField<
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                        >? =
                        null
                    private var purchaseInfoAndQualityIssue: JsonField<String>? = null
                    private var servicesReceivedAt: JsonField<LocalDate>? = null
                    private var cardholderPaidToHaveWorkRedone:
                        JsonField<CardholderPaidToHaveWorkRedone> =
                        JsonMissing.of()
                    private var ongoingNegotiations: JsonField<OngoingNegotiations> =
                        JsonMissing.of()
                    private var restaurantFoodRelated: JsonField<RestaurantFoodRelated> =
                        JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(consumerQualityServices: ConsumerQualityServices) = apply {
                        cardholderCancellation = consumerQualityServices.cardholderCancellation
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription =
                            consumerQualityServices
                                .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                        purchaseInfoAndQualityIssue =
                            consumerQualityServices.purchaseInfoAndQualityIssue
                        servicesReceivedAt = consumerQualityServices.servicesReceivedAt
                        cardholderPaidToHaveWorkRedone =
                            consumerQualityServices.cardholderPaidToHaveWorkRedone
                        ongoingNegotiations = consumerQualityServices.ongoingNegotiations
                        restaurantFoodRelated = consumerQualityServices.restaurantFoodRelated
                        additionalProperties =
                            consumerQualityServices.additionalProperties.toMutableMap()
                    }

                    /** Cardholder cancellation. */
                    fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                        cardholderCancellation(JsonField.of(cardholderCancellation))

                    /**
                     * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderCancellation] with a well-typed
                     * [CardholderCancellation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun cardholderCancellation(
                        cardholderCancellation: JsonField<CardholderCancellation>
                    ) = apply { this.cardholderCancellation = cardholderCancellation }

                    /**
                     * Non-fiat currency or non-fungible token related and not matching description.
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                    ) =
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                            JsonField.of(
                                nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                            )
                        )

                    /**
                     * Sets
                     * [Builder.nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]
                     * to an arbitrary JSON value.
                     *
                     * You should usually call
                     * [Builder.nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]
                     * with a well-typed
                     * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                            JsonField<
                                NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                            >
                    ) = apply {
                        this.nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription =
                            nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                    }

                    /** Purchase information and quality issue. */
                    fun purchaseInfoAndQualityIssue(purchaseInfoAndQualityIssue: String) =
                        purchaseInfoAndQualityIssue(JsonField.of(purchaseInfoAndQualityIssue))

                    /**
                     * Sets [Builder.purchaseInfoAndQualityIssue] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseInfoAndQualityIssue] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun purchaseInfoAndQualityIssue(
                        purchaseInfoAndQualityIssue: JsonField<String>
                    ) = apply { this.purchaseInfoAndQualityIssue = purchaseInfoAndQualityIssue }

                    /** Services received at. */
                    fun servicesReceivedAt(servicesReceivedAt: LocalDate) =
                        servicesReceivedAt(JsonField.of(servicesReceivedAt))

                    /**
                     * Sets [Builder.servicesReceivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.servicesReceivedAt] with a well-typed
                     * [LocalDate] value instead. This method is primarily for setting the field to
                     * an undocumented or not yet supported value.
                     */
                    fun servicesReceivedAt(servicesReceivedAt: JsonField<LocalDate>) = apply {
                        this.servicesReceivedAt = servicesReceivedAt
                    }

                    /** Cardholder paid to have work redone. */
                    fun cardholderPaidToHaveWorkRedone(
                        cardholderPaidToHaveWorkRedone: CardholderPaidToHaveWorkRedone
                    ) = cardholderPaidToHaveWorkRedone(JsonField.of(cardholderPaidToHaveWorkRedone))

                    /**
                     * Sets [Builder.cardholderPaidToHaveWorkRedone] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderPaidToHaveWorkRedone] with a
                     * well-typed [CardholderPaidToHaveWorkRedone] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun cardholderPaidToHaveWorkRedone(
                        cardholderPaidToHaveWorkRedone: JsonField<CardholderPaidToHaveWorkRedone>
                    ) = apply {
                        this.cardholderPaidToHaveWorkRedone = cardholderPaidToHaveWorkRedone
                    }

                    /**
                     * Ongoing negotiations. Exclude if there is no evidence of ongoing
                     * negotiations.
                     */
                    fun ongoingNegotiations(ongoingNegotiations: OngoingNegotiations) =
                        ongoingNegotiations(JsonField.of(ongoingNegotiations))

                    /**
                     * Sets [Builder.ongoingNegotiations] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.ongoingNegotiations] with a well-typed
                     * [OngoingNegotiations] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun ongoingNegotiations(ongoingNegotiations: JsonField<OngoingNegotiations>) =
                        apply {
                            this.ongoingNegotiations = ongoingNegotiations
                        }

                    /**
                     * Whether the dispute is related to the quality of food from an eating place or
                     * restaurant. Must be provided when Merchant Category Code (MCC) is 5812, 5813
                     * or 5814.
                     */
                    fun restaurantFoodRelated(restaurantFoodRelated: RestaurantFoodRelated) =
                        restaurantFoodRelated(JsonField.of(restaurantFoodRelated))

                    /**
                     * Sets [Builder.restaurantFoodRelated] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.restaurantFoodRelated] with a well-typed
                     * [RestaurantFoodRelated] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun restaurantFoodRelated(
                        restaurantFoodRelated: JsonField<RestaurantFoodRelated>
                    ) = apply { this.restaurantFoodRelated = restaurantFoodRelated }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerQualityServices].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription()
                     * .purchaseInfoAndQualityIssue()
                     * .servicesReceivedAt()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerQualityServices =
                        ConsumerQualityServices(
                            checkRequired("cardholderCancellation", cardholderCancellation),
                            checkRequired(
                                "nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription",
                                nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription,
                            ),
                            checkRequired(
                                "purchaseInfoAndQualityIssue",
                                purchaseInfoAndQualityIssue,
                            ),
                            checkRequired("servicesReceivedAt", servicesReceivedAt),
                            cardholderPaidToHaveWorkRedone,
                            ongoingNegotiations,
                            restaurantFoodRelated,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerQualityServices = apply {
                    if (validated) {
                        return@apply
                    }

                    cardholderCancellation().validate()
                    nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription().validate()
                    purchaseInfoAndQualityIssue()
                    servicesReceivedAt()
                    cardholderPaidToHaveWorkRedone()?.validate()
                    ongoingNegotiations()?.validate()
                    restaurantFoodRelated()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cardholderCancellation.asKnown()?.validity() ?: 0) +
                        (nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                            .asKnown()
                            ?.validity() ?: 0) +
                        (if (purchaseInfoAndQualityIssue.asKnown() == null) 0 else 1) +
                        (if (servicesReceivedAt.asKnown() == null) 0 else 1) +
                        (cardholderPaidToHaveWorkRedone.asKnown()?.validity() ?: 0) +
                        (ongoingNegotiations.asKnown()?.validity() ?: 0) +
                        (restaurantFoodRelated.asKnown()?.validity() ?: 0)

                /** Cardholder cancellation. */
                class CardholderCancellation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val acceptedByMerchant: JsonField<AcceptedByMerchant>,
                    private val canceledAt: JsonField<LocalDate>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("accepted_by_merchant")
                        @ExcludeMissing
                        acceptedByMerchant: JsonField<AcceptedByMerchant> = JsonMissing.of(),
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(acceptedByMerchant, canceledAt, reason, mutableMapOf())

                    /**
                     * Accepted by merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun acceptedByMerchant(): AcceptedByMerchant =
                        acceptedByMerchant.getRequired("accepted_by_merchant")

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): String = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [acceptedByMerchant].
                     *
                     * Unlike [acceptedByMerchant], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("accepted_by_merchant")
                    @ExcludeMissing
                    fun _acceptedByMerchant(): JsonField<AcceptedByMerchant> = acceptedByMerchant

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderCancellation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .acceptedByMerchant()
                         * .canceledAt()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderCancellation]. */
                    class Builder internal constructor() {

                        private var acceptedByMerchant: JsonField<AcceptedByMerchant>? = null
                        private var canceledAt: JsonField<LocalDate>? = null
                        private var reason: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(cardholderCancellation: CardholderCancellation) = apply {
                            acceptedByMerchant = cardholderCancellation.acceptedByMerchant
                            canceledAt = cardholderCancellation.canceledAt
                            reason = cardholderCancellation.reason
                            additionalProperties =
                                cardholderCancellation.additionalProperties.toMutableMap()
                        }

                        /** Accepted by merchant. */
                        fun acceptedByMerchant(acceptedByMerchant: AcceptedByMerchant) =
                            acceptedByMerchant(JsonField.of(acceptedByMerchant))

                        /**
                         * Sets [Builder.acceptedByMerchant] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.acceptedByMerchant] with a well-typed
                         * [AcceptedByMerchant] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun acceptedByMerchant(acceptedByMerchant: JsonField<AcceptedByMerchant>) =
                            apply {
                                this.acceptedByMerchant = acceptedByMerchant
                            }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        /** Reason. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CardholderCancellation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .acceptedByMerchant()
                         * .canceledAt()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderCancellation =
                            CardholderCancellation(
                                checkRequired("acceptedByMerchant", acceptedByMerchant),
                                checkRequired("canceledAt", canceledAt),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderCancellation = apply {
                        if (validated) {
                            return@apply
                        }

                        acceptedByMerchant().validate()
                        canceledAt()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (acceptedByMerchant.asKnown()?.validity() ?: 0) +
                            (if (canceledAt.asKnown() == null) 0 else 1) +
                            (if (reason.asKnown() == null) 0 else 1)

                    /** Accepted by merchant. */
                    class AcceptedByMerchant
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Accepted. */
                            val ACCEPTED = of("accepted")

                            /** Not accepted. */
                            val NOT_ACCEPTED = of("not_accepted")

                            fun of(value: String) = AcceptedByMerchant(JsonField.of(value))
                        }

                        /** An enum containing [AcceptedByMerchant]'s known values. */
                        enum class Known {
                            /** Accepted. */
                            ACCEPTED,
                            /** Not accepted. */
                            NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AcceptedByMerchant]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AcceptedByMerchant] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Accepted. */
                            ACCEPTED,
                            /** Not accepted. */
                            NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AcceptedByMerchant] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ACCEPTED -> Value.ACCEPTED
                                NOT_ACCEPTED -> Value.NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ACCEPTED -> Known.ACCEPTED
                                NOT_ACCEPTED -> Known.NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AcceptedByMerchant: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AcceptedByMerchant = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AcceptedByMerchant && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderCancellation &&
                            acceptedByMerchant == other.acceptedByMerchant &&
                            canceledAt == other.canceledAt &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(acceptedByMerchant, canceledAt, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderCancellation{acceptedByMerchant=$acceptedByMerchant, canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /** Non-fiat currency or non-fungible token related and not matching description. */
                class NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Not related. */
                        val NOT_RELATED = of("not_related")

                        /** Related. */
                        val RELATED = of("related")

                        fun of(value: String) =
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                                JsonField.of(value)
                            )
                    }

                    /**
                     * An enum containing
                     * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]'s known
                     * values.
                     */
                    enum class Known {
                        /** Not related. */
                        NOT_RELATED,
                        /** Related. */
                        RELATED,
                    }

                    /**
                     * An enum containing
                     * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]'s known
                     * values, as well as an [_UNKNOWN] member.
                     *
                     * An instance of
                     * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription] can
                     * contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Not related. */
                        NOT_RELATED,
                        /** Related. */
                        RELATED,
                        /**
                         * An enum member indicating that
                         * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            NOT_RELATED -> Value.NOT_RELATED
                            RELATED -> Value.RELATED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            NOT_RELATED -> Known.NOT_RELATED
                            RELATED -> Known.RELATED
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate():
                        NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription &&
                            value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Cardholder paid to have work redone. */
                class CardholderPaidToHaveWorkRedone
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Cardholder did not pay to have work redone. */
                        val DID_NOT_PAY_TO_HAVE_WORK_REDONE = of("did_not_pay_to_have_work_redone")

                        /** Cardholder paid to have work redone. */
                        val PAID_TO_HAVE_WORK_REDONE = of("paid_to_have_work_redone")

                        fun of(value: String) = CardholderPaidToHaveWorkRedone(JsonField.of(value))
                    }

                    /** An enum containing [CardholderPaidToHaveWorkRedone]'s known values. */
                    enum class Known {
                        /** Cardholder did not pay to have work redone. */
                        DID_NOT_PAY_TO_HAVE_WORK_REDONE,
                        /** Cardholder paid to have work redone. */
                        PAID_TO_HAVE_WORK_REDONE,
                    }

                    /**
                     * An enum containing [CardholderPaidToHaveWorkRedone]'s known values, as well
                     * as an [_UNKNOWN] member.
                     *
                     * An instance of [CardholderPaidToHaveWorkRedone] can contain an unknown value
                     * in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Cardholder did not pay to have work redone. */
                        DID_NOT_PAY_TO_HAVE_WORK_REDONE,
                        /** Cardholder paid to have work redone. */
                        PAID_TO_HAVE_WORK_REDONE,
                        /**
                         * An enum member indicating that [CardholderPaidToHaveWorkRedone] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            DID_NOT_PAY_TO_HAVE_WORK_REDONE -> Value.DID_NOT_PAY_TO_HAVE_WORK_REDONE
                            PAID_TO_HAVE_WORK_REDONE -> Value.PAID_TO_HAVE_WORK_REDONE
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            DID_NOT_PAY_TO_HAVE_WORK_REDONE -> Known.DID_NOT_PAY_TO_HAVE_WORK_REDONE
                            PAID_TO_HAVE_WORK_REDONE -> Known.PAID_TO_HAVE_WORK_REDONE
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown CardholderPaidToHaveWorkRedone: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): CardholderPaidToHaveWorkRedone = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderPaidToHaveWorkRedone && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Ongoing negotiations. Exclude if there is no evidence of ongoing negotiations.
                 */
                class OngoingNegotiations
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val issuerFirstNotifiedAt: JsonField<LocalDate>,
                    private val startedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("issuer_first_notified_at")
                        @ExcludeMissing
                        issuerFirstNotifiedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("started_at")
                        @ExcludeMissing
                        startedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(explanation, issuerFirstNotifiedAt, startedAt, mutableMapOf())

                    /**
                     * Explanation of the previous ongoing negotiations between the cardholder and
                     * merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun explanation(): String = explanation.getRequired("explanation")

                    /**
                     * Date the cardholder first notified the issuer of the dispute.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun issuerFirstNotifiedAt(): LocalDate =
                        issuerFirstNotifiedAt.getRequired("issuer_first_notified_at")

                    /**
                     * Started at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun startedAt(): LocalDate = startedAt.getRequired("started_at")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [issuerFirstNotifiedAt].
                     *
                     * Unlike [issuerFirstNotifiedAt], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("issuer_first_notified_at")
                    @ExcludeMissing
                    fun _issuerFirstNotifiedAt(): JsonField<LocalDate> = issuerFirstNotifiedAt

                    /**
                     * Returns the raw JSON value of [startedAt].
                     *
                     * Unlike [startedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("started_at")
                    @ExcludeMissing
                    fun _startedAt(): JsonField<LocalDate> = startedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [OngoingNegotiations].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .issuerFirstNotifiedAt()
                         * .startedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [OngoingNegotiations]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var issuerFirstNotifiedAt: JsonField<LocalDate>? = null
                        private var startedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(ongoingNegotiations: OngoingNegotiations) = apply {
                            explanation = ongoingNegotiations.explanation
                            issuerFirstNotifiedAt = ongoingNegotiations.issuerFirstNotifiedAt
                            startedAt = ongoingNegotiations.startedAt
                            additionalProperties =
                                ongoingNegotiations.additionalProperties.toMutableMap()
                        }

                        /**
                         * Explanation of the previous ongoing negotiations between the cardholder
                         * and merchant.
                         */
                        fun explanation(explanation: String) =
                            explanation(JsonField.of(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** Date the cardholder first notified the issuer of the dispute. */
                        fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: LocalDate) =
                            issuerFirstNotifiedAt(JsonField.of(issuerFirstNotifiedAt))

                        /**
                         * Sets [Builder.issuerFirstNotifiedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.issuerFirstNotifiedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: JsonField<LocalDate>) =
                            apply {
                                this.issuerFirstNotifiedAt = issuerFirstNotifiedAt
                            }

                        /** Started at. */
                        fun startedAt(startedAt: LocalDate) = startedAt(JsonField.of(startedAt))

                        /**
                         * Sets [Builder.startedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.startedAt] with a well-typed [LocalDate]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun startedAt(startedAt: JsonField<LocalDate>) = apply {
                            this.startedAt = startedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [OngoingNegotiations].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .issuerFirstNotifiedAt()
                         * .startedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): OngoingNegotiations =
                            OngoingNegotiations(
                                checkRequired("explanation", explanation),
                                checkRequired("issuerFirstNotifiedAt", issuerFirstNotifiedAt),
                                checkRequired("startedAt", startedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): OngoingNegotiations = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        issuerFirstNotifiedAt()
                        startedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (explanation.asKnown() == null) 0 else 1) +
                            (if (issuerFirstNotifiedAt.asKnown() == null) 0 else 1) +
                            (if (startedAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is OngoingNegotiations &&
                            explanation == other.explanation &&
                            issuerFirstNotifiedAt == other.issuerFirstNotifiedAt &&
                            startedAt == other.startedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            explanation,
                            issuerFirstNotifiedAt,
                            startedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "OngoingNegotiations{explanation=$explanation, issuerFirstNotifiedAt=$issuerFirstNotifiedAt, startedAt=$startedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Whether the dispute is related to the quality of food from an eating place or
                 * restaurant. Must be provided when Merchant Category Code (MCC) is 5812, 5813
                 * or 5814.
                 */
                class RestaurantFoodRelated
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Not related. */
                        val NOT_RELATED = of("not_related")

                        /** Related. */
                        val RELATED = of("related")

                        fun of(value: String) = RestaurantFoodRelated(JsonField.of(value))
                    }

                    /** An enum containing [RestaurantFoodRelated]'s known values. */
                    enum class Known {
                        /** Not related. */
                        NOT_RELATED,
                        /** Related. */
                        RELATED,
                    }

                    /**
                     * An enum containing [RestaurantFoodRelated]'s known values, as well as an
                     * [_UNKNOWN] member.
                     *
                     * An instance of [RestaurantFoodRelated] can contain an unknown value in a
                     * couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Not related. */
                        NOT_RELATED,
                        /** Related. */
                        RELATED,
                        /**
                         * An enum member indicating that [RestaurantFoodRelated] was instantiated
                         * with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            NOT_RELATED -> Value.NOT_RELATED
                            RELATED -> Value.RELATED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            NOT_RELATED -> Known.NOT_RELATED
                            RELATED -> Known.RELATED
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown RestaurantFoodRelated: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): RestaurantFoodRelated = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is RestaurantFoodRelated && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerQualityServices &&
                        cardholderCancellation == other.cardholderCancellation &&
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription ==
                            other
                                .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription &&
                        purchaseInfoAndQualityIssue == other.purchaseInfoAndQualityIssue &&
                        servicesReceivedAt == other.servicesReceivedAt &&
                        cardholderPaidToHaveWorkRedone == other.cardholderPaidToHaveWorkRedone &&
                        ongoingNegotiations == other.ongoingNegotiations &&
                        restaurantFoodRelated == other.restaurantFoodRelated &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cardholderCancellation,
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription,
                        purchaseInfoAndQualityIssue,
                        servicesReceivedAt,
                        cardholderPaidToHaveWorkRedone,
                        ongoingNegotiations,
                        restaurantFoodRelated,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerQualityServices{cardholderCancellation=$cardholderCancellation, nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription=$nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription, purchaseInfoAndQualityIssue=$purchaseInfoAndQualityIssue, servicesReceivedAt=$servicesReceivedAt, cardholderPaidToHaveWorkRedone=$cardholderPaidToHaveWorkRedone, ongoingNegotiations=$ongoingNegotiations, restaurantFoodRelated=$restaurantFoodRelated, additionalProperties=$additionalProperties}"
            }

            /**
             * Services misrepresentation. Required if and only if `category` is
             * `consumer_services_misrepresentation`.
             */
            class ConsumerServicesMisrepresentation
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cardholderCancellation: JsonField<CardholderCancellation>,
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val misrepresentationExplanation: JsonField<String>,
                private val purchaseExplanation: JsonField<String>,
                private val receivedAt: JsonField<LocalDate>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    cardholderCancellation: JsonField<CardholderCancellation> = JsonMissing.of(),
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("misrepresentation_explanation")
                    @ExcludeMissing
                    misrepresentationExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    purchaseExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                ) : this(
                    cardholderCancellation,
                    merchantResolutionAttempted,
                    misrepresentationExplanation,
                    purchaseExplanation,
                    receivedAt,
                    mutableMapOf(),
                )

                /**
                 * Cardholder cancellation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun cardholderCancellation(): CardholderCancellation =
                    cardholderCancellation.getRequired("cardholder_cancellation")

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Misrepresentation explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun misrepresentationExplanation(): String =
                    misrepresentationExplanation.getRequired("misrepresentation_explanation")

                /**
                 * Purchase explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseExplanation(): String =
                    purchaseExplanation.getRequired("purchase_explanation")

                /**
                 * Received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                /**
                 * Returns the raw JSON value of [cardholderCancellation].
                 *
                 * Unlike [cardholderCancellation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("cardholder_cancellation")
                @ExcludeMissing
                fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                    cardholderCancellation

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [misrepresentationExplanation].
                 *
                 * Unlike [misrepresentationExplanation], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("misrepresentation_explanation")
                @ExcludeMissing
                fun _misrepresentationExplanation(): JsonField<String> =
                    misrepresentationExplanation

                /**
                 * Returns the raw JSON value of [purchaseExplanation].
                 *
                 * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("purchase_explanation")
                @ExcludeMissing
                fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                /**
                 * Returns the raw JSON value of [receivedAt].
                 *
                 * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_at")
                @ExcludeMissing
                fun _receivedAt(): JsonField<LocalDate> = receivedAt

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerServicesMisrepresentation].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .merchantResolutionAttempted()
                     * .misrepresentationExplanation()
                     * .purchaseExplanation()
                     * .receivedAt()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerServicesMisrepresentation]. */
                class Builder internal constructor() {

                    private var cardholderCancellation: JsonField<CardholderCancellation>? = null
                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var misrepresentationExplanation: JsonField<String>? = null
                    private var purchaseExplanation: JsonField<String>? = null
                    private var receivedAt: JsonField<LocalDate>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerServicesMisrepresentation: ConsumerServicesMisrepresentation
                    ) = apply {
                        cardholderCancellation =
                            consumerServicesMisrepresentation.cardholderCancellation
                        merchantResolutionAttempted =
                            consumerServicesMisrepresentation.merchantResolutionAttempted
                        misrepresentationExplanation =
                            consumerServicesMisrepresentation.misrepresentationExplanation
                        purchaseExplanation = consumerServicesMisrepresentation.purchaseExplanation
                        receivedAt = consumerServicesMisrepresentation.receivedAt
                        additionalProperties =
                            consumerServicesMisrepresentation.additionalProperties.toMutableMap()
                    }

                    /** Cardholder cancellation. */
                    fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                        cardholderCancellation(JsonField.of(cardholderCancellation))

                    /**
                     * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderCancellation] with a well-typed
                     * [CardholderCancellation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun cardholderCancellation(
                        cardholderCancellation: JsonField<CardholderCancellation>
                    ) = apply { this.cardholderCancellation = cardholderCancellation }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Misrepresentation explanation. */
                    fun misrepresentationExplanation(misrepresentationExplanation: String) =
                        misrepresentationExplanation(JsonField.of(misrepresentationExplanation))

                    /**
                     * Sets [Builder.misrepresentationExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.misrepresentationExplanation] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun misrepresentationExplanation(
                        misrepresentationExplanation: JsonField<String>
                    ) = apply { this.misrepresentationExplanation = misrepresentationExplanation }

                    /** Purchase explanation. */
                    fun purchaseExplanation(purchaseExplanation: String) =
                        purchaseExplanation(JsonField.of(purchaseExplanation))

                    /**
                     * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseExplanation] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                        this.purchaseExplanation = purchaseExplanation
                    }

                    /** Received at. */
                    fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                    /**
                     * Sets [Builder.receivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                        this.receivedAt = receivedAt
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerServicesMisrepresentation].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .merchantResolutionAttempted()
                     * .misrepresentationExplanation()
                     * .purchaseExplanation()
                     * .receivedAt()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerServicesMisrepresentation =
                        ConsumerServicesMisrepresentation(
                            checkRequired("cardholderCancellation", cardholderCancellation),
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired(
                                "misrepresentationExplanation",
                                misrepresentationExplanation,
                            ),
                            checkRequired("purchaseExplanation", purchaseExplanation),
                            checkRequired("receivedAt", receivedAt),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerServicesMisrepresentation = apply {
                    if (validated) {
                        return@apply
                    }

                    cardholderCancellation().validate()
                    merchantResolutionAttempted().validate()
                    misrepresentationExplanation()
                    purchaseExplanation()
                    receivedAt()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cardholderCancellation.asKnown()?.validity() ?: 0) +
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (misrepresentationExplanation.asKnown() == null) 0 else 1) +
                        (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                        (if (receivedAt.asKnown() == null) 0 else 1)

                /** Cardholder cancellation. */
                class CardholderCancellation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val acceptedByMerchant: JsonField<AcceptedByMerchant>,
                    private val canceledAt: JsonField<LocalDate>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("accepted_by_merchant")
                        @ExcludeMissing
                        acceptedByMerchant: JsonField<AcceptedByMerchant> = JsonMissing.of(),
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(acceptedByMerchant, canceledAt, reason, mutableMapOf())

                    /**
                     * Accepted by merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun acceptedByMerchant(): AcceptedByMerchant =
                        acceptedByMerchant.getRequired("accepted_by_merchant")

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): String = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [acceptedByMerchant].
                     *
                     * Unlike [acceptedByMerchant], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("accepted_by_merchant")
                    @ExcludeMissing
                    fun _acceptedByMerchant(): JsonField<AcceptedByMerchant> = acceptedByMerchant

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderCancellation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .acceptedByMerchant()
                         * .canceledAt()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderCancellation]. */
                    class Builder internal constructor() {

                        private var acceptedByMerchant: JsonField<AcceptedByMerchant>? = null
                        private var canceledAt: JsonField<LocalDate>? = null
                        private var reason: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(cardholderCancellation: CardholderCancellation) = apply {
                            acceptedByMerchant = cardholderCancellation.acceptedByMerchant
                            canceledAt = cardholderCancellation.canceledAt
                            reason = cardholderCancellation.reason
                            additionalProperties =
                                cardholderCancellation.additionalProperties.toMutableMap()
                        }

                        /** Accepted by merchant. */
                        fun acceptedByMerchant(acceptedByMerchant: AcceptedByMerchant) =
                            acceptedByMerchant(JsonField.of(acceptedByMerchant))

                        /**
                         * Sets [Builder.acceptedByMerchant] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.acceptedByMerchant] with a well-typed
                         * [AcceptedByMerchant] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun acceptedByMerchant(acceptedByMerchant: JsonField<AcceptedByMerchant>) =
                            apply {
                                this.acceptedByMerchant = acceptedByMerchant
                            }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        /** Reason. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CardholderCancellation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .acceptedByMerchant()
                         * .canceledAt()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderCancellation =
                            CardholderCancellation(
                                checkRequired("acceptedByMerchant", acceptedByMerchant),
                                checkRequired("canceledAt", canceledAt),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderCancellation = apply {
                        if (validated) {
                            return@apply
                        }

                        acceptedByMerchant().validate()
                        canceledAt()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (acceptedByMerchant.asKnown()?.validity() ?: 0) +
                            (if (canceledAt.asKnown() == null) 0 else 1) +
                            (if (reason.asKnown() == null) 0 else 1)

                    /** Accepted by merchant. */
                    class AcceptedByMerchant
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Accepted. */
                            val ACCEPTED = of("accepted")

                            /** Not accepted. */
                            val NOT_ACCEPTED = of("not_accepted")

                            fun of(value: String) = AcceptedByMerchant(JsonField.of(value))
                        }

                        /** An enum containing [AcceptedByMerchant]'s known values. */
                        enum class Known {
                            /** Accepted. */
                            ACCEPTED,
                            /** Not accepted. */
                            NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AcceptedByMerchant]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AcceptedByMerchant] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Accepted. */
                            ACCEPTED,
                            /** Not accepted. */
                            NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AcceptedByMerchant] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ACCEPTED -> Value.ACCEPTED
                                NOT_ACCEPTED -> Value.NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ACCEPTED -> Known.ACCEPTED
                                NOT_ACCEPTED -> Known.NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AcceptedByMerchant: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AcceptedByMerchant = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AcceptedByMerchant && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderCancellation &&
                            acceptedByMerchant == other.acceptedByMerchant &&
                            canceledAt == other.canceledAt &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(acceptedByMerchant, canceledAt, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderCancellation{acceptedByMerchant=$acceptedByMerchant, canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerServicesMisrepresentation &&
                        cardholderCancellation == other.cardholderCancellation &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        misrepresentationExplanation == other.misrepresentationExplanation &&
                        purchaseExplanation == other.purchaseExplanation &&
                        receivedAt == other.receivedAt &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cardholderCancellation,
                        merchantResolutionAttempted,
                        misrepresentationExplanation,
                        purchaseExplanation,
                        receivedAt,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerServicesMisrepresentation{cardholderCancellation=$cardholderCancellation, merchantResolutionAttempted=$merchantResolutionAttempted, misrepresentationExplanation=$misrepresentationExplanation, purchaseExplanation=$purchaseExplanation, receivedAt=$receivedAt, additionalProperties=$additionalProperties}"
            }

            /**
             * Services not as described. Required if and only if `category` is
             * `consumer_services_not_as_described`.
             */
            class ConsumerServicesNotAsDescribed
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cardholderCancellation: JsonField<CardholderCancellation>,
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val receivedAt: JsonField<LocalDate>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    cardholderCancellation: JsonField<CardholderCancellation> = JsonMissing.of(),
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                ) : this(
                    cardholderCancellation,
                    merchantResolutionAttempted,
                    receivedAt,
                    mutableMapOf(),
                )

                /**
                 * Cardholder cancellation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun cardholderCancellation(): CardholderCancellation =
                    cardholderCancellation.getRequired("cardholder_cancellation")

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Received at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                /**
                 * Returns the raw JSON value of [cardholderCancellation].
                 *
                 * Unlike [cardholderCancellation], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("cardholder_cancellation")
                @ExcludeMissing
                fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                    cardholderCancellation

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [receivedAt].
                 *
                 * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("received_at")
                @ExcludeMissing
                fun _receivedAt(): JsonField<LocalDate> = receivedAt

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerServicesNotAsDescribed].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .merchantResolutionAttempted()
                     * .receivedAt()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerServicesNotAsDescribed]. */
                class Builder internal constructor() {

                    private var cardholderCancellation: JsonField<CardholderCancellation>? = null
                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var receivedAt: JsonField<LocalDate>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        consumerServicesNotAsDescribed: ConsumerServicesNotAsDescribed
                    ) = apply {
                        cardholderCancellation =
                            consumerServicesNotAsDescribed.cardholderCancellation
                        merchantResolutionAttempted =
                            consumerServicesNotAsDescribed.merchantResolutionAttempted
                        receivedAt = consumerServicesNotAsDescribed.receivedAt
                        additionalProperties =
                            consumerServicesNotAsDescribed.additionalProperties.toMutableMap()
                    }

                    /** Cardholder cancellation. */
                    fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                        cardholderCancellation(JsonField.of(cardholderCancellation))

                    /**
                     * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderCancellation] with a well-typed
                     * [CardholderCancellation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun cardholderCancellation(
                        cardholderCancellation: JsonField<CardholderCancellation>
                    ) = apply { this.cardholderCancellation = cardholderCancellation }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Received at. */
                    fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                    /**
                     * Sets [Builder.receivedAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.receivedAt] with a well-typed [LocalDate]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                        this.receivedAt = receivedAt
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerServicesNotAsDescribed].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderCancellation()
                     * .merchantResolutionAttempted()
                     * .receivedAt()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerServicesNotAsDescribed =
                        ConsumerServicesNotAsDescribed(
                            checkRequired("cardholderCancellation", cardholderCancellation),
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired("receivedAt", receivedAt),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerServicesNotAsDescribed = apply {
                    if (validated) {
                        return@apply
                    }

                    cardholderCancellation().validate()
                    merchantResolutionAttempted().validate()
                    receivedAt()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cardholderCancellation.asKnown()?.validity() ?: 0) +
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (receivedAt.asKnown() == null) 0 else 1)

                /** Cardholder cancellation. */
                class CardholderCancellation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val acceptedByMerchant: JsonField<AcceptedByMerchant>,
                    private val canceledAt: JsonField<LocalDate>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("accepted_by_merchant")
                        @ExcludeMissing
                        acceptedByMerchant: JsonField<AcceptedByMerchant> = JsonMissing.of(),
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(acceptedByMerchant, canceledAt, reason, mutableMapOf())

                    /**
                     * Accepted by merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun acceptedByMerchant(): AcceptedByMerchant =
                        acceptedByMerchant.getRequired("accepted_by_merchant")

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): String = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [acceptedByMerchant].
                     *
                     * Unlike [acceptedByMerchant], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("accepted_by_merchant")
                    @ExcludeMissing
                    fun _acceptedByMerchant(): JsonField<AcceptedByMerchant> = acceptedByMerchant

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderCancellation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .acceptedByMerchant()
                         * .canceledAt()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderCancellation]. */
                    class Builder internal constructor() {

                        private var acceptedByMerchant: JsonField<AcceptedByMerchant>? = null
                        private var canceledAt: JsonField<LocalDate>? = null
                        private var reason: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(cardholderCancellation: CardholderCancellation) = apply {
                            acceptedByMerchant = cardholderCancellation.acceptedByMerchant
                            canceledAt = cardholderCancellation.canceledAt
                            reason = cardholderCancellation.reason
                            additionalProperties =
                                cardholderCancellation.additionalProperties.toMutableMap()
                        }

                        /** Accepted by merchant. */
                        fun acceptedByMerchant(acceptedByMerchant: AcceptedByMerchant) =
                            acceptedByMerchant(JsonField.of(acceptedByMerchant))

                        /**
                         * Sets [Builder.acceptedByMerchant] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.acceptedByMerchant] with a well-typed
                         * [AcceptedByMerchant] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun acceptedByMerchant(acceptedByMerchant: JsonField<AcceptedByMerchant>) =
                            apply {
                                this.acceptedByMerchant = acceptedByMerchant
                            }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        /** Reason. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CardholderCancellation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .acceptedByMerchant()
                         * .canceledAt()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderCancellation =
                            CardholderCancellation(
                                checkRequired("acceptedByMerchant", acceptedByMerchant),
                                checkRequired("canceledAt", canceledAt),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderCancellation = apply {
                        if (validated) {
                            return@apply
                        }

                        acceptedByMerchant().validate()
                        canceledAt()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (acceptedByMerchant.asKnown()?.validity() ?: 0) +
                            (if (canceledAt.asKnown() == null) 0 else 1) +
                            (if (reason.asKnown() == null) 0 else 1)

                    /** Accepted by merchant. */
                    class AcceptedByMerchant
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Accepted. */
                            val ACCEPTED = of("accepted")

                            /** Not accepted. */
                            val NOT_ACCEPTED = of("not_accepted")

                            fun of(value: String) = AcceptedByMerchant(JsonField.of(value))
                        }

                        /** An enum containing [AcceptedByMerchant]'s known values. */
                        enum class Known {
                            /** Accepted. */
                            ACCEPTED,
                            /** Not accepted. */
                            NOT_ACCEPTED,
                        }

                        /**
                         * An enum containing [AcceptedByMerchant]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AcceptedByMerchant] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Accepted. */
                            ACCEPTED,
                            /** Not accepted. */
                            NOT_ACCEPTED,
                            /**
                             * An enum member indicating that [AcceptedByMerchant] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ACCEPTED -> Value.ACCEPTED
                                NOT_ACCEPTED -> Value.NOT_ACCEPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ACCEPTED -> Known.ACCEPTED
                                NOT_ACCEPTED -> Known.NOT_ACCEPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AcceptedByMerchant: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AcceptedByMerchant = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AcceptedByMerchant && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderCancellation &&
                            acceptedByMerchant == other.acceptedByMerchant &&
                            canceledAt == other.canceledAt &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(acceptedByMerchant, canceledAt, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderCancellation{acceptedByMerchant=$acceptedByMerchant, canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerServicesNotAsDescribed &&
                        cardholderCancellation == other.cardholderCancellation &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        receivedAt == other.receivedAt &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cardholderCancellation,
                        merchantResolutionAttempted,
                        receivedAt,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerServicesNotAsDescribed{cardholderCancellation=$cardholderCancellation, merchantResolutionAttempted=$merchantResolutionAttempted, receivedAt=$receivedAt, additionalProperties=$additionalProperties}"
            }

            /**
             * Services not received. Required if and only if `category` is
             * `consumer_services_not_received`.
             */
            class ConsumerServicesNotReceived
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cancellationOutcome: JsonField<CancellationOutcome>,
                private val lastExpectedReceiptAt: JsonField<LocalDate>,
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val purchaseInfoAndExplanation: JsonField<String>,
                private val cardholderCancellationPriorToExpectedReceipt:
                    JsonField<CardholderCancellationPriorToExpectedReceipt>,
                private val merchantCancellation: JsonField<MerchantCancellation>,
                private val noCancellation: JsonValue,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cancellation_outcome")
                    @ExcludeMissing
                    cancellationOutcome: JsonField<CancellationOutcome> = JsonMissing.of(),
                    @JsonProperty("last_expected_receipt_at")
                    @ExcludeMissing
                    lastExpectedReceiptAt: JsonField<LocalDate> = JsonMissing.of(),
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("purchase_info_and_explanation")
                    @ExcludeMissing
                    purchaseInfoAndExplanation: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                    @ExcludeMissing
                    cardholderCancellationPriorToExpectedReceipt:
                        JsonField<CardholderCancellationPriorToExpectedReceipt> =
                        JsonMissing.of(),
                    @JsonProperty("merchant_cancellation")
                    @ExcludeMissing
                    merchantCancellation: JsonField<MerchantCancellation> = JsonMissing.of(),
                    @JsonProperty("no_cancellation")
                    @ExcludeMissing
                    noCancellation: JsonValue = JsonMissing.of(),
                ) : this(
                    cancellationOutcome,
                    lastExpectedReceiptAt,
                    merchantResolutionAttempted,
                    purchaseInfoAndExplanation,
                    cardholderCancellationPriorToExpectedReceipt,
                    merchantCancellation,
                    noCancellation,
                    mutableMapOf(),
                )

                /**
                 * Cancellation outcome.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun cancellationOutcome(): CancellationOutcome =
                    cancellationOutcome.getRequired("cancellation_outcome")

                /**
                 * Last expected receipt at.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun lastExpectedReceiptAt(): LocalDate =
                    lastExpectedReceiptAt.getRequired("last_expected_receipt_at")

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Purchase information and explanation.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun purchaseInfoAndExplanation(): String =
                    purchaseInfoAndExplanation.getRequired("purchase_info_and_explanation")

                /**
                 * Cardholder cancellation prior to expected receipt. Required if and only if
                 * `cancellation_outcome` is `cardholder_cancellation_prior_to_expected_receipt`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun cardholderCancellationPriorToExpectedReceipt():
                    CardholderCancellationPriorToExpectedReceipt? =
                    cardholderCancellationPriorToExpectedReceipt.getNullable(
                        "cardholder_cancellation_prior_to_expected_receipt"
                    )

                /**
                 * Merchant cancellation. Required if and only if `cancellation_outcome` is
                 * `merchant_cancellation`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun merchantCancellation(): MerchantCancellation? =
                    merchantCancellation.getNullable("merchant_cancellation")

                /**
                 * No cancellation. Required if and only if `cancellation_outcome` is
                 * `no_cancellation`.
                 */
                @JsonProperty("no_cancellation")
                @ExcludeMissing
                fun _noCancellation(): JsonValue = noCancellation

                /**
                 * Returns the raw JSON value of [cancellationOutcome].
                 *
                 * Unlike [cancellationOutcome], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("cancellation_outcome")
                @ExcludeMissing
                fun _cancellationOutcome(): JsonField<CancellationOutcome> = cancellationOutcome

                /**
                 * Returns the raw JSON value of [lastExpectedReceiptAt].
                 *
                 * Unlike [lastExpectedReceiptAt], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("last_expected_receipt_at")
                @ExcludeMissing
                fun _lastExpectedReceiptAt(): JsonField<LocalDate> = lastExpectedReceiptAt

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [purchaseInfoAndExplanation].
                 *
                 * Unlike [purchaseInfoAndExplanation], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("purchase_info_and_explanation")
                @ExcludeMissing
                fun _purchaseInfoAndExplanation(): JsonField<String> = purchaseInfoAndExplanation

                /**
                 * Returns the raw JSON value of [cardholderCancellationPriorToExpectedReceipt].
                 *
                 * Unlike [cardholderCancellationPriorToExpectedReceipt], this method doesn't throw
                 * if the JSON field has an unexpected type.
                 */
                @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                @ExcludeMissing
                fun _cardholderCancellationPriorToExpectedReceipt():
                    JsonField<CardholderCancellationPriorToExpectedReceipt> =
                    cardholderCancellationPriorToExpectedReceipt

                /**
                 * Returns the raw JSON value of [merchantCancellation].
                 *
                 * Unlike [merchantCancellation], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("merchant_cancellation")
                @ExcludeMissing
                fun _merchantCancellation(): JsonField<MerchantCancellation> = merchantCancellation

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [ConsumerServicesNotReceived].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cancellationOutcome()
                     * .lastExpectedReceiptAt()
                     * .merchantResolutionAttempted()
                     * .purchaseInfoAndExplanation()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ConsumerServicesNotReceived]. */
                class Builder internal constructor() {

                    private var cancellationOutcome: JsonField<CancellationOutcome>? = null
                    private var lastExpectedReceiptAt: JsonField<LocalDate>? = null
                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var purchaseInfoAndExplanation: JsonField<String>? = null
                    private var cardholderCancellationPriorToExpectedReceipt:
                        JsonField<CardholderCancellationPriorToExpectedReceipt> =
                        JsonMissing.of()
                    private var merchantCancellation: JsonField<MerchantCancellation> =
                        JsonMissing.of()
                    private var noCancellation: JsonValue = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(consumerServicesNotReceived: ConsumerServicesNotReceived) =
                        apply {
                            cancellationOutcome = consumerServicesNotReceived.cancellationOutcome
                            lastExpectedReceiptAt =
                                consumerServicesNotReceived.lastExpectedReceiptAt
                            merchantResolutionAttempted =
                                consumerServicesNotReceived.merchantResolutionAttempted
                            purchaseInfoAndExplanation =
                                consumerServicesNotReceived.purchaseInfoAndExplanation
                            cardholderCancellationPriorToExpectedReceipt =
                                consumerServicesNotReceived
                                    .cardholderCancellationPriorToExpectedReceipt
                            merchantCancellation = consumerServicesNotReceived.merchantCancellation
                            noCancellation = consumerServicesNotReceived.noCancellation
                            additionalProperties =
                                consumerServicesNotReceived.additionalProperties.toMutableMap()
                        }

                    /** Cancellation outcome. */
                    fun cancellationOutcome(cancellationOutcome: CancellationOutcome) =
                        cancellationOutcome(JsonField.of(cancellationOutcome))

                    /**
                     * Sets [Builder.cancellationOutcome] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cancellationOutcome] with a well-typed
                     * [CancellationOutcome] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun cancellationOutcome(cancellationOutcome: JsonField<CancellationOutcome>) =
                        apply {
                            this.cancellationOutcome = cancellationOutcome
                        }

                    /** Last expected receipt at. */
                    fun lastExpectedReceiptAt(lastExpectedReceiptAt: LocalDate) =
                        lastExpectedReceiptAt(JsonField.of(lastExpectedReceiptAt))

                    /**
                     * Sets [Builder.lastExpectedReceiptAt] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.lastExpectedReceiptAt] with a well-typed
                     * [LocalDate] value instead. This method is primarily for setting the field to
                     * an undocumented or not yet supported value.
                     */
                    fun lastExpectedReceiptAt(lastExpectedReceiptAt: JsonField<LocalDate>) = apply {
                        this.lastExpectedReceiptAt = lastExpectedReceiptAt
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /** Purchase information and explanation. */
                    fun purchaseInfoAndExplanation(purchaseInfoAndExplanation: String) =
                        purchaseInfoAndExplanation(JsonField.of(purchaseInfoAndExplanation))

                    /**
                     * Sets [Builder.purchaseInfoAndExplanation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseInfoAndExplanation] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun purchaseInfoAndExplanation(purchaseInfoAndExplanation: JsonField<String>) =
                        apply {
                            this.purchaseInfoAndExplanation = purchaseInfoAndExplanation
                        }

                    /**
                     * Cardholder cancellation prior to expected receipt. Required if and only if
                     * `cancellation_outcome` is
                     * `cardholder_cancellation_prior_to_expected_receipt`.
                     */
                    fun cardholderCancellationPriorToExpectedReceipt(
                        cardholderCancellationPriorToExpectedReceipt:
                            CardholderCancellationPriorToExpectedReceipt
                    ) =
                        cardholderCancellationPriorToExpectedReceipt(
                            JsonField.of(cardholderCancellationPriorToExpectedReceipt)
                        )

                    /**
                     * Sets [Builder.cardholderCancellationPriorToExpectedReceipt] to an arbitrary
                     * JSON value.
                     *
                     * You should usually call
                     * [Builder.cardholderCancellationPriorToExpectedReceipt] with a well-typed
                     * [CardholderCancellationPriorToExpectedReceipt] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun cardholderCancellationPriorToExpectedReceipt(
                        cardholderCancellationPriorToExpectedReceipt:
                            JsonField<CardholderCancellationPriorToExpectedReceipt>
                    ) = apply {
                        this.cardholderCancellationPriorToExpectedReceipt =
                            cardholderCancellationPriorToExpectedReceipt
                    }

                    /**
                     * Merchant cancellation. Required if and only if `cancellation_outcome` is
                     * `merchant_cancellation`.
                     */
                    fun merchantCancellation(merchantCancellation: MerchantCancellation) =
                        merchantCancellation(JsonField.of(merchantCancellation))

                    /**
                     * Sets [Builder.merchantCancellation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantCancellation] with a well-typed
                     * [MerchantCancellation] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun merchantCancellation(
                        merchantCancellation: JsonField<MerchantCancellation>
                    ) = apply { this.merchantCancellation = merchantCancellation }

                    /**
                     * No cancellation. Required if and only if `cancellation_outcome` is
                     * `no_cancellation`.
                     */
                    fun noCancellation(noCancellation: JsonValue) = apply {
                        this.noCancellation = noCancellation
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ConsumerServicesNotReceived].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cancellationOutcome()
                     * .lastExpectedReceiptAt()
                     * .merchantResolutionAttempted()
                     * .purchaseInfoAndExplanation()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ConsumerServicesNotReceived =
                        ConsumerServicesNotReceived(
                            checkRequired("cancellationOutcome", cancellationOutcome),
                            checkRequired("lastExpectedReceiptAt", lastExpectedReceiptAt),
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            checkRequired("purchaseInfoAndExplanation", purchaseInfoAndExplanation),
                            cardholderCancellationPriorToExpectedReceipt,
                            merchantCancellation,
                            noCancellation,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ConsumerServicesNotReceived = apply {
                    if (validated) {
                        return@apply
                    }

                    cancellationOutcome().validate()
                    lastExpectedReceiptAt()
                    merchantResolutionAttempted().validate()
                    purchaseInfoAndExplanation()
                    cardholderCancellationPriorToExpectedReceipt()?.validate()
                    merchantCancellation()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cancellationOutcome.asKnown()?.validity() ?: 0) +
                        (if (lastExpectedReceiptAt.asKnown() == null) 0 else 1) +
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (if (purchaseInfoAndExplanation.asKnown() == null) 0 else 1) +
                        (cardholderCancellationPriorToExpectedReceipt.asKnown()?.validity() ?: 0) +
                        (merchantCancellation.asKnown()?.validity() ?: 0)

                /** Cancellation outcome. */
                class CancellationOutcome
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Cardholder cancellation prior to expected receipt. */
                        val CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT =
                            of("cardholder_cancellation_prior_to_expected_receipt")

                        /** Merchant cancellation. */
                        val MERCHANT_CANCELLATION = of("merchant_cancellation")

                        /** No cancellation. */
                        val NO_CANCELLATION = of("no_cancellation")

                        fun of(value: String) = CancellationOutcome(JsonField.of(value))
                    }

                    /** An enum containing [CancellationOutcome]'s known values. */
                    enum class Known {
                        /** Cardholder cancellation prior to expected receipt. */
                        CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                        /** Merchant cancellation. */
                        MERCHANT_CANCELLATION,
                        /** No cancellation. */
                        NO_CANCELLATION,
                    }

                    /**
                     * An enum containing [CancellationOutcome]'s known values, as well as an
                     * [_UNKNOWN] member.
                     *
                     * An instance of [CancellationOutcome] can contain an unknown value in a couple
                     * of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Cardholder cancellation prior to expected receipt. */
                        CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                        /** Merchant cancellation. */
                        MERCHANT_CANCELLATION,
                        /** No cancellation. */
                        NO_CANCELLATION,
                        /**
                         * An enum member indicating that [CancellationOutcome] was instantiated
                         * with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                Value.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                            MERCHANT_CANCELLATION -> Value.MERCHANT_CANCELLATION
                            NO_CANCELLATION -> Value.NO_CANCELLATION
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                Known.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                            MERCHANT_CANCELLATION -> Known.MERCHANT_CANCELLATION
                            NO_CANCELLATION -> Known.NO_CANCELLATION
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown CancellationOutcome: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): CancellationOutcome = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CancellationOutcome && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Cardholder cancellation prior to expected receipt. Required if and only if
                 * `cancellation_outcome` is `cardholder_cancellation_prior_to_expected_receipt`.
                 */
                class CardholderCancellationPriorToExpectedReceipt
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val canceledAt: JsonField<LocalDate>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(canceledAt, reason, mutableMapOf())

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun reason(): String? = reason.getNullable("reason")

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderCancellationPriorToExpectedReceipt].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderCancellationPriorToExpectedReceipt]. */
                    class Builder internal constructor() {

                        private var canceledAt: JsonField<LocalDate>? = null
                        private var reason: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            cardholderCancellationPriorToExpectedReceipt:
                                CardholderCancellationPriorToExpectedReceipt
                        ) = apply {
                            canceledAt = cardholderCancellationPriorToExpectedReceipt.canceledAt
                            reason = cardholderCancellationPriorToExpectedReceipt.reason
                            additionalProperties =
                                cardholderCancellationPriorToExpectedReceipt.additionalProperties
                                    .toMutableMap()
                        }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        /** Reason. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of
                         * [CardholderCancellationPriorToExpectedReceipt].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderCancellationPriorToExpectedReceipt =
                            CardholderCancellationPriorToExpectedReceipt(
                                checkRequired("canceledAt", canceledAt),
                                reason,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderCancellationPriorToExpectedReceipt = apply {
                        if (validated) {
                            return@apply
                        }

                        canceledAt()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (canceledAt.asKnown() == null) 0 else 1) +
                            (if (reason.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderCancellationPriorToExpectedReceipt &&
                            canceledAt == other.canceledAt &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(canceledAt, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderCancellationPriorToExpectedReceipt{canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /**
                 * Merchant cancellation. Required if and only if `cancellation_outcome` is
                 * `merchant_cancellation`.
                 */
                class MerchantCancellation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val canceledAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        canceledAt: JsonField<LocalDate> = JsonMissing.of()
                    ) : this(canceledAt, mutableMapOf())

                    /**
                     * Canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                    /**
                     * Returns the raw JSON value of [canceledAt].
                     *
                     * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("canceled_at")
                    @ExcludeMissing
                    fun _canceledAt(): JsonField<LocalDate> = canceledAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [MerchantCancellation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [MerchantCancellation]. */
                    class Builder internal constructor() {

                        private var canceledAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(merchantCancellation: MerchantCancellation) = apply {
                            canceledAt = merchantCancellation.canceledAt
                            additionalProperties =
                                merchantCancellation.additionalProperties.toMutableMap()
                        }

                        /** Canceled at. */
                        fun canceledAt(canceledAt: LocalDate) = canceledAt(JsonField.of(canceledAt))

                        /**
                         * Sets [Builder.canceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                            this.canceledAt = canceledAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [MerchantCancellation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): MerchantCancellation =
                            MerchantCancellation(
                                checkRequired("canceledAt", canceledAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): MerchantCancellation = apply {
                        if (validated) {
                            return@apply
                        }

                        canceledAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (canceledAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantCancellation &&
                            canceledAt == other.canceledAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(canceledAt, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "MerchantCancellation{canceledAt=$canceledAt, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ConsumerServicesNotReceived &&
                        cancellationOutcome == other.cancellationOutcome &&
                        lastExpectedReceiptAt == other.lastExpectedReceiptAt &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        purchaseInfoAndExplanation == other.purchaseInfoAndExplanation &&
                        cardholderCancellationPriorToExpectedReceipt ==
                            other.cardholderCancellationPriorToExpectedReceipt &&
                        merchantCancellation == other.merchantCancellation &&
                        noCancellation == other.noCancellation &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cancellationOutcome,
                        lastExpectedReceiptAt,
                        merchantResolutionAttempted,
                        purchaseInfoAndExplanation,
                        cardholderCancellationPriorToExpectedReceipt,
                        merchantCancellation,
                        noCancellation,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ConsumerServicesNotReceived{cancellationOutcome=$cancellationOutcome, lastExpectedReceiptAt=$lastExpectedReceiptAt, merchantResolutionAttempted=$merchantResolutionAttempted, purchaseInfoAndExplanation=$purchaseInfoAndExplanation, cardholderCancellationPriorToExpectedReceipt=$cardholderCancellationPriorToExpectedReceipt, merchantCancellation=$merchantCancellation, noCancellation=$noCancellation, additionalProperties=$additionalProperties}"
            }

            /** Fraud. Required if and only if `category` is `fraud`. */
            class Fraud
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val fraudType: JsonField<FraudType>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("fraud_type")
                    @ExcludeMissing
                    fraudType: JsonField<FraudType> = JsonMissing.of()
                ) : this(fraudType, mutableMapOf())

                /**
                 * Fraud type.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun fraudType(): FraudType = fraudType.getRequired("fraud_type")

                /**
                 * Returns the raw JSON value of [fraudType].
                 *
                 * Unlike [fraudType], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("fraud_type")
                @ExcludeMissing
                fun _fraudType(): JsonField<FraudType> = fraudType

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Fraud].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .fraudType()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Fraud]. */
                class Builder internal constructor() {

                    private var fraudType: JsonField<FraudType>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(fraud: Fraud) = apply {
                        fraudType = fraud.fraudType
                        additionalProperties = fraud.additionalProperties.toMutableMap()
                    }

                    /** Fraud type. */
                    fun fraudType(fraudType: FraudType) = fraudType(JsonField.of(fraudType))

                    /**
                     * Sets [Builder.fraudType] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.fraudType] with a well-typed [FraudType]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun fraudType(fraudType: JsonField<FraudType>) = apply {
                        this.fraudType = fraudType
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Fraud].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .fraudType()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Fraud =
                        Fraud(
                            checkRequired("fraudType", fraudType),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Fraud = apply {
                    if (validated) {
                        return@apply
                    }

                    fraudType().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = (fraudType.asKnown()?.validity() ?: 0)

                /** Fraud type. */
                class FraudType
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Account or credentials takeover. */
                        val ACCOUNT_OR_CREDENTIALS_TAKEOVER = of("account_or_credentials_takeover")

                        /** Card not received as issued. */
                        val CARD_NOT_RECEIVED_AS_ISSUED = of("card_not_received_as_issued")

                        /** Fraudulent application. */
                        val FRAUDULENT_APPLICATION = of("fraudulent_application")

                        /** Fraudulent use of account number. */
                        val FRAUDULENT_USE_OF_ACCOUNT_NUMBER =
                            of("fraudulent_use_of_account_number")

                        /** Incorrect processing. */
                        val INCORRECT_PROCESSING = of("incorrect_processing")

                        /** Issuer reported counterfeit. */
                        val ISSUER_REPORTED_COUNTERFEIT = of("issuer_reported_counterfeit")

                        /** Lost. */
                        val LOST = of("lost")

                        /** Manipulation of account holder. */
                        val MANIPULATION_OF_ACCOUNT_HOLDER = of("manipulation_of_account_holder")

                        /** Merchant misrepresentation. */
                        val MERCHANT_MISREPRESENTATION = of("merchant_misrepresentation")

                        /** Miscellaneous. */
                        val MISCELLANEOUS = of("miscellaneous")

                        /** Stolen. */
                        val STOLEN = of("stolen")

                        fun of(value: String) = FraudType(JsonField.of(value))
                    }

                    /** An enum containing [FraudType]'s known values. */
                    enum class Known {
                        /** Account or credentials takeover. */
                        ACCOUNT_OR_CREDENTIALS_TAKEOVER,
                        /** Card not received as issued. */
                        CARD_NOT_RECEIVED_AS_ISSUED,
                        /** Fraudulent application. */
                        FRAUDULENT_APPLICATION,
                        /** Fraudulent use of account number. */
                        FRAUDULENT_USE_OF_ACCOUNT_NUMBER,
                        /** Incorrect processing. */
                        INCORRECT_PROCESSING,
                        /** Issuer reported counterfeit. */
                        ISSUER_REPORTED_COUNTERFEIT,
                        /** Lost. */
                        LOST,
                        /** Manipulation of account holder. */
                        MANIPULATION_OF_ACCOUNT_HOLDER,
                        /** Merchant misrepresentation. */
                        MERCHANT_MISREPRESENTATION,
                        /** Miscellaneous. */
                        MISCELLANEOUS,
                        /** Stolen. */
                        STOLEN,
                    }

                    /**
                     * An enum containing [FraudType]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [FraudType] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Account or credentials takeover. */
                        ACCOUNT_OR_CREDENTIALS_TAKEOVER,
                        /** Card not received as issued. */
                        CARD_NOT_RECEIVED_AS_ISSUED,
                        /** Fraudulent application. */
                        FRAUDULENT_APPLICATION,
                        /** Fraudulent use of account number. */
                        FRAUDULENT_USE_OF_ACCOUNT_NUMBER,
                        /** Incorrect processing. */
                        INCORRECT_PROCESSING,
                        /** Issuer reported counterfeit. */
                        ISSUER_REPORTED_COUNTERFEIT,
                        /** Lost. */
                        LOST,
                        /** Manipulation of account holder. */
                        MANIPULATION_OF_ACCOUNT_HOLDER,
                        /** Merchant misrepresentation. */
                        MERCHANT_MISREPRESENTATION,
                        /** Miscellaneous. */
                        MISCELLANEOUS,
                        /** Stolen. */
                        STOLEN,
                        /**
                         * An enum member indicating that [FraudType] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ACCOUNT_OR_CREDENTIALS_TAKEOVER -> Value.ACCOUNT_OR_CREDENTIALS_TAKEOVER
                            CARD_NOT_RECEIVED_AS_ISSUED -> Value.CARD_NOT_RECEIVED_AS_ISSUED
                            FRAUDULENT_APPLICATION -> Value.FRAUDULENT_APPLICATION
                            FRAUDULENT_USE_OF_ACCOUNT_NUMBER ->
                                Value.FRAUDULENT_USE_OF_ACCOUNT_NUMBER
                            INCORRECT_PROCESSING -> Value.INCORRECT_PROCESSING
                            ISSUER_REPORTED_COUNTERFEIT -> Value.ISSUER_REPORTED_COUNTERFEIT
                            LOST -> Value.LOST
                            MANIPULATION_OF_ACCOUNT_HOLDER -> Value.MANIPULATION_OF_ACCOUNT_HOLDER
                            MERCHANT_MISREPRESENTATION -> Value.MERCHANT_MISREPRESENTATION
                            MISCELLANEOUS -> Value.MISCELLANEOUS
                            STOLEN -> Value.STOLEN
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ACCOUNT_OR_CREDENTIALS_TAKEOVER -> Known.ACCOUNT_OR_CREDENTIALS_TAKEOVER
                            CARD_NOT_RECEIVED_AS_ISSUED -> Known.CARD_NOT_RECEIVED_AS_ISSUED
                            FRAUDULENT_APPLICATION -> Known.FRAUDULENT_APPLICATION
                            FRAUDULENT_USE_OF_ACCOUNT_NUMBER ->
                                Known.FRAUDULENT_USE_OF_ACCOUNT_NUMBER
                            INCORRECT_PROCESSING -> Known.INCORRECT_PROCESSING
                            ISSUER_REPORTED_COUNTERFEIT -> Known.ISSUER_REPORTED_COUNTERFEIT
                            LOST -> Known.LOST
                            MANIPULATION_OF_ACCOUNT_HOLDER -> Known.MANIPULATION_OF_ACCOUNT_HOLDER
                            MERCHANT_MISREPRESENTATION -> Known.MERCHANT_MISREPRESENTATION
                            MISCELLANEOUS -> Known.MISCELLANEOUS
                            STOLEN -> Known.STOLEN
                            else -> throw IncreaseInvalidDataException("Unknown FraudType: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): FraudType = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is FraudType && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Fraud &&
                        fraudType == other.fraudType &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy { Objects.hash(fraudType, additionalProperties) }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Fraud{fraudType=$fraudType, additionalProperties=$additionalProperties}"
            }

            /** Processing error. Required if and only if `category` is `processing_error`. */
            class ProcessingError
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val errorReason: JsonField<ErrorReason>,
                private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                private val duplicateTransaction: JsonField<DuplicateTransaction>,
                private val incorrectAmount: JsonField<IncorrectAmount>,
                private val paidByOtherMeans: JsonField<PaidByOtherMeans>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("error_reason")
                    @ExcludeMissing
                    errorReason: JsonField<ErrorReason> = JsonMissing.of(),
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                        JsonMissing.of(),
                    @JsonProperty("duplicate_transaction")
                    @ExcludeMissing
                    duplicateTransaction: JsonField<DuplicateTransaction> = JsonMissing.of(),
                    @JsonProperty("incorrect_amount")
                    @ExcludeMissing
                    incorrectAmount: JsonField<IncorrectAmount> = JsonMissing.of(),
                    @JsonProperty("paid_by_other_means")
                    @ExcludeMissing
                    paidByOtherMeans: JsonField<PaidByOtherMeans> = JsonMissing.of(),
                ) : this(
                    errorReason,
                    merchantResolutionAttempted,
                    duplicateTransaction,
                    incorrectAmount,
                    paidByOtherMeans,
                    mutableMapOf(),
                )

                /**
                 * Error reason.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun errorReason(): ErrorReason = errorReason.getRequired("error_reason")

                /**
                 * Merchant resolution attempted.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                    merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                /**
                 * Duplicate transaction. Required if and only if `error_reason` is
                 * `duplicate_transaction`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun duplicateTransaction(): DuplicateTransaction? =
                    duplicateTransaction.getNullable("duplicate_transaction")

                /**
                 * Incorrect amount. Required if and only if `error_reason` is `incorrect_amount`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun incorrectAmount(): IncorrectAmount? =
                    incorrectAmount.getNullable("incorrect_amount")

                /**
                 * Paid by other means. Required if and only if `error_reason` is
                 * `paid_by_other_means`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun paidByOtherMeans(): PaidByOtherMeans? =
                    paidByOtherMeans.getNullable("paid_by_other_means")

                /**
                 * Returns the raw JSON value of [errorReason].
                 *
                 * Unlike [errorReason], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("error_reason")
                @ExcludeMissing
                fun _errorReason(): JsonField<ErrorReason> = errorReason

                /**
                 * Returns the raw JSON value of [merchantResolutionAttempted].
                 *
                 * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("merchant_resolution_attempted")
                @ExcludeMissing
                fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                    merchantResolutionAttempted

                /**
                 * Returns the raw JSON value of [duplicateTransaction].
                 *
                 * Unlike [duplicateTransaction], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("duplicate_transaction")
                @ExcludeMissing
                fun _duplicateTransaction(): JsonField<DuplicateTransaction> = duplicateTransaction

                /**
                 * Returns the raw JSON value of [incorrectAmount].
                 *
                 * Unlike [incorrectAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("incorrect_amount")
                @ExcludeMissing
                fun _incorrectAmount(): JsonField<IncorrectAmount> = incorrectAmount

                /**
                 * Returns the raw JSON value of [paidByOtherMeans].
                 *
                 * Unlike [paidByOtherMeans], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("paid_by_other_means")
                @ExcludeMissing
                fun _paidByOtherMeans(): JsonField<PaidByOtherMeans> = paidByOtherMeans

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [ProcessingError].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .errorReason()
                     * .merchantResolutionAttempted()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [ProcessingError]. */
                class Builder internal constructor() {

                    private var errorReason: JsonField<ErrorReason>? = null
                    private var merchantResolutionAttempted:
                        JsonField<MerchantResolutionAttempted>? =
                        null
                    private var duplicateTransaction: JsonField<DuplicateTransaction> =
                        JsonMissing.of()
                    private var incorrectAmount: JsonField<IncorrectAmount> = JsonMissing.of()
                    private var paidByOtherMeans: JsonField<PaidByOtherMeans> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(processingError: ProcessingError) = apply {
                        errorReason = processingError.errorReason
                        merchantResolutionAttempted = processingError.merchantResolutionAttempted
                        duplicateTransaction = processingError.duplicateTransaction
                        incorrectAmount = processingError.incorrectAmount
                        paidByOtherMeans = processingError.paidByOtherMeans
                        additionalProperties = processingError.additionalProperties.toMutableMap()
                    }

                    /** Error reason. */
                    fun errorReason(errorReason: ErrorReason) =
                        errorReason(JsonField.of(errorReason))

                    /**
                     * Sets [Builder.errorReason] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.errorReason] with a well-typed [ErrorReason]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun errorReason(errorReason: JsonField<ErrorReason>) = apply {
                        this.errorReason = errorReason
                    }

                    /** Merchant resolution attempted. */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: MerchantResolutionAttempted
                    ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                    /**
                     * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.merchantResolutionAttempted] with a
                     * well-typed [MerchantResolutionAttempted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun merchantResolutionAttempted(
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                    ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                    /**
                     * Duplicate transaction. Required if and only if `error_reason` is
                     * `duplicate_transaction`.
                     */
                    fun duplicateTransaction(duplicateTransaction: DuplicateTransaction) =
                        duplicateTransaction(JsonField.of(duplicateTransaction))

                    /**
                     * Sets [Builder.duplicateTransaction] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.duplicateTransaction] with a well-typed
                     * [DuplicateTransaction] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun duplicateTransaction(
                        duplicateTransaction: JsonField<DuplicateTransaction>
                    ) = apply { this.duplicateTransaction = duplicateTransaction }

                    /**
                     * Incorrect amount. Required if and only if `error_reason` is
                     * `incorrect_amount`.
                     */
                    fun incorrectAmount(incorrectAmount: IncorrectAmount) =
                        incorrectAmount(JsonField.of(incorrectAmount))

                    /**
                     * Sets [Builder.incorrectAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.incorrectAmount] with a well-typed
                     * [IncorrectAmount] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun incorrectAmount(incorrectAmount: JsonField<IncorrectAmount>) = apply {
                        this.incorrectAmount = incorrectAmount
                    }

                    /**
                     * Paid by other means. Required if and only if `error_reason` is
                     * `paid_by_other_means`.
                     */
                    fun paidByOtherMeans(paidByOtherMeans: PaidByOtherMeans) =
                        paidByOtherMeans(JsonField.of(paidByOtherMeans))

                    /**
                     * Sets [Builder.paidByOtherMeans] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.paidByOtherMeans] with a well-typed
                     * [PaidByOtherMeans] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun paidByOtherMeans(paidByOtherMeans: JsonField<PaidByOtherMeans>) = apply {
                        this.paidByOtherMeans = paidByOtherMeans
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [ProcessingError].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .errorReason()
                     * .merchantResolutionAttempted()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): ProcessingError =
                        ProcessingError(
                            checkRequired("errorReason", errorReason),
                            checkRequired(
                                "merchantResolutionAttempted",
                                merchantResolutionAttempted,
                            ),
                            duplicateTransaction,
                            incorrectAmount,
                            paidByOtherMeans,
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): ProcessingError = apply {
                    if (validated) {
                        return@apply
                    }

                    errorReason().validate()
                    merchantResolutionAttempted().validate()
                    duplicateTransaction()?.validate()
                    incorrectAmount()?.validate()
                    paidByOtherMeans()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (errorReason.asKnown()?.validity() ?: 0) +
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                        (duplicateTransaction.asKnown()?.validity() ?: 0) +
                        (incorrectAmount.asKnown()?.validity() ?: 0) +
                        (paidByOtherMeans.asKnown()?.validity() ?: 0)

                /** Error reason. */
                class ErrorReason
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Duplicate transaction. */
                        val DUPLICATE_TRANSACTION = of("duplicate_transaction")

                        /** Incorrect amount. */
                        val INCORRECT_AMOUNT = of("incorrect_amount")

                        /** Paid by other means. */
                        val PAID_BY_OTHER_MEANS = of("paid_by_other_means")

                        fun of(value: String) = ErrorReason(JsonField.of(value))
                    }

                    /** An enum containing [ErrorReason]'s known values. */
                    enum class Known {
                        /** Duplicate transaction. */
                        DUPLICATE_TRANSACTION,
                        /** Incorrect amount. */
                        INCORRECT_AMOUNT,
                        /** Paid by other means. */
                        PAID_BY_OTHER_MEANS,
                    }

                    /**
                     * An enum containing [ErrorReason]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [ErrorReason] can contain an unknown value in a couple of
                     * cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Duplicate transaction. */
                        DUPLICATE_TRANSACTION,
                        /** Incorrect amount. */
                        INCORRECT_AMOUNT,
                        /** Paid by other means. */
                        PAID_BY_OTHER_MEANS,
                        /**
                         * An enum member indicating that [ErrorReason] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            DUPLICATE_TRANSACTION -> Value.DUPLICATE_TRANSACTION
                            INCORRECT_AMOUNT -> Value.INCORRECT_AMOUNT
                            PAID_BY_OTHER_MEANS -> Value.PAID_BY_OTHER_MEANS
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            DUPLICATE_TRANSACTION -> Known.DUPLICATE_TRANSACTION
                            INCORRECT_AMOUNT -> Known.INCORRECT_AMOUNT
                            PAID_BY_OTHER_MEANS -> Known.PAID_BY_OTHER_MEANS
                            else ->
                                throw IncreaseInvalidDataException("Unknown ErrorReason: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): ErrorReason = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ErrorReason && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Merchant resolution attempted. */
                class MerchantResolutionAttempted
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Attempted. */
                        val ATTEMPTED = of("attempted")

                        /** Prohibited by local law. */
                        val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                        fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                    }

                    /** An enum containing [MerchantResolutionAttempted]'s known values. */
                    enum class Known {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                    }

                    /**
                     * An enum containing [MerchantResolutionAttempted]'s known values, as well as
                     * an [_UNKNOWN] member.
                     *
                     * An instance of [MerchantResolutionAttempted] can contain an unknown value in
                     * a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Attempted. */
                        ATTEMPTED,
                        /** Prohibited by local law. */
                        PROHIBITED_BY_LOCAL_LAW,
                        /**
                         * An enum member indicating that [MerchantResolutionAttempted] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            ATTEMPTED -> Value.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            ATTEMPTED -> Known.ATTEMPTED
                            PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown MerchantResolutionAttempted: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): MerchantResolutionAttempted = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is MerchantResolutionAttempted && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Duplicate transaction. Required if and only if `error_reason` is
                 * `duplicate_transaction`.
                 */
                class DuplicateTransaction
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val otherTransactionId: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("other_transaction_id")
                        @ExcludeMissing
                        otherTransactionId: JsonField<String> = JsonMissing.of()
                    ) : this(otherTransactionId, mutableMapOf())

                    /**
                     * Other transaction ID.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun otherTransactionId(): String =
                        otherTransactionId.getRequired("other_transaction_id")

                    /**
                     * Returns the raw JSON value of [otherTransactionId].
                     *
                     * Unlike [otherTransactionId], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("other_transaction_id")
                    @ExcludeMissing
                    fun _otherTransactionId(): JsonField<String> = otherTransactionId

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [DuplicateTransaction].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .otherTransactionId()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [DuplicateTransaction]. */
                    class Builder internal constructor() {

                        private var otherTransactionId: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(duplicateTransaction: DuplicateTransaction) = apply {
                            otherTransactionId = duplicateTransaction.otherTransactionId
                            additionalProperties =
                                duplicateTransaction.additionalProperties.toMutableMap()
                        }

                        /** Other transaction ID. */
                        fun otherTransactionId(otherTransactionId: String) =
                            otherTransactionId(JsonField.of(otherTransactionId))

                        /**
                         * Sets [Builder.otherTransactionId] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherTransactionId] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun otherTransactionId(otherTransactionId: JsonField<String>) = apply {
                            this.otherTransactionId = otherTransactionId
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [DuplicateTransaction].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .otherTransactionId()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): DuplicateTransaction =
                            DuplicateTransaction(
                                checkRequired("otherTransactionId", otherTransactionId),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): DuplicateTransaction = apply {
                        if (validated) {
                            return@apply
                        }

                        otherTransactionId()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (otherTransactionId.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DuplicateTransaction &&
                            otherTransactionId == other.otherTransactionId &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(otherTransactionId, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "DuplicateTransaction{otherTransactionId=$otherTransactionId, additionalProperties=$additionalProperties}"
                }

                /**
                 * Incorrect amount. Required if and only if `error_reason` is `incorrect_amount`.
                 */
                class IncorrectAmount
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val expectedAmount: JsonField<Long>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("expected_amount")
                        @ExcludeMissing
                        expectedAmount: JsonField<Long> = JsonMissing.of()
                    ) : this(expectedAmount, mutableMapOf())

                    /**
                     * Expected amount.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun expectedAmount(): Long = expectedAmount.getRequired("expected_amount")

                    /**
                     * Returns the raw JSON value of [expectedAmount].
                     *
                     * Unlike [expectedAmount], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("expected_amount")
                    @ExcludeMissing
                    fun _expectedAmount(): JsonField<Long> = expectedAmount

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [IncorrectAmount].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .expectedAmount()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [IncorrectAmount]. */
                    class Builder internal constructor() {

                        private var expectedAmount: JsonField<Long>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(incorrectAmount: IncorrectAmount) = apply {
                            expectedAmount = incorrectAmount.expectedAmount
                            additionalProperties =
                                incorrectAmount.additionalProperties.toMutableMap()
                        }

                        /** Expected amount. */
                        fun expectedAmount(expectedAmount: Long) =
                            expectedAmount(JsonField.of(expectedAmount))

                        /**
                         * Sets [Builder.expectedAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.expectedAmount] with a well-typed [Long]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun expectedAmount(expectedAmount: JsonField<Long>) = apply {
                            this.expectedAmount = expectedAmount
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [IncorrectAmount].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .expectedAmount()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): IncorrectAmount =
                            IncorrectAmount(
                                checkRequired("expectedAmount", expectedAmount),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): IncorrectAmount = apply {
                        if (validated) {
                            return@apply
                        }

                        expectedAmount()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (expectedAmount.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is IncorrectAmount &&
                            expectedAmount == other.expectedAmount &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(expectedAmount, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "IncorrectAmount{expectedAmount=$expectedAmount, additionalProperties=$additionalProperties}"
                }

                /**
                 * Paid by other means. Required if and only if `error_reason` is
                 * `paid_by_other_means`.
                 */
                class PaidByOtherMeans
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val otherFormOfPaymentEvidence: JsonField<OtherFormOfPaymentEvidence>,
                    private val otherTransactionId: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("other_form_of_payment_evidence")
                        @ExcludeMissing
                        otherFormOfPaymentEvidence: JsonField<OtherFormOfPaymentEvidence> =
                            JsonMissing.of(),
                        @JsonProperty("other_transaction_id")
                        @ExcludeMissing
                        otherTransactionId: JsonField<String> = JsonMissing.of(),
                    ) : this(otherFormOfPaymentEvidence, otherTransactionId, mutableMapOf())

                    /**
                     * Other form of payment evidence.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun otherFormOfPaymentEvidence(): OtherFormOfPaymentEvidence =
                        otherFormOfPaymentEvidence.getRequired("other_form_of_payment_evidence")

                    /**
                     * Other transaction ID.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun otherTransactionId(): String? =
                        otherTransactionId.getNullable("other_transaction_id")

                    /**
                     * Returns the raw JSON value of [otherFormOfPaymentEvidence].
                     *
                     * Unlike [otherFormOfPaymentEvidence], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("other_form_of_payment_evidence")
                    @ExcludeMissing
                    fun _otherFormOfPaymentEvidence(): JsonField<OtherFormOfPaymentEvidence> =
                        otherFormOfPaymentEvidence

                    /**
                     * Returns the raw JSON value of [otherTransactionId].
                     *
                     * Unlike [otherTransactionId], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("other_transaction_id")
                    @ExcludeMissing
                    fun _otherTransactionId(): JsonField<String> = otherTransactionId

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [PaidByOtherMeans].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .otherFormOfPaymentEvidence()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [PaidByOtherMeans]. */
                    class Builder internal constructor() {

                        private var otherFormOfPaymentEvidence:
                            JsonField<OtherFormOfPaymentEvidence>? =
                            null
                        private var otherTransactionId: JsonField<String> = JsonMissing.of()
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(paidByOtherMeans: PaidByOtherMeans) = apply {
                            otherFormOfPaymentEvidence = paidByOtherMeans.otherFormOfPaymentEvidence
                            otherTransactionId = paidByOtherMeans.otherTransactionId
                            additionalProperties =
                                paidByOtherMeans.additionalProperties.toMutableMap()
                        }

                        /** Other form of payment evidence. */
                        fun otherFormOfPaymentEvidence(
                            otherFormOfPaymentEvidence: OtherFormOfPaymentEvidence
                        ) = otherFormOfPaymentEvidence(JsonField.of(otherFormOfPaymentEvidence))

                        /**
                         * Sets [Builder.otherFormOfPaymentEvidence] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherFormOfPaymentEvidence] with a
                         * well-typed [OtherFormOfPaymentEvidence] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun otherFormOfPaymentEvidence(
                            otherFormOfPaymentEvidence: JsonField<OtherFormOfPaymentEvidence>
                        ) = apply { this.otherFormOfPaymentEvidence = otherFormOfPaymentEvidence }

                        /** Other transaction ID. */
                        fun otherTransactionId(otherTransactionId: String) =
                            otherTransactionId(JsonField.of(otherTransactionId))

                        /**
                         * Sets [Builder.otherTransactionId] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherTransactionId] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun otherTransactionId(otherTransactionId: JsonField<String>) = apply {
                            this.otherTransactionId = otherTransactionId
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [PaidByOtherMeans].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .otherFormOfPaymentEvidence()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): PaidByOtherMeans =
                            PaidByOtherMeans(
                                checkRequired(
                                    "otherFormOfPaymentEvidence",
                                    otherFormOfPaymentEvidence,
                                ),
                                otherTransactionId,
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): PaidByOtherMeans = apply {
                        if (validated) {
                            return@apply
                        }

                        otherFormOfPaymentEvidence().validate()
                        otherTransactionId()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (otherFormOfPaymentEvidence.asKnown()?.validity() ?: 0) +
                            (if (otherTransactionId.asKnown() == null) 0 else 1)

                    /** Other form of payment evidence. */
                    class OtherFormOfPaymentEvidence
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Canceled check. */
                            val CANCELED_CHECK = of("canceled_check")

                            /** Card transaction. */
                            val CARD_TRANSACTION = of("card_transaction")

                            /** Cash receipt. */
                            val CASH_RECEIPT = of("cash_receipt")

                            /** Other. */
                            val OTHER = of("other")

                            /** Statement. */
                            val STATEMENT = of("statement")

                            /** Voucher. */
                            val VOUCHER = of("voucher")

                            fun of(value: String) = OtherFormOfPaymentEvidence(JsonField.of(value))
                        }

                        /** An enum containing [OtherFormOfPaymentEvidence]'s known values. */
                        enum class Known {
                            /** Canceled check. */
                            CANCELED_CHECK,
                            /** Card transaction. */
                            CARD_TRANSACTION,
                            /** Cash receipt. */
                            CASH_RECEIPT,
                            /** Other. */
                            OTHER,
                            /** Statement. */
                            STATEMENT,
                            /** Voucher. */
                            VOUCHER,
                        }

                        /**
                         * An enum containing [OtherFormOfPaymentEvidence]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [OtherFormOfPaymentEvidence] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Canceled check. */
                            CANCELED_CHECK,
                            /** Card transaction. */
                            CARD_TRANSACTION,
                            /** Cash receipt. */
                            CASH_RECEIPT,
                            /** Other. */
                            OTHER,
                            /** Statement. */
                            STATEMENT,
                            /** Voucher. */
                            VOUCHER,
                            /**
                             * An enum member indicating that [OtherFormOfPaymentEvidence] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                CANCELED_CHECK -> Value.CANCELED_CHECK
                                CARD_TRANSACTION -> Value.CARD_TRANSACTION
                                CASH_RECEIPT -> Value.CASH_RECEIPT
                                OTHER -> Value.OTHER
                                STATEMENT -> Value.STATEMENT
                                VOUCHER -> Value.VOUCHER
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                CANCELED_CHECK -> Known.CANCELED_CHECK
                                CARD_TRANSACTION -> Known.CARD_TRANSACTION
                                CASH_RECEIPT -> Known.CASH_RECEIPT
                                OTHER -> Known.OTHER
                                STATEMENT -> Known.STATEMENT
                                VOUCHER -> Known.VOUCHER
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown OtherFormOfPaymentEvidence: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): OtherFormOfPaymentEvidence = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is OtherFormOfPaymentEvidence && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PaidByOtherMeans &&
                            otherFormOfPaymentEvidence == other.otherFormOfPaymentEvidence &&
                            otherTransactionId == other.otherTransactionId &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            otherFormOfPaymentEvidence,
                            otherTransactionId,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "PaidByOtherMeans{otherFormOfPaymentEvidence=$otherFormOfPaymentEvidence, otherTransactionId=$otherTransactionId, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ProcessingError &&
                        errorReason == other.errorReason &&
                        merchantResolutionAttempted == other.merchantResolutionAttempted &&
                        duplicateTransaction == other.duplicateTransaction &&
                        incorrectAmount == other.incorrectAmount &&
                        paidByOtherMeans == other.paidByOtherMeans &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        errorReason,
                        merchantResolutionAttempted,
                        duplicateTransaction,
                        incorrectAmount,
                        paidByOtherMeans,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "ProcessingError{errorReason=$errorReason, merchantResolutionAttempted=$merchantResolutionAttempted, duplicateTransaction=$duplicateTransaction, incorrectAmount=$incorrectAmount, paidByOtherMeans=$paidByOtherMeans, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Chargeback &&
                    category == other.category &&
                    authorization == other.authorization &&
                    consumerCanceledMerchandise == other.consumerCanceledMerchandise &&
                    consumerCanceledRecurringTransaction ==
                        other.consumerCanceledRecurringTransaction &&
                    consumerCanceledServices == other.consumerCanceledServices &&
                    consumerCounterfeitMerchandise == other.consumerCounterfeitMerchandise &&
                    consumerCreditNotProcessed == other.consumerCreditNotProcessed &&
                    consumerDamagedOrDefectiveMerchandise ==
                        other.consumerDamagedOrDefectiveMerchandise &&
                    consumerMerchandiseMisrepresentation ==
                        other.consumerMerchandiseMisrepresentation &&
                    consumerMerchandiseNotAsDescribed == other.consumerMerchandiseNotAsDescribed &&
                    consumerMerchandiseNotReceived == other.consumerMerchandiseNotReceived &&
                    consumerNonReceiptOfCash == other.consumerNonReceiptOfCash &&
                    consumerOriginalCreditTransactionNotAccepted ==
                        other.consumerOriginalCreditTransactionNotAccepted &&
                    consumerQualityMerchandise == other.consumerQualityMerchandise &&
                    consumerQualityServices == other.consumerQualityServices &&
                    consumerServicesMisrepresentation == other.consumerServicesMisrepresentation &&
                    consumerServicesNotAsDescribed == other.consumerServicesNotAsDescribed &&
                    consumerServicesNotReceived == other.consumerServicesNotReceived &&
                    fraud == other.fraud &&
                    processingError == other.processingError &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    category,
                    authorization,
                    consumerCanceledMerchandise,
                    consumerCanceledRecurringTransaction,
                    consumerCanceledServices,
                    consumerCounterfeitMerchandise,
                    consumerCreditNotProcessed,
                    consumerDamagedOrDefectiveMerchandise,
                    consumerMerchandiseMisrepresentation,
                    consumerMerchandiseNotAsDescribed,
                    consumerMerchandiseNotReceived,
                    consumerNonReceiptOfCash,
                    consumerOriginalCreditTransactionNotAccepted,
                    consumerQualityMerchandise,
                    consumerQualityServices,
                    consumerServicesMisrepresentation,
                    consumerServicesNotAsDescribed,
                    consumerServicesNotReceived,
                    fraud,
                    processingError,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Chargeback{category=$category, authorization=$authorization, consumerCanceledMerchandise=$consumerCanceledMerchandise, consumerCanceledRecurringTransaction=$consumerCanceledRecurringTransaction, consumerCanceledServices=$consumerCanceledServices, consumerCounterfeitMerchandise=$consumerCounterfeitMerchandise, consumerCreditNotProcessed=$consumerCreditNotProcessed, consumerDamagedOrDefectiveMerchandise=$consumerDamagedOrDefectiveMerchandise, consumerMerchandiseMisrepresentation=$consumerMerchandiseMisrepresentation, consumerMerchandiseNotAsDescribed=$consumerMerchandiseNotAsDescribed, consumerMerchandiseNotReceived=$consumerMerchandiseNotReceived, consumerNonReceiptOfCash=$consumerNonReceiptOfCash, consumerOriginalCreditTransactionNotAccepted=$consumerOriginalCreditTransactionNotAccepted, consumerQualityMerchandise=$consumerQualityMerchandise, consumerQualityServices=$consumerQualityServices, consumerServicesMisrepresentation=$consumerServicesMisrepresentation, consumerServicesNotAsDescribed=$consumerServicesNotAsDescribed, consumerServicesNotReceived=$consumerServicesNotReceived, fraud=$fraud, processingError=$processingError, additionalProperties=$additionalProperties}"
        }

        /**
         * The merchant pre-arbitration decline details for the user submission. Required if and
         * only if `category` is `merchant_prearbitration_decline`.
         */
        class MerchantPrearbitrationDecline
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val reason: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("reason") @ExcludeMissing reason: JsonField<String> = JsonMissing.of()
            ) : this(reason, mutableMapOf())

            /**
             * The reason for declining the merchant's pre-arbitration request.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun reason(): String = reason.getRequired("reason")

            /**
             * Returns the raw JSON value of [reason].
             *
             * Unlike [reason], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<String> = reason

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MerchantPrearbitrationDecline].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .reason()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [MerchantPrearbitrationDecline]. */
            class Builder internal constructor() {

                private var reason: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(merchantPrearbitrationDecline: MerchantPrearbitrationDecline) =
                    apply {
                        reason = merchantPrearbitrationDecline.reason
                        additionalProperties =
                            merchantPrearbitrationDecline.additionalProperties.toMutableMap()
                    }

                /** The reason for declining the merchant's pre-arbitration request. */
                fun reason(reason: String) = reason(JsonField.of(reason))

                /**
                 * Sets [Builder.reason] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.reason] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [MerchantPrearbitrationDecline].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .reason()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): MerchantPrearbitrationDecline =
                    MerchantPrearbitrationDecline(
                        checkRequired("reason", reason),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): MerchantPrearbitrationDecline = apply {
                if (validated) {
                    return@apply
                }

                reason()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (reason.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is MerchantPrearbitrationDecline &&
                    reason == other.reason &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(reason, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MerchantPrearbitrationDecline{reason=$reason, additionalProperties=$additionalProperties}"
        }

        /**
         * The user pre-arbitration details for the user submission. Required if and only if
         * `category` is `user_prearbitration`.
         */
        class UserPrearbitration
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val reason: JsonField<String>,
            private val categoryChange: JsonField<CategoryChange>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("reason")
                @ExcludeMissing
                reason: JsonField<String> = JsonMissing.of(),
                @JsonProperty("category_change")
                @ExcludeMissing
                categoryChange: JsonField<CategoryChange> = JsonMissing.of(),
            ) : this(reason, categoryChange, mutableMapOf())

            /**
             * The reason for the pre-arbitration request.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun reason(): String = reason.getRequired("reason")

            /**
             * Category change details for the pre-arbitration request. Should only be populated if
             * the category of the dispute is being changed as part of the pre-arbitration request.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun categoryChange(): CategoryChange? = categoryChange.getNullable("category_change")

            /**
             * Returns the raw JSON value of [reason].
             *
             * Unlike [reason], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<String> = reason

            /**
             * Returns the raw JSON value of [categoryChange].
             *
             * Unlike [categoryChange], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("category_change")
            @ExcludeMissing
            fun _categoryChange(): JsonField<CategoryChange> = categoryChange

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [UserPrearbitration].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .reason()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [UserPrearbitration]. */
            class Builder internal constructor() {

                private var reason: JsonField<String>? = null
                private var categoryChange: JsonField<CategoryChange> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(userPrearbitration: UserPrearbitration) = apply {
                    reason = userPrearbitration.reason
                    categoryChange = userPrearbitration.categoryChange
                    additionalProperties = userPrearbitration.additionalProperties.toMutableMap()
                }

                /** The reason for the pre-arbitration request. */
                fun reason(reason: String) = reason(JsonField.of(reason))

                /**
                 * Sets [Builder.reason] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.reason] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                /**
                 * Category change details for the pre-arbitration request. Should only be populated
                 * if the category of the dispute is being changed as part of the pre-arbitration
                 * request.
                 */
                fun categoryChange(categoryChange: CategoryChange) =
                    categoryChange(JsonField.of(categoryChange))

                /**
                 * Sets [Builder.categoryChange] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.categoryChange] with a well-typed
                 * [CategoryChange] value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun categoryChange(categoryChange: JsonField<CategoryChange>) = apply {
                    this.categoryChange = categoryChange
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [UserPrearbitration].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .reason()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): UserPrearbitration =
                    UserPrearbitration(
                        checkRequired("reason", reason),
                        categoryChange,
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): UserPrearbitration = apply {
                if (validated) {
                    return@apply
                }

                reason()
                categoryChange()?.validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (reason.asKnown() == null) 0 else 1) +
                    (categoryChange.asKnown()?.validity() ?: 0)

            /**
             * Category change details for the pre-arbitration request. Should only be populated if
             * the category of the dispute is being changed as part of the pre-arbitration request.
             */
            class CategoryChange
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val category: JsonField<Category>,
                private val reason: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("category")
                    @ExcludeMissing
                    category: JsonField<Category> = JsonMissing.of(),
                    @JsonProperty("reason")
                    @ExcludeMissing
                    reason: JsonField<String> = JsonMissing.of(),
                ) : this(category, reason, mutableMapOf())

                /**
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun category(): Category = category.getRequired("category")

                /**
                 * The reason for the category change.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun reason(): String = reason.getRequired("reason")

                /**
                 * Returns the raw JSON value of [category].
                 *
                 * Unlike [category], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("category")
                @ExcludeMissing
                fun _category(): JsonField<Category> = category

                /**
                 * Returns the raw JSON value of [reason].
                 *
                 * Unlike [reason], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<String> = reason

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [CategoryChange].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .category()
                     * .reason()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [CategoryChange]. */
                class Builder internal constructor() {

                    private var category: JsonField<Category>? = null
                    private var reason: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(categoryChange: CategoryChange) = apply {
                        category = categoryChange.category
                        reason = categoryChange.reason
                        additionalProperties = categoryChange.additionalProperties.toMutableMap()
                    }

                    fun category(category: Category) = category(JsonField.of(category))

                    /**
                     * Sets [Builder.category] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.category] with a well-typed [Category] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun category(category: JsonField<Category>) = apply { this.category = category }

                    /** The reason for the category change. */
                    fun reason(reason: String) = reason(JsonField.of(reason))

                    /**
                     * Sets [Builder.reason] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.reason] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [CategoryChange].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .category()
                     * .reason()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): CategoryChange =
                        CategoryChange(
                            checkRequired("category", category),
                            checkRequired("reason", reason),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): CategoryChange = apply {
                    if (validated) {
                        return@apply
                    }

                    category().validate()
                    reason()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (category.asKnown()?.validity() ?: 0) + (if (reason.asKnown() == null) 0 else 1)

                class Category
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Authorization. */
                        val AUTHORIZATION = of("authorization")

                        /** Consumer: canceled merchandise. */
                        val CONSUMER_CANCELED_MERCHANDISE = of("consumer_canceled_merchandise")

                        /** Consumer: canceled recurring transaction. */
                        val CONSUMER_CANCELED_RECURRING_TRANSACTION =
                            of("consumer_canceled_recurring_transaction")

                        /** Consumer: canceled services. */
                        val CONSUMER_CANCELED_SERVICES = of("consumer_canceled_services")

                        /** Consumer: counterfeit merchandise. */
                        val CONSUMER_COUNTERFEIT_MERCHANDISE =
                            of("consumer_counterfeit_merchandise")

                        /** Consumer: credit not processed. */
                        val CONSUMER_CREDIT_NOT_PROCESSED = of("consumer_credit_not_processed")

                        /** Consumer: damaged or defective merchandise. */
                        val CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE =
                            of("consumer_damaged_or_defective_merchandise")

                        /** Consumer: merchandise misrepresentation. */
                        val CONSUMER_MERCHANDISE_MISREPRESENTATION =
                            of("consumer_merchandise_misrepresentation")

                        /** Consumer: merchandise not as described. */
                        val CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED =
                            of("consumer_merchandise_not_as_described")

                        /** Consumer: merchandise not received. */
                        val CONSUMER_MERCHANDISE_NOT_RECEIVED =
                            of("consumer_merchandise_not_received")

                        /** Consumer: non-receipt of cash. */
                        val CONSUMER_NON_RECEIPT_OF_CASH = of("consumer_non_receipt_of_cash")

                        /** Consumer: Original Credit Transaction (OCT) not accepted. */
                        val CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED =
                            of("consumer_original_credit_transaction_not_accepted")

                        /** Consumer: merchandise quality issue. */
                        val CONSUMER_QUALITY_MERCHANDISE = of("consumer_quality_merchandise")

                        /** Consumer: services quality issue. */
                        val CONSUMER_QUALITY_SERVICES = of("consumer_quality_services")

                        /** Consumer: services misrepresentation. */
                        val CONSUMER_SERVICES_MISREPRESENTATION =
                            of("consumer_services_misrepresentation")

                        /** Consumer: services not as described. */
                        val CONSUMER_SERVICES_NOT_AS_DESCRIBED =
                            of("consumer_services_not_as_described")

                        /** Consumer: services not received. */
                        val CONSUMER_SERVICES_NOT_RECEIVED = of("consumer_services_not_received")

                        /** Fraud. */
                        val FRAUD = of("fraud")

                        /** Processing error. */
                        val PROCESSING_ERROR = of("processing_error")

                        fun of(value: String) = Category(JsonField.of(value))
                    }

                    /** An enum containing [Category]'s known values. */
                    enum class Known {
                        /** Authorization. */
                        AUTHORIZATION,
                        /** Consumer: canceled merchandise. */
                        CONSUMER_CANCELED_MERCHANDISE,
                        /** Consumer: canceled recurring transaction. */
                        CONSUMER_CANCELED_RECURRING_TRANSACTION,
                        /** Consumer: canceled services. */
                        CONSUMER_CANCELED_SERVICES,
                        /** Consumer: counterfeit merchandise. */
                        CONSUMER_COUNTERFEIT_MERCHANDISE,
                        /** Consumer: credit not processed. */
                        CONSUMER_CREDIT_NOT_PROCESSED,
                        /** Consumer: damaged or defective merchandise. */
                        CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                        /** Consumer: merchandise misrepresentation. */
                        CONSUMER_MERCHANDISE_MISREPRESENTATION,
                        /** Consumer: merchandise not as described. */
                        CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                        /** Consumer: merchandise not received. */
                        CONSUMER_MERCHANDISE_NOT_RECEIVED,
                        /** Consumer: non-receipt of cash. */
                        CONSUMER_NON_RECEIPT_OF_CASH,
                        /** Consumer: Original Credit Transaction (OCT) not accepted. */
                        CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                        /** Consumer: merchandise quality issue. */
                        CONSUMER_QUALITY_MERCHANDISE,
                        /** Consumer: services quality issue. */
                        CONSUMER_QUALITY_SERVICES,
                        /** Consumer: services misrepresentation. */
                        CONSUMER_SERVICES_MISREPRESENTATION,
                        /** Consumer: services not as described. */
                        CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                        /** Consumer: services not received. */
                        CONSUMER_SERVICES_NOT_RECEIVED,
                        /** Fraud. */
                        FRAUD,
                        /** Processing error. */
                        PROCESSING_ERROR,
                    }

                    /**
                     * An enum containing [Category]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [Category] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Authorization. */
                        AUTHORIZATION,
                        /** Consumer: canceled merchandise. */
                        CONSUMER_CANCELED_MERCHANDISE,
                        /** Consumer: canceled recurring transaction. */
                        CONSUMER_CANCELED_RECURRING_TRANSACTION,
                        /** Consumer: canceled services. */
                        CONSUMER_CANCELED_SERVICES,
                        /** Consumer: counterfeit merchandise. */
                        CONSUMER_COUNTERFEIT_MERCHANDISE,
                        /** Consumer: credit not processed. */
                        CONSUMER_CREDIT_NOT_PROCESSED,
                        /** Consumer: damaged or defective merchandise. */
                        CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                        /** Consumer: merchandise misrepresentation. */
                        CONSUMER_MERCHANDISE_MISREPRESENTATION,
                        /** Consumer: merchandise not as described. */
                        CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                        /** Consumer: merchandise not received. */
                        CONSUMER_MERCHANDISE_NOT_RECEIVED,
                        /** Consumer: non-receipt of cash. */
                        CONSUMER_NON_RECEIPT_OF_CASH,
                        /** Consumer: Original Credit Transaction (OCT) not accepted. */
                        CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                        /** Consumer: merchandise quality issue. */
                        CONSUMER_QUALITY_MERCHANDISE,
                        /** Consumer: services quality issue. */
                        CONSUMER_QUALITY_SERVICES,
                        /** Consumer: services misrepresentation. */
                        CONSUMER_SERVICES_MISREPRESENTATION,
                        /** Consumer: services not as described. */
                        CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                        /** Consumer: services not received. */
                        CONSUMER_SERVICES_NOT_RECEIVED,
                        /** Fraud. */
                        FRAUD,
                        /** Processing error. */
                        PROCESSING_ERROR,
                        /**
                         * An enum member indicating that [Category] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            AUTHORIZATION -> Value.AUTHORIZATION
                            CONSUMER_CANCELED_MERCHANDISE -> Value.CONSUMER_CANCELED_MERCHANDISE
                            CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                                Value.CONSUMER_CANCELED_RECURRING_TRANSACTION
                            CONSUMER_CANCELED_SERVICES -> Value.CONSUMER_CANCELED_SERVICES
                            CONSUMER_COUNTERFEIT_MERCHANDISE ->
                                Value.CONSUMER_COUNTERFEIT_MERCHANDISE
                            CONSUMER_CREDIT_NOT_PROCESSED -> Value.CONSUMER_CREDIT_NOT_PROCESSED
                            CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                                Value.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                            CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                                Value.CONSUMER_MERCHANDISE_MISREPRESENTATION
                            CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                                Value.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                            CONSUMER_MERCHANDISE_NOT_RECEIVED ->
                                Value.CONSUMER_MERCHANDISE_NOT_RECEIVED
                            CONSUMER_NON_RECEIPT_OF_CASH -> Value.CONSUMER_NON_RECEIPT_OF_CASH
                            CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                                Value.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                            CONSUMER_QUALITY_MERCHANDISE -> Value.CONSUMER_QUALITY_MERCHANDISE
                            CONSUMER_QUALITY_SERVICES -> Value.CONSUMER_QUALITY_SERVICES
                            CONSUMER_SERVICES_MISREPRESENTATION ->
                                Value.CONSUMER_SERVICES_MISREPRESENTATION
                            CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                                Value.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                            CONSUMER_SERVICES_NOT_RECEIVED -> Value.CONSUMER_SERVICES_NOT_RECEIVED
                            FRAUD -> Value.FRAUD
                            PROCESSING_ERROR -> Value.PROCESSING_ERROR
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            AUTHORIZATION -> Known.AUTHORIZATION
                            CONSUMER_CANCELED_MERCHANDISE -> Known.CONSUMER_CANCELED_MERCHANDISE
                            CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                                Known.CONSUMER_CANCELED_RECURRING_TRANSACTION
                            CONSUMER_CANCELED_SERVICES -> Known.CONSUMER_CANCELED_SERVICES
                            CONSUMER_COUNTERFEIT_MERCHANDISE ->
                                Known.CONSUMER_COUNTERFEIT_MERCHANDISE
                            CONSUMER_CREDIT_NOT_PROCESSED -> Known.CONSUMER_CREDIT_NOT_PROCESSED
                            CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                                Known.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                            CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                                Known.CONSUMER_MERCHANDISE_MISREPRESENTATION
                            CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                                Known.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                            CONSUMER_MERCHANDISE_NOT_RECEIVED ->
                                Known.CONSUMER_MERCHANDISE_NOT_RECEIVED
                            CONSUMER_NON_RECEIPT_OF_CASH -> Known.CONSUMER_NON_RECEIPT_OF_CASH
                            CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                                Known.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                            CONSUMER_QUALITY_MERCHANDISE -> Known.CONSUMER_QUALITY_MERCHANDISE
                            CONSUMER_QUALITY_SERVICES -> Known.CONSUMER_QUALITY_SERVICES
                            CONSUMER_SERVICES_MISREPRESENTATION ->
                                Known.CONSUMER_SERVICES_MISREPRESENTATION
                            CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                                Known.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                            CONSUMER_SERVICES_NOT_RECEIVED -> Known.CONSUMER_SERVICES_NOT_RECEIVED
                            FRAUD -> Known.FRAUD
                            PROCESSING_ERROR -> Known.PROCESSING_ERROR
                            else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Category = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Category && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is CategoryChange &&
                        category == other.category &&
                        reason == other.reason &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(category, reason, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "CategoryChange{category=$category, reason=$reason, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is UserPrearbitration &&
                    reason == other.reason &&
                    categoryChange == other.categoryChange &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(reason, categoryChange, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UserPrearbitration{reason=$reason, categoryChange=$categoryChange, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Visa &&
                category == other.category &&
                chargeback == other.chargeback &&
                merchantPrearbitrationDecline == other.merchantPrearbitrationDecline &&
                userPrearbitration == other.userPrearbitration &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                category,
                chargeback,
                merchantPrearbitrationDecline,
                userPrearbitration,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Visa{category=$category, chargeback=$chargeback, merchantPrearbitrationDecline=$merchantPrearbitrationDecline, userPrearbitration=$userPrearbitration, additionalProperties=$additionalProperties}"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is CardDisputeSubmitUserSubmissionParams &&
            cardDisputeId == other.cardDisputeId &&
            body == other.body &&
            additionalHeaders == other.additionalHeaders &&
            additionalQueryParams == other.additionalQueryParams
    }

    override fun hashCode(): Int =
        Objects.hash(cardDisputeId, body, additionalHeaders, additionalQueryParams)

    override fun toString() =
        "CardDisputeSubmitUserSubmissionParams{cardDisputeId=$cardDisputeId, body=$body, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams}"
}
