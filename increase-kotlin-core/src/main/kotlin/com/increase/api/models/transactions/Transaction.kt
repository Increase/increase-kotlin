// File generated from our OpenAPI spec by Stainless.

package com.increase.api.models.transactions

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.increase.api.core.Enum
import com.increase.api.core.ExcludeMissing
import com.increase.api.core.JsonField
import com.increase.api.core.JsonMissing
import com.increase.api.core.JsonValue
import com.increase.api.core.checkKnown
import com.increase.api.core.checkRequired
import com.increase.api.core.toImmutable
import com.increase.api.errors.IncreaseInvalidDataException
import java.time.LocalDate
import java.time.OffsetDateTime
import java.util.Collections
import java.util.Objects

/**
 * Transactions are the immutable additions and removals of money from your bank account. They're
 * the equivalent of line items on your bank statement. To learn more, see
 * [Transactions and Transfers](/documentation/transactions-transfers).
 */
class Transaction
private constructor(
    private val id: JsonField<String>,
    private val accountId: JsonField<String>,
    private val amount: JsonField<Long>,
    private val createdAt: JsonField<OffsetDateTime>,
    private val currency: JsonField<Currency>,
    private val description: JsonField<String>,
    private val routeId: JsonField<String>,
    private val routeType: JsonField<RouteType>,
    private val source: JsonField<Source>,
    private val type: JsonField<Type>,
    private val additionalProperties: MutableMap<String, JsonValue>,
) {

    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("account_id") @ExcludeMissing accountId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("currency") @ExcludeMissing currency: JsonField<Currency> = JsonMissing.of(),
        @JsonProperty("description")
        @ExcludeMissing
        description: JsonField<String> = JsonMissing.of(),
        @JsonProperty("route_id") @ExcludeMissing routeId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("route_type")
        @ExcludeMissing
        routeType: JsonField<RouteType> = JsonMissing.of(),
        @JsonProperty("source") @ExcludeMissing source: JsonField<Source> = JsonMissing.of(),
        @JsonProperty("type") @ExcludeMissing type: JsonField<Type> = JsonMissing.of(),
    ) : this(
        id,
        accountId,
        amount,
        createdAt,
        currency,
        description,
        routeId,
        routeType,
        source,
        type,
        mutableMapOf(),
    )

    /**
     * The Transaction identifier.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun id(): String = id.getRequired("id")

    /**
     * The identifier for the Account the Transaction belongs to.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun accountId(): String = accountId.getRequired("account_id")

    /**
     * The Transaction amount in the minor unit of its currency. For dollars, for example, this is
     * cents.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun amount(): Long = amount.getRequired("amount")

    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date on which the Transaction
     * occurred.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

    /**
     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the Transaction's currency.
     * This will match the currency on the Transaction's Account.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun currency(): Currency = currency.getRequired("currency")

    /**
     * An informational message describing this transaction. Use the fields in `source` to get more
     * detailed information. This field appears as the line-item on the statement.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun description(): String = description.getRequired("description")

    /**
     * The identifier for the route this Transaction came through. Routes are things like cards and
     * ACH details.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun routeId(): String? = routeId.getNullable("route_id")

    /**
     * The type of the route this Transaction came through.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun routeType(): RouteType? = routeType.getNullable("route_type")

    /**
     * This is an object giving more details on the network-level event that caused the Transaction.
     * Note that for backwards compatibility reasons, additional undocumented keys may appear in
     * this object. These should be treated as deprecated and will be removed in the future.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun source(): Source = source.getRequired("source")

    /**
     * A constant representing the object's type. For this resource it will always be `transaction`.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun type(): Type = type.getRequired("type")

    /**
     * Returns the raw JSON value of [id].
     *
     * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

    /**
     * Returns the raw JSON value of [accountId].
     *
     * Unlike [accountId], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("account_id") @ExcludeMissing fun _accountId(): JsonField<String> = accountId

    /**
     * Returns the raw JSON value of [amount].
     *
     * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

    /**
     * Returns the raw JSON value of [createdAt].
     *
     * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("created_at")
    @ExcludeMissing
    fun _createdAt(): JsonField<OffsetDateTime> = createdAt

    /**
     * Returns the raw JSON value of [currency].
     *
     * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<Currency> = currency

    /**
     * Returns the raw JSON value of [description].
     *
     * Unlike [description], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("description") @ExcludeMissing fun _description(): JsonField<String> = description

    /**
     * Returns the raw JSON value of [routeId].
     *
     * Unlike [routeId], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("route_id") @ExcludeMissing fun _routeId(): JsonField<String> = routeId

    /**
     * Returns the raw JSON value of [routeType].
     *
     * Unlike [routeType], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("route_type") @ExcludeMissing fun _routeType(): JsonField<RouteType> = routeType

    /**
     * Returns the raw JSON value of [source].
     *
     * Unlike [source], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("source") @ExcludeMissing fun _source(): JsonField<Source> = source

    /**
     * Returns the raw JSON value of [type].
     *
     * Unlike [type], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("type") @ExcludeMissing fun _type(): JsonField<Type> = type

    @JsonAnySetter
    private fun putAdditionalProperty(key: String, value: JsonValue) {
        additionalProperties.put(key, value)
    }

    @JsonAnyGetter
    @ExcludeMissing
    fun _additionalProperties(): Map<String, JsonValue> =
        Collections.unmodifiableMap(additionalProperties)

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of [Transaction].
         *
         * The following fields are required:
         * ```kotlin
         * .id()
         * .accountId()
         * .amount()
         * .createdAt()
         * .currency()
         * .description()
         * .routeId()
         * .routeType()
         * .source()
         * .type()
         * ```
         */
        fun builder() = Builder()
    }

    /** A builder for [Transaction]. */
    class Builder internal constructor() {

        private var id: JsonField<String>? = null
        private var accountId: JsonField<String>? = null
        private var amount: JsonField<Long>? = null
        private var createdAt: JsonField<OffsetDateTime>? = null
        private var currency: JsonField<Currency>? = null
        private var description: JsonField<String>? = null
        private var routeId: JsonField<String>? = null
        private var routeType: JsonField<RouteType>? = null
        private var source: JsonField<Source>? = null
        private var type: JsonField<Type>? = null
        private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

        internal fun from(transaction: Transaction) = apply {
            id = transaction.id
            accountId = transaction.accountId
            amount = transaction.amount
            createdAt = transaction.createdAt
            currency = transaction.currency
            description = transaction.description
            routeId = transaction.routeId
            routeType = transaction.routeType
            source = transaction.source
            type = transaction.type
            additionalProperties = transaction.additionalProperties.toMutableMap()
        }

        /** The Transaction identifier. */
        fun id(id: String) = id(JsonField.of(id))

        /**
         * Sets [Builder.id] to an arbitrary JSON value.
         *
         * You should usually call [Builder.id] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun id(id: JsonField<String>) = apply { this.id = id }

        /** The identifier for the Account the Transaction belongs to. */
        fun accountId(accountId: String) = accountId(JsonField.of(accountId))

        /**
         * Sets [Builder.accountId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.accountId] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun accountId(accountId: JsonField<String>) = apply { this.accountId = accountId }

        /**
         * The Transaction amount in the minor unit of its currency. For dollars, for example, this
         * is cents.
         */
        fun amount(amount: Long) = amount(JsonField.of(amount))

        /**
         * Sets [Builder.amount] to an arbitrary JSON value.
         *
         * You should usually call [Builder.amount] with a well-typed [Long] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

        /**
         * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date on which the Transaction
         * occurred.
         */
        fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

        /**
         * Sets [Builder.createdAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply { this.createdAt = createdAt }

        /**
         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the Transaction's
         * currency. This will match the currency on the Transaction's Account.
         */
        fun currency(currency: Currency) = currency(JsonField.of(currency))

        /**
         * Sets [Builder.currency] to an arbitrary JSON value.
         *
         * You should usually call [Builder.currency] with a well-typed [Currency] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

        /**
         * An informational message describing this transaction. Use the fields in `source` to get
         * more detailed information. This field appears as the line-item on the statement.
         */
        fun description(description: String) = description(JsonField.of(description))

        /**
         * Sets [Builder.description] to an arbitrary JSON value.
         *
         * You should usually call [Builder.description] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun description(description: JsonField<String>) = apply { this.description = description }

        /**
         * The identifier for the route this Transaction came through. Routes are things like cards
         * and ACH details.
         */
        fun routeId(routeId: String?) = routeId(JsonField.ofNullable(routeId))

        /**
         * Sets [Builder.routeId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.routeId] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun routeId(routeId: JsonField<String>) = apply { this.routeId = routeId }

        /** The type of the route this Transaction came through. */
        fun routeType(routeType: RouteType?) = routeType(JsonField.ofNullable(routeType))

        /**
         * Sets [Builder.routeType] to an arbitrary JSON value.
         *
         * You should usually call [Builder.routeType] with a well-typed [RouteType] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun routeType(routeType: JsonField<RouteType>) = apply { this.routeType = routeType }

        /**
         * This is an object giving more details on the network-level event that caused the
         * Transaction. Note that for backwards compatibility reasons, additional undocumented keys
         * may appear in this object. These should be treated as deprecated and will be removed in
         * the future.
         */
        fun source(source: Source) = source(JsonField.of(source))

        /**
         * Sets [Builder.source] to an arbitrary JSON value.
         *
         * You should usually call [Builder.source] with a well-typed [Source] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun source(source: JsonField<Source>) = apply { this.source = source }

        /**
         * A constant representing the object's type. For this resource it will always be
         * `transaction`.
         */
        fun type(type: Type) = type(JsonField.of(type))

        /**
         * Sets [Builder.type] to an arbitrary JSON value.
         *
         * You should usually call [Builder.type] with a well-typed [Type] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun type(type: JsonField<Type>) = apply { this.type = type }

        fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.clear()
            putAllAdditionalProperties(additionalProperties)
        }

        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
            additionalProperties.put(key, value)
        }

        fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.putAll(additionalProperties)
        }

        fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
            keys.forEach(::removeAdditionalProperty)
        }

        /**
         * Returns an immutable instance of [Transaction].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```kotlin
         * .id()
         * .accountId()
         * .amount()
         * .createdAt()
         * .currency()
         * .description()
         * .routeId()
         * .routeType()
         * .source()
         * .type()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): Transaction =
            Transaction(
                checkRequired("id", id),
                checkRequired("accountId", accountId),
                checkRequired("amount", amount),
                checkRequired("createdAt", createdAt),
                checkRequired("currency", currency),
                checkRequired("description", description),
                checkRequired("routeId", routeId),
                checkRequired("routeType", routeType),
                checkRequired("source", source),
                checkRequired("type", type),
                additionalProperties.toMutableMap(),
            )
    }

    private var validated: Boolean = false

    fun validate(): Transaction = apply {
        if (validated) {
            return@apply
        }

        id()
        accountId()
        amount()
        createdAt()
        currency().validate()
        description()
        routeId()
        routeType()?.validate()
        source().validate()
        type().validate()
        validated = true
    }

    fun isValid(): Boolean =
        try {
            validate()
            true
        } catch (e: IncreaseInvalidDataException) {
            false
        }

    /**
     * Returns a score indicating how many valid values are contained in this object recursively.
     *
     * Used for best match union deserialization.
     */
    internal fun validity(): Int =
        (if (id.asKnown() == null) 0 else 1) +
            (if (accountId.asKnown() == null) 0 else 1) +
            (if (amount.asKnown() == null) 0 else 1) +
            (if (createdAt.asKnown() == null) 0 else 1) +
            (currency.asKnown()?.validity() ?: 0) +
            (if (description.asKnown() == null) 0 else 1) +
            (if (routeId.asKnown() == null) 0 else 1) +
            (routeType.asKnown()?.validity() ?: 0) +
            (source.asKnown()?.validity() ?: 0) +
            (type.asKnown()?.validity() ?: 0)

    /**
     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the Transaction's currency.
     * This will match the currency on the Transaction's Account.
     */
    class Currency @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            /** Canadian Dollar (CAD) */
            val CAD = of("CAD")

            /** Swiss Franc (CHF) */
            val CHF = of("CHF")

            /** Euro (EUR) */
            val EUR = of("EUR")

            /** British Pound (GBP) */
            val GBP = of("GBP")

            /** Japanese Yen (JPY) */
            val JPY = of("JPY")

            /** US Dollar (USD) */
            val USD = of("USD")

            fun of(value: String) = Currency(JsonField.of(value))
        }

        /** An enum containing [Currency]'s known values. */
        enum class Known {
            /** Canadian Dollar (CAD) */
            CAD,
            /** Swiss Franc (CHF) */
            CHF,
            /** Euro (EUR) */
            EUR,
            /** British Pound (GBP) */
            GBP,
            /** Japanese Yen (JPY) */
            JPY,
            /** US Dollar (USD) */
            USD,
        }

        /**
         * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Currency] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            /** Canadian Dollar (CAD) */
            CAD,
            /** Swiss Franc (CHF) */
            CHF,
            /** Euro (EUR) */
            EUR,
            /** British Pound (GBP) */
            GBP,
            /** Japanese Yen (JPY) */
            JPY,
            /** US Dollar (USD) */
            USD,
            /** An enum member indicating that [Currency] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                CAD -> Value.CAD
                CHF -> Value.CHF
                EUR -> Value.EUR
                GBP -> Value.GBP
                JPY -> Value.JPY
                USD -> Value.USD
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws IncreaseInvalidDataException if this class instance's value is a not a known
         *   member.
         */
        fun known(): Known =
            when (this) {
                CAD -> Known.CAD
                CHF -> Known.CHF
                EUR -> Known.EUR
                GBP -> Known.GBP
                JPY -> Known.JPY
                USD -> Known.USD
                else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws IncreaseInvalidDataException if this class instance's value does not have the
         *   expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): Currency = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Currency && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /** The type of the route this Transaction came through. */
    class RouteType @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            /** An Account Number. */
            val ACCOUNT_NUMBER = of("account_number")

            /** A Card. */
            val CARD = of("card")

            /** A Lockbox. */
            val LOCKBOX = of("lockbox")

            fun of(value: String) = RouteType(JsonField.of(value))
        }

        /** An enum containing [RouteType]'s known values. */
        enum class Known {
            /** An Account Number. */
            ACCOUNT_NUMBER,
            /** A Card. */
            CARD,
            /** A Lockbox. */
            LOCKBOX,
        }

        /**
         * An enum containing [RouteType]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [RouteType] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            /** An Account Number. */
            ACCOUNT_NUMBER,
            /** A Card. */
            CARD,
            /** A Lockbox. */
            LOCKBOX,
            /**
             * An enum member indicating that [RouteType] was instantiated with an unknown value.
             */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                ACCOUNT_NUMBER -> Value.ACCOUNT_NUMBER
                CARD -> Value.CARD
                LOCKBOX -> Value.LOCKBOX
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws IncreaseInvalidDataException if this class instance's value is a not a known
         *   member.
         */
        fun known(): Known =
            when (this) {
                ACCOUNT_NUMBER -> Known.ACCOUNT_NUMBER
                CARD -> Known.CARD
                LOCKBOX -> Known.LOCKBOX
                else -> throw IncreaseInvalidDataException("Unknown RouteType: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws IncreaseInvalidDataException if this class instance's value does not have the
         *   expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): RouteType = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is RouteType && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /**
     * This is an object giving more details on the network-level event that caused the Transaction.
     * Note that for backwards compatibility reasons, additional undocumented keys may appear in
     * this object. These should be treated as deprecated and will be removed in the future.
     */
    class Source
    private constructor(
        private val accountRevenuePayment: JsonField<AccountRevenuePayment>,
        private val accountTransferIntention: JsonField<AccountTransferIntention>,
        private val achTransferIntention: JsonField<AchTransferIntention>,
        private val achTransferRejection: JsonField<AchTransferRejection>,
        private val achTransferReturn: JsonField<AchTransferReturn>,
        private val cardDisputeAcceptance: JsonField<CardDisputeAcceptance>,
        private val cardDisputeFinancial: JsonField<CardDisputeFinancial>,
        private val cardDisputeLoss: JsonField<CardDisputeLoss>,
        private val cardPushTransferAcceptance: JsonField<CardPushTransferAcceptance>,
        private val cardRefund: JsonField<CardRefund>,
        private val cardRevenuePayment: JsonField<CardRevenuePayment>,
        private val cardSettlement: JsonField<CardSettlement>,
        private val cashbackPayment: JsonField<CashbackPayment>,
        private val category: JsonField<Category>,
        private val checkDepositAcceptance: JsonField<CheckDepositAcceptance>,
        private val checkDepositReturn: JsonField<CheckDepositReturn>,
        private val checkTransferDeposit: JsonField<CheckTransferDeposit>,
        private val feePayment: JsonField<FeePayment>,
        private val inboundAchTransfer: JsonField<InboundAchTransfer>,
        private val inboundAchTransferReturnIntention: JsonField<InboundAchTransferReturnIntention>,
        private val inboundCheckAdjustment: JsonField<InboundCheckAdjustment>,
        private val inboundCheckDepositReturnIntention:
            JsonField<InboundCheckDepositReturnIntention>,
        private val inboundRealTimePaymentsTransferConfirmation:
            JsonField<InboundRealTimePaymentsTransferConfirmation>,
        private val inboundWireReversal: JsonField<InboundWireReversal>,
        private val inboundWireTransfer: JsonField<InboundWireTransfer>,
        private val inboundWireTransferReversal: JsonField<InboundWireTransferReversal>,
        private val interestPayment: JsonField<InterestPayment>,
        private val internalSource: JsonField<InternalSource>,
        private val other: JsonValue,
        private val realTimePaymentsTransferAcknowledgement:
            JsonField<RealTimePaymentsTransferAcknowledgement>,
        private val sampleFunds: JsonField<SampleFunds>,
        private val swiftTransferIntention: JsonField<SwiftTransferIntention>,
        private val swiftTransferReturn: JsonField<SwiftTransferReturn>,
        private val wireTransferIntention: JsonField<WireTransferIntention>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("account_revenue_payment")
            @ExcludeMissing
            accountRevenuePayment: JsonField<AccountRevenuePayment> = JsonMissing.of(),
            @JsonProperty("account_transfer_intention")
            @ExcludeMissing
            accountTransferIntention: JsonField<AccountTransferIntention> = JsonMissing.of(),
            @JsonProperty("ach_transfer_intention")
            @ExcludeMissing
            achTransferIntention: JsonField<AchTransferIntention> = JsonMissing.of(),
            @JsonProperty("ach_transfer_rejection")
            @ExcludeMissing
            achTransferRejection: JsonField<AchTransferRejection> = JsonMissing.of(),
            @JsonProperty("ach_transfer_return")
            @ExcludeMissing
            achTransferReturn: JsonField<AchTransferReturn> = JsonMissing.of(),
            @JsonProperty("card_dispute_acceptance")
            @ExcludeMissing
            cardDisputeAcceptance: JsonField<CardDisputeAcceptance> = JsonMissing.of(),
            @JsonProperty("card_dispute_financial")
            @ExcludeMissing
            cardDisputeFinancial: JsonField<CardDisputeFinancial> = JsonMissing.of(),
            @JsonProperty("card_dispute_loss")
            @ExcludeMissing
            cardDisputeLoss: JsonField<CardDisputeLoss> = JsonMissing.of(),
            @JsonProperty("card_push_transfer_acceptance")
            @ExcludeMissing
            cardPushTransferAcceptance: JsonField<CardPushTransferAcceptance> = JsonMissing.of(),
            @JsonProperty("card_refund")
            @ExcludeMissing
            cardRefund: JsonField<CardRefund> = JsonMissing.of(),
            @JsonProperty("card_revenue_payment")
            @ExcludeMissing
            cardRevenuePayment: JsonField<CardRevenuePayment> = JsonMissing.of(),
            @JsonProperty("card_settlement")
            @ExcludeMissing
            cardSettlement: JsonField<CardSettlement> = JsonMissing.of(),
            @JsonProperty("cashback_payment")
            @ExcludeMissing
            cashbackPayment: JsonField<CashbackPayment> = JsonMissing.of(),
            @JsonProperty("category")
            @ExcludeMissing
            category: JsonField<Category> = JsonMissing.of(),
            @JsonProperty("check_deposit_acceptance")
            @ExcludeMissing
            checkDepositAcceptance: JsonField<CheckDepositAcceptance> = JsonMissing.of(),
            @JsonProperty("check_deposit_return")
            @ExcludeMissing
            checkDepositReturn: JsonField<CheckDepositReturn> = JsonMissing.of(),
            @JsonProperty("check_transfer_deposit")
            @ExcludeMissing
            checkTransferDeposit: JsonField<CheckTransferDeposit> = JsonMissing.of(),
            @JsonProperty("fee_payment")
            @ExcludeMissing
            feePayment: JsonField<FeePayment> = JsonMissing.of(),
            @JsonProperty("inbound_ach_transfer")
            @ExcludeMissing
            inboundAchTransfer: JsonField<InboundAchTransfer> = JsonMissing.of(),
            @JsonProperty("inbound_ach_transfer_return_intention")
            @ExcludeMissing
            inboundAchTransferReturnIntention: JsonField<InboundAchTransferReturnIntention> =
                JsonMissing.of(),
            @JsonProperty("inbound_check_adjustment")
            @ExcludeMissing
            inboundCheckAdjustment: JsonField<InboundCheckAdjustment> = JsonMissing.of(),
            @JsonProperty("inbound_check_deposit_return_intention")
            @ExcludeMissing
            inboundCheckDepositReturnIntention: JsonField<InboundCheckDepositReturnIntention> =
                JsonMissing.of(),
            @JsonProperty("inbound_real_time_payments_transfer_confirmation")
            @ExcludeMissing
            inboundRealTimePaymentsTransferConfirmation:
                JsonField<InboundRealTimePaymentsTransferConfirmation> =
                JsonMissing.of(),
            @JsonProperty("inbound_wire_reversal")
            @ExcludeMissing
            inboundWireReversal: JsonField<InboundWireReversal> = JsonMissing.of(),
            @JsonProperty("inbound_wire_transfer")
            @ExcludeMissing
            inboundWireTransfer: JsonField<InboundWireTransfer> = JsonMissing.of(),
            @JsonProperty("inbound_wire_transfer_reversal")
            @ExcludeMissing
            inboundWireTransferReversal: JsonField<InboundWireTransferReversal> = JsonMissing.of(),
            @JsonProperty("interest_payment")
            @ExcludeMissing
            interestPayment: JsonField<InterestPayment> = JsonMissing.of(),
            @JsonProperty("internal_source")
            @ExcludeMissing
            internalSource: JsonField<InternalSource> = JsonMissing.of(),
            @JsonProperty("other") @ExcludeMissing other: JsonValue = JsonMissing.of(),
            @JsonProperty("real_time_payments_transfer_acknowledgement")
            @ExcludeMissing
            realTimePaymentsTransferAcknowledgement:
                JsonField<RealTimePaymentsTransferAcknowledgement> =
                JsonMissing.of(),
            @JsonProperty("sample_funds")
            @ExcludeMissing
            sampleFunds: JsonField<SampleFunds> = JsonMissing.of(),
            @JsonProperty("swift_transfer_intention")
            @ExcludeMissing
            swiftTransferIntention: JsonField<SwiftTransferIntention> = JsonMissing.of(),
            @JsonProperty("swift_transfer_return")
            @ExcludeMissing
            swiftTransferReturn: JsonField<SwiftTransferReturn> = JsonMissing.of(),
            @JsonProperty("wire_transfer_intention")
            @ExcludeMissing
            wireTransferIntention: JsonField<WireTransferIntention> = JsonMissing.of(),
        ) : this(
            accountRevenuePayment,
            accountTransferIntention,
            achTransferIntention,
            achTransferRejection,
            achTransferReturn,
            cardDisputeAcceptance,
            cardDisputeFinancial,
            cardDisputeLoss,
            cardPushTransferAcceptance,
            cardRefund,
            cardRevenuePayment,
            cardSettlement,
            cashbackPayment,
            category,
            checkDepositAcceptance,
            checkDepositReturn,
            checkTransferDeposit,
            feePayment,
            inboundAchTransfer,
            inboundAchTransferReturnIntention,
            inboundCheckAdjustment,
            inboundCheckDepositReturnIntention,
            inboundRealTimePaymentsTransferConfirmation,
            inboundWireReversal,
            inboundWireTransfer,
            inboundWireTransferReversal,
            interestPayment,
            internalSource,
            other,
            realTimePaymentsTransferAcknowledgement,
            sampleFunds,
            swiftTransferIntention,
            swiftTransferReturn,
            wireTransferIntention,
            mutableMapOf(),
        )

        /**
         * An Account Revenue Payment object. This field will be present in the JSON response if and
         * only if `category` is equal to `account_revenue_payment`. A Account Revenue Payment
         * represents a payment made to an account from the bank. Account revenue is a type of
         * non-interest income.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun accountRevenuePayment(): AccountRevenuePayment? =
            accountRevenuePayment.getNullable("account_revenue_payment")

        /**
         * An Account Transfer Intention object. This field will be present in the JSON response if
         * and only if `category` is equal to `account_transfer_intention`. Two Account Transfer
         * Intentions are created from each Account Transfer. One decrements the source account, and
         * the other increments the destination account.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun accountTransferIntention(): AccountTransferIntention? =
            accountTransferIntention.getNullable("account_transfer_intention")

        /**
         * An ACH Transfer Intention object. This field will be present in the JSON response if and
         * only if `category` is equal to `ach_transfer_intention`. An ACH Transfer Intention is
         * created from an ACH Transfer. It reflects the intention to move money into or out of an
         * Increase account via the ACH network.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun achTransferIntention(): AchTransferIntention? =
            achTransferIntention.getNullable("ach_transfer_intention")

        /**
         * An ACH Transfer Rejection object. This field will be present in the JSON response if and
         * only if `category` is equal to `ach_transfer_rejection`. An ACH Transfer Rejection is
         * created when an ACH Transfer is rejected by Increase. It offsets the ACH Transfer
         * Intention. These rejections are rare.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun achTransferRejection(): AchTransferRejection? =
            achTransferRejection.getNullable("ach_transfer_rejection")

        /**
         * An ACH Transfer Return object. This field will be present in the JSON response if and
         * only if `category` is equal to `ach_transfer_return`. An ACH Transfer Return is created
         * when an ACH Transfer is returned by the receiving bank. It offsets the ACH Transfer
         * Intention. ACH Transfer Returns usually occur within the first two business days after
         * the transfer is initiated, but can occur much later.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun achTransferReturn(): AchTransferReturn? =
            achTransferReturn.getNullable("ach_transfer_return")

        /**
         * A Card Dispute Acceptance object. This field will be present in the JSON response if and
         * only if `category` is equal to `card_dispute_acceptance`. Contains the details of a
         * successful Card Dispute.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cardDisputeAcceptance(): CardDisputeAcceptance? =
            cardDisputeAcceptance.getNullable("card_dispute_acceptance")

        /**
         * A Card Dispute Financial object. This field will be present in the JSON response if and
         * only if `category` is equal to `card_dispute_financial`. Financial event related to a
         * Card Dispute.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cardDisputeFinancial(): CardDisputeFinancial? =
            cardDisputeFinancial.getNullable("card_dispute_financial")

        /**
         * A Card Dispute Loss object. This field will be present in the JSON response if and only
         * if `category` is equal to `card_dispute_loss`. Contains the details of a lost Card
         * Dispute.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cardDisputeLoss(): CardDisputeLoss? = cardDisputeLoss.getNullable("card_dispute_loss")

        /**
         * A Card Push Transfer Acceptance object. This field will be present in the JSON response
         * if and only if `category` is equal to `card_push_transfer_acceptance`. A Card Push
         * Transfer Acceptance is created when an Outbound Card Push Transfer sent from Increase is
         * accepted by the receiving bank.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cardPushTransferAcceptance(): CardPushTransferAcceptance? =
            cardPushTransferAcceptance.getNullable("card_push_transfer_acceptance")

        /**
         * A Card Refund object. This field will be present in the JSON response if and only if
         * `category` is equal to `card_refund`. Card Refunds move money back to the cardholder.
         * While they are usually connected to a Card Settlement an acquirer can also refund money
         * directly to a card without relation to a transaction.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cardRefund(): CardRefund? = cardRefund.getNullable("card_refund")

        /**
         * A Card Revenue Payment object. This field will be present in the JSON response if and
         * only if `category` is equal to `card_revenue_payment`. Card Revenue Payments reflect
         * earnings from fees on card transactions.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cardRevenuePayment(): CardRevenuePayment? =
            cardRevenuePayment.getNullable("card_revenue_payment")

        /**
         * A Card Settlement object. This field will be present in the JSON response if and only if
         * `category` is equal to `card_settlement`. Card Settlements are card transactions that
         * have cleared and settled. While a settlement is usually preceded by an authorization, an
         * acquirer can also directly clear a transaction without first authorizing it.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cardSettlement(): CardSettlement? = cardSettlement.getNullable("card_settlement")

        /**
         * A Cashback Payment object. This field will be present in the JSON response if and only if
         * `category` is equal to `cashback_payment`. A Cashback Payment represents the cashback
         * paid to a cardholder for a given period. Cashback is usually paid monthly for the prior
         * month's transactions.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun cashbackPayment(): CashbackPayment? = cashbackPayment.getNullable("cashback_payment")

        /**
         * The type of the resource. We may add additional possible values for this enum over time;
         * your application should be able to handle such additions gracefully.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun category(): Category = category.getRequired("category")

        /**
         * A Check Deposit Acceptance object. This field will be present in the JSON response if and
         * only if `category` is equal to `check_deposit_acceptance`. A Check Deposit Acceptance is
         * created when a Check Deposit is processed and its details confirmed. Check Deposits may
         * be returned by the receiving bank, which will appear as a Check Deposit Return.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun checkDepositAcceptance(): CheckDepositAcceptance? =
            checkDepositAcceptance.getNullable("check_deposit_acceptance")

        /**
         * A Check Deposit Return object. This field will be present in the JSON response if and
         * only if `category` is equal to `check_deposit_return`. A Check Deposit Return is created
         * when a Check Deposit is returned by the bank holding the account it was drawn against.
         * Check Deposits may be returned for a variety of reasons, including insufficient funds or
         * a mismatched account number. Usually, checks are returned within the first 7 days after
         * the deposit is made.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun checkDepositReturn(): CheckDepositReturn? =
            checkDepositReturn.getNullable("check_deposit_return")

        /**
         * A Check Transfer Deposit object. This field will be present in the JSON response if and
         * only if `category` is equal to `check_transfer_deposit`. An Inbound Check is a check
         * drawn on an Increase account that has been deposited by an external bank account. These
         * types of checks are not pre-registered.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun checkTransferDeposit(): CheckTransferDeposit? =
            checkTransferDeposit.getNullable("check_transfer_deposit")

        /**
         * A Fee Payment object. This field will be present in the JSON response if and only if
         * `category` is equal to `fee_payment`. A Fee Payment represents a payment made to
         * Increase.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun feePayment(): FeePayment? = feePayment.getNullable("fee_payment")

        /**
         * An Inbound ACH Transfer Intention object. This field will be present in the JSON response
         * if and only if `category` is equal to `inbound_ach_transfer`. An Inbound ACH Transfer
         * Intention is created when an ACH transfer is initiated at another bank and received by
         * Increase.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundAchTransfer(): InboundAchTransfer? =
            inboundAchTransfer.getNullable("inbound_ach_transfer")

        /**
         * An Inbound ACH Transfer Return Intention object. This field will be present in the JSON
         * response if and only if `category` is equal to `inbound_ach_transfer_return_intention`.
         * An Inbound ACH Transfer Return Intention is created when an ACH transfer is initiated at
         * another bank and returned by Increase.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundAchTransferReturnIntention(): InboundAchTransferReturnIntention? =
            inboundAchTransferReturnIntention.getNullable("inbound_ach_transfer_return_intention")

        /**
         * An Inbound Check Adjustment object. This field will be present in the JSON response if
         * and only if `category` is equal to `inbound_check_adjustment`. An Inbound Check
         * Adjustment is created when Increase receives an adjustment for a check or return
         * deposited through Check21.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundCheckAdjustment(): InboundCheckAdjustment? =
            inboundCheckAdjustment.getNullable("inbound_check_adjustment")

        /**
         * An Inbound Check Deposit Return Intention object. This field will be present in the JSON
         * response if and only if `category` is equal to `inbound_check_deposit_return_intention`.
         * An Inbound Check Deposit Return Intention is created when Increase receives an Inbound
         * Check and the User requests that it be returned.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundCheckDepositReturnIntention(): InboundCheckDepositReturnIntention? =
            inboundCheckDepositReturnIntention.getNullable("inbound_check_deposit_return_intention")

        /**
         * An Inbound Real-Time Payments Transfer Confirmation object. This field will be present in
         * the JSON response if and only if `category` is equal to
         * `inbound_real_time_payments_transfer_confirmation`. An Inbound Real-Time Payments
         * Transfer Confirmation is created when a Real-Time Payments transfer is initiated at
         * another bank and received by Increase.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundRealTimePaymentsTransferConfirmation():
            InboundRealTimePaymentsTransferConfirmation? =
            inboundRealTimePaymentsTransferConfirmation.getNullable(
                "inbound_real_time_payments_transfer_confirmation"
            )

        /**
         * An Inbound Wire Reversal object. This field will be present in the JSON response if and
         * only if `category` is equal to `inbound_wire_reversal`. An Inbound Wire Reversal
         * represents a reversal of a wire transfer that was initiated via Increase. The other bank
         * is sending the money back. This most often happens when the original destination account
         * details were incorrect.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundWireReversal(): InboundWireReversal? =
            inboundWireReversal.getNullable("inbound_wire_reversal")

        /**
         * An Inbound Wire Transfer Intention object. This field will be present in the JSON
         * response if and only if `category` is equal to `inbound_wire_transfer`. An Inbound Wire
         * Transfer Intention is created when a wire transfer is initiated at another bank and
         * received by Increase.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundWireTransfer(): InboundWireTransfer? =
            inboundWireTransfer.getNullable("inbound_wire_transfer")

        /**
         * An Inbound Wire Transfer Reversal Intention object. This field will be present in the
         * JSON response if and only if `category` is equal to `inbound_wire_transfer_reversal`. An
         * Inbound Wire Transfer Reversal Intention is created when Increase has received a wire and
         * the User requests that it be reversed.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun inboundWireTransferReversal(): InboundWireTransferReversal? =
            inboundWireTransferReversal.getNullable("inbound_wire_transfer_reversal")

        /**
         * An Interest Payment object. This field will be present in the JSON response if and only
         * if `category` is equal to `interest_payment`. An Interest Payment represents a payment of
         * interest on an account. Interest is usually paid monthly.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun interestPayment(): InterestPayment? = interestPayment.getNullable("interest_payment")

        /**
         * An Internal Source object. This field will be present in the JSON response if and only if
         * `category` is equal to `internal_source`. A transaction between the user and Increase.
         * See the `reason` attribute for more information.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun internalSource(): InternalSource? = internalSource.getNullable("internal_source")

        /**
         * If the category of this Transaction source is equal to `other`, this field will contain
         * an empty object, otherwise it will contain null.
         */
        @JsonProperty("other") @ExcludeMissing fun _other(): JsonValue = other

        /**
         * A Real-Time Payments Transfer Acknowledgement object. This field will be present in the
         * JSON response if and only if `category` is equal to
         * `real_time_payments_transfer_acknowledgement`. A Real-Time Payments Transfer
         * Acknowledgement is created when a Real-Time Payments Transfer sent from Increase is
         * acknowledged by the receiving bank.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun realTimePaymentsTransferAcknowledgement(): RealTimePaymentsTransferAcknowledgement? =
            realTimePaymentsTransferAcknowledgement.getNullable(
                "real_time_payments_transfer_acknowledgement"
            )

        /**
         * A Sample Funds object. This field will be present in the JSON response if and only if
         * `category` is equal to `sample_funds`. Sample funds for testing purposes.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun sampleFunds(): SampleFunds? = sampleFunds.getNullable("sample_funds")

        /**
         * A Swift Transfer Intention object. This field will be present in the JSON response if and
         * only if `category` is equal to `swift_transfer_intention`. A Swift Transfer initiated via
         * Increase.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun swiftTransferIntention(): SwiftTransferIntention? =
            swiftTransferIntention.getNullable("swift_transfer_intention")

        /**
         * A Swift Transfer Return object. This field will be present in the JSON response if and
         * only if `category` is equal to `swift_transfer_return`. A Swift Transfer Return is
         * created when a Swift Transfer is returned by the receiving bank.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun swiftTransferReturn(): SwiftTransferReturn? =
            swiftTransferReturn.getNullable("swift_transfer_return")

        /**
         * A Wire Transfer Intention object. This field will be present in the JSON response if and
         * only if `category` is equal to `wire_transfer_intention`. A Wire Transfer initiated via
         * Increase and sent to a different bank.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun wireTransferIntention(): WireTransferIntention? =
            wireTransferIntention.getNullable("wire_transfer_intention")

        /**
         * Returns the raw JSON value of [accountRevenuePayment].
         *
         * Unlike [accountRevenuePayment], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("account_revenue_payment")
        @ExcludeMissing
        fun _accountRevenuePayment(): JsonField<AccountRevenuePayment> = accountRevenuePayment

        /**
         * Returns the raw JSON value of [accountTransferIntention].
         *
         * Unlike [accountTransferIntention], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("account_transfer_intention")
        @ExcludeMissing
        fun _accountTransferIntention(): JsonField<AccountTransferIntention> =
            accountTransferIntention

        /**
         * Returns the raw JSON value of [achTransferIntention].
         *
         * Unlike [achTransferIntention], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("ach_transfer_intention")
        @ExcludeMissing
        fun _achTransferIntention(): JsonField<AchTransferIntention> = achTransferIntention

        /**
         * Returns the raw JSON value of [achTransferRejection].
         *
         * Unlike [achTransferRejection], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("ach_transfer_rejection")
        @ExcludeMissing
        fun _achTransferRejection(): JsonField<AchTransferRejection> = achTransferRejection

        /**
         * Returns the raw JSON value of [achTransferReturn].
         *
         * Unlike [achTransferReturn], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("ach_transfer_return")
        @ExcludeMissing
        fun _achTransferReturn(): JsonField<AchTransferReturn> = achTransferReturn

        /**
         * Returns the raw JSON value of [cardDisputeAcceptance].
         *
         * Unlike [cardDisputeAcceptance], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("card_dispute_acceptance")
        @ExcludeMissing
        fun _cardDisputeAcceptance(): JsonField<CardDisputeAcceptance> = cardDisputeAcceptance

        /**
         * Returns the raw JSON value of [cardDisputeFinancial].
         *
         * Unlike [cardDisputeFinancial], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("card_dispute_financial")
        @ExcludeMissing
        fun _cardDisputeFinancial(): JsonField<CardDisputeFinancial> = cardDisputeFinancial

        /**
         * Returns the raw JSON value of [cardDisputeLoss].
         *
         * Unlike [cardDisputeLoss], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("card_dispute_loss")
        @ExcludeMissing
        fun _cardDisputeLoss(): JsonField<CardDisputeLoss> = cardDisputeLoss

        /**
         * Returns the raw JSON value of [cardPushTransferAcceptance].
         *
         * Unlike [cardPushTransferAcceptance], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("card_push_transfer_acceptance")
        @ExcludeMissing
        fun _cardPushTransferAcceptance(): JsonField<CardPushTransferAcceptance> =
            cardPushTransferAcceptance

        /**
         * Returns the raw JSON value of [cardRefund].
         *
         * Unlike [cardRefund], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("card_refund")
        @ExcludeMissing
        fun _cardRefund(): JsonField<CardRefund> = cardRefund

        /**
         * Returns the raw JSON value of [cardRevenuePayment].
         *
         * Unlike [cardRevenuePayment], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("card_revenue_payment")
        @ExcludeMissing
        fun _cardRevenuePayment(): JsonField<CardRevenuePayment> = cardRevenuePayment

        /**
         * Returns the raw JSON value of [cardSettlement].
         *
         * Unlike [cardSettlement], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("card_settlement")
        @ExcludeMissing
        fun _cardSettlement(): JsonField<CardSettlement> = cardSettlement

        /**
         * Returns the raw JSON value of [cashbackPayment].
         *
         * Unlike [cashbackPayment], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("cashback_payment")
        @ExcludeMissing
        fun _cashbackPayment(): JsonField<CashbackPayment> = cashbackPayment

        /**
         * Returns the raw JSON value of [category].
         *
         * Unlike [category], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("category") @ExcludeMissing fun _category(): JsonField<Category> = category

        /**
         * Returns the raw JSON value of [checkDepositAcceptance].
         *
         * Unlike [checkDepositAcceptance], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("check_deposit_acceptance")
        @ExcludeMissing
        fun _checkDepositAcceptance(): JsonField<CheckDepositAcceptance> = checkDepositAcceptance

        /**
         * Returns the raw JSON value of [checkDepositReturn].
         *
         * Unlike [checkDepositReturn], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("check_deposit_return")
        @ExcludeMissing
        fun _checkDepositReturn(): JsonField<CheckDepositReturn> = checkDepositReturn

        /**
         * Returns the raw JSON value of [checkTransferDeposit].
         *
         * Unlike [checkTransferDeposit], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("check_transfer_deposit")
        @ExcludeMissing
        fun _checkTransferDeposit(): JsonField<CheckTransferDeposit> = checkTransferDeposit

        /**
         * Returns the raw JSON value of [feePayment].
         *
         * Unlike [feePayment], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("fee_payment")
        @ExcludeMissing
        fun _feePayment(): JsonField<FeePayment> = feePayment

        /**
         * Returns the raw JSON value of [inboundAchTransfer].
         *
         * Unlike [inboundAchTransfer], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("inbound_ach_transfer")
        @ExcludeMissing
        fun _inboundAchTransfer(): JsonField<InboundAchTransfer> = inboundAchTransfer

        /**
         * Returns the raw JSON value of [inboundAchTransferReturnIntention].
         *
         * Unlike [inboundAchTransferReturnIntention], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("inbound_ach_transfer_return_intention")
        @ExcludeMissing
        fun _inboundAchTransferReturnIntention(): JsonField<InboundAchTransferReturnIntention> =
            inboundAchTransferReturnIntention

        /**
         * Returns the raw JSON value of [inboundCheckAdjustment].
         *
         * Unlike [inboundCheckAdjustment], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("inbound_check_adjustment")
        @ExcludeMissing
        fun _inboundCheckAdjustment(): JsonField<InboundCheckAdjustment> = inboundCheckAdjustment

        /**
         * Returns the raw JSON value of [inboundCheckDepositReturnIntention].
         *
         * Unlike [inboundCheckDepositReturnIntention], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("inbound_check_deposit_return_intention")
        @ExcludeMissing
        fun _inboundCheckDepositReturnIntention(): JsonField<InboundCheckDepositReturnIntention> =
            inboundCheckDepositReturnIntention

        /**
         * Returns the raw JSON value of [inboundRealTimePaymentsTransferConfirmation].
         *
         * Unlike [inboundRealTimePaymentsTransferConfirmation], this method doesn't throw if the
         * JSON field has an unexpected type.
         */
        @JsonProperty("inbound_real_time_payments_transfer_confirmation")
        @ExcludeMissing
        fun _inboundRealTimePaymentsTransferConfirmation():
            JsonField<InboundRealTimePaymentsTransferConfirmation> =
            inboundRealTimePaymentsTransferConfirmation

        /**
         * Returns the raw JSON value of [inboundWireReversal].
         *
         * Unlike [inboundWireReversal], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("inbound_wire_reversal")
        @ExcludeMissing
        fun _inboundWireReversal(): JsonField<InboundWireReversal> = inboundWireReversal

        /**
         * Returns the raw JSON value of [inboundWireTransfer].
         *
         * Unlike [inboundWireTransfer], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("inbound_wire_transfer")
        @ExcludeMissing
        fun _inboundWireTransfer(): JsonField<InboundWireTransfer> = inboundWireTransfer

        /**
         * Returns the raw JSON value of [inboundWireTransferReversal].
         *
         * Unlike [inboundWireTransferReversal], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("inbound_wire_transfer_reversal")
        @ExcludeMissing
        fun _inboundWireTransferReversal(): JsonField<InboundWireTransferReversal> =
            inboundWireTransferReversal

        /**
         * Returns the raw JSON value of [interestPayment].
         *
         * Unlike [interestPayment], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("interest_payment")
        @ExcludeMissing
        fun _interestPayment(): JsonField<InterestPayment> = interestPayment

        /**
         * Returns the raw JSON value of [internalSource].
         *
         * Unlike [internalSource], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("internal_source")
        @ExcludeMissing
        fun _internalSource(): JsonField<InternalSource> = internalSource

        /**
         * Returns the raw JSON value of [realTimePaymentsTransferAcknowledgement].
         *
         * Unlike [realTimePaymentsTransferAcknowledgement], this method doesn't throw if the JSON
         * field has an unexpected type.
         */
        @JsonProperty("real_time_payments_transfer_acknowledgement")
        @ExcludeMissing
        fun _realTimePaymentsTransferAcknowledgement():
            JsonField<RealTimePaymentsTransferAcknowledgement> =
            realTimePaymentsTransferAcknowledgement

        /**
         * Returns the raw JSON value of [sampleFunds].
         *
         * Unlike [sampleFunds], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("sample_funds")
        @ExcludeMissing
        fun _sampleFunds(): JsonField<SampleFunds> = sampleFunds

        /**
         * Returns the raw JSON value of [swiftTransferIntention].
         *
         * Unlike [swiftTransferIntention], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("swift_transfer_intention")
        @ExcludeMissing
        fun _swiftTransferIntention(): JsonField<SwiftTransferIntention> = swiftTransferIntention

        /**
         * Returns the raw JSON value of [swiftTransferReturn].
         *
         * Unlike [swiftTransferReturn], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("swift_transfer_return")
        @ExcludeMissing
        fun _swiftTransferReturn(): JsonField<SwiftTransferReturn> = swiftTransferReturn

        /**
         * Returns the raw JSON value of [wireTransferIntention].
         *
         * Unlike [wireTransferIntention], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("wire_transfer_intention")
        @ExcludeMissing
        fun _wireTransferIntention(): JsonField<WireTransferIntention> = wireTransferIntention

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Source].
             *
             * The following fields are required:
             * ```kotlin
             * .accountRevenuePayment()
             * .accountTransferIntention()
             * .achTransferIntention()
             * .achTransferRejection()
             * .achTransferReturn()
             * .cardDisputeAcceptance()
             * .cardDisputeFinancial()
             * .cardDisputeLoss()
             * .cardPushTransferAcceptance()
             * .cardRefund()
             * .cardRevenuePayment()
             * .cardSettlement()
             * .cashbackPayment()
             * .category()
             * .checkDepositAcceptance()
             * .checkDepositReturn()
             * .checkTransferDeposit()
             * .feePayment()
             * .inboundAchTransfer()
             * .inboundAchTransferReturnIntention()
             * .inboundCheckAdjustment()
             * .inboundCheckDepositReturnIntention()
             * .inboundRealTimePaymentsTransferConfirmation()
             * .inboundWireReversal()
             * .inboundWireTransfer()
             * .inboundWireTransferReversal()
             * .interestPayment()
             * .internalSource()
             * .other()
             * .realTimePaymentsTransferAcknowledgement()
             * .sampleFunds()
             * .swiftTransferIntention()
             * .swiftTransferReturn()
             * .wireTransferIntention()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Source]. */
        class Builder internal constructor() {

            private var accountRevenuePayment: JsonField<AccountRevenuePayment>? = null
            private var accountTransferIntention: JsonField<AccountTransferIntention>? = null
            private var achTransferIntention: JsonField<AchTransferIntention>? = null
            private var achTransferRejection: JsonField<AchTransferRejection>? = null
            private var achTransferReturn: JsonField<AchTransferReturn>? = null
            private var cardDisputeAcceptance: JsonField<CardDisputeAcceptance>? = null
            private var cardDisputeFinancial: JsonField<CardDisputeFinancial>? = null
            private var cardDisputeLoss: JsonField<CardDisputeLoss>? = null
            private var cardPushTransferAcceptance: JsonField<CardPushTransferAcceptance>? = null
            private var cardRefund: JsonField<CardRefund>? = null
            private var cardRevenuePayment: JsonField<CardRevenuePayment>? = null
            private var cardSettlement: JsonField<CardSettlement>? = null
            private var cashbackPayment: JsonField<CashbackPayment>? = null
            private var category: JsonField<Category>? = null
            private var checkDepositAcceptance: JsonField<CheckDepositAcceptance>? = null
            private var checkDepositReturn: JsonField<CheckDepositReturn>? = null
            private var checkTransferDeposit: JsonField<CheckTransferDeposit>? = null
            private var feePayment: JsonField<FeePayment>? = null
            private var inboundAchTransfer: JsonField<InboundAchTransfer>? = null
            private var inboundAchTransferReturnIntention:
                JsonField<InboundAchTransferReturnIntention>? =
                null
            private var inboundCheckAdjustment: JsonField<InboundCheckAdjustment>? = null
            private var inboundCheckDepositReturnIntention:
                JsonField<InboundCheckDepositReturnIntention>? =
                null
            private var inboundRealTimePaymentsTransferConfirmation:
                JsonField<InboundRealTimePaymentsTransferConfirmation>? =
                null
            private var inboundWireReversal: JsonField<InboundWireReversal>? = null
            private var inboundWireTransfer: JsonField<InboundWireTransfer>? = null
            private var inboundWireTransferReversal: JsonField<InboundWireTransferReversal>? = null
            private var interestPayment: JsonField<InterestPayment>? = null
            private var internalSource: JsonField<InternalSource>? = null
            private var other: JsonValue? = null
            private var realTimePaymentsTransferAcknowledgement:
                JsonField<RealTimePaymentsTransferAcknowledgement>? =
                null
            private var sampleFunds: JsonField<SampleFunds>? = null
            private var swiftTransferIntention: JsonField<SwiftTransferIntention>? = null
            private var swiftTransferReturn: JsonField<SwiftTransferReturn>? = null
            private var wireTransferIntention: JsonField<WireTransferIntention>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(source: Source) = apply {
                accountRevenuePayment = source.accountRevenuePayment
                accountTransferIntention = source.accountTransferIntention
                achTransferIntention = source.achTransferIntention
                achTransferRejection = source.achTransferRejection
                achTransferReturn = source.achTransferReturn
                cardDisputeAcceptance = source.cardDisputeAcceptance
                cardDisputeFinancial = source.cardDisputeFinancial
                cardDisputeLoss = source.cardDisputeLoss
                cardPushTransferAcceptance = source.cardPushTransferAcceptance
                cardRefund = source.cardRefund
                cardRevenuePayment = source.cardRevenuePayment
                cardSettlement = source.cardSettlement
                cashbackPayment = source.cashbackPayment
                category = source.category
                checkDepositAcceptance = source.checkDepositAcceptance
                checkDepositReturn = source.checkDepositReturn
                checkTransferDeposit = source.checkTransferDeposit
                feePayment = source.feePayment
                inboundAchTransfer = source.inboundAchTransfer
                inboundAchTransferReturnIntention = source.inboundAchTransferReturnIntention
                inboundCheckAdjustment = source.inboundCheckAdjustment
                inboundCheckDepositReturnIntention = source.inboundCheckDepositReturnIntention
                inboundRealTimePaymentsTransferConfirmation =
                    source.inboundRealTimePaymentsTransferConfirmation
                inboundWireReversal = source.inboundWireReversal
                inboundWireTransfer = source.inboundWireTransfer
                inboundWireTransferReversal = source.inboundWireTransferReversal
                interestPayment = source.interestPayment
                internalSource = source.internalSource
                other = source.other
                realTimePaymentsTransferAcknowledgement =
                    source.realTimePaymentsTransferAcknowledgement
                sampleFunds = source.sampleFunds
                swiftTransferIntention = source.swiftTransferIntention
                swiftTransferReturn = source.swiftTransferReturn
                wireTransferIntention = source.wireTransferIntention
                additionalProperties = source.additionalProperties.toMutableMap()
            }

            /**
             * An Account Revenue Payment object. This field will be present in the JSON response if
             * and only if `category` is equal to `account_revenue_payment`. A Account Revenue
             * Payment represents a payment made to an account from the bank. Account revenue is a
             * type of non-interest income.
             */
            fun accountRevenuePayment(accountRevenuePayment: AccountRevenuePayment?) =
                accountRevenuePayment(JsonField.ofNullable(accountRevenuePayment))

            /**
             * Sets [Builder.accountRevenuePayment] to an arbitrary JSON value.
             *
             * You should usually call [Builder.accountRevenuePayment] with a well-typed
             * [AccountRevenuePayment] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun accountRevenuePayment(accountRevenuePayment: JsonField<AccountRevenuePayment>) =
                apply {
                    this.accountRevenuePayment = accountRevenuePayment
                }

            /**
             * An Account Transfer Intention object. This field will be present in the JSON response
             * if and only if `category` is equal to `account_transfer_intention`. Two Account
             * Transfer Intentions are created from each Account Transfer. One decrements the source
             * account, and the other increments the destination account.
             */
            fun accountTransferIntention(accountTransferIntention: AccountTransferIntention?) =
                accountTransferIntention(JsonField.ofNullable(accountTransferIntention))

            /**
             * Sets [Builder.accountTransferIntention] to an arbitrary JSON value.
             *
             * You should usually call [Builder.accountTransferIntention] with a well-typed
             * [AccountTransferIntention] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun accountTransferIntention(
                accountTransferIntention: JsonField<AccountTransferIntention>
            ) = apply { this.accountTransferIntention = accountTransferIntention }

            /**
             * An ACH Transfer Intention object. This field will be present in the JSON response if
             * and only if `category` is equal to `ach_transfer_intention`. An ACH Transfer
             * Intention is created from an ACH Transfer. It reflects the intention to move money
             * into or out of an Increase account via the ACH network.
             */
            fun achTransferIntention(achTransferIntention: AchTransferIntention?) =
                achTransferIntention(JsonField.ofNullable(achTransferIntention))

            /**
             * Sets [Builder.achTransferIntention] to an arbitrary JSON value.
             *
             * You should usually call [Builder.achTransferIntention] with a well-typed
             * [AchTransferIntention] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun achTransferIntention(achTransferIntention: JsonField<AchTransferIntention>) =
                apply {
                    this.achTransferIntention = achTransferIntention
                }

            /**
             * An ACH Transfer Rejection object. This field will be present in the JSON response if
             * and only if `category` is equal to `ach_transfer_rejection`. An ACH Transfer
             * Rejection is created when an ACH Transfer is rejected by Increase. It offsets the ACH
             * Transfer Intention. These rejections are rare.
             */
            fun achTransferRejection(achTransferRejection: AchTransferRejection?) =
                achTransferRejection(JsonField.ofNullable(achTransferRejection))

            /**
             * Sets [Builder.achTransferRejection] to an arbitrary JSON value.
             *
             * You should usually call [Builder.achTransferRejection] with a well-typed
             * [AchTransferRejection] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun achTransferRejection(achTransferRejection: JsonField<AchTransferRejection>) =
                apply {
                    this.achTransferRejection = achTransferRejection
                }

            /**
             * An ACH Transfer Return object. This field will be present in the JSON response if and
             * only if `category` is equal to `ach_transfer_return`. An ACH Transfer Return is
             * created when an ACH Transfer is returned by the receiving bank. It offsets the ACH
             * Transfer Intention. ACH Transfer Returns usually occur within the first two business
             * days after the transfer is initiated, but can occur much later.
             */
            fun achTransferReturn(achTransferReturn: AchTransferReturn?) =
                achTransferReturn(JsonField.ofNullable(achTransferReturn))

            /**
             * Sets [Builder.achTransferReturn] to an arbitrary JSON value.
             *
             * You should usually call [Builder.achTransferReturn] with a well-typed
             * [AchTransferReturn] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun achTransferReturn(achTransferReturn: JsonField<AchTransferReturn>) = apply {
                this.achTransferReturn = achTransferReturn
            }

            /**
             * A Card Dispute Acceptance object. This field will be present in the JSON response if
             * and only if `category` is equal to `card_dispute_acceptance`. Contains the details of
             * a successful Card Dispute.
             */
            fun cardDisputeAcceptance(cardDisputeAcceptance: CardDisputeAcceptance?) =
                cardDisputeAcceptance(JsonField.ofNullable(cardDisputeAcceptance))

            /**
             * Sets [Builder.cardDisputeAcceptance] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cardDisputeAcceptance] with a well-typed
             * [CardDisputeAcceptance] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun cardDisputeAcceptance(cardDisputeAcceptance: JsonField<CardDisputeAcceptance>) =
                apply {
                    this.cardDisputeAcceptance = cardDisputeAcceptance
                }

            /**
             * A Card Dispute Financial object. This field will be present in the JSON response if
             * and only if `category` is equal to `card_dispute_financial`. Financial event related
             * to a Card Dispute.
             */
            fun cardDisputeFinancial(cardDisputeFinancial: CardDisputeFinancial?) =
                cardDisputeFinancial(JsonField.ofNullable(cardDisputeFinancial))

            /**
             * Sets [Builder.cardDisputeFinancial] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cardDisputeFinancial] with a well-typed
             * [CardDisputeFinancial] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun cardDisputeFinancial(cardDisputeFinancial: JsonField<CardDisputeFinancial>) =
                apply {
                    this.cardDisputeFinancial = cardDisputeFinancial
                }

            /**
             * A Card Dispute Loss object. This field will be present in the JSON response if and
             * only if `category` is equal to `card_dispute_loss`. Contains the details of a lost
             * Card Dispute.
             */
            fun cardDisputeLoss(cardDisputeLoss: CardDisputeLoss?) =
                cardDisputeLoss(JsonField.ofNullable(cardDisputeLoss))

            /**
             * Sets [Builder.cardDisputeLoss] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cardDisputeLoss] with a well-typed [CardDisputeLoss]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun cardDisputeLoss(cardDisputeLoss: JsonField<CardDisputeLoss>) = apply {
                this.cardDisputeLoss = cardDisputeLoss
            }

            /**
             * A Card Push Transfer Acceptance object. This field will be present in the JSON
             * response if and only if `category` is equal to `card_push_transfer_acceptance`. A
             * Card Push Transfer Acceptance is created when an Outbound Card Push Transfer sent
             * from Increase is accepted by the receiving bank.
             */
            fun cardPushTransferAcceptance(
                cardPushTransferAcceptance: CardPushTransferAcceptance?
            ) = cardPushTransferAcceptance(JsonField.ofNullable(cardPushTransferAcceptance))

            /**
             * Sets [Builder.cardPushTransferAcceptance] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cardPushTransferAcceptance] with a well-typed
             * [CardPushTransferAcceptance] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun cardPushTransferAcceptance(
                cardPushTransferAcceptance: JsonField<CardPushTransferAcceptance>
            ) = apply { this.cardPushTransferAcceptance = cardPushTransferAcceptance }

            /**
             * A Card Refund object. This field will be present in the JSON response if and only if
             * `category` is equal to `card_refund`. Card Refunds move money back to the cardholder.
             * While they are usually connected to a Card Settlement an acquirer can also refund
             * money directly to a card without relation to a transaction.
             */
            fun cardRefund(cardRefund: CardRefund?) = cardRefund(JsonField.ofNullable(cardRefund))

            /**
             * Sets [Builder.cardRefund] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cardRefund] with a well-typed [CardRefund] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cardRefund(cardRefund: JsonField<CardRefund>) = apply {
                this.cardRefund = cardRefund
            }

            /**
             * A Card Revenue Payment object. This field will be present in the JSON response if and
             * only if `category` is equal to `card_revenue_payment`. Card Revenue Payments reflect
             * earnings from fees on card transactions.
             */
            fun cardRevenuePayment(cardRevenuePayment: CardRevenuePayment?) =
                cardRevenuePayment(JsonField.ofNullable(cardRevenuePayment))

            /**
             * Sets [Builder.cardRevenuePayment] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cardRevenuePayment] with a well-typed
             * [CardRevenuePayment] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun cardRevenuePayment(cardRevenuePayment: JsonField<CardRevenuePayment>) = apply {
                this.cardRevenuePayment = cardRevenuePayment
            }

            /**
             * A Card Settlement object. This field will be present in the JSON response if and only
             * if `category` is equal to `card_settlement`. Card Settlements are card transactions
             * that have cleared and settled. While a settlement is usually preceded by an
             * authorization, an acquirer can also directly clear a transaction without first
             * authorizing it.
             */
            fun cardSettlement(cardSettlement: CardSettlement?) =
                cardSettlement(JsonField.ofNullable(cardSettlement))

            /**
             * Sets [Builder.cardSettlement] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cardSettlement] with a well-typed [CardSettlement]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun cardSettlement(cardSettlement: JsonField<CardSettlement>) = apply {
                this.cardSettlement = cardSettlement
            }

            /**
             * A Cashback Payment object. This field will be present in the JSON response if and
             * only if `category` is equal to `cashback_payment`. A Cashback Payment represents the
             * cashback paid to a cardholder for a given period. Cashback is usually paid monthly
             * for the prior month's transactions.
             */
            fun cashbackPayment(cashbackPayment: CashbackPayment?) =
                cashbackPayment(JsonField.ofNullable(cashbackPayment))

            /**
             * Sets [Builder.cashbackPayment] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cashbackPayment] with a well-typed [CashbackPayment]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun cashbackPayment(cashbackPayment: JsonField<CashbackPayment>) = apply {
                this.cashbackPayment = cashbackPayment
            }

            /**
             * The type of the resource. We may add additional possible values for this enum over
             * time; your application should be able to handle such additions gracefully.
             */
            fun category(category: Category) = category(JsonField.of(category))

            /**
             * Sets [Builder.category] to an arbitrary JSON value.
             *
             * You should usually call [Builder.category] with a well-typed [Category] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun category(category: JsonField<Category>) = apply { this.category = category }

            /**
             * A Check Deposit Acceptance object. This field will be present in the JSON response if
             * and only if `category` is equal to `check_deposit_acceptance`. A Check Deposit
             * Acceptance is created when a Check Deposit is processed and its details confirmed.
             * Check Deposits may be returned by the receiving bank, which will appear as a Check
             * Deposit Return.
             */
            fun checkDepositAcceptance(checkDepositAcceptance: CheckDepositAcceptance?) =
                checkDepositAcceptance(JsonField.ofNullable(checkDepositAcceptance))

            /**
             * Sets [Builder.checkDepositAcceptance] to an arbitrary JSON value.
             *
             * You should usually call [Builder.checkDepositAcceptance] with a well-typed
             * [CheckDepositAcceptance] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun checkDepositAcceptance(checkDepositAcceptance: JsonField<CheckDepositAcceptance>) =
                apply {
                    this.checkDepositAcceptance = checkDepositAcceptance
                }

            /**
             * A Check Deposit Return object. This field will be present in the JSON response if and
             * only if `category` is equal to `check_deposit_return`. A Check Deposit Return is
             * created when a Check Deposit is returned by the bank holding the account it was drawn
             * against. Check Deposits may be returned for a variety of reasons, including
             * insufficient funds or a mismatched account number. Usually, checks are returned
             * within the first 7 days after the deposit is made.
             */
            fun checkDepositReturn(checkDepositReturn: CheckDepositReturn?) =
                checkDepositReturn(JsonField.ofNullable(checkDepositReturn))

            /**
             * Sets [Builder.checkDepositReturn] to an arbitrary JSON value.
             *
             * You should usually call [Builder.checkDepositReturn] with a well-typed
             * [CheckDepositReturn] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun checkDepositReturn(checkDepositReturn: JsonField<CheckDepositReturn>) = apply {
                this.checkDepositReturn = checkDepositReturn
            }

            /**
             * A Check Transfer Deposit object. This field will be present in the JSON response if
             * and only if `category` is equal to `check_transfer_deposit`. An Inbound Check is a
             * check drawn on an Increase account that has been deposited by an external bank
             * account. These types of checks are not pre-registered.
             */
            fun checkTransferDeposit(checkTransferDeposit: CheckTransferDeposit?) =
                checkTransferDeposit(JsonField.ofNullable(checkTransferDeposit))

            /**
             * Sets [Builder.checkTransferDeposit] to an arbitrary JSON value.
             *
             * You should usually call [Builder.checkTransferDeposit] with a well-typed
             * [CheckTransferDeposit] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun checkTransferDeposit(checkTransferDeposit: JsonField<CheckTransferDeposit>) =
                apply {
                    this.checkTransferDeposit = checkTransferDeposit
                }

            /**
             * A Fee Payment object. This field will be present in the JSON response if and only if
             * `category` is equal to `fee_payment`. A Fee Payment represents a payment made to
             * Increase.
             */
            fun feePayment(feePayment: FeePayment?) = feePayment(JsonField.ofNullable(feePayment))

            /**
             * Sets [Builder.feePayment] to an arbitrary JSON value.
             *
             * You should usually call [Builder.feePayment] with a well-typed [FeePayment] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun feePayment(feePayment: JsonField<FeePayment>) = apply {
                this.feePayment = feePayment
            }

            /**
             * An Inbound ACH Transfer Intention object. This field will be present in the JSON
             * response if and only if `category` is equal to `inbound_ach_transfer`. An Inbound ACH
             * Transfer Intention is created when an ACH transfer is initiated at another bank and
             * received by Increase.
             */
            fun inboundAchTransfer(inboundAchTransfer: InboundAchTransfer?) =
                inboundAchTransfer(JsonField.ofNullable(inboundAchTransfer))

            /**
             * Sets [Builder.inboundAchTransfer] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inboundAchTransfer] with a well-typed
             * [InboundAchTransfer] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun inboundAchTransfer(inboundAchTransfer: JsonField<InboundAchTransfer>) = apply {
                this.inboundAchTransfer = inboundAchTransfer
            }

            /**
             * An Inbound ACH Transfer Return Intention object. This field will be present in the
             * JSON response if and only if `category` is equal to
             * `inbound_ach_transfer_return_intention`. An Inbound ACH Transfer Return Intention is
             * created when an ACH transfer is initiated at another bank and returned by Increase.
             */
            fun inboundAchTransferReturnIntention(
                inboundAchTransferReturnIntention: InboundAchTransferReturnIntention?
            ) =
                inboundAchTransferReturnIntention(
                    JsonField.ofNullable(inboundAchTransferReturnIntention)
                )

            /**
             * Sets [Builder.inboundAchTransferReturnIntention] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inboundAchTransferReturnIntention] with a well-typed
             * [InboundAchTransferReturnIntention] value instead. This method is primarily for
             * setting the field to an undocumented or not yet supported value.
             */
            fun inboundAchTransferReturnIntention(
                inboundAchTransferReturnIntention: JsonField<InboundAchTransferReturnIntention>
            ) = apply { this.inboundAchTransferReturnIntention = inboundAchTransferReturnIntention }

            /**
             * An Inbound Check Adjustment object. This field will be present in the JSON response
             * if and only if `category` is equal to `inbound_check_adjustment`. An Inbound Check
             * Adjustment is created when Increase receives an adjustment for a check or return
             * deposited through Check21.
             */
            fun inboundCheckAdjustment(inboundCheckAdjustment: InboundCheckAdjustment?) =
                inboundCheckAdjustment(JsonField.ofNullable(inboundCheckAdjustment))

            /**
             * Sets [Builder.inboundCheckAdjustment] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inboundCheckAdjustment] with a well-typed
             * [InboundCheckAdjustment] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun inboundCheckAdjustment(inboundCheckAdjustment: JsonField<InboundCheckAdjustment>) =
                apply {
                    this.inboundCheckAdjustment = inboundCheckAdjustment
                }

            /**
             * An Inbound Check Deposit Return Intention object. This field will be present in the
             * JSON response if and only if `category` is equal to
             * `inbound_check_deposit_return_intention`. An Inbound Check Deposit Return Intention
             * is created when Increase receives an Inbound Check and the User requests that it be
             * returned.
             */
            fun inboundCheckDepositReturnIntention(
                inboundCheckDepositReturnIntention: InboundCheckDepositReturnIntention?
            ) =
                inboundCheckDepositReturnIntention(
                    JsonField.ofNullable(inboundCheckDepositReturnIntention)
                )

            /**
             * Sets [Builder.inboundCheckDepositReturnIntention] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inboundCheckDepositReturnIntention] with a
             * well-typed [InboundCheckDepositReturnIntention] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun inboundCheckDepositReturnIntention(
                inboundCheckDepositReturnIntention: JsonField<InboundCheckDepositReturnIntention>
            ) = apply {
                this.inboundCheckDepositReturnIntention = inboundCheckDepositReturnIntention
            }

            /**
             * An Inbound Real-Time Payments Transfer Confirmation object. This field will be
             * present in the JSON response if and only if `category` is equal to
             * `inbound_real_time_payments_transfer_confirmation`. An Inbound Real-Time Payments
             * Transfer Confirmation is created when a Real-Time Payments transfer is initiated at
             * another bank and received by Increase.
             */
            fun inboundRealTimePaymentsTransferConfirmation(
                inboundRealTimePaymentsTransferConfirmation:
                    InboundRealTimePaymentsTransferConfirmation?
            ) =
                inboundRealTimePaymentsTransferConfirmation(
                    JsonField.ofNullable(inboundRealTimePaymentsTransferConfirmation)
                )

            /**
             * Sets [Builder.inboundRealTimePaymentsTransferConfirmation] to an arbitrary JSON
             * value.
             *
             * You should usually call [Builder.inboundRealTimePaymentsTransferConfirmation] with a
             * well-typed [InboundRealTimePaymentsTransferConfirmation] value instead. This method
             * is primarily for setting the field to an undocumented or not yet supported value.
             */
            fun inboundRealTimePaymentsTransferConfirmation(
                inboundRealTimePaymentsTransferConfirmation:
                    JsonField<InboundRealTimePaymentsTransferConfirmation>
            ) = apply {
                this.inboundRealTimePaymentsTransferConfirmation =
                    inboundRealTimePaymentsTransferConfirmation
            }

            /**
             * An Inbound Wire Reversal object. This field will be present in the JSON response if
             * and only if `category` is equal to `inbound_wire_reversal`. An Inbound Wire Reversal
             * represents a reversal of a wire transfer that was initiated via Increase. The other
             * bank is sending the money back. This most often happens when the original destination
             * account details were incorrect.
             */
            fun inboundWireReversal(inboundWireReversal: InboundWireReversal?) =
                inboundWireReversal(JsonField.ofNullable(inboundWireReversal))

            /**
             * Sets [Builder.inboundWireReversal] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inboundWireReversal] with a well-typed
             * [InboundWireReversal] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun inboundWireReversal(inboundWireReversal: JsonField<InboundWireReversal>) = apply {
                this.inboundWireReversal = inboundWireReversal
            }

            /**
             * An Inbound Wire Transfer Intention object. This field will be present in the JSON
             * response if and only if `category` is equal to `inbound_wire_transfer`. An Inbound
             * Wire Transfer Intention is created when a wire transfer is initiated at another bank
             * and received by Increase.
             */
            fun inboundWireTransfer(inboundWireTransfer: InboundWireTransfer?) =
                inboundWireTransfer(JsonField.ofNullable(inboundWireTransfer))

            /**
             * Sets [Builder.inboundWireTransfer] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inboundWireTransfer] with a well-typed
             * [InboundWireTransfer] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun inboundWireTransfer(inboundWireTransfer: JsonField<InboundWireTransfer>) = apply {
                this.inboundWireTransfer = inboundWireTransfer
            }

            /**
             * An Inbound Wire Transfer Reversal Intention object. This field will be present in the
             * JSON response if and only if `category` is equal to `inbound_wire_transfer_reversal`.
             * An Inbound Wire Transfer Reversal Intention is created when Increase has received a
             * wire and the User requests that it be reversed.
             */
            fun inboundWireTransferReversal(
                inboundWireTransferReversal: InboundWireTransferReversal?
            ) = inboundWireTransferReversal(JsonField.ofNullable(inboundWireTransferReversal))

            /**
             * Sets [Builder.inboundWireTransferReversal] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inboundWireTransferReversal] with a well-typed
             * [InboundWireTransferReversal] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun inboundWireTransferReversal(
                inboundWireTransferReversal: JsonField<InboundWireTransferReversal>
            ) = apply { this.inboundWireTransferReversal = inboundWireTransferReversal }

            /**
             * An Interest Payment object. This field will be present in the JSON response if and
             * only if `category` is equal to `interest_payment`. An Interest Payment represents a
             * payment of interest on an account. Interest is usually paid monthly.
             */
            fun interestPayment(interestPayment: InterestPayment?) =
                interestPayment(JsonField.ofNullable(interestPayment))

            /**
             * Sets [Builder.interestPayment] to an arbitrary JSON value.
             *
             * You should usually call [Builder.interestPayment] with a well-typed [InterestPayment]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun interestPayment(interestPayment: JsonField<InterestPayment>) = apply {
                this.interestPayment = interestPayment
            }

            /**
             * An Internal Source object. This field will be present in the JSON response if and
             * only if `category` is equal to `internal_source`. A transaction between the user and
             * Increase. See the `reason` attribute for more information.
             */
            fun internalSource(internalSource: InternalSource?) =
                internalSource(JsonField.ofNullable(internalSource))

            /**
             * Sets [Builder.internalSource] to an arbitrary JSON value.
             *
             * You should usually call [Builder.internalSource] with a well-typed [InternalSource]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun internalSource(internalSource: JsonField<InternalSource>) = apply {
                this.internalSource = internalSource
            }

            /**
             * If the category of this Transaction source is equal to `other`, this field will
             * contain an empty object, otherwise it will contain null.
             */
            fun other(other: JsonValue) = apply { this.other = other }

            /**
             * A Real-Time Payments Transfer Acknowledgement object. This field will be present in
             * the JSON response if and only if `category` is equal to
             * `real_time_payments_transfer_acknowledgement`. A Real-Time Payments Transfer
             * Acknowledgement is created when a Real-Time Payments Transfer sent from Increase is
             * acknowledged by the receiving bank.
             */
            fun realTimePaymentsTransferAcknowledgement(
                realTimePaymentsTransferAcknowledgement: RealTimePaymentsTransferAcknowledgement?
            ) =
                realTimePaymentsTransferAcknowledgement(
                    JsonField.ofNullable(realTimePaymentsTransferAcknowledgement)
                )

            /**
             * Sets [Builder.realTimePaymentsTransferAcknowledgement] to an arbitrary JSON value.
             *
             * You should usually call [Builder.realTimePaymentsTransferAcknowledgement] with a
             * well-typed [RealTimePaymentsTransferAcknowledgement] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun realTimePaymentsTransferAcknowledgement(
                realTimePaymentsTransferAcknowledgement:
                    JsonField<RealTimePaymentsTransferAcknowledgement>
            ) = apply {
                this.realTimePaymentsTransferAcknowledgement =
                    realTimePaymentsTransferAcknowledgement
            }

            /**
             * A Sample Funds object. This field will be present in the JSON response if and only if
             * `category` is equal to `sample_funds`. Sample funds for testing purposes.
             */
            fun sampleFunds(sampleFunds: SampleFunds?) =
                sampleFunds(JsonField.ofNullable(sampleFunds))

            /**
             * Sets [Builder.sampleFunds] to an arbitrary JSON value.
             *
             * You should usually call [Builder.sampleFunds] with a well-typed [SampleFunds] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun sampleFunds(sampleFunds: JsonField<SampleFunds>) = apply {
                this.sampleFunds = sampleFunds
            }

            /**
             * A Swift Transfer Intention object. This field will be present in the JSON response if
             * and only if `category` is equal to `swift_transfer_intention`. A Swift Transfer
             * initiated via Increase.
             */
            fun swiftTransferIntention(swiftTransferIntention: SwiftTransferIntention?) =
                swiftTransferIntention(JsonField.ofNullable(swiftTransferIntention))

            /**
             * Sets [Builder.swiftTransferIntention] to an arbitrary JSON value.
             *
             * You should usually call [Builder.swiftTransferIntention] with a well-typed
             * [SwiftTransferIntention] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun swiftTransferIntention(swiftTransferIntention: JsonField<SwiftTransferIntention>) =
                apply {
                    this.swiftTransferIntention = swiftTransferIntention
                }

            /**
             * A Swift Transfer Return object. This field will be present in the JSON response if
             * and only if `category` is equal to `swift_transfer_return`. A Swift Transfer Return
             * is created when a Swift Transfer is returned by the receiving bank.
             */
            fun swiftTransferReturn(swiftTransferReturn: SwiftTransferReturn?) =
                swiftTransferReturn(JsonField.ofNullable(swiftTransferReturn))

            /**
             * Sets [Builder.swiftTransferReturn] to an arbitrary JSON value.
             *
             * You should usually call [Builder.swiftTransferReturn] with a well-typed
             * [SwiftTransferReturn] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun swiftTransferReturn(swiftTransferReturn: JsonField<SwiftTransferReturn>) = apply {
                this.swiftTransferReturn = swiftTransferReturn
            }

            /**
             * A Wire Transfer Intention object. This field will be present in the JSON response if
             * and only if `category` is equal to `wire_transfer_intention`. A Wire Transfer
             * initiated via Increase and sent to a different bank.
             */
            fun wireTransferIntention(wireTransferIntention: WireTransferIntention?) =
                wireTransferIntention(JsonField.ofNullable(wireTransferIntention))

            /**
             * Sets [Builder.wireTransferIntention] to an arbitrary JSON value.
             *
             * You should usually call [Builder.wireTransferIntention] with a well-typed
             * [WireTransferIntention] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun wireTransferIntention(wireTransferIntention: JsonField<WireTransferIntention>) =
                apply {
                    this.wireTransferIntention = wireTransferIntention
                }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Source].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .accountRevenuePayment()
             * .accountTransferIntention()
             * .achTransferIntention()
             * .achTransferRejection()
             * .achTransferReturn()
             * .cardDisputeAcceptance()
             * .cardDisputeFinancial()
             * .cardDisputeLoss()
             * .cardPushTransferAcceptance()
             * .cardRefund()
             * .cardRevenuePayment()
             * .cardSettlement()
             * .cashbackPayment()
             * .category()
             * .checkDepositAcceptance()
             * .checkDepositReturn()
             * .checkTransferDeposit()
             * .feePayment()
             * .inboundAchTransfer()
             * .inboundAchTransferReturnIntention()
             * .inboundCheckAdjustment()
             * .inboundCheckDepositReturnIntention()
             * .inboundRealTimePaymentsTransferConfirmation()
             * .inboundWireReversal()
             * .inboundWireTransfer()
             * .inboundWireTransferReversal()
             * .interestPayment()
             * .internalSource()
             * .other()
             * .realTimePaymentsTransferAcknowledgement()
             * .sampleFunds()
             * .swiftTransferIntention()
             * .swiftTransferReturn()
             * .wireTransferIntention()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Source =
                Source(
                    checkRequired("accountRevenuePayment", accountRevenuePayment),
                    checkRequired("accountTransferIntention", accountTransferIntention),
                    checkRequired("achTransferIntention", achTransferIntention),
                    checkRequired("achTransferRejection", achTransferRejection),
                    checkRequired("achTransferReturn", achTransferReturn),
                    checkRequired("cardDisputeAcceptance", cardDisputeAcceptance),
                    checkRequired("cardDisputeFinancial", cardDisputeFinancial),
                    checkRequired("cardDisputeLoss", cardDisputeLoss),
                    checkRequired("cardPushTransferAcceptance", cardPushTransferAcceptance),
                    checkRequired("cardRefund", cardRefund),
                    checkRequired("cardRevenuePayment", cardRevenuePayment),
                    checkRequired("cardSettlement", cardSettlement),
                    checkRequired("cashbackPayment", cashbackPayment),
                    checkRequired("category", category),
                    checkRequired("checkDepositAcceptance", checkDepositAcceptance),
                    checkRequired("checkDepositReturn", checkDepositReturn),
                    checkRequired("checkTransferDeposit", checkTransferDeposit),
                    checkRequired("feePayment", feePayment),
                    checkRequired("inboundAchTransfer", inboundAchTransfer),
                    checkRequired(
                        "inboundAchTransferReturnIntention",
                        inboundAchTransferReturnIntention,
                    ),
                    checkRequired("inboundCheckAdjustment", inboundCheckAdjustment),
                    checkRequired(
                        "inboundCheckDepositReturnIntention",
                        inboundCheckDepositReturnIntention,
                    ),
                    checkRequired(
                        "inboundRealTimePaymentsTransferConfirmation",
                        inboundRealTimePaymentsTransferConfirmation,
                    ),
                    checkRequired("inboundWireReversal", inboundWireReversal),
                    checkRequired("inboundWireTransfer", inboundWireTransfer),
                    checkRequired("inboundWireTransferReversal", inboundWireTransferReversal),
                    checkRequired("interestPayment", interestPayment),
                    checkRequired("internalSource", internalSource),
                    checkRequired("other", other),
                    checkRequired(
                        "realTimePaymentsTransferAcknowledgement",
                        realTimePaymentsTransferAcknowledgement,
                    ),
                    checkRequired("sampleFunds", sampleFunds),
                    checkRequired("swiftTransferIntention", swiftTransferIntention),
                    checkRequired("swiftTransferReturn", swiftTransferReturn),
                    checkRequired("wireTransferIntention", wireTransferIntention),
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Source = apply {
            if (validated) {
                return@apply
            }

            accountRevenuePayment()?.validate()
            accountTransferIntention()?.validate()
            achTransferIntention()?.validate()
            achTransferRejection()?.validate()
            achTransferReturn()?.validate()
            cardDisputeAcceptance()?.validate()
            cardDisputeFinancial()?.validate()
            cardDisputeLoss()?.validate()
            cardPushTransferAcceptance()?.validate()
            cardRefund()?.validate()
            cardRevenuePayment()?.validate()
            cardSettlement()?.validate()
            cashbackPayment()?.validate()
            category().validate()
            checkDepositAcceptance()?.validate()
            checkDepositReturn()?.validate()
            checkTransferDeposit()?.validate()
            feePayment()?.validate()
            inboundAchTransfer()?.validate()
            inboundAchTransferReturnIntention()?.validate()
            inboundCheckAdjustment()?.validate()
            inboundCheckDepositReturnIntention()?.validate()
            inboundRealTimePaymentsTransferConfirmation()?.validate()
            inboundWireReversal()?.validate()
            inboundWireTransfer()?.validate()
            inboundWireTransferReversal()?.validate()
            interestPayment()?.validate()
            internalSource()?.validate()
            realTimePaymentsTransferAcknowledgement()?.validate()
            sampleFunds()?.validate()
            swiftTransferIntention()?.validate()
            swiftTransferReturn()?.validate()
            wireTransferIntention()?.validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (accountRevenuePayment.asKnown()?.validity() ?: 0) +
                (accountTransferIntention.asKnown()?.validity() ?: 0) +
                (achTransferIntention.asKnown()?.validity() ?: 0) +
                (achTransferRejection.asKnown()?.validity() ?: 0) +
                (achTransferReturn.asKnown()?.validity() ?: 0) +
                (cardDisputeAcceptance.asKnown()?.validity() ?: 0) +
                (cardDisputeFinancial.asKnown()?.validity() ?: 0) +
                (cardDisputeLoss.asKnown()?.validity() ?: 0) +
                (cardPushTransferAcceptance.asKnown()?.validity() ?: 0) +
                (cardRefund.asKnown()?.validity() ?: 0) +
                (cardRevenuePayment.asKnown()?.validity() ?: 0) +
                (cardSettlement.asKnown()?.validity() ?: 0) +
                (cashbackPayment.asKnown()?.validity() ?: 0) +
                (category.asKnown()?.validity() ?: 0) +
                (checkDepositAcceptance.asKnown()?.validity() ?: 0) +
                (checkDepositReturn.asKnown()?.validity() ?: 0) +
                (checkTransferDeposit.asKnown()?.validity() ?: 0) +
                (feePayment.asKnown()?.validity() ?: 0) +
                (inboundAchTransfer.asKnown()?.validity() ?: 0) +
                (inboundAchTransferReturnIntention.asKnown()?.validity() ?: 0) +
                (inboundCheckAdjustment.asKnown()?.validity() ?: 0) +
                (inboundCheckDepositReturnIntention.asKnown()?.validity() ?: 0) +
                (inboundRealTimePaymentsTransferConfirmation.asKnown()?.validity() ?: 0) +
                (inboundWireReversal.asKnown()?.validity() ?: 0) +
                (inboundWireTransfer.asKnown()?.validity() ?: 0) +
                (inboundWireTransferReversal.asKnown()?.validity() ?: 0) +
                (interestPayment.asKnown()?.validity() ?: 0) +
                (internalSource.asKnown()?.validity() ?: 0) +
                (realTimePaymentsTransferAcknowledgement.asKnown()?.validity() ?: 0) +
                (sampleFunds.asKnown()?.validity() ?: 0) +
                (swiftTransferIntention.asKnown()?.validity() ?: 0) +
                (swiftTransferReturn.asKnown()?.validity() ?: 0) +
                (wireTransferIntention.asKnown()?.validity() ?: 0)

        /**
         * An Account Revenue Payment object. This field will be present in the JSON response if and
         * only if `category` is equal to `account_revenue_payment`. A Account Revenue Payment
         * represents a payment made to an account from the bank. Account revenue is a type of
         * non-interest income.
         */
        class AccountRevenuePayment
        private constructor(
            private val accruedOnAccountId: JsonField<String>,
            private val periodEnd: JsonField<OffsetDateTime>,
            private val periodStart: JsonField<OffsetDateTime>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("accrued_on_account_id")
                @ExcludeMissing
                accruedOnAccountId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("period_end")
                @ExcludeMissing
                periodEnd: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("period_start")
                @ExcludeMissing
                periodStart: JsonField<OffsetDateTime> = JsonMissing.of(),
            ) : this(accruedOnAccountId, periodEnd, periodStart, mutableMapOf())

            /**
             * The account on which the account revenue was accrued.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun accruedOnAccountId(): String =
                accruedOnAccountId.getRequired("accrued_on_account_id")

            /**
             * The end of the period for which this transaction paid account revenue.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodEnd(): OffsetDateTime = periodEnd.getRequired("period_end")

            /**
             * The start of the period for which this transaction paid account revenue.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodStart(): OffsetDateTime = periodStart.getRequired("period_start")

            /**
             * Returns the raw JSON value of [accruedOnAccountId].
             *
             * Unlike [accruedOnAccountId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("accrued_on_account_id")
            @ExcludeMissing
            fun _accruedOnAccountId(): JsonField<String> = accruedOnAccountId

            /**
             * Returns the raw JSON value of [periodEnd].
             *
             * Unlike [periodEnd], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_end")
            @ExcludeMissing
            fun _periodEnd(): JsonField<OffsetDateTime> = periodEnd

            /**
             * Returns the raw JSON value of [periodStart].
             *
             * Unlike [periodStart], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_start")
            @ExcludeMissing
            fun _periodStart(): JsonField<OffsetDateTime> = periodStart

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [AccountRevenuePayment].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accruedOnAccountId()
                 * .periodEnd()
                 * .periodStart()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [AccountRevenuePayment]. */
            class Builder internal constructor() {

                private var accruedOnAccountId: JsonField<String>? = null
                private var periodEnd: JsonField<OffsetDateTime>? = null
                private var periodStart: JsonField<OffsetDateTime>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(accountRevenuePayment: AccountRevenuePayment) = apply {
                    accruedOnAccountId = accountRevenuePayment.accruedOnAccountId
                    periodEnd = accountRevenuePayment.periodEnd
                    periodStart = accountRevenuePayment.periodStart
                    additionalProperties = accountRevenuePayment.additionalProperties.toMutableMap()
                }

                /** The account on which the account revenue was accrued. */
                fun accruedOnAccountId(accruedOnAccountId: String) =
                    accruedOnAccountId(JsonField.of(accruedOnAccountId))

                /**
                 * Sets [Builder.accruedOnAccountId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.accruedOnAccountId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun accruedOnAccountId(accruedOnAccountId: JsonField<String>) = apply {
                    this.accruedOnAccountId = accruedOnAccountId
                }

                /** The end of the period for which this transaction paid account revenue. */
                fun periodEnd(periodEnd: OffsetDateTime) = periodEnd(JsonField.of(periodEnd))

                /**
                 * Sets [Builder.periodEnd] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodEnd] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodEnd(periodEnd: JsonField<OffsetDateTime>) = apply {
                    this.periodEnd = periodEnd
                }

                /** The start of the period for which this transaction paid account revenue. */
                fun periodStart(periodStart: OffsetDateTime) =
                    periodStart(JsonField.of(periodStart))

                /**
                 * Sets [Builder.periodStart] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodStart] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodStart(periodStart: JsonField<OffsetDateTime>) = apply {
                    this.periodStart = periodStart
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [AccountRevenuePayment].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accruedOnAccountId()
                 * .periodEnd()
                 * .periodStart()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): AccountRevenuePayment =
                    AccountRevenuePayment(
                        checkRequired("accruedOnAccountId", accruedOnAccountId),
                        checkRequired("periodEnd", periodEnd),
                        checkRequired("periodStart", periodStart),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): AccountRevenuePayment = apply {
                if (validated) {
                    return@apply
                }

                accruedOnAccountId()
                periodEnd()
                periodStart()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (accruedOnAccountId.asKnown() == null) 0 else 1) +
                    (if (periodEnd.asKnown() == null) 0 else 1) +
                    (if (periodStart.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is AccountRevenuePayment &&
                    accruedOnAccountId == other.accruedOnAccountId &&
                    periodEnd == other.periodEnd &&
                    periodStart == other.periodStart &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(accruedOnAccountId, periodEnd, periodStart, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "AccountRevenuePayment{accruedOnAccountId=$accruedOnAccountId, periodEnd=$periodEnd, periodStart=$periodStart, additionalProperties=$additionalProperties}"
        }

        /**
         * An Account Transfer Intention object. This field will be present in the JSON response if
         * and only if `category` is equal to `account_transfer_intention`. Two Account Transfer
         * Intentions are created from each Account Transfer. One decrements the source account, and
         * the other increments the destination account.
         */
        class AccountTransferIntention
        private constructor(
            private val amount: JsonField<Long>,
            private val currency: JsonField<Currency>,
            private val description: JsonField<String>,
            private val destinationAccountId: JsonField<String>,
            private val sourceAccountId: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("description")
                @ExcludeMissing
                description: JsonField<String> = JsonMissing.of(),
                @JsonProperty("destination_account_id")
                @ExcludeMissing
                destinationAccountId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("source_account_id")
                @ExcludeMissing
                sourceAccountId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                amount,
                currency,
                description,
                destinationAccountId,
                sourceAccountId,
                transferId,
                mutableMapOf(),
            )

            /**
             * The pending amount in the minor unit of the transaction's currency. For dollars, for
             * example, this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the destination
             * account currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * The description you chose to give the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun description(): String = description.getRequired("description")

            /**
             * The identifier of the Account to where the Account Transfer was sent.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun destinationAccountId(): String =
                destinationAccountId.getRequired("destination_account_id")

            /**
             * The identifier of the Account from where the Account Transfer was sent.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun sourceAccountId(): String = sourceAccountId.getRequired("source_account_id")

            /**
             * The identifier of the Account Transfer that led to this Pending Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [description].
             *
             * Unlike [description], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("description")
            @ExcludeMissing
            fun _description(): JsonField<String> = description

            /**
             * Returns the raw JSON value of [destinationAccountId].
             *
             * Unlike [destinationAccountId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("destination_account_id")
            @ExcludeMissing
            fun _destinationAccountId(): JsonField<String> = destinationAccountId

            /**
             * Returns the raw JSON value of [sourceAccountId].
             *
             * Unlike [sourceAccountId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("source_account_id")
            @ExcludeMissing
            fun _sourceAccountId(): JsonField<String> = sourceAccountId

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [AccountTransferIntention].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .description()
                 * .destinationAccountId()
                 * .sourceAccountId()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [AccountTransferIntention]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var currency: JsonField<Currency>? = null
                private var description: JsonField<String>? = null
                private var destinationAccountId: JsonField<String>? = null
                private var sourceAccountId: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(accountTransferIntention: AccountTransferIntention) = apply {
                    amount = accountTransferIntention.amount
                    currency = accountTransferIntention.currency
                    description = accountTransferIntention.description
                    destinationAccountId = accountTransferIntention.destinationAccountId
                    sourceAccountId = accountTransferIntention.sourceAccountId
                    transferId = accountTransferIntention.transferId
                    additionalProperties =
                        accountTransferIntention.additionalProperties.toMutableMap()
                }

                /**
                 * The pending amount in the minor unit of the transaction's currency. For dollars,
                 * for example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the destination
                 * account currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** The description you chose to give the transfer. */
                fun description(description: String) = description(JsonField.of(description))

                /**
                 * Sets [Builder.description] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.description] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun description(description: JsonField<String>) = apply {
                    this.description = description
                }

                /** The identifier of the Account to where the Account Transfer was sent. */
                fun destinationAccountId(destinationAccountId: String) =
                    destinationAccountId(JsonField.of(destinationAccountId))

                /**
                 * Sets [Builder.destinationAccountId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.destinationAccountId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun destinationAccountId(destinationAccountId: JsonField<String>) = apply {
                    this.destinationAccountId = destinationAccountId
                }

                /** The identifier of the Account from where the Account Transfer was sent. */
                fun sourceAccountId(sourceAccountId: String) =
                    sourceAccountId(JsonField.of(sourceAccountId))

                /**
                 * Sets [Builder.sourceAccountId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.sourceAccountId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun sourceAccountId(sourceAccountId: JsonField<String>) = apply {
                    this.sourceAccountId = sourceAccountId
                }

                /** The identifier of the Account Transfer that led to this Pending Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [AccountTransferIntention].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .description()
                 * .destinationAccountId()
                 * .sourceAccountId()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): AccountTransferIntention =
                    AccountTransferIntention(
                        checkRequired("amount", amount),
                        checkRequired("currency", currency),
                        checkRequired("description", description),
                        checkRequired("destinationAccountId", destinationAccountId),
                        checkRequired("sourceAccountId", sourceAccountId),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): AccountTransferIntention = apply {
                if (validated) {
                    return@apply
                }

                amount()
                currency().validate()
                description()
                destinationAccountId()
                sourceAccountId()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (if (description.asKnown() == null) 0 else 1) +
                    (if (destinationAccountId.asKnown() == null) 0 else 1) +
                    (if (sourceAccountId.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the destination
             * account currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is AccountTransferIntention &&
                    amount == other.amount &&
                    currency == other.currency &&
                    description == other.description &&
                    destinationAccountId == other.destinationAccountId &&
                    sourceAccountId == other.sourceAccountId &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    currency,
                    description,
                    destinationAccountId,
                    sourceAccountId,
                    transferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "AccountTransferIntention{amount=$amount, currency=$currency, description=$description, destinationAccountId=$destinationAccountId, sourceAccountId=$sourceAccountId, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An ACH Transfer Intention object. This field will be present in the JSON response if and
         * only if `category` is equal to `ach_transfer_intention`. An ACH Transfer Intention is
         * created from an ACH Transfer. It reflects the intention to move money into or out of an
         * Increase account via the ACH network.
         */
        class AchTransferIntention
        private constructor(
            private val accountNumber: JsonField<String>,
            private val amount: JsonField<Long>,
            private val routingNumber: JsonField<String>,
            private val statementDescriptor: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("account_number")
                @ExcludeMissing
                accountNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("routing_number")
                @ExcludeMissing
                routingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("statement_descriptor")
                @ExcludeMissing
                statementDescriptor: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                accountNumber,
                amount,
                routingNumber,
                statementDescriptor,
                transferId,
                mutableMapOf(),
            )

            /**
             * The account number for the destination account.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun accountNumber(): String = accountNumber.getRequired("account_number")

            /**
             * The amount in the minor unit of the transaction's currency. For dollars, for example,
             * this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The American Bankers' Association (ABA) Routing Transit Number (RTN) for the
             * destination account.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun routingNumber(): String = routingNumber.getRequired("routing_number")

            /**
             * A description set when the ACH Transfer was created.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun statementDescriptor(): String =
                statementDescriptor.getRequired("statement_descriptor")

            /**
             * The identifier of the ACH Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [accountNumber].
             *
             * Unlike [accountNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("account_number")
            @ExcludeMissing
            fun _accountNumber(): JsonField<String> = accountNumber

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [routingNumber].
             *
             * Unlike [routingNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("routing_number")
            @ExcludeMissing
            fun _routingNumber(): JsonField<String> = routingNumber

            /**
             * Returns the raw JSON value of [statementDescriptor].
             *
             * Unlike [statementDescriptor], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("statement_descriptor")
            @ExcludeMissing
            fun _statementDescriptor(): JsonField<String> = statementDescriptor

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [AchTransferIntention].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accountNumber()
                 * .amount()
                 * .routingNumber()
                 * .statementDescriptor()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [AchTransferIntention]. */
            class Builder internal constructor() {

                private var accountNumber: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var routingNumber: JsonField<String>? = null
                private var statementDescriptor: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(achTransferIntention: AchTransferIntention) = apply {
                    accountNumber = achTransferIntention.accountNumber
                    amount = achTransferIntention.amount
                    routingNumber = achTransferIntention.routingNumber
                    statementDescriptor = achTransferIntention.statementDescriptor
                    transferId = achTransferIntention.transferId
                    additionalProperties = achTransferIntention.additionalProperties.toMutableMap()
                }

                /** The account number for the destination account. */
                fun accountNumber(accountNumber: String) =
                    accountNumber(JsonField.of(accountNumber))

                /**
                 * Sets [Builder.accountNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.accountNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun accountNumber(accountNumber: JsonField<String>) = apply {
                    this.accountNumber = accountNumber
                }

                /**
                 * The amount in the minor unit of the transaction's currency. For dollars, for
                 * example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The American Bankers' Association (ABA) Routing Transit Number (RTN) for the
                 * destination account.
                 */
                fun routingNumber(routingNumber: String) =
                    routingNumber(JsonField.of(routingNumber))

                /**
                 * Sets [Builder.routingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.routingNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun routingNumber(routingNumber: JsonField<String>) = apply {
                    this.routingNumber = routingNumber
                }

                /** A description set when the ACH Transfer was created. */
                fun statementDescriptor(statementDescriptor: String) =
                    statementDescriptor(JsonField.of(statementDescriptor))

                /**
                 * Sets [Builder.statementDescriptor] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.statementDescriptor] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun statementDescriptor(statementDescriptor: JsonField<String>) = apply {
                    this.statementDescriptor = statementDescriptor
                }

                /** The identifier of the ACH Transfer that led to this Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [AchTransferIntention].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accountNumber()
                 * .amount()
                 * .routingNumber()
                 * .statementDescriptor()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): AchTransferIntention =
                    AchTransferIntention(
                        checkRequired("accountNumber", accountNumber),
                        checkRequired("amount", amount),
                        checkRequired("routingNumber", routingNumber),
                        checkRequired("statementDescriptor", statementDescriptor),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): AchTransferIntention = apply {
                if (validated) {
                    return@apply
                }

                accountNumber()
                amount()
                routingNumber()
                statementDescriptor()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (accountNumber.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (if (routingNumber.asKnown() == null) 0 else 1) +
                    (if (statementDescriptor.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is AchTransferIntention &&
                    accountNumber == other.accountNumber &&
                    amount == other.amount &&
                    routingNumber == other.routingNumber &&
                    statementDescriptor == other.statementDescriptor &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    accountNumber,
                    amount,
                    routingNumber,
                    statementDescriptor,
                    transferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "AchTransferIntention{accountNumber=$accountNumber, amount=$amount, routingNumber=$routingNumber, statementDescriptor=$statementDescriptor, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An ACH Transfer Rejection object. This field will be present in the JSON response if and
         * only if `category` is equal to `ach_transfer_rejection`. An ACH Transfer Rejection is
         * created when an ACH Transfer is rejected by Increase. It offsets the ACH Transfer
         * Intention. These rejections are rare.
         */
        class AchTransferRejection
        private constructor(
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of()
            ) : this(transferId, mutableMapOf())

            /**
             * The identifier of the ACH Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [AchTransferRejection].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [AchTransferRejection]. */
            class Builder internal constructor() {

                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(achTransferRejection: AchTransferRejection) = apply {
                    transferId = achTransferRejection.transferId
                    additionalProperties = achTransferRejection.additionalProperties.toMutableMap()
                }

                /** The identifier of the ACH Transfer that led to this Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [AchTransferRejection].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): AchTransferRejection =
                    AchTransferRejection(
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): AchTransferRejection = apply {
                if (validated) {
                    return@apply
                }

                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is AchTransferRejection &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(transferId, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "AchTransferRejection{transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An ACH Transfer Return object. This field will be present in the JSON response if and
         * only if `category` is equal to `ach_transfer_return`. An ACH Transfer Return is created
         * when an ACH Transfer is returned by the receiving bank. It offsets the ACH Transfer
         * Intention. ACH Transfer Returns usually occur within the first two business days after
         * the transfer is initiated, but can occur much later.
         */
        class AchTransferReturn
        private constructor(
            private val createdAt: JsonField<OffsetDateTime>,
            private val rawReturnReasonCode: JsonField<String>,
            private val returnReasonCode: JsonField<ReturnReasonCode>,
            private val traceNumber: JsonField<String>,
            private val transactionId: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("created_at")
                @ExcludeMissing
                createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("raw_return_reason_code")
                @ExcludeMissing
                rawReturnReasonCode: JsonField<String> = JsonMissing.of(),
                @JsonProperty("return_reason_code")
                @ExcludeMissing
                returnReasonCode: JsonField<ReturnReasonCode> = JsonMissing.of(),
                @JsonProperty("trace_number")
                @ExcludeMissing
                traceNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                createdAt,
                rawReturnReasonCode,
                returnReasonCode,
                traceNumber,
                transactionId,
                transferId,
                mutableMapOf(),
            )

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * transfer was created.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

            /**
             * The three character ACH return code, in the range R01 to R85.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun rawReturnReasonCode(): String =
                rawReturnReasonCode.getRequired("raw_return_reason_code")

            /**
             * Why the ACH Transfer was returned. This reason code is sent by the receiving bank
             * back to Increase.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun returnReasonCode(): ReturnReasonCode =
                returnReasonCode.getRequired("return_reason_code")

            /**
             * A 15 digit number that was generated by the bank that initiated the return. The trace
             * number of the return is different than that of the original transfer. ACH trace
             * numbers are not unique, but along with the amount and date this number can be used to
             * identify the ACH return at the bank that initiated it.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun traceNumber(): String = traceNumber.getRequired("trace_number")

            /**
             * The identifier of the Transaction associated with this return.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * The identifier of the ACH Transfer associated with this return.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [createdAt].
             *
             * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("created_at")
            @ExcludeMissing
            fun _createdAt(): JsonField<OffsetDateTime> = createdAt

            /**
             * Returns the raw JSON value of [rawReturnReasonCode].
             *
             * Unlike [rawReturnReasonCode], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("raw_return_reason_code")
            @ExcludeMissing
            fun _rawReturnReasonCode(): JsonField<String> = rawReturnReasonCode

            /**
             * Returns the raw JSON value of [returnReasonCode].
             *
             * Unlike [returnReasonCode], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("return_reason_code")
            @ExcludeMissing
            fun _returnReasonCode(): JsonField<ReturnReasonCode> = returnReasonCode

            /**
             * Returns the raw JSON value of [traceNumber].
             *
             * Unlike [traceNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("trace_number")
            @ExcludeMissing
            fun _traceNumber(): JsonField<String> = traceNumber

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [AchTransferReturn].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .createdAt()
                 * .rawReturnReasonCode()
                 * .returnReasonCode()
                 * .traceNumber()
                 * .transactionId()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [AchTransferReturn]. */
            class Builder internal constructor() {

                private var createdAt: JsonField<OffsetDateTime>? = null
                private var rawReturnReasonCode: JsonField<String>? = null
                private var returnReasonCode: JsonField<ReturnReasonCode>? = null
                private var traceNumber: JsonField<String>? = null
                private var transactionId: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(achTransferReturn: AchTransferReturn) = apply {
                    createdAt = achTransferReturn.createdAt
                    rawReturnReasonCode = achTransferReturn.rawReturnReasonCode
                    returnReasonCode = achTransferReturn.returnReasonCode
                    traceNumber = achTransferReturn.traceNumber
                    transactionId = achTransferReturn.transactionId
                    transferId = achTransferReturn.transferId
                    additionalProperties = achTransferReturn.additionalProperties.toMutableMap()
                }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * transfer was created.
                 */
                fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

                /**
                 * Sets [Builder.createdAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                    this.createdAt = createdAt
                }

                /** The three character ACH return code, in the range R01 to R85. */
                fun rawReturnReasonCode(rawReturnReasonCode: String) =
                    rawReturnReasonCode(JsonField.of(rawReturnReasonCode))

                /**
                 * Sets [Builder.rawReturnReasonCode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.rawReturnReasonCode] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun rawReturnReasonCode(rawReturnReasonCode: JsonField<String>) = apply {
                    this.rawReturnReasonCode = rawReturnReasonCode
                }

                /**
                 * Why the ACH Transfer was returned. This reason code is sent by the receiving bank
                 * back to Increase.
                 */
                fun returnReasonCode(returnReasonCode: ReturnReasonCode) =
                    returnReasonCode(JsonField.of(returnReasonCode))

                /**
                 * Sets [Builder.returnReasonCode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.returnReasonCode] with a well-typed
                 * [ReturnReasonCode] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun returnReasonCode(returnReasonCode: JsonField<ReturnReasonCode>) = apply {
                    this.returnReasonCode = returnReasonCode
                }

                /**
                 * A 15 digit number that was generated by the bank that initiated the return. The
                 * trace number of the return is different than that of the original transfer. ACH
                 * trace numbers are not unique, but along with the amount and date this number can
                 * be used to identify the ACH return at the bank that initiated it.
                 */
                fun traceNumber(traceNumber: String) = traceNumber(JsonField.of(traceNumber))

                /**
                 * Sets [Builder.traceNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.traceNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun traceNumber(traceNumber: JsonField<String>) = apply {
                    this.traceNumber = traceNumber
                }

                /** The identifier of the Transaction associated with this return. */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                /** The identifier of the ACH Transfer associated with this return. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [AchTransferReturn].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .createdAt()
                 * .rawReturnReasonCode()
                 * .returnReasonCode()
                 * .traceNumber()
                 * .transactionId()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): AchTransferReturn =
                    AchTransferReturn(
                        checkRequired("createdAt", createdAt),
                        checkRequired("rawReturnReasonCode", rawReturnReasonCode),
                        checkRequired("returnReasonCode", returnReasonCode),
                        checkRequired("traceNumber", traceNumber),
                        checkRequired("transactionId", transactionId),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): AchTransferReturn = apply {
                if (validated) {
                    return@apply
                }

                createdAt()
                rawReturnReasonCode()
                returnReasonCode().validate()
                traceNumber()
                transactionId()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (createdAt.asKnown() == null) 0 else 1) +
                    (if (rawReturnReasonCode.asKnown() == null) 0 else 1) +
                    (returnReasonCode.asKnown()?.validity() ?: 0) +
                    (if (traceNumber.asKnown() == null) 0 else 1) +
                    (if (transactionId.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            /**
             * Why the ACH Transfer was returned. This reason code is sent by the receiving bank
             * back to Increase.
             */
            class ReturnReasonCode
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /**
                     * Code R01. Insufficient funds in the receiving account. Sometimes abbreviated
                     * to NSF.
                     */
                    val INSUFFICIENT_FUND = of("insufficient_fund")

                    /**
                     * Code R03. The account does not exist or the receiving bank was unable to
                     * locate it.
                     */
                    val NO_ACCOUNT = of("no_account")

                    /** Code R02. The account is closed at the receiving bank. */
                    val ACCOUNT_CLOSED = of("account_closed")

                    /** Code R04. The account number is invalid at the receiving bank. */
                    val INVALID_ACCOUNT_NUMBER_STRUCTURE = of("invalid_account_number_structure")

                    /**
                     * Code R16. The account at the receiving bank was frozen per the Office of
                     * Foreign Assets Control.
                     */
                    val ACCOUNT_FROZEN_ENTRY_RETURNED_PER_OFAC_INSTRUCTION =
                        of("account_frozen_entry_returned_per_ofac_instruction")

                    /** Code R23. The receiving bank account refused a credit transfer. */
                    val CREDIT_ENTRY_REFUSED_BY_RECEIVER = of("credit_entry_refused_by_receiver")

                    /**
                     * Code R05. The receiving bank rejected because of an incorrect Standard Entry
                     * Class code.
                     */
                    val UNAUTHORIZED_DEBIT_TO_CONSUMER_ACCOUNT_USING_CORPORATE_SEC_CODE =
                        of("unauthorized_debit_to_consumer_account_using_corporate_sec_code")

                    /**
                     * Code R29. The corporate customer at the receiving bank reversed the transfer.
                     */
                    val CORPORATE_CUSTOMER_ADVISED_NOT_AUTHORIZED =
                        of("corporate_customer_advised_not_authorized")

                    /** Code R08. The receiving bank stopped payment on this transfer. */
                    val PAYMENT_STOPPED = of("payment_stopped")

                    /** Code R20. The receiving bank account does not perform transfers. */
                    val NON_TRANSACTION_ACCOUNT = of("non_transaction_account")

                    /**
                     * Code R09. The receiving bank account does not have enough available balance
                     * for the transfer.
                     */
                    val UNCOLLECTED_FUNDS = of("uncollected_funds")

                    /** Code R28. The routing number is incorrect. */
                    val ROUTING_NUMBER_CHECK_DIGIT_ERROR = of("routing_number_check_digit_error")

                    /** Code R10. The customer at the receiving bank reversed the transfer. */
                    val CUSTOMER_ADVISED_UNAUTHORIZED_IMPROPER_INELIGIBLE_OR_INCOMPLETE =
                        of("customer_advised_unauthorized_improper_ineligible_or_incomplete")

                    /** Code R19. The amount field is incorrect or too large. */
                    val AMOUNT_FIELD_ERROR = of("amount_field_error")

                    /**
                     * Code R07. The customer at the receiving institution informed their bank that
                     * they have revoked authorization for a previously authorized transfer.
                     */
                    val AUTHORIZATION_REVOKED_BY_CUSTOMER = of("authorization_revoked_by_customer")

                    /** Code R13. The routing number is invalid. */
                    val INVALID_ACH_ROUTING_NUMBER = of("invalid_ach_routing_number")

                    /**
                     * Code R17. The receiving bank is unable to process a field in the transfer.
                     */
                    val FILE_RECORD_EDIT_CRITERIA = of("file_record_edit_criteria")

                    /** Code R45. The individual name field was invalid. */
                    val ENR_INVALID_INDIVIDUAL_NAME = of("enr_invalid_individual_name")

                    /**
                     * Code R06. The originating financial institution asked for this transfer to be
                     * returned. The receiving bank is complying with the request.
                     */
                    val RETURNED_PER_ODFI_REQUEST = of("returned_per_odfi_request")

                    /**
                     * Code R34. The receiving bank's regulatory supervisor has limited their
                     * participation in the ACH network.
                     */
                    val LIMITED_PARTICIPATION_DFI = of("limited_participation_dfi")

                    /** Code R85. The outbound international ACH transfer was incorrect. */
                    val INCORRECTLY_CODED_OUTBOUND_INTERNATIONAL_PAYMENT =
                        of("incorrectly_coded_outbound_international_payment")

                    /** Code R12. A rare return reason. The account was sold to another bank. */
                    val ACCOUNT_SOLD_TO_ANOTHER_DFI = of("account_sold_to_another_dfi")

                    /** Code R25. The addenda record is incorrect or missing. */
                    val ADDENDA_ERROR = of("addenda_error")

                    /** Code R15. A rare return reason. The account holder is deceased. */
                    val BENEFICIARY_OR_ACCOUNT_HOLDER_DECEASED =
                        of("beneficiary_or_account_holder_deceased")

                    /**
                     * Code R11. A rare return reason. The customer authorized some payment to the
                     * sender, but this payment was not in error.
                     */
                    val CUSTOMER_ADVISED_NOT_WITHIN_AUTHORIZATION_TERMS =
                        of("customer_advised_not_within_authorization_terms")

                    /**
                     * Code R74. A rare return reason. Sent in response to a return that was
                     * returned with code `field_error`. The latest return should include the
                     * corrected field(s).
                     */
                    val CORRECTED_RETURN = of("corrected_return")

                    /**
                     * Code R24. A rare return reason. The receiving bank received an exact
                     * duplicate entry with the same trace number and amount.
                     */
                    val DUPLICATE_ENTRY = of("duplicate_entry")

                    /**
                     * Code R67. A rare return reason. The return this message refers to was a
                     * duplicate.
                     */
                    val DUPLICATE_RETURN = of("duplicate_return")

                    /**
                     * Code R47. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    val ENR_DUPLICATE_ENROLLMENT = of("enr_duplicate_enrollment")

                    /**
                     * Code R43. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    val ENR_INVALID_DFI_ACCOUNT_NUMBER = of("enr_invalid_dfi_account_number")

                    /**
                     * Code R44. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    val ENR_INVALID_INDIVIDUAL_ID_NUMBER = of("enr_invalid_individual_id_number")

                    /**
                     * Code R46. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    val ENR_INVALID_REPRESENTATIVE_PAYEE_INDICATOR =
                        of("enr_invalid_representative_payee_indicator")

                    /**
                     * Code R41. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    val ENR_INVALID_TRANSACTION_CODE = of("enr_invalid_transaction_code")

                    /**
                     * Code R40. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    val ENR_RETURN_OF_ENR_ENTRY = of("enr_return_of_enr_entry")

                    /**
                     * Code R42. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    val ENR_ROUTING_NUMBER_CHECK_DIGIT_ERROR =
                        of("enr_routing_number_check_digit_error")

                    /**
                     * Code R84. A rare return reason. The International ACH Transfer cannot be
                     * processed by the gateway.
                     */
                    val ENTRY_NOT_PROCESSED_BY_GATEWAY = of("entry_not_processed_by_gateway")

                    /**
                     * Code R69. A rare return reason. One or more of the fields in the ACH were
                     * malformed.
                     */
                    val FIELD_ERROR = of("field_error")

                    /**
                     * Code R83. A rare return reason. The Foreign receiving bank was unable to
                     * settle this ACH transfer.
                     */
                    val FOREIGN_RECEIVING_DFI_UNABLE_TO_SETTLE =
                        of("foreign_receiving_dfi_unable_to_settle")

                    /**
                     * Code R80. A rare return reason. The International ACH Transfer is malformed.
                     */
                    val IAT_ENTRY_CODING_ERROR = of("iat_entry_coding_error")

                    /**
                     * Code R18. A rare return reason. The ACH has an improper effective entry date
                     * field.
                     */
                    val IMPROPER_EFFECTIVE_ENTRY_DATE = of("improper_effective_entry_date")

                    /**
                     * Code R39. A rare return reason. The source document related to this ACH,
                     * usually an ACH check conversion, was presented to the bank.
                     */
                    val IMPROPER_SOURCE_DOCUMENT_SOURCE_DOCUMENT_PRESENTED =
                        of("improper_source_document_source_document_presented")

                    /**
                     * Code R21. A rare return reason. The Company ID field of the ACH was invalid.
                     */
                    val INVALID_COMPANY_ID = of("invalid_company_id")

                    /**
                     * Code R82. A rare return reason. The foreign receiving bank identifier for an
                     * International ACH Transfer was invalid.
                     */
                    val INVALID_FOREIGN_RECEIVING_DFI_IDENTIFICATION =
                        of("invalid_foreign_receiving_dfi_identification")

                    /**
                     * Code R22. A rare return reason. The Individual ID number field of the ACH was
                     * invalid.
                     */
                    val INVALID_INDIVIDUAL_ID_NUMBER = of("invalid_individual_id_number")

                    /**
                     * Code R53. A rare return reason. Both the Represented Check ("RCK") entry and
                     * the original check were presented to the bank.
                     */
                    val ITEM_AND_RCK_ENTRY_PRESENTED_FOR_PAYMENT =
                        of("item_and_rck_entry_presented_for_payment")

                    /**
                     * Code R51. A rare return reason. The Represented Check ("RCK") entry is
                     * ineligible.
                     */
                    val ITEM_RELATED_TO_RCK_ENTRY_IS_INELIGIBLE =
                        of("item_related_to_rck_entry_is_ineligible")

                    /** Code R26. A rare return reason. The ACH is missing a required field. */
                    val MANDATORY_FIELD_ERROR = of("mandatory_field_error")

                    /**
                     * Code R71. A rare return reason. The receiving bank does not recognize the
                     * routing number in a dishonored return entry.
                     */
                    val MISROUTED_DISHONORED_RETURN = of("misrouted_dishonored_return")

                    /**
                     * Code R61. A rare return reason. The receiving bank does not recognize the
                     * routing number in a return entry.
                     */
                    val MISROUTED_RETURN = of("misrouted_return")

                    /**
                     * Code R76. A rare return reason. Sent in response to a return, the bank does
                     * not find the errors alleged by the returning bank.
                     */
                    val NO_ERRORS_FOUND = of("no_errors_found")

                    /**
                     * Code R77. A rare return reason. The receiving bank does not accept the return
                     * of the erroneous debit. The funds are not available at the receiving bank.
                     */
                    val NON_ACCEPTANCE_OF_R62_DISHONORED_RETURN =
                        of("non_acceptance_of_r62_dishonored_return")

                    /**
                     * Code R81. A rare return reason. The receiving bank does not accept
                     * International ACH Transfers.
                     */
                    val NON_PARTICIPANT_IN_IAT_PROGRAM = of("non_participant_in_iat_program")

                    /**
                     * Code R31. A rare return reason. A return that has been agreed to be accepted
                     * by the receiving bank, despite falling outside of the usual return timeframe.
                     */
                    val PERMISSIBLE_RETURN_ENTRY = of("permissible_return_entry")

                    /**
                     * Code R70. A rare return reason. The receiving bank had not approved this
                     * return.
                     */
                    val PERMISSIBLE_RETURN_ENTRY_NOT_ACCEPTED =
                        of("permissible_return_entry_not_accepted")

                    /**
                     * Code R32. A rare return reason. The receiving bank could not settle this
                     * transaction.
                     */
                    val RDFI_NON_SETTLEMENT = of("rdfi_non_settlement")

                    /**
                     * Code R30. A rare return reason. The receiving bank does not accept Check
                     * Truncation ACH transfers.
                     */
                    val RDFI_PARTICIPANT_IN_CHECK_TRUNCATION_PROGRAM =
                        of("rdfi_participant_in_check_truncation_program")

                    /** Code R14. A rare return reason. The payee is deceased. */
                    val REPRESENTATIVE_PAYEE_DECEASED_OR_UNABLE_TO_CONTINUE_IN_THAT_CAPACITY =
                        of("representative_payee_deceased_or_unable_to_continue_in_that_capacity")

                    /**
                     * Code R75. A rare return reason. The originating bank disputes that an earlier
                     * `duplicate_entry` return was actually a duplicate.
                     */
                    val RETURN_NOT_A_DUPLICATE = of("return_not_a_duplicate")

                    /**
                     * Code R62. A rare return reason. The originating financial institution made a
                     * mistake and this return corrects it.
                     */
                    val RETURN_OF_ERRONEOUS_OR_REVERSING_DEBIT =
                        of("return_of_erroneous_or_reversing_debit")

                    /** Code R36. A rare return reason. Return of a malformed credit entry. */
                    val RETURN_OF_IMPROPER_CREDIT_ENTRY = of("return_of_improper_credit_entry")

                    /** Code R35. A rare return reason. Return of a malformed debit entry. */
                    val RETURN_OF_IMPROPER_DEBIT_ENTRY = of("return_of_improper_debit_entry")

                    /**
                     * Code R33. A rare return reason. Return of a Destroyed Check ("XKC") entry.
                     */
                    val RETURN_OF_XCK_ENTRY = of("return_of_xck_entry")

                    /**
                     * Code R37. A rare return reason. The source document related to this ACH,
                     * usually an ACH check conversion, was presented to the bank.
                     */
                    val SOURCE_DOCUMENT_PRESENTED_FOR_PAYMENT =
                        of("source_document_presented_for_payment")

                    /**
                     * Code R50. A rare return reason. State law prevents the bank from accepting
                     * the Represented Check ("RCK") entry.
                     */
                    val STATE_LAW_AFFECTING_RCK_ACCEPTANCE =
                        of("state_law_affecting_rck_acceptance")

                    /**
                     * Code R52. A rare return reason. A stop payment was issued on a Represented
                     * Check ("RCK") entry.
                     */
                    val STOP_PAYMENT_ON_ITEM_RELATED_TO_RCK_ENTRY =
                        of("stop_payment_on_item_related_to_rck_entry")

                    /**
                     * Code R38. A rare return reason. The source attached to the ACH, usually an
                     * ACH check conversion, includes a stop payment.
                     */
                    val STOP_PAYMENT_ON_SOURCE_DOCUMENT = of("stop_payment_on_source_document")

                    /**
                     * Code R73. A rare return reason. The bank receiving an `untimely_return`
                     * believes it was on time.
                     */
                    val TIMELY_ORIGINAL_RETURN = of("timely_original_return")

                    /**
                     * Code R27. A rare return reason. An ACH return's trace number does not match
                     * an originated ACH.
                     */
                    val TRACE_NUMBER_ERROR = of("trace_number_error")

                    /** Code R72. A rare return reason. The dishonored return was sent too late. */
                    val UNTIMELY_DISHONORED_RETURN = of("untimely_dishonored_return")

                    /** Code R68. A rare return reason. The return was sent too late. */
                    val UNTIMELY_RETURN = of("untimely_return")

                    fun of(value: String) = ReturnReasonCode(JsonField.of(value))
                }

                /** An enum containing [ReturnReasonCode]'s known values. */
                enum class Known {
                    /**
                     * Code R01. Insufficient funds in the receiving account. Sometimes abbreviated
                     * to NSF.
                     */
                    INSUFFICIENT_FUND,
                    /**
                     * Code R03. The account does not exist or the receiving bank was unable to
                     * locate it.
                     */
                    NO_ACCOUNT,
                    /** Code R02. The account is closed at the receiving bank. */
                    ACCOUNT_CLOSED,
                    /** Code R04. The account number is invalid at the receiving bank. */
                    INVALID_ACCOUNT_NUMBER_STRUCTURE,
                    /**
                     * Code R16. The account at the receiving bank was frozen per the Office of
                     * Foreign Assets Control.
                     */
                    ACCOUNT_FROZEN_ENTRY_RETURNED_PER_OFAC_INSTRUCTION,
                    /** Code R23. The receiving bank account refused a credit transfer. */
                    CREDIT_ENTRY_REFUSED_BY_RECEIVER,
                    /**
                     * Code R05. The receiving bank rejected because of an incorrect Standard Entry
                     * Class code.
                     */
                    UNAUTHORIZED_DEBIT_TO_CONSUMER_ACCOUNT_USING_CORPORATE_SEC_CODE,
                    /**
                     * Code R29. The corporate customer at the receiving bank reversed the transfer.
                     */
                    CORPORATE_CUSTOMER_ADVISED_NOT_AUTHORIZED,
                    /** Code R08. The receiving bank stopped payment on this transfer. */
                    PAYMENT_STOPPED,
                    /** Code R20. The receiving bank account does not perform transfers. */
                    NON_TRANSACTION_ACCOUNT,
                    /**
                     * Code R09. The receiving bank account does not have enough available balance
                     * for the transfer.
                     */
                    UNCOLLECTED_FUNDS,
                    /** Code R28. The routing number is incorrect. */
                    ROUTING_NUMBER_CHECK_DIGIT_ERROR,
                    /** Code R10. The customer at the receiving bank reversed the transfer. */
                    CUSTOMER_ADVISED_UNAUTHORIZED_IMPROPER_INELIGIBLE_OR_INCOMPLETE,
                    /** Code R19. The amount field is incorrect or too large. */
                    AMOUNT_FIELD_ERROR,
                    /**
                     * Code R07. The customer at the receiving institution informed their bank that
                     * they have revoked authorization for a previously authorized transfer.
                     */
                    AUTHORIZATION_REVOKED_BY_CUSTOMER,
                    /** Code R13. The routing number is invalid. */
                    INVALID_ACH_ROUTING_NUMBER,
                    /**
                     * Code R17. The receiving bank is unable to process a field in the transfer.
                     */
                    FILE_RECORD_EDIT_CRITERIA,
                    /** Code R45. The individual name field was invalid. */
                    ENR_INVALID_INDIVIDUAL_NAME,
                    /**
                     * Code R06. The originating financial institution asked for this transfer to be
                     * returned. The receiving bank is complying with the request.
                     */
                    RETURNED_PER_ODFI_REQUEST,
                    /**
                     * Code R34. The receiving bank's regulatory supervisor has limited their
                     * participation in the ACH network.
                     */
                    LIMITED_PARTICIPATION_DFI,
                    /** Code R85. The outbound international ACH transfer was incorrect. */
                    INCORRECTLY_CODED_OUTBOUND_INTERNATIONAL_PAYMENT,
                    /** Code R12. A rare return reason. The account was sold to another bank. */
                    ACCOUNT_SOLD_TO_ANOTHER_DFI,
                    /** Code R25. The addenda record is incorrect or missing. */
                    ADDENDA_ERROR,
                    /** Code R15. A rare return reason. The account holder is deceased. */
                    BENEFICIARY_OR_ACCOUNT_HOLDER_DECEASED,
                    /**
                     * Code R11. A rare return reason. The customer authorized some payment to the
                     * sender, but this payment was not in error.
                     */
                    CUSTOMER_ADVISED_NOT_WITHIN_AUTHORIZATION_TERMS,
                    /**
                     * Code R74. A rare return reason. Sent in response to a return that was
                     * returned with code `field_error`. The latest return should include the
                     * corrected field(s).
                     */
                    CORRECTED_RETURN,
                    /**
                     * Code R24. A rare return reason. The receiving bank received an exact
                     * duplicate entry with the same trace number and amount.
                     */
                    DUPLICATE_ENTRY,
                    /**
                     * Code R67. A rare return reason. The return this message refers to was a
                     * duplicate.
                     */
                    DUPLICATE_RETURN,
                    /**
                     * Code R47. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_DUPLICATE_ENROLLMENT,
                    /**
                     * Code R43. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_DFI_ACCOUNT_NUMBER,
                    /**
                     * Code R44. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_INDIVIDUAL_ID_NUMBER,
                    /**
                     * Code R46. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_REPRESENTATIVE_PAYEE_INDICATOR,
                    /**
                     * Code R41. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_TRANSACTION_CODE,
                    /**
                     * Code R40. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_RETURN_OF_ENR_ENTRY,
                    /**
                     * Code R42. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_ROUTING_NUMBER_CHECK_DIGIT_ERROR,
                    /**
                     * Code R84. A rare return reason. The International ACH Transfer cannot be
                     * processed by the gateway.
                     */
                    ENTRY_NOT_PROCESSED_BY_GATEWAY,
                    /**
                     * Code R69. A rare return reason. One or more of the fields in the ACH were
                     * malformed.
                     */
                    FIELD_ERROR,
                    /**
                     * Code R83. A rare return reason. The Foreign receiving bank was unable to
                     * settle this ACH transfer.
                     */
                    FOREIGN_RECEIVING_DFI_UNABLE_TO_SETTLE,
                    /**
                     * Code R80. A rare return reason. The International ACH Transfer is malformed.
                     */
                    IAT_ENTRY_CODING_ERROR,
                    /**
                     * Code R18. A rare return reason. The ACH has an improper effective entry date
                     * field.
                     */
                    IMPROPER_EFFECTIVE_ENTRY_DATE,
                    /**
                     * Code R39. A rare return reason. The source document related to this ACH,
                     * usually an ACH check conversion, was presented to the bank.
                     */
                    IMPROPER_SOURCE_DOCUMENT_SOURCE_DOCUMENT_PRESENTED,
                    /**
                     * Code R21. A rare return reason. The Company ID field of the ACH was invalid.
                     */
                    INVALID_COMPANY_ID,
                    /**
                     * Code R82. A rare return reason. The foreign receiving bank identifier for an
                     * International ACH Transfer was invalid.
                     */
                    INVALID_FOREIGN_RECEIVING_DFI_IDENTIFICATION,
                    /**
                     * Code R22. A rare return reason. The Individual ID number field of the ACH was
                     * invalid.
                     */
                    INVALID_INDIVIDUAL_ID_NUMBER,
                    /**
                     * Code R53. A rare return reason. Both the Represented Check ("RCK") entry and
                     * the original check were presented to the bank.
                     */
                    ITEM_AND_RCK_ENTRY_PRESENTED_FOR_PAYMENT,
                    /**
                     * Code R51. A rare return reason. The Represented Check ("RCK") entry is
                     * ineligible.
                     */
                    ITEM_RELATED_TO_RCK_ENTRY_IS_INELIGIBLE,
                    /** Code R26. A rare return reason. The ACH is missing a required field. */
                    MANDATORY_FIELD_ERROR,
                    /**
                     * Code R71. A rare return reason. The receiving bank does not recognize the
                     * routing number in a dishonored return entry.
                     */
                    MISROUTED_DISHONORED_RETURN,
                    /**
                     * Code R61. A rare return reason. The receiving bank does not recognize the
                     * routing number in a return entry.
                     */
                    MISROUTED_RETURN,
                    /**
                     * Code R76. A rare return reason. Sent in response to a return, the bank does
                     * not find the errors alleged by the returning bank.
                     */
                    NO_ERRORS_FOUND,
                    /**
                     * Code R77. A rare return reason. The receiving bank does not accept the return
                     * of the erroneous debit. The funds are not available at the receiving bank.
                     */
                    NON_ACCEPTANCE_OF_R62_DISHONORED_RETURN,
                    /**
                     * Code R81. A rare return reason. The receiving bank does not accept
                     * International ACH Transfers.
                     */
                    NON_PARTICIPANT_IN_IAT_PROGRAM,
                    /**
                     * Code R31. A rare return reason. A return that has been agreed to be accepted
                     * by the receiving bank, despite falling outside of the usual return timeframe.
                     */
                    PERMISSIBLE_RETURN_ENTRY,
                    /**
                     * Code R70. A rare return reason. The receiving bank had not approved this
                     * return.
                     */
                    PERMISSIBLE_RETURN_ENTRY_NOT_ACCEPTED,
                    /**
                     * Code R32. A rare return reason. The receiving bank could not settle this
                     * transaction.
                     */
                    RDFI_NON_SETTLEMENT,
                    /**
                     * Code R30. A rare return reason. The receiving bank does not accept Check
                     * Truncation ACH transfers.
                     */
                    RDFI_PARTICIPANT_IN_CHECK_TRUNCATION_PROGRAM,
                    /** Code R14. A rare return reason. The payee is deceased. */
                    REPRESENTATIVE_PAYEE_DECEASED_OR_UNABLE_TO_CONTINUE_IN_THAT_CAPACITY,
                    /**
                     * Code R75. A rare return reason. The originating bank disputes that an earlier
                     * `duplicate_entry` return was actually a duplicate.
                     */
                    RETURN_NOT_A_DUPLICATE,
                    /**
                     * Code R62. A rare return reason. The originating financial institution made a
                     * mistake and this return corrects it.
                     */
                    RETURN_OF_ERRONEOUS_OR_REVERSING_DEBIT,
                    /** Code R36. A rare return reason. Return of a malformed credit entry. */
                    RETURN_OF_IMPROPER_CREDIT_ENTRY,
                    /** Code R35. A rare return reason. Return of a malformed debit entry. */
                    RETURN_OF_IMPROPER_DEBIT_ENTRY,
                    /**
                     * Code R33. A rare return reason. Return of a Destroyed Check ("XKC") entry.
                     */
                    RETURN_OF_XCK_ENTRY,
                    /**
                     * Code R37. A rare return reason. The source document related to this ACH,
                     * usually an ACH check conversion, was presented to the bank.
                     */
                    SOURCE_DOCUMENT_PRESENTED_FOR_PAYMENT,
                    /**
                     * Code R50. A rare return reason. State law prevents the bank from accepting
                     * the Represented Check ("RCK") entry.
                     */
                    STATE_LAW_AFFECTING_RCK_ACCEPTANCE,
                    /**
                     * Code R52. A rare return reason. A stop payment was issued on a Represented
                     * Check ("RCK") entry.
                     */
                    STOP_PAYMENT_ON_ITEM_RELATED_TO_RCK_ENTRY,
                    /**
                     * Code R38. A rare return reason. The source attached to the ACH, usually an
                     * ACH check conversion, includes a stop payment.
                     */
                    STOP_PAYMENT_ON_SOURCE_DOCUMENT,
                    /**
                     * Code R73. A rare return reason. The bank receiving an `untimely_return`
                     * believes it was on time.
                     */
                    TIMELY_ORIGINAL_RETURN,
                    /**
                     * Code R27. A rare return reason. An ACH return's trace number does not match
                     * an originated ACH.
                     */
                    TRACE_NUMBER_ERROR,
                    /** Code R72. A rare return reason. The dishonored return was sent too late. */
                    UNTIMELY_DISHONORED_RETURN,
                    /** Code R68. A rare return reason. The return was sent too late. */
                    UNTIMELY_RETURN,
                }

                /**
                 * An enum containing [ReturnReasonCode]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [ReturnReasonCode] can contain an unknown value in a couple of
                 * cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /**
                     * Code R01. Insufficient funds in the receiving account. Sometimes abbreviated
                     * to NSF.
                     */
                    INSUFFICIENT_FUND,
                    /**
                     * Code R03. The account does not exist or the receiving bank was unable to
                     * locate it.
                     */
                    NO_ACCOUNT,
                    /** Code R02. The account is closed at the receiving bank. */
                    ACCOUNT_CLOSED,
                    /** Code R04. The account number is invalid at the receiving bank. */
                    INVALID_ACCOUNT_NUMBER_STRUCTURE,
                    /**
                     * Code R16. The account at the receiving bank was frozen per the Office of
                     * Foreign Assets Control.
                     */
                    ACCOUNT_FROZEN_ENTRY_RETURNED_PER_OFAC_INSTRUCTION,
                    /** Code R23. The receiving bank account refused a credit transfer. */
                    CREDIT_ENTRY_REFUSED_BY_RECEIVER,
                    /**
                     * Code R05. The receiving bank rejected because of an incorrect Standard Entry
                     * Class code.
                     */
                    UNAUTHORIZED_DEBIT_TO_CONSUMER_ACCOUNT_USING_CORPORATE_SEC_CODE,
                    /**
                     * Code R29. The corporate customer at the receiving bank reversed the transfer.
                     */
                    CORPORATE_CUSTOMER_ADVISED_NOT_AUTHORIZED,
                    /** Code R08. The receiving bank stopped payment on this transfer. */
                    PAYMENT_STOPPED,
                    /** Code R20. The receiving bank account does not perform transfers. */
                    NON_TRANSACTION_ACCOUNT,
                    /**
                     * Code R09. The receiving bank account does not have enough available balance
                     * for the transfer.
                     */
                    UNCOLLECTED_FUNDS,
                    /** Code R28. The routing number is incorrect. */
                    ROUTING_NUMBER_CHECK_DIGIT_ERROR,
                    /** Code R10. The customer at the receiving bank reversed the transfer. */
                    CUSTOMER_ADVISED_UNAUTHORIZED_IMPROPER_INELIGIBLE_OR_INCOMPLETE,
                    /** Code R19. The amount field is incorrect or too large. */
                    AMOUNT_FIELD_ERROR,
                    /**
                     * Code R07. The customer at the receiving institution informed their bank that
                     * they have revoked authorization for a previously authorized transfer.
                     */
                    AUTHORIZATION_REVOKED_BY_CUSTOMER,
                    /** Code R13. The routing number is invalid. */
                    INVALID_ACH_ROUTING_NUMBER,
                    /**
                     * Code R17. The receiving bank is unable to process a field in the transfer.
                     */
                    FILE_RECORD_EDIT_CRITERIA,
                    /** Code R45. The individual name field was invalid. */
                    ENR_INVALID_INDIVIDUAL_NAME,
                    /**
                     * Code R06. The originating financial institution asked for this transfer to be
                     * returned. The receiving bank is complying with the request.
                     */
                    RETURNED_PER_ODFI_REQUEST,
                    /**
                     * Code R34. The receiving bank's regulatory supervisor has limited their
                     * participation in the ACH network.
                     */
                    LIMITED_PARTICIPATION_DFI,
                    /** Code R85. The outbound international ACH transfer was incorrect. */
                    INCORRECTLY_CODED_OUTBOUND_INTERNATIONAL_PAYMENT,
                    /** Code R12. A rare return reason. The account was sold to another bank. */
                    ACCOUNT_SOLD_TO_ANOTHER_DFI,
                    /** Code R25. The addenda record is incorrect or missing. */
                    ADDENDA_ERROR,
                    /** Code R15. A rare return reason. The account holder is deceased. */
                    BENEFICIARY_OR_ACCOUNT_HOLDER_DECEASED,
                    /**
                     * Code R11. A rare return reason. The customer authorized some payment to the
                     * sender, but this payment was not in error.
                     */
                    CUSTOMER_ADVISED_NOT_WITHIN_AUTHORIZATION_TERMS,
                    /**
                     * Code R74. A rare return reason. Sent in response to a return that was
                     * returned with code `field_error`. The latest return should include the
                     * corrected field(s).
                     */
                    CORRECTED_RETURN,
                    /**
                     * Code R24. A rare return reason. The receiving bank received an exact
                     * duplicate entry with the same trace number and amount.
                     */
                    DUPLICATE_ENTRY,
                    /**
                     * Code R67. A rare return reason. The return this message refers to was a
                     * duplicate.
                     */
                    DUPLICATE_RETURN,
                    /**
                     * Code R47. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_DUPLICATE_ENROLLMENT,
                    /**
                     * Code R43. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_DFI_ACCOUNT_NUMBER,
                    /**
                     * Code R44. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_INDIVIDUAL_ID_NUMBER,
                    /**
                     * Code R46. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_REPRESENTATIVE_PAYEE_INDICATOR,
                    /**
                     * Code R41. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_INVALID_TRANSACTION_CODE,
                    /**
                     * Code R40. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_RETURN_OF_ENR_ENTRY,
                    /**
                     * Code R42. A rare return reason. Only used for US Government agency
                     * non-monetary automatic enrollment messages.
                     */
                    ENR_ROUTING_NUMBER_CHECK_DIGIT_ERROR,
                    /**
                     * Code R84. A rare return reason. The International ACH Transfer cannot be
                     * processed by the gateway.
                     */
                    ENTRY_NOT_PROCESSED_BY_GATEWAY,
                    /**
                     * Code R69. A rare return reason. One or more of the fields in the ACH were
                     * malformed.
                     */
                    FIELD_ERROR,
                    /**
                     * Code R83. A rare return reason. The Foreign receiving bank was unable to
                     * settle this ACH transfer.
                     */
                    FOREIGN_RECEIVING_DFI_UNABLE_TO_SETTLE,
                    /**
                     * Code R80. A rare return reason. The International ACH Transfer is malformed.
                     */
                    IAT_ENTRY_CODING_ERROR,
                    /**
                     * Code R18. A rare return reason. The ACH has an improper effective entry date
                     * field.
                     */
                    IMPROPER_EFFECTIVE_ENTRY_DATE,
                    /**
                     * Code R39. A rare return reason. The source document related to this ACH,
                     * usually an ACH check conversion, was presented to the bank.
                     */
                    IMPROPER_SOURCE_DOCUMENT_SOURCE_DOCUMENT_PRESENTED,
                    /**
                     * Code R21. A rare return reason. The Company ID field of the ACH was invalid.
                     */
                    INVALID_COMPANY_ID,
                    /**
                     * Code R82. A rare return reason. The foreign receiving bank identifier for an
                     * International ACH Transfer was invalid.
                     */
                    INVALID_FOREIGN_RECEIVING_DFI_IDENTIFICATION,
                    /**
                     * Code R22. A rare return reason. The Individual ID number field of the ACH was
                     * invalid.
                     */
                    INVALID_INDIVIDUAL_ID_NUMBER,
                    /**
                     * Code R53. A rare return reason. Both the Represented Check ("RCK") entry and
                     * the original check were presented to the bank.
                     */
                    ITEM_AND_RCK_ENTRY_PRESENTED_FOR_PAYMENT,
                    /**
                     * Code R51. A rare return reason. The Represented Check ("RCK") entry is
                     * ineligible.
                     */
                    ITEM_RELATED_TO_RCK_ENTRY_IS_INELIGIBLE,
                    /** Code R26. A rare return reason. The ACH is missing a required field. */
                    MANDATORY_FIELD_ERROR,
                    /**
                     * Code R71. A rare return reason. The receiving bank does not recognize the
                     * routing number in a dishonored return entry.
                     */
                    MISROUTED_DISHONORED_RETURN,
                    /**
                     * Code R61. A rare return reason. The receiving bank does not recognize the
                     * routing number in a return entry.
                     */
                    MISROUTED_RETURN,
                    /**
                     * Code R76. A rare return reason. Sent in response to a return, the bank does
                     * not find the errors alleged by the returning bank.
                     */
                    NO_ERRORS_FOUND,
                    /**
                     * Code R77. A rare return reason. The receiving bank does not accept the return
                     * of the erroneous debit. The funds are not available at the receiving bank.
                     */
                    NON_ACCEPTANCE_OF_R62_DISHONORED_RETURN,
                    /**
                     * Code R81. A rare return reason. The receiving bank does not accept
                     * International ACH Transfers.
                     */
                    NON_PARTICIPANT_IN_IAT_PROGRAM,
                    /**
                     * Code R31. A rare return reason. A return that has been agreed to be accepted
                     * by the receiving bank, despite falling outside of the usual return timeframe.
                     */
                    PERMISSIBLE_RETURN_ENTRY,
                    /**
                     * Code R70. A rare return reason. The receiving bank had not approved this
                     * return.
                     */
                    PERMISSIBLE_RETURN_ENTRY_NOT_ACCEPTED,
                    /**
                     * Code R32. A rare return reason. The receiving bank could not settle this
                     * transaction.
                     */
                    RDFI_NON_SETTLEMENT,
                    /**
                     * Code R30. A rare return reason. The receiving bank does not accept Check
                     * Truncation ACH transfers.
                     */
                    RDFI_PARTICIPANT_IN_CHECK_TRUNCATION_PROGRAM,
                    /** Code R14. A rare return reason. The payee is deceased. */
                    REPRESENTATIVE_PAYEE_DECEASED_OR_UNABLE_TO_CONTINUE_IN_THAT_CAPACITY,
                    /**
                     * Code R75. A rare return reason. The originating bank disputes that an earlier
                     * `duplicate_entry` return was actually a duplicate.
                     */
                    RETURN_NOT_A_DUPLICATE,
                    /**
                     * Code R62. A rare return reason. The originating financial institution made a
                     * mistake and this return corrects it.
                     */
                    RETURN_OF_ERRONEOUS_OR_REVERSING_DEBIT,
                    /** Code R36. A rare return reason. Return of a malformed credit entry. */
                    RETURN_OF_IMPROPER_CREDIT_ENTRY,
                    /** Code R35. A rare return reason. Return of a malformed debit entry. */
                    RETURN_OF_IMPROPER_DEBIT_ENTRY,
                    /**
                     * Code R33. A rare return reason. Return of a Destroyed Check ("XKC") entry.
                     */
                    RETURN_OF_XCK_ENTRY,
                    /**
                     * Code R37. A rare return reason. The source document related to this ACH,
                     * usually an ACH check conversion, was presented to the bank.
                     */
                    SOURCE_DOCUMENT_PRESENTED_FOR_PAYMENT,
                    /**
                     * Code R50. A rare return reason. State law prevents the bank from accepting
                     * the Represented Check ("RCK") entry.
                     */
                    STATE_LAW_AFFECTING_RCK_ACCEPTANCE,
                    /**
                     * Code R52. A rare return reason. A stop payment was issued on a Represented
                     * Check ("RCK") entry.
                     */
                    STOP_PAYMENT_ON_ITEM_RELATED_TO_RCK_ENTRY,
                    /**
                     * Code R38. A rare return reason. The source attached to the ACH, usually an
                     * ACH check conversion, includes a stop payment.
                     */
                    STOP_PAYMENT_ON_SOURCE_DOCUMENT,
                    /**
                     * Code R73. A rare return reason. The bank receiving an `untimely_return`
                     * believes it was on time.
                     */
                    TIMELY_ORIGINAL_RETURN,
                    /**
                     * Code R27. A rare return reason. An ACH return's trace number does not match
                     * an originated ACH.
                     */
                    TRACE_NUMBER_ERROR,
                    /** Code R72. A rare return reason. The dishonored return was sent too late. */
                    UNTIMELY_DISHONORED_RETURN,
                    /** Code R68. A rare return reason. The return was sent too late. */
                    UNTIMELY_RETURN,
                    /**
                     * An enum member indicating that [ReturnReasonCode] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        INSUFFICIENT_FUND -> Value.INSUFFICIENT_FUND
                        NO_ACCOUNT -> Value.NO_ACCOUNT
                        ACCOUNT_CLOSED -> Value.ACCOUNT_CLOSED
                        INVALID_ACCOUNT_NUMBER_STRUCTURE -> Value.INVALID_ACCOUNT_NUMBER_STRUCTURE
                        ACCOUNT_FROZEN_ENTRY_RETURNED_PER_OFAC_INSTRUCTION ->
                            Value.ACCOUNT_FROZEN_ENTRY_RETURNED_PER_OFAC_INSTRUCTION
                        CREDIT_ENTRY_REFUSED_BY_RECEIVER -> Value.CREDIT_ENTRY_REFUSED_BY_RECEIVER
                        UNAUTHORIZED_DEBIT_TO_CONSUMER_ACCOUNT_USING_CORPORATE_SEC_CODE ->
                            Value.UNAUTHORIZED_DEBIT_TO_CONSUMER_ACCOUNT_USING_CORPORATE_SEC_CODE
                        CORPORATE_CUSTOMER_ADVISED_NOT_AUTHORIZED ->
                            Value.CORPORATE_CUSTOMER_ADVISED_NOT_AUTHORIZED
                        PAYMENT_STOPPED -> Value.PAYMENT_STOPPED
                        NON_TRANSACTION_ACCOUNT -> Value.NON_TRANSACTION_ACCOUNT
                        UNCOLLECTED_FUNDS -> Value.UNCOLLECTED_FUNDS
                        ROUTING_NUMBER_CHECK_DIGIT_ERROR -> Value.ROUTING_NUMBER_CHECK_DIGIT_ERROR
                        CUSTOMER_ADVISED_UNAUTHORIZED_IMPROPER_INELIGIBLE_OR_INCOMPLETE ->
                            Value.CUSTOMER_ADVISED_UNAUTHORIZED_IMPROPER_INELIGIBLE_OR_INCOMPLETE
                        AMOUNT_FIELD_ERROR -> Value.AMOUNT_FIELD_ERROR
                        AUTHORIZATION_REVOKED_BY_CUSTOMER -> Value.AUTHORIZATION_REVOKED_BY_CUSTOMER
                        INVALID_ACH_ROUTING_NUMBER -> Value.INVALID_ACH_ROUTING_NUMBER
                        FILE_RECORD_EDIT_CRITERIA -> Value.FILE_RECORD_EDIT_CRITERIA
                        ENR_INVALID_INDIVIDUAL_NAME -> Value.ENR_INVALID_INDIVIDUAL_NAME
                        RETURNED_PER_ODFI_REQUEST -> Value.RETURNED_PER_ODFI_REQUEST
                        LIMITED_PARTICIPATION_DFI -> Value.LIMITED_PARTICIPATION_DFI
                        INCORRECTLY_CODED_OUTBOUND_INTERNATIONAL_PAYMENT ->
                            Value.INCORRECTLY_CODED_OUTBOUND_INTERNATIONAL_PAYMENT
                        ACCOUNT_SOLD_TO_ANOTHER_DFI -> Value.ACCOUNT_SOLD_TO_ANOTHER_DFI
                        ADDENDA_ERROR -> Value.ADDENDA_ERROR
                        BENEFICIARY_OR_ACCOUNT_HOLDER_DECEASED ->
                            Value.BENEFICIARY_OR_ACCOUNT_HOLDER_DECEASED
                        CUSTOMER_ADVISED_NOT_WITHIN_AUTHORIZATION_TERMS ->
                            Value.CUSTOMER_ADVISED_NOT_WITHIN_AUTHORIZATION_TERMS
                        CORRECTED_RETURN -> Value.CORRECTED_RETURN
                        DUPLICATE_ENTRY -> Value.DUPLICATE_ENTRY
                        DUPLICATE_RETURN -> Value.DUPLICATE_RETURN
                        ENR_DUPLICATE_ENROLLMENT -> Value.ENR_DUPLICATE_ENROLLMENT
                        ENR_INVALID_DFI_ACCOUNT_NUMBER -> Value.ENR_INVALID_DFI_ACCOUNT_NUMBER
                        ENR_INVALID_INDIVIDUAL_ID_NUMBER -> Value.ENR_INVALID_INDIVIDUAL_ID_NUMBER
                        ENR_INVALID_REPRESENTATIVE_PAYEE_INDICATOR ->
                            Value.ENR_INVALID_REPRESENTATIVE_PAYEE_INDICATOR
                        ENR_INVALID_TRANSACTION_CODE -> Value.ENR_INVALID_TRANSACTION_CODE
                        ENR_RETURN_OF_ENR_ENTRY -> Value.ENR_RETURN_OF_ENR_ENTRY
                        ENR_ROUTING_NUMBER_CHECK_DIGIT_ERROR ->
                            Value.ENR_ROUTING_NUMBER_CHECK_DIGIT_ERROR
                        ENTRY_NOT_PROCESSED_BY_GATEWAY -> Value.ENTRY_NOT_PROCESSED_BY_GATEWAY
                        FIELD_ERROR -> Value.FIELD_ERROR
                        FOREIGN_RECEIVING_DFI_UNABLE_TO_SETTLE ->
                            Value.FOREIGN_RECEIVING_DFI_UNABLE_TO_SETTLE
                        IAT_ENTRY_CODING_ERROR -> Value.IAT_ENTRY_CODING_ERROR
                        IMPROPER_EFFECTIVE_ENTRY_DATE -> Value.IMPROPER_EFFECTIVE_ENTRY_DATE
                        IMPROPER_SOURCE_DOCUMENT_SOURCE_DOCUMENT_PRESENTED ->
                            Value.IMPROPER_SOURCE_DOCUMENT_SOURCE_DOCUMENT_PRESENTED
                        INVALID_COMPANY_ID -> Value.INVALID_COMPANY_ID
                        INVALID_FOREIGN_RECEIVING_DFI_IDENTIFICATION ->
                            Value.INVALID_FOREIGN_RECEIVING_DFI_IDENTIFICATION
                        INVALID_INDIVIDUAL_ID_NUMBER -> Value.INVALID_INDIVIDUAL_ID_NUMBER
                        ITEM_AND_RCK_ENTRY_PRESENTED_FOR_PAYMENT ->
                            Value.ITEM_AND_RCK_ENTRY_PRESENTED_FOR_PAYMENT
                        ITEM_RELATED_TO_RCK_ENTRY_IS_INELIGIBLE ->
                            Value.ITEM_RELATED_TO_RCK_ENTRY_IS_INELIGIBLE
                        MANDATORY_FIELD_ERROR -> Value.MANDATORY_FIELD_ERROR
                        MISROUTED_DISHONORED_RETURN -> Value.MISROUTED_DISHONORED_RETURN
                        MISROUTED_RETURN -> Value.MISROUTED_RETURN
                        NO_ERRORS_FOUND -> Value.NO_ERRORS_FOUND
                        NON_ACCEPTANCE_OF_R62_DISHONORED_RETURN ->
                            Value.NON_ACCEPTANCE_OF_R62_DISHONORED_RETURN
                        NON_PARTICIPANT_IN_IAT_PROGRAM -> Value.NON_PARTICIPANT_IN_IAT_PROGRAM
                        PERMISSIBLE_RETURN_ENTRY -> Value.PERMISSIBLE_RETURN_ENTRY
                        PERMISSIBLE_RETURN_ENTRY_NOT_ACCEPTED ->
                            Value.PERMISSIBLE_RETURN_ENTRY_NOT_ACCEPTED
                        RDFI_NON_SETTLEMENT -> Value.RDFI_NON_SETTLEMENT
                        RDFI_PARTICIPANT_IN_CHECK_TRUNCATION_PROGRAM ->
                            Value.RDFI_PARTICIPANT_IN_CHECK_TRUNCATION_PROGRAM
                        REPRESENTATIVE_PAYEE_DECEASED_OR_UNABLE_TO_CONTINUE_IN_THAT_CAPACITY ->
                            Value
                                .REPRESENTATIVE_PAYEE_DECEASED_OR_UNABLE_TO_CONTINUE_IN_THAT_CAPACITY
                        RETURN_NOT_A_DUPLICATE -> Value.RETURN_NOT_A_DUPLICATE
                        RETURN_OF_ERRONEOUS_OR_REVERSING_DEBIT ->
                            Value.RETURN_OF_ERRONEOUS_OR_REVERSING_DEBIT
                        RETURN_OF_IMPROPER_CREDIT_ENTRY -> Value.RETURN_OF_IMPROPER_CREDIT_ENTRY
                        RETURN_OF_IMPROPER_DEBIT_ENTRY -> Value.RETURN_OF_IMPROPER_DEBIT_ENTRY
                        RETURN_OF_XCK_ENTRY -> Value.RETURN_OF_XCK_ENTRY
                        SOURCE_DOCUMENT_PRESENTED_FOR_PAYMENT ->
                            Value.SOURCE_DOCUMENT_PRESENTED_FOR_PAYMENT
                        STATE_LAW_AFFECTING_RCK_ACCEPTANCE ->
                            Value.STATE_LAW_AFFECTING_RCK_ACCEPTANCE
                        STOP_PAYMENT_ON_ITEM_RELATED_TO_RCK_ENTRY ->
                            Value.STOP_PAYMENT_ON_ITEM_RELATED_TO_RCK_ENTRY
                        STOP_PAYMENT_ON_SOURCE_DOCUMENT -> Value.STOP_PAYMENT_ON_SOURCE_DOCUMENT
                        TIMELY_ORIGINAL_RETURN -> Value.TIMELY_ORIGINAL_RETURN
                        TRACE_NUMBER_ERROR -> Value.TRACE_NUMBER_ERROR
                        UNTIMELY_DISHONORED_RETURN -> Value.UNTIMELY_DISHONORED_RETURN
                        UNTIMELY_RETURN -> Value.UNTIMELY_RETURN
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        INSUFFICIENT_FUND -> Known.INSUFFICIENT_FUND
                        NO_ACCOUNT -> Known.NO_ACCOUNT
                        ACCOUNT_CLOSED -> Known.ACCOUNT_CLOSED
                        INVALID_ACCOUNT_NUMBER_STRUCTURE -> Known.INVALID_ACCOUNT_NUMBER_STRUCTURE
                        ACCOUNT_FROZEN_ENTRY_RETURNED_PER_OFAC_INSTRUCTION ->
                            Known.ACCOUNT_FROZEN_ENTRY_RETURNED_PER_OFAC_INSTRUCTION
                        CREDIT_ENTRY_REFUSED_BY_RECEIVER -> Known.CREDIT_ENTRY_REFUSED_BY_RECEIVER
                        UNAUTHORIZED_DEBIT_TO_CONSUMER_ACCOUNT_USING_CORPORATE_SEC_CODE ->
                            Known.UNAUTHORIZED_DEBIT_TO_CONSUMER_ACCOUNT_USING_CORPORATE_SEC_CODE
                        CORPORATE_CUSTOMER_ADVISED_NOT_AUTHORIZED ->
                            Known.CORPORATE_CUSTOMER_ADVISED_NOT_AUTHORIZED
                        PAYMENT_STOPPED -> Known.PAYMENT_STOPPED
                        NON_TRANSACTION_ACCOUNT -> Known.NON_TRANSACTION_ACCOUNT
                        UNCOLLECTED_FUNDS -> Known.UNCOLLECTED_FUNDS
                        ROUTING_NUMBER_CHECK_DIGIT_ERROR -> Known.ROUTING_NUMBER_CHECK_DIGIT_ERROR
                        CUSTOMER_ADVISED_UNAUTHORIZED_IMPROPER_INELIGIBLE_OR_INCOMPLETE ->
                            Known.CUSTOMER_ADVISED_UNAUTHORIZED_IMPROPER_INELIGIBLE_OR_INCOMPLETE
                        AMOUNT_FIELD_ERROR -> Known.AMOUNT_FIELD_ERROR
                        AUTHORIZATION_REVOKED_BY_CUSTOMER -> Known.AUTHORIZATION_REVOKED_BY_CUSTOMER
                        INVALID_ACH_ROUTING_NUMBER -> Known.INVALID_ACH_ROUTING_NUMBER
                        FILE_RECORD_EDIT_CRITERIA -> Known.FILE_RECORD_EDIT_CRITERIA
                        ENR_INVALID_INDIVIDUAL_NAME -> Known.ENR_INVALID_INDIVIDUAL_NAME
                        RETURNED_PER_ODFI_REQUEST -> Known.RETURNED_PER_ODFI_REQUEST
                        LIMITED_PARTICIPATION_DFI -> Known.LIMITED_PARTICIPATION_DFI
                        INCORRECTLY_CODED_OUTBOUND_INTERNATIONAL_PAYMENT ->
                            Known.INCORRECTLY_CODED_OUTBOUND_INTERNATIONAL_PAYMENT
                        ACCOUNT_SOLD_TO_ANOTHER_DFI -> Known.ACCOUNT_SOLD_TO_ANOTHER_DFI
                        ADDENDA_ERROR -> Known.ADDENDA_ERROR
                        BENEFICIARY_OR_ACCOUNT_HOLDER_DECEASED ->
                            Known.BENEFICIARY_OR_ACCOUNT_HOLDER_DECEASED
                        CUSTOMER_ADVISED_NOT_WITHIN_AUTHORIZATION_TERMS ->
                            Known.CUSTOMER_ADVISED_NOT_WITHIN_AUTHORIZATION_TERMS
                        CORRECTED_RETURN -> Known.CORRECTED_RETURN
                        DUPLICATE_ENTRY -> Known.DUPLICATE_ENTRY
                        DUPLICATE_RETURN -> Known.DUPLICATE_RETURN
                        ENR_DUPLICATE_ENROLLMENT -> Known.ENR_DUPLICATE_ENROLLMENT
                        ENR_INVALID_DFI_ACCOUNT_NUMBER -> Known.ENR_INVALID_DFI_ACCOUNT_NUMBER
                        ENR_INVALID_INDIVIDUAL_ID_NUMBER -> Known.ENR_INVALID_INDIVIDUAL_ID_NUMBER
                        ENR_INVALID_REPRESENTATIVE_PAYEE_INDICATOR ->
                            Known.ENR_INVALID_REPRESENTATIVE_PAYEE_INDICATOR
                        ENR_INVALID_TRANSACTION_CODE -> Known.ENR_INVALID_TRANSACTION_CODE
                        ENR_RETURN_OF_ENR_ENTRY -> Known.ENR_RETURN_OF_ENR_ENTRY
                        ENR_ROUTING_NUMBER_CHECK_DIGIT_ERROR ->
                            Known.ENR_ROUTING_NUMBER_CHECK_DIGIT_ERROR
                        ENTRY_NOT_PROCESSED_BY_GATEWAY -> Known.ENTRY_NOT_PROCESSED_BY_GATEWAY
                        FIELD_ERROR -> Known.FIELD_ERROR
                        FOREIGN_RECEIVING_DFI_UNABLE_TO_SETTLE ->
                            Known.FOREIGN_RECEIVING_DFI_UNABLE_TO_SETTLE
                        IAT_ENTRY_CODING_ERROR -> Known.IAT_ENTRY_CODING_ERROR
                        IMPROPER_EFFECTIVE_ENTRY_DATE -> Known.IMPROPER_EFFECTIVE_ENTRY_DATE
                        IMPROPER_SOURCE_DOCUMENT_SOURCE_DOCUMENT_PRESENTED ->
                            Known.IMPROPER_SOURCE_DOCUMENT_SOURCE_DOCUMENT_PRESENTED
                        INVALID_COMPANY_ID -> Known.INVALID_COMPANY_ID
                        INVALID_FOREIGN_RECEIVING_DFI_IDENTIFICATION ->
                            Known.INVALID_FOREIGN_RECEIVING_DFI_IDENTIFICATION
                        INVALID_INDIVIDUAL_ID_NUMBER -> Known.INVALID_INDIVIDUAL_ID_NUMBER
                        ITEM_AND_RCK_ENTRY_PRESENTED_FOR_PAYMENT ->
                            Known.ITEM_AND_RCK_ENTRY_PRESENTED_FOR_PAYMENT
                        ITEM_RELATED_TO_RCK_ENTRY_IS_INELIGIBLE ->
                            Known.ITEM_RELATED_TO_RCK_ENTRY_IS_INELIGIBLE
                        MANDATORY_FIELD_ERROR -> Known.MANDATORY_FIELD_ERROR
                        MISROUTED_DISHONORED_RETURN -> Known.MISROUTED_DISHONORED_RETURN
                        MISROUTED_RETURN -> Known.MISROUTED_RETURN
                        NO_ERRORS_FOUND -> Known.NO_ERRORS_FOUND
                        NON_ACCEPTANCE_OF_R62_DISHONORED_RETURN ->
                            Known.NON_ACCEPTANCE_OF_R62_DISHONORED_RETURN
                        NON_PARTICIPANT_IN_IAT_PROGRAM -> Known.NON_PARTICIPANT_IN_IAT_PROGRAM
                        PERMISSIBLE_RETURN_ENTRY -> Known.PERMISSIBLE_RETURN_ENTRY
                        PERMISSIBLE_RETURN_ENTRY_NOT_ACCEPTED ->
                            Known.PERMISSIBLE_RETURN_ENTRY_NOT_ACCEPTED
                        RDFI_NON_SETTLEMENT -> Known.RDFI_NON_SETTLEMENT
                        RDFI_PARTICIPANT_IN_CHECK_TRUNCATION_PROGRAM ->
                            Known.RDFI_PARTICIPANT_IN_CHECK_TRUNCATION_PROGRAM
                        REPRESENTATIVE_PAYEE_DECEASED_OR_UNABLE_TO_CONTINUE_IN_THAT_CAPACITY ->
                            Known
                                .REPRESENTATIVE_PAYEE_DECEASED_OR_UNABLE_TO_CONTINUE_IN_THAT_CAPACITY
                        RETURN_NOT_A_DUPLICATE -> Known.RETURN_NOT_A_DUPLICATE
                        RETURN_OF_ERRONEOUS_OR_REVERSING_DEBIT ->
                            Known.RETURN_OF_ERRONEOUS_OR_REVERSING_DEBIT
                        RETURN_OF_IMPROPER_CREDIT_ENTRY -> Known.RETURN_OF_IMPROPER_CREDIT_ENTRY
                        RETURN_OF_IMPROPER_DEBIT_ENTRY -> Known.RETURN_OF_IMPROPER_DEBIT_ENTRY
                        RETURN_OF_XCK_ENTRY -> Known.RETURN_OF_XCK_ENTRY
                        SOURCE_DOCUMENT_PRESENTED_FOR_PAYMENT ->
                            Known.SOURCE_DOCUMENT_PRESENTED_FOR_PAYMENT
                        STATE_LAW_AFFECTING_RCK_ACCEPTANCE ->
                            Known.STATE_LAW_AFFECTING_RCK_ACCEPTANCE
                        STOP_PAYMENT_ON_ITEM_RELATED_TO_RCK_ENTRY ->
                            Known.STOP_PAYMENT_ON_ITEM_RELATED_TO_RCK_ENTRY
                        STOP_PAYMENT_ON_SOURCE_DOCUMENT -> Known.STOP_PAYMENT_ON_SOURCE_DOCUMENT
                        TIMELY_ORIGINAL_RETURN -> Known.TIMELY_ORIGINAL_RETURN
                        TRACE_NUMBER_ERROR -> Known.TRACE_NUMBER_ERROR
                        UNTIMELY_DISHONORED_RETURN -> Known.UNTIMELY_DISHONORED_RETURN
                        UNTIMELY_RETURN -> Known.UNTIMELY_RETURN
                        else ->
                            throw IncreaseInvalidDataException("Unknown ReturnReasonCode: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): ReturnReasonCode = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ReturnReasonCode && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is AchTransferReturn &&
                    createdAt == other.createdAt &&
                    rawReturnReasonCode == other.rawReturnReasonCode &&
                    returnReasonCode == other.returnReasonCode &&
                    traceNumber == other.traceNumber &&
                    transactionId == other.transactionId &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    createdAt,
                    rawReturnReasonCode,
                    returnReasonCode,
                    traceNumber,
                    transactionId,
                    transferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "AchTransferReturn{createdAt=$createdAt, rawReturnReasonCode=$rawReturnReasonCode, returnReasonCode=$returnReasonCode, traceNumber=$traceNumber, transactionId=$transactionId, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Card Dispute Acceptance object. This field will be present in the JSON response if and
         * only if `category` is equal to `card_dispute_acceptance`. Contains the details of a
         * successful Card Dispute.
         */
        class CardDisputeAcceptance
        private constructor(
            private val acceptedAt: JsonField<OffsetDateTime>,
            private val cardDisputeId: JsonField<String>,
            private val transactionId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("accepted_at")
                @ExcludeMissing
                acceptedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("card_dispute_id")
                @ExcludeMissing
                cardDisputeId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
            ) : this(acceptedAt, cardDisputeId, transactionId, mutableMapOf())

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * Card Dispute was accepted.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun acceptedAt(): OffsetDateTime = acceptedAt.getRequired("accepted_at")

            /**
             * The identifier of the Card Dispute that was accepted.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun cardDisputeId(): String = cardDisputeId.getRequired("card_dispute_id")

            /**
             * The identifier of the Transaction that was created to return the disputed funds to
             * your account.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * Returns the raw JSON value of [acceptedAt].
             *
             * Unlike [acceptedAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("accepted_at")
            @ExcludeMissing
            fun _acceptedAt(): JsonField<OffsetDateTime> = acceptedAt

            /**
             * Returns the raw JSON value of [cardDisputeId].
             *
             * Unlike [cardDisputeId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("card_dispute_id")
            @ExcludeMissing
            fun _cardDisputeId(): JsonField<String> = cardDisputeId

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [CardDisputeAcceptance].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .acceptedAt()
                 * .cardDisputeId()
                 * .transactionId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CardDisputeAcceptance]. */
            class Builder internal constructor() {

                private var acceptedAt: JsonField<OffsetDateTime>? = null
                private var cardDisputeId: JsonField<String>? = null
                private var transactionId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cardDisputeAcceptance: CardDisputeAcceptance) = apply {
                    acceptedAt = cardDisputeAcceptance.acceptedAt
                    cardDisputeId = cardDisputeAcceptance.cardDisputeId
                    transactionId = cardDisputeAcceptance.transactionId
                    additionalProperties = cardDisputeAcceptance.additionalProperties.toMutableMap()
                }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * Card Dispute was accepted.
                 */
                fun acceptedAt(acceptedAt: OffsetDateTime) = acceptedAt(JsonField.of(acceptedAt))

                /**
                 * Sets [Builder.acceptedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.acceptedAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun acceptedAt(acceptedAt: JsonField<OffsetDateTime>) = apply {
                    this.acceptedAt = acceptedAt
                }

                /** The identifier of the Card Dispute that was accepted. */
                fun cardDisputeId(cardDisputeId: String) =
                    cardDisputeId(JsonField.of(cardDisputeId))

                /**
                 * Sets [Builder.cardDisputeId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cardDisputeId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun cardDisputeId(cardDisputeId: JsonField<String>) = apply {
                    this.cardDisputeId = cardDisputeId
                }

                /**
                 * The identifier of the Transaction that was created to return the disputed funds
                 * to your account.
                 */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CardDisputeAcceptance].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .acceptedAt()
                 * .cardDisputeId()
                 * .transactionId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CardDisputeAcceptance =
                    CardDisputeAcceptance(
                        checkRequired("acceptedAt", acceptedAt),
                        checkRequired("cardDisputeId", cardDisputeId),
                        checkRequired("transactionId", transactionId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CardDisputeAcceptance = apply {
                if (validated) {
                    return@apply
                }

                acceptedAt()
                cardDisputeId()
                transactionId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (acceptedAt.asKnown() == null) 0 else 1) +
                    (if (cardDisputeId.asKnown() == null) 0 else 1) +
                    (if (transactionId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CardDisputeAcceptance &&
                    acceptedAt == other.acceptedAt &&
                    cardDisputeId == other.cardDisputeId &&
                    transactionId == other.transactionId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(acceptedAt, cardDisputeId, transactionId, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CardDisputeAcceptance{acceptedAt=$acceptedAt, cardDisputeId=$cardDisputeId, transactionId=$transactionId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Card Dispute Financial object. This field will be present in the JSON response if and
         * only if `category` is equal to `card_dispute_financial`. Financial event related to a
         * Card Dispute.
         */
        class CardDisputeFinancial
        private constructor(
            private val amount: JsonField<Long>,
            private val cardDisputeId: JsonField<String>,
            private val network: JsonField<Network>,
            private val transactionId: JsonField<String>,
            private val visa: JsonField<Visa>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("card_dispute_id")
                @ExcludeMissing
                cardDisputeId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("network")
                @ExcludeMissing
                network: JsonField<Network> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("visa") @ExcludeMissing visa: JsonField<Visa> = JsonMissing.of(),
            ) : this(amount, cardDisputeId, network, transactionId, visa, mutableMapOf())

            /**
             * The amount of the financial event.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The identifier of the Card Dispute the financial event is associated with.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun cardDisputeId(): String = cardDisputeId.getRequired("card_dispute_id")

            /**
             * The network that the Card Dispute is associated with.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun network(): Network = network.getRequired("network")

            /**
             * The identifier of the Transaction that was created to credit or debit the disputed
             * funds to or from your account.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * Information for events related to card dispute for card payments processed over
             * Visa's network. This field will be present in the JSON response if and only if
             * `network` is equal to `visa`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun visa(): Visa? = visa.getNullable("visa")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [cardDisputeId].
             *
             * Unlike [cardDisputeId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("card_dispute_id")
            @ExcludeMissing
            fun _cardDisputeId(): JsonField<String> = cardDisputeId

            /**
             * Returns the raw JSON value of [network].
             *
             * Unlike [network], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("network") @ExcludeMissing fun _network(): JsonField<Network> = network

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            /**
             * Returns the raw JSON value of [visa].
             *
             * Unlike [visa], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("visa") @ExcludeMissing fun _visa(): JsonField<Visa> = visa

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CardDisputeFinancial].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .cardDisputeId()
                 * .network()
                 * .transactionId()
                 * .visa()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CardDisputeFinancial]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var cardDisputeId: JsonField<String>? = null
                private var network: JsonField<Network>? = null
                private var transactionId: JsonField<String>? = null
                private var visa: JsonField<Visa>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cardDisputeFinancial: CardDisputeFinancial) = apply {
                    amount = cardDisputeFinancial.amount
                    cardDisputeId = cardDisputeFinancial.cardDisputeId
                    network = cardDisputeFinancial.network
                    transactionId = cardDisputeFinancial.transactionId
                    visa = cardDisputeFinancial.visa
                    additionalProperties = cardDisputeFinancial.additionalProperties.toMutableMap()
                }

                /** The amount of the financial event. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The identifier of the Card Dispute the financial event is associated with. */
                fun cardDisputeId(cardDisputeId: String) =
                    cardDisputeId(JsonField.of(cardDisputeId))

                /**
                 * Sets [Builder.cardDisputeId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cardDisputeId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun cardDisputeId(cardDisputeId: JsonField<String>) = apply {
                    this.cardDisputeId = cardDisputeId
                }

                /** The network that the Card Dispute is associated with. */
                fun network(network: Network) = network(JsonField.of(network))

                /**
                 * Sets [Builder.network] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.network] with a well-typed [Network] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun network(network: JsonField<Network>) = apply { this.network = network }

                /**
                 * The identifier of the Transaction that was created to credit or debit the
                 * disputed funds to or from your account.
                 */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                /**
                 * Information for events related to card dispute for card payments processed over
                 * Visa's network. This field will be present in the JSON response if and only if
                 * `network` is equal to `visa`.
                 */
                fun visa(visa: Visa?) = visa(JsonField.ofNullable(visa))

                /**
                 * Sets [Builder.visa] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.visa] with a well-typed [Visa] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun visa(visa: JsonField<Visa>) = apply { this.visa = visa }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CardDisputeFinancial].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .cardDisputeId()
                 * .network()
                 * .transactionId()
                 * .visa()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CardDisputeFinancial =
                    CardDisputeFinancial(
                        checkRequired("amount", amount),
                        checkRequired("cardDisputeId", cardDisputeId),
                        checkRequired("network", network),
                        checkRequired("transactionId", transactionId),
                        checkRequired("visa", visa),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CardDisputeFinancial = apply {
                if (validated) {
                    return@apply
                }

                amount()
                cardDisputeId()
                network().validate()
                transactionId()
                visa()?.validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (if (cardDisputeId.asKnown() == null) 0 else 1) +
                    (network.asKnown()?.validity() ?: 0) +
                    (if (transactionId.asKnown() == null) 0 else 1) +
                    (visa.asKnown()?.validity() ?: 0)

            /** The network that the Card Dispute is associated with. */
            class Network @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Visa: details will be under the `visa` object. */
                    val VISA = of("visa")

                    fun of(value: String) = Network(JsonField.of(value))
                }

                /** An enum containing [Network]'s known values. */
                enum class Known {
                    /** Visa: details will be under the `visa` object. */
                    VISA
                }

                /**
                 * An enum containing [Network]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Network] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Visa: details will be under the `visa` object. */
                    VISA,
                    /**
                     * An enum member indicating that [Network] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        VISA -> Value.VISA
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        VISA -> Known.VISA
                        else -> throw IncreaseInvalidDataException("Unknown Network: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Network = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Network && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * Information for events related to card dispute for card payments processed over
             * Visa's network. This field will be present in the JSON response if and only if
             * `network` is equal to `visa`.
             */
            class Visa
            private constructor(
                private val eventType: JsonField<EventType>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("event_type")
                    @ExcludeMissing
                    eventType: JsonField<EventType> = JsonMissing.of()
                ) : this(eventType, mutableMapOf())

                /**
                 * The type of card dispute financial event.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun eventType(): EventType = eventType.getRequired("event_type")

                /**
                 * Returns the raw JSON value of [eventType].
                 *
                 * Unlike [eventType], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("event_type")
                @ExcludeMissing
                fun _eventType(): JsonField<EventType> = eventType

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Visa].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .eventType()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Visa]. */
                class Builder internal constructor() {

                    private var eventType: JsonField<EventType>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(visa: Visa) = apply {
                        eventType = visa.eventType
                        additionalProperties = visa.additionalProperties.toMutableMap()
                    }

                    /** The type of card dispute financial event. */
                    fun eventType(eventType: EventType) = eventType(JsonField.of(eventType))

                    /**
                     * Sets [Builder.eventType] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.eventType] with a well-typed [EventType]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun eventType(eventType: JsonField<EventType>) = apply {
                        this.eventType = eventType
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Visa].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .eventType()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Visa =
                        Visa(
                            checkRequired("eventType", eventType),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Visa = apply {
                    if (validated) {
                        return@apply
                    }

                    eventType().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = (eventType.asKnown()?.validity() ?: 0)

                /** The type of card dispute financial event. */
                class EventType
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** The user's chargeback was submitted. */
                        val CHARGEBACK_SUBMITTED = of("chargeback_submitted")

                        /** The user declined the merchant's pre-arbitration submission. */
                        val MERCHANT_PREARBITRATION_DECLINE_SUBMITTED =
                            of("merchant_prearbitration_decline_submitted")

                        /** The merchant's pre-arbitration submission was received. */
                        val MERCHANT_PREARBITRATION_RECEIVED =
                            of("merchant_prearbitration_received")

                        /** The transaction was re-presented by the merchant. */
                        val REPRESENTED = of("represented")

                        /** The user's pre-arbitration was declined by the merchant. */
                        val USER_PREARBITRATION_DECLINE_RECEIVED =
                            of("user_prearbitration_decline_received")

                        /** The user's pre-arbitration was submitted. */
                        val USER_PREARBITRATION_SUBMITTED = of("user_prearbitration_submitted")

                        /** The user withdrew from the dispute. */
                        val USER_WITHDRAWAL_SUBMITTED = of("user_withdrawal_submitted")

                        fun of(value: String) = EventType(JsonField.of(value))
                    }

                    /** An enum containing [EventType]'s known values. */
                    enum class Known {
                        /** The user's chargeback was submitted. */
                        CHARGEBACK_SUBMITTED,
                        /** The user declined the merchant's pre-arbitration submission. */
                        MERCHANT_PREARBITRATION_DECLINE_SUBMITTED,
                        /** The merchant's pre-arbitration submission was received. */
                        MERCHANT_PREARBITRATION_RECEIVED,
                        /** The transaction was re-presented by the merchant. */
                        REPRESENTED,
                        /** The user's pre-arbitration was declined by the merchant. */
                        USER_PREARBITRATION_DECLINE_RECEIVED,
                        /** The user's pre-arbitration was submitted. */
                        USER_PREARBITRATION_SUBMITTED,
                        /** The user withdrew from the dispute. */
                        USER_WITHDRAWAL_SUBMITTED,
                    }

                    /**
                     * An enum containing [EventType]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [EventType] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** The user's chargeback was submitted. */
                        CHARGEBACK_SUBMITTED,
                        /** The user declined the merchant's pre-arbitration submission. */
                        MERCHANT_PREARBITRATION_DECLINE_SUBMITTED,
                        /** The merchant's pre-arbitration submission was received. */
                        MERCHANT_PREARBITRATION_RECEIVED,
                        /** The transaction was re-presented by the merchant. */
                        REPRESENTED,
                        /** The user's pre-arbitration was declined by the merchant. */
                        USER_PREARBITRATION_DECLINE_RECEIVED,
                        /** The user's pre-arbitration was submitted. */
                        USER_PREARBITRATION_SUBMITTED,
                        /** The user withdrew from the dispute. */
                        USER_WITHDRAWAL_SUBMITTED,
                        /**
                         * An enum member indicating that [EventType] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CHARGEBACK_SUBMITTED -> Value.CHARGEBACK_SUBMITTED
                            MERCHANT_PREARBITRATION_DECLINE_SUBMITTED ->
                                Value.MERCHANT_PREARBITRATION_DECLINE_SUBMITTED
                            MERCHANT_PREARBITRATION_RECEIVED ->
                                Value.MERCHANT_PREARBITRATION_RECEIVED
                            REPRESENTED -> Value.REPRESENTED
                            USER_PREARBITRATION_DECLINE_RECEIVED ->
                                Value.USER_PREARBITRATION_DECLINE_RECEIVED
                            USER_PREARBITRATION_SUBMITTED -> Value.USER_PREARBITRATION_SUBMITTED
                            USER_WITHDRAWAL_SUBMITTED -> Value.USER_WITHDRAWAL_SUBMITTED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CHARGEBACK_SUBMITTED -> Known.CHARGEBACK_SUBMITTED
                            MERCHANT_PREARBITRATION_DECLINE_SUBMITTED ->
                                Known.MERCHANT_PREARBITRATION_DECLINE_SUBMITTED
                            MERCHANT_PREARBITRATION_RECEIVED ->
                                Known.MERCHANT_PREARBITRATION_RECEIVED
                            REPRESENTED -> Known.REPRESENTED
                            USER_PREARBITRATION_DECLINE_RECEIVED ->
                                Known.USER_PREARBITRATION_DECLINE_RECEIVED
                            USER_PREARBITRATION_SUBMITTED -> Known.USER_PREARBITRATION_SUBMITTED
                            USER_WITHDRAWAL_SUBMITTED -> Known.USER_WITHDRAWAL_SUBMITTED
                            else -> throw IncreaseInvalidDataException("Unknown EventType: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): EventType = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is EventType && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Visa &&
                        eventType == other.eventType &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy { Objects.hash(eventType, additionalProperties) }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Visa{eventType=$eventType, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CardDisputeFinancial &&
                    amount == other.amount &&
                    cardDisputeId == other.cardDisputeId &&
                    network == other.network &&
                    transactionId == other.transactionId &&
                    visa == other.visa &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    cardDisputeId,
                    network,
                    transactionId,
                    visa,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CardDisputeFinancial{amount=$amount, cardDisputeId=$cardDisputeId, network=$network, transactionId=$transactionId, visa=$visa, additionalProperties=$additionalProperties}"
        }

        /**
         * A Card Dispute Loss object. This field will be present in the JSON response if and only
         * if `category` is equal to `card_dispute_loss`. Contains the details of a lost Card
         * Dispute.
         */
        class CardDisputeLoss
        private constructor(
            private val cardDisputeId: JsonField<String>,
            private val explanation: JsonField<String>,
            private val lostAt: JsonField<OffsetDateTime>,
            private val transactionId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("card_dispute_id")
                @ExcludeMissing
                cardDisputeId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("explanation")
                @ExcludeMissing
                explanation: JsonField<String> = JsonMissing.of(),
                @JsonProperty("lost_at")
                @ExcludeMissing
                lostAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
            ) : this(cardDisputeId, explanation, lostAt, transactionId, mutableMapOf())

            /**
             * The identifier of the Card Dispute that was lost.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun cardDisputeId(): String = cardDisputeId.getRequired("card_dispute_id")

            /**
             * Why the Card Dispute was lost.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun explanation(): String = explanation.getRequired("explanation")

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * Card Dispute was lost.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun lostAt(): OffsetDateTime = lostAt.getRequired("lost_at")

            /**
             * The identifier of the Transaction that was created to debit the disputed funds from
             * your account.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * Returns the raw JSON value of [cardDisputeId].
             *
             * Unlike [cardDisputeId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("card_dispute_id")
            @ExcludeMissing
            fun _cardDisputeId(): JsonField<String> = cardDisputeId

            /**
             * Returns the raw JSON value of [explanation].
             *
             * Unlike [explanation], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("explanation")
            @ExcludeMissing
            fun _explanation(): JsonField<String> = explanation

            /**
             * Returns the raw JSON value of [lostAt].
             *
             * Unlike [lostAt], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("lost_at")
            @ExcludeMissing
            fun _lostAt(): JsonField<OffsetDateTime> = lostAt

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CardDisputeLoss].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .cardDisputeId()
                 * .explanation()
                 * .lostAt()
                 * .transactionId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CardDisputeLoss]. */
            class Builder internal constructor() {

                private var cardDisputeId: JsonField<String>? = null
                private var explanation: JsonField<String>? = null
                private var lostAt: JsonField<OffsetDateTime>? = null
                private var transactionId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cardDisputeLoss: CardDisputeLoss) = apply {
                    cardDisputeId = cardDisputeLoss.cardDisputeId
                    explanation = cardDisputeLoss.explanation
                    lostAt = cardDisputeLoss.lostAt
                    transactionId = cardDisputeLoss.transactionId
                    additionalProperties = cardDisputeLoss.additionalProperties.toMutableMap()
                }

                /** The identifier of the Card Dispute that was lost. */
                fun cardDisputeId(cardDisputeId: String) =
                    cardDisputeId(JsonField.of(cardDisputeId))

                /**
                 * Sets [Builder.cardDisputeId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cardDisputeId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun cardDisputeId(cardDisputeId: JsonField<String>) = apply {
                    this.cardDisputeId = cardDisputeId
                }

                /** Why the Card Dispute was lost. */
                fun explanation(explanation: String) = explanation(JsonField.of(explanation))

                /**
                 * Sets [Builder.explanation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.explanation] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun explanation(explanation: JsonField<String>) = apply {
                    this.explanation = explanation
                }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * Card Dispute was lost.
                 */
                fun lostAt(lostAt: OffsetDateTime) = lostAt(JsonField.of(lostAt))

                /**
                 * Sets [Builder.lostAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.lostAt] with a well-typed [OffsetDateTime] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun lostAt(lostAt: JsonField<OffsetDateTime>) = apply { this.lostAt = lostAt }

                /**
                 * The identifier of the Transaction that was created to debit the disputed funds
                 * from your account.
                 */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CardDisputeLoss].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .cardDisputeId()
                 * .explanation()
                 * .lostAt()
                 * .transactionId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CardDisputeLoss =
                    CardDisputeLoss(
                        checkRequired("cardDisputeId", cardDisputeId),
                        checkRequired("explanation", explanation),
                        checkRequired("lostAt", lostAt),
                        checkRequired("transactionId", transactionId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CardDisputeLoss = apply {
                if (validated) {
                    return@apply
                }

                cardDisputeId()
                explanation()
                lostAt()
                transactionId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (cardDisputeId.asKnown() == null) 0 else 1) +
                    (if (explanation.asKnown() == null) 0 else 1) +
                    (if (lostAt.asKnown() == null) 0 else 1) +
                    (if (transactionId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CardDisputeLoss &&
                    cardDisputeId == other.cardDisputeId &&
                    explanation == other.explanation &&
                    lostAt == other.lostAt &&
                    transactionId == other.transactionId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    cardDisputeId,
                    explanation,
                    lostAt,
                    transactionId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CardDisputeLoss{cardDisputeId=$cardDisputeId, explanation=$explanation, lostAt=$lostAt, transactionId=$transactionId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Card Push Transfer Acceptance object. This field will be present in the JSON response
         * if and only if `category` is equal to `card_push_transfer_acceptance`. A Card Push
         * Transfer Acceptance is created when an Outbound Card Push Transfer sent from Increase is
         * accepted by the receiving bank.
         */
        class CardPushTransferAcceptance
        private constructor(
            private val amount: JsonField<Long>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(amount, transferId, mutableMapOf())

            /**
             * The transfer amount in USD cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The identifier of the Card Push Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [CardPushTransferAcceptance].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CardPushTransferAcceptance]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cardPushTransferAcceptance: CardPushTransferAcceptance) = apply {
                    amount = cardPushTransferAcceptance.amount
                    transferId = cardPushTransferAcceptance.transferId
                    additionalProperties =
                        cardPushTransferAcceptance.additionalProperties.toMutableMap()
                }

                /** The transfer amount in USD cents. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The identifier of the Card Push Transfer that led to this Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CardPushTransferAcceptance].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CardPushTransferAcceptance =
                    CardPushTransferAcceptance(
                        checkRequired("amount", amount),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CardPushTransferAcceptance = apply {
                if (validated) {
                    return@apply
                }

                amount()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CardPushTransferAcceptance &&
                    amount == other.amount &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(amount, transferId, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CardPushTransferAcceptance{amount=$amount, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Card Refund object. This field will be present in the JSON response if and only if
         * `category` is equal to `card_refund`. Card Refunds move money back to the cardholder.
         * While they are usually connected to a Card Settlement an acquirer can also refund money
         * directly to a card without relation to a transaction.
         */
        class CardRefund
        private constructor(
            private val id: JsonField<String>,
            private val amount: JsonField<Long>,
            private val cardPaymentId: JsonField<String>,
            private val cashback: JsonField<Cashback>,
            private val currency: JsonField<Currency>,
            private val interchange: JsonField<Interchange>,
            private val merchantAcceptorId: JsonField<String>,
            private val merchantCategoryCode: JsonField<String>,
            private val merchantCity: JsonField<String>,
            private val merchantCountry: JsonField<String>,
            private val merchantName: JsonField<String>,
            private val merchantPostalCode: JsonField<String>,
            private val merchantState: JsonField<String>,
            private val networkIdentifiers: JsonField<NetworkIdentifiers>,
            private val presentmentAmount: JsonField<Long>,
            private val presentmentCurrency: JsonField<String>,
            private val purchaseDetails: JsonField<PurchaseDetails>,
            private val transactionId: JsonField<String>,
            private val type: JsonField<Type>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("card_payment_id")
                @ExcludeMissing
                cardPaymentId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("cashback")
                @ExcludeMissing
                cashback: JsonField<Cashback> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("interchange")
                @ExcludeMissing
                interchange: JsonField<Interchange> = JsonMissing.of(),
                @JsonProperty("merchant_acceptor_id")
                @ExcludeMissing
                merchantAcceptorId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_category_code")
                @ExcludeMissing
                merchantCategoryCode: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_city")
                @ExcludeMissing
                merchantCity: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_country")
                @ExcludeMissing
                merchantCountry: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_name")
                @ExcludeMissing
                merchantName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_postal_code")
                @ExcludeMissing
                merchantPostalCode: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_state")
                @ExcludeMissing
                merchantState: JsonField<String> = JsonMissing.of(),
                @JsonProperty("network_identifiers")
                @ExcludeMissing
                networkIdentifiers: JsonField<NetworkIdentifiers> = JsonMissing.of(),
                @JsonProperty("presentment_amount")
                @ExcludeMissing
                presentmentAmount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("presentment_currency")
                @ExcludeMissing
                presentmentCurrency: JsonField<String> = JsonMissing.of(),
                @JsonProperty("purchase_details")
                @ExcludeMissing
                purchaseDetails: JsonField<PurchaseDetails> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("type") @ExcludeMissing type: JsonField<Type> = JsonMissing.of(),
            ) : this(
                id,
                amount,
                cardPaymentId,
                cashback,
                currency,
                interchange,
                merchantAcceptorId,
                merchantCategoryCode,
                merchantCity,
                merchantCountry,
                merchantName,
                merchantPostalCode,
                merchantState,
                networkIdentifiers,
                presentmentAmount,
                presentmentCurrency,
                purchaseDetails,
                transactionId,
                type,
                mutableMapOf(),
            )

            /**
             * The Card Refund identifier.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * The amount in the minor unit of the transaction's settlement currency. For dollars,
             * for example, this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The ID of the Card Payment this transaction belongs to.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun cardPaymentId(): String = cardPaymentId.getRequired("card_payment_id")

            /**
             * Cashback debited for this transaction, if eligible. Cashback is paid out in
             * aggregate, monthly.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun cashback(): Cashback? = cashback.getNullable("cashback")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * settlement currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * Interchange assessed as a part of this transaciton.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun interchange(): Interchange? = interchange.getNullable("interchange")

            /**
             * The merchant identifier (commonly abbreviated as MID) of the merchant the card is
             * transacting with.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantAcceptorId(): String =
                merchantAcceptorId.getRequired("merchant_acceptor_id")

            /**
             * The 4-digit MCC describing the merchant's business.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantCategoryCode(): String =
                merchantCategoryCode.getRequired("merchant_category_code")

            /**
             * The city the merchant resides in.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantCity(): String = merchantCity.getRequired("merchant_city")

            /**
             * The country the merchant resides in.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantCountry(): String = merchantCountry.getRequired("merchant_country")

            /**
             * The name of the merchant.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantName(): String = merchantName.getRequired("merchant_name")

            /**
             * The merchant's postal code. For US merchants this is always a 5-digit ZIP code.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun merchantPostalCode(): String? =
                merchantPostalCode.getNullable("merchant_postal_code")

            /**
             * The state the merchant resides in.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun merchantState(): String? = merchantState.getNullable("merchant_state")

            /**
             * Network-specific identifiers for this refund.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun networkIdentifiers(): NetworkIdentifiers =
                networkIdentifiers.getRequired("network_identifiers")

            /**
             * The amount in the minor unit of the transaction's presentment currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun presentmentAmount(): Long = presentmentAmount.getRequired("presentment_amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * presentment currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun presentmentCurrency(): String =
                presentmentCurrency.getRequired("presentment_currency")

            /**
             * Additional details about the card purchase, such as tax and industry-specific fields.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun purchaseDetails(): PurchaseDetails? =
                purchaseDetails.getNullable("purchase_details")

            /**
             * The identifier of the Transaction associated with this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * A constant representing the object's type. For this resource it will always be
             * `card_refund`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun type(): Type = type.getRequired("type")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [cardPaymentId].
             *
             * Unlike [cardPaymentId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("card_payment_id")
            @ExcludeMissing
            fun _cardPaymentId(): JsonField<String> = cardPaymentId

            /**
             * Returns the raw JSON value of [cashback].
             *
             * Unlike [cashback], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("cashback")
            @ExcludeMissing
            fun _cashback(): JsonField<Cashback> = cashback

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [interchange].
             *
             * Unlike [interchange], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("interchange")
            @ExcludeMissing
            fun _interchange(): JsonField<Interchange> = interchange

            /**
             * Returns the raw JSON value of [merchantAcceptorId].
             *
             * Unlike [merchantAcceptorId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_acceptor_id")
            @ExcludeMissing
            fun _merchantAcceptorId(): JsonField<String> = merchantAcceptorId

            /**
             * Returns the raw JSON value of [merchantCategoryCode].
             *
             * Unlike [merchantCategoryCode], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_category_code")
            @ExcludeMissing
            fun _merchantCategoryCode(): JsonField<String> = merchantCategoryCode

            /**
             * Returns the raw JSON value of [merchantCity].
             *
             * Unlike [merchantCity], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("merchant_city")
            @ExcludeMissing
            fun _merchantCity(): JsonField<String> = merchantCity

            /**
             * Returns the raw JSON value of [merchantCountry].
             *
             * Unlike [merchantCountry], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_country")
            @ExcludeMissing
            fun _merchantCountry(): JsonField<String> = merchantCountry

            /**
             * Returns the raw JSON value of [merchantName].
             *
             * Unlike [merchantName], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("merchant_name")
            @ExcludeMissing
            fun _merchantName(): JsonField<String> = merchantName

            /**
             * Returns the raw JSON value of [merchantPostalCode].
             *
             * Unlike [merchantPostalCode], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_postal_code")
            @ExcludeMissing
            fun _merchantPostalCode(): JsonField<String> = merchantPostalCode

            /**
             * Returns the raw JSON value of [merchantState].
             *
             * Unlike [merchantState], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("merchant_state")
            @ExcludeMissing
            fun _merchantState(): JsonField<String> = merchantState

            /**
             * Returns the raw JSON value of [networkIdentifiers].
             *
             * Unlike [networkIdentifiers], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("network_identifiers")
            @ExcludeMissing
            fun _networkIdentifiers(): JsonField<NetworkIdentifiers> = networkIdentifiers

            /**
             * Returns the raw JSON value of [presentmentAmount].
             *
             * Unlike [presentmentAmount], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("presentment_amount")
            @ExcludeMissing
            fun _presentmentAmount(): JsonField<Long> = presentmentAmount

            /**
             * Returns the raw JSON value of [presentmentCurrency].
             *
             * Unlike [presentmentCurrency], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("presentment_currency")
            @ExcludeMissing
            fun _presentmentCurrency(): JsonField<String> = presentmentCurrency

            /**
             * Returns the raw JSON value of [purchaseDetails].
             *
             * Unlike [purchaseDetails], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("purchase_details")
            @ExcludeMissing
            fun _purchaseDetails(): JsonField<PurchaseDetails> = purchaseDetails

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            /**
             * Returns the raw JSON value of [type].
             *
             * Unlike [type], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("type") @ExcludeMissing fun _type(): JsonField<Type> = type

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CardRefund].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .id()
                 * .amount()
                 * .cardPaymentId()
                 * .cashback()
                 * .currency()
                 * .interchange()
                 * .merchantAcceptorId()
                 * .merchantCategoryCode()
                 * .merchantCity()
                 * .merchantCountry()
                 * .merchantName()
                 * .merchantPostalCode()
                 * .merchantState()
                 * .networkIdentifiers()
                 * .presentmentAmount()
                 * .presentmentCurrency()
                 * .purchaseDetails()
                 * .transactionId()
                 * .type()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CardRefund]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var cardPaymentId: JsonField<String>? = null
                private var cashback: JsonField<Cashback>? = null
                private var currency: JsonField<Currency>? = null
                private var interchange: JsonField<Interchange>? = null
                private var merchantAcceptorId: JsonField<String>? = null
                private var merchantCategoryCode: JsonField<String>? = null
                private var merchantCity: JsonField<String>? = null
                private var merchantCountry: JsonField<String>? = null
                private var merchantName: JsonField<String>? = null
                private var merchantPostalCode: JsonField<String>? = null
                private var merchantState: JsonField<String>? = null
                private var networkIdentifiers: JsonField<NetworkIdentifiers>? = null
                private var presentmentAmount: JsonField<Long>? = null
                private var presentmentCurrency: JsonField<String>? = null
                private var purchaseDetails: JsonField<PurchaseDetails>? = null
                private var transactionId: JsonField<String>? = null
                private var type: JsonField<Type>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cardRefund: CardRefund) = apply {
                    id = cardRefund.id
                    amount = cardRefund.amount
                    cardPaymentId = cardRefund.cardPaymentId
                    cashback = cardRefund.cashback
                    currency = cardRefund.currency
                    interchange = cardRefund.interchange
                    merchantAcceptorId = cardRefund.merchantAcceptorId
                    merchantCategoryCode = cardRefund.merchantCategoryCode
                    merchantCity = cardRefund.merchantCity
                    merchantCountry = cardRefund.merchantCountry
                    merchantName = cardRefund.merchantName
                    merchantPostalCode = cardRefund.merchantPostalCode
                    merchantState = cardRefund.merchantState
                    networkIdentifiers = cardRefund.networkIdentifiers
                    presentmentAmount = cardRefund.presentmentAmount
                    presentmentCurrency = cardRefund.presentmentCurrency
                    purchaseDetails = cardRefund.purchaseDetails
                    transactionId = cardRefund.transactionId
                    type = cardRefund.type
                    additionalProperties = cardRefund.additionalProperties.toMutableMap()
                }

                /** The Card Refund identifier. */
                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                /**
                 * The amount in the minor unit of the transaction's settlement currency. For
                 * dollars, for example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The ID of the Card Payment this transaction belongs to. */
                fun cardPaymentId(cardPaymentId: String) =
                    cardPaymentId(JsonField.of(cardPaymentId))

                /**
                 * Sets [Builder.cardPaymentId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cardPaymentId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun cardPaymentId(cardPaymentId: JsonField<String>) = apply {
                    this.cardPaymentId = cardPaymentId
                }

                /**
                 * Cashback debited for this transaction, if eligible. Cashback is paid out in
                 * aggregate, monthly.
                 */
                fun cashback(cashback: Cashback?) = cashback(JsonField.ofNullable(cashback))

                /**
                 * Sets [Builder.cashback] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cashback] with a well-typed [Cashback] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun cashback(cashback: JsonField<Cashback>) = apply { this.cashback = cashback }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
                 * settlement currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** Interchange assessed as a part of this transaciton. */
                fun interchange(interchange: Interchange?) =
                    interchange(JsonField.ofNullable(interchange))

                /**
                 * Sets [Builder.interchange] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.interchange] with a well-typed [Interchange]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun interchange(interchange: JsonField<Interchange>) = apply {
                    this.interchange = interchange
                }

                /**
                 * The merchant identifier (commonly abbreviated as MID) of the merchant the card is
                 * transacting with.
                 */
                fun merchantAcceptorId(merchantAcceptorId: String) =
                    merchantAcceptorId(JsonField.of(merchantAcceptorId))

                /**
                 * Sets [Builder.merchantAcceptorId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantAcceptorId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantAcceptorId(merchantAcceptorId: JsonField<String>) = apply {
                    this.merchantAcceptorId = merchantAcceptorId
                }

                /** The 4-digit MCC describing the merchant's business. */
                fun merchantCategoryCode(merchantCategoryCode: String) =
                    merchantCategoryCode(JsonField.of(merchantCategoryCode))

                /**
                 * Sets [Builder.merchantCategoryCode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantCategoryCode] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantCategoryCode(merchantCategoryCode: JsonField<String>) = apply {
                    this.merchantCategoryCode = merchantCategoryCode
                }

                /** The city the merchant resides in. */
                fun merchantCity(merchantCity: String) = merchantCity(JsonField.of(merchantCity))

                /**
                 * Sets [Builder.merchantCity] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantCity] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun merchantCity(merchantCity: JsonField<String>) = apply {
                    this.merchantCity = merchantCity
                }

                /** The country the merchant resides in. */
                fun merchantCountry(merchantCountry: String) =
                    merchantCountry(JsonField.of(merchantCountry))

                /**
                 * Sets [Builder.merchantCountry] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantCountry] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantCountry(merchantCountry: JsonField<String>) = apply {
                    this.merchantCountry = merchantCountry
                }

                /** The name of the merchant. */
                fun merchantName(merchantName: String) = merchantName(JsonField.of(merchantName))

                /**
                 * Sets [Builder.merchantName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantName] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun merchantName(merchantName: JsonField<String>) = apply {
                    this.merchantName = merchantName
                }

                /**
                 * The merchant's postal code. For US merchants this is always a 5-digit ZIP code.
                 */
                fun merchantPostalCode(merchantPostalCode: String?) =
                    merchantPostalCode(JsonField.ofNullable(merchantPostalCode))

                /**
                 * Sets [Builder.merchantPostalCode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantPostalCode] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantPostalCode(merchantPostalCode: JsonField<String>) = apply {
                    this.merchantPostalCode = merchantPostalCode
                }

                /** The state the merchant resides in. */
                fun merchantState(merchantState: String?) =
                    merchantState(JsonField.ofNullable(merchantState))

                /**
                 * Sets [Builder.merchantState] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantState] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun merchantState(merchantState: JsonField<String>) = apply {
                    this.merchantState = merchantState
                }

                /** Network-specific identifiers for this refund. */
                fun networkIdentifiers(networkIdentifiers: NetworkIdentifiers) =
                    networkIdentifiers(JsonField.of(networkIdentifiers))

                /**
                 * Sets [Builder.networkIdentifiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.networkIdentifiers] with a well-typed
                 * [NetworkIdentifiers] value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun networkIdentifiers(networkIdentifiers: JsonField<NetworkIdentifiers>) = apply {
                    this.networkIdentifiers = networkIdentifiers
                }

                /** The amount in the minor unit of the transaction's presentment currency. */
                fun presentmentAmount(presentmentAmount: Long) =
                    presentmentAmount(JsonField.of(presentmentAmount))

                /**
                 * Sets [Builder.presentmentAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.presentmentAmount] with a well-typed [Long]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun presentmentAmount(presentmentAmount: JsonField<Long>) = apply {
                    this.presentmentAmount = presentmentAmount
                }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
                 * presentment currency.
                 */
                fun presentmentCurrency(presentmentCurrency: String) =
                    presentmentCurrency(JsonField.of(presentmentCurrency))

                /**
                 * Sets [Builder.presentmentCurrency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.presentmentCurrency] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun presentmentCurrency(presentmentCurrency: JsonField<String>) = apply {
                    this.presentmentCurrency = presentmentCurrency
                }

                /**
                 * Additional details about the card purchase, such as tax and industry-specific
                 * fields.
                 */
                fun purchaseDetails(purchaseDetails: PurchaseDetails?) =
                    purchaseDetails(JsonField.ofNullable(purchaseDetails))

                /**
                 * Sets [Builder.purchaseDetails] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.purchaseDetails] with a well-typed
                 * [PurchaseDetails] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun purchaseDetails(purchaseDetails: JsonField<PurchaseDetails>) = apply {
                    this.purchaseDetails = purchaseDetails
                }

                /** The identifier of the Transaction associated with this Transaction. */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                /**
                 * A constant representing the object's type. For this resource it will always be
                 * `card_refund`.
                 */
                fun type(type: Type) = type(JsonField.of(type))

                /**
                 * Sets [Builder.type] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.type] with a well-typed [Type] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun type(type: JsonField<Type>) = apply { this.type = type }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CardRefund].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .id()
                 * .amount()
                 * .cardPaymentId()
                 * .cashback()
                 * .currency()
                 * .interchange()
                 * .merchantAcceptorId()
                 * .merchantCategoryCode()
                 * .merchantCity()
                 * .merchantCountry()
                 * .merchantName()
                 * .merchantPostalCode()
                 * .merchantState()
                 * .networkIdentifiers()
                 * .presentmentAmount()
                 * .presentmentCurrency()
                 * .purchaseDetails()
                 * .transactionId()
                 * .type()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CardRefund =
                    CardRefund(
                        checkRequired("id", id),
                        checkRequired("amount", amount),
                        checkRequired("cardPaymentId", cardPaymentId),
                        checkRequired("cashback", cashback),
                        checkRequired("currency", currency),
                        checkRequired("interchange", interchange),
                        checkRequired("merchantAcceptorId", merchantAcceptorId),
                        checkRequired("merchantCategoryCode", merchantCategoryCode),
                        checkRequired("merchantCity", merchantCity),
                        checkRequired("merchantCountry", merchantCountry),
                        checkRequired("merchantName", merchantName),
                        checkRequired("merchantPostalCode", merchantPostalCode),
                        checkRequired("merchantState", merchantState),
                        checkRequired("networkIdentifiers", networkIdentifiers),
                        checkRequired("presentmentAmount", presentmentAmount),
                        checkRequired("presentmentCurrency", presentmentCurrency),
                        checkRequired("purchaseDetails", purchaseDetails),
                        checkRequired("transactionId", transactionId),
                        checkRequired("type", type),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CardRefund = apply {
                if (validated) {
                    return@apply
                }

                id()
                amount()
                cardPaymentId()
                cashback()?.validate()
                currency().validate()
                interchange()?.validate()
                merchantAcceptorId()
                merchantCategoryCode()
                merchantCity()
                merchantCountry()
                merchantName()
                merchantPostalCode()
                merchantState()
                networkIdentifiers().validate()
                presentmentAmount()
                presentmentCurrency()
                purchaseDetails()?.validate()
                transactionId()
                type().validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (id.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (if (cardPaymentId.asKnown() == null) 0 else 1) +
                    (cashback.asKnown()?.validity() ?: 0) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (interchange.asKnown()?.validity() ?: 0) +
                    (if (merchantAcceptorId.asKnown() == null) 0 else 1) +
                    (if (merchantCategoryCode.asKnown() == null) 0 else 1) +
                    (if (merchantCity.asKnown() == null) 0 else 1) +
                    (if (merchantCountry.asKnown() == null) 0 else 1) +
                    (if (merchantName.asKnown() == null) 0 else 1) +
                    (if (merchantPostalCode.asKnown() == null) 0 else 1) +
                    (if (merchantState.asKnown() == null) 0 else 1) +
                    (networkIdentifiers.asKnown()?.validity() ?: 0) +
                    (if (presentmentAmount.asKnown() == null) 0 else 1) +
                    (if (presentmentCurrency.asKnown() == null) 0 else 1) +
                    (purchaseDetails.asKnown()?.validity() ?: 0) +
                    (if (transactionId.asKnown() == null) 0 else 1) +
                    (type.asKnown()?.validity() ?: 0)

            /**
             * Cashback debited for this transaction, if eligible. Cashback is paid out in
             * aggregate, monthly.
             */
            class Cashback
            private constructor(
                private val amount: JsonField<String>,
                private val currency: JsonField<Currency>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("amount")
                    @ExcludeMissing
                    amount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("currency")
                    @ExcludeMissing
                    currency: JsonField<Currency> = JsonMissing.of(),
                ) : this(amount, currency, mutableMapOf())

                /**
                 * The cashback amount given as a string containing a decimal number. The amount is
                 * a positive number if it will be credited to you (e.g., settlements) and a
                 * negative number if it will be debited (e.g., refunds).
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun amount(): String = amount.getRequired("amount")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the cashback.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun currency(): Currency = currency.getRequired("currency")

                /**
                 * Returns the raw JSON value of [amount].
                 *
                 * Unlike [amount], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<String> = amount

                /**
                 * Returns the raw JSON value of [currency].
                 *
                 * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun _currency(): JsonField<Currency> = currency

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Cashback].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .currency()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Cashback]. */
                class Builder internal constructor() {

                    private var amount: JsonField<String>? = null
                    private var currency: JsonField<Currency>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(cashback: Cashback) = apply {
                        amount = cashback.amount
                        currency = cashback.currency
                        additionalProperties = cashback.additionalProperties.toMutableMap()
                    }

                    /**
                     * The cashback amount given as a string containing a decimal number. The amount
                     * is a positive number if it will be credited to you (e.g., settlements) and a
                     * negative number if it will be debited (e.g., refunds).
                     */
                    fun amount(amount: String) = amount(JsonField.of(amount))

                    /**
                     * Sets [Builder.amount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.amount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun amount(amount: JsonField<String>) = apply { this.amount = amount }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the cashback.
                     */
                    fun currency(currency: Currency) = currency(JsonField.of(currency))

                    /**
                     * Sets [Builder.currency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.currency] with a well-typed [Currency] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Cashback].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .currency()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Cashback =
                        Cashback(
                            checkRequired("amount", amount),
                            checkRequired("currency", currency),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Cashback = apply {
                    if (validated) {
                        return@apply
                    }

                    amount()
                    currency().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (amount.asKnown() == null) 0 else 1) + (currency.asKnown()?.validity() ?: 0)

                /** The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the cashback. */
                class Currency
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Canadian Dollar (CAD) */
                        val CAD = of("CAD")

                        /** Swiss Franc (CHF) */
                        val CHF = of("CHF")

                        /** Euro (EUR) */
                        val EUR = of("EUR")

                        /** British Pound (GBP) */
                        val GBP = of("GBP")

                        /** Japanese Yen (JPY) */
                        val JPY = of("JPY")

                        /** US Dollar (USD) */
                        val USD = of("USD")

                        fun of(value: String) = Currency(JsonField.of(value))
                    }

                    /** An enum containing [Currency]'s known values. */
                    enum class Known {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                    }

                    /**
                     * An enum containing [Currency]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [Currency] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                        /**
                         * An enum member indicating that [Currency] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CAD -> Value.CAD
                            CHF -> Value.CHF
                            EUR -> Value.EUR
                            GBP -> Value.GBP
                            JPY -> Value.JPY
                            USD -> Value.USD
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CAD -> Known.CAD
                            CHF -> Known.CHF
                            EUR -> Known.EUR
                            GBP -> Known.GBP
                            JPY -> Known.JPY
                            USD -> Known.USD
                            else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Currency = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Currency && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cashback &&
                        amount == other.amount &&
                        currency == other.currency &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(amount, currency, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Cashback{amount=$amount, currency=$currency, additionalProperties=$additionalProperties}"
            }

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * settlement currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /** Interchange assessed as a part of this transaciton. */
            class Interchange
            private constructor(
                private val amount: JsonField<String>,
                private val code: JsonField<String>,
                private val currency: JsonField<Currency>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("amount")
                    @ExcludeMissing
                    amount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("code")
                    @ExcludeMissing
                    code: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("currency")
                    @ExcludeMissing
                    currency: JsonField<Currency> = JsonMissing.of(),
                ) : this(amount, code, currency, mutableMapOf())

                /**
                 * The interchange amount given as a string containing a decimal number in major
                 * units (so e.g., "3.14" for $3.14). The amount is a positive number if it is
                 * credited to Increase (e.g., settlements) and a negative number if it is debited
                 * (e.g., refunds).
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun amount(): String = amount.getRequired("amount")

                /**
                 * The card network specific interchange code.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun code(): String? = code.getNullable("code")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the interchange
                 * reimbursement.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun currency(): Currency = currency.getRequired("currency")

                /**
                 * Returns the raw JSON value of [amount].
                 *
                 * Unlike [amount], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<String> = amount

                /**
                 * Returns the raw JSON value of [code].
                 *
                 * Unlike [code], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("code") @ExcludeMissing fun _code(): JsonField<String> = code

                /**
                 * Returns the raw JSON value of [currency].
                 *
                 * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun _currency(): JsonField<Currency> = currency

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Interchange].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .code()
                     * .currency()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Interchange]. */
                class Builder internal constructor() {

                    private var amount: JsonField<String>? = null
                    private var code: JsonField<String>? = null
                    private var currency: JsonField<Currency>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(interchange: Interchange) = apply {
                        amount = interchange.amount
                        code = interchange.code
                        currency = interchange.currency
                        additionalProperties = interchange.additionalProperties.toMutableMap()
                    }

                    /**
                     * The interchange amount given as a string containing a decimal number in major
                     * units (so e.g., "3.14" for $3.14). The amount is a positive number if it is
                     * credited to Increase (e.g., settlements) and a negative number if it is
                     * debited (e.g., refunds).
                     */
                    fun amount(amount: String) = amount(JsonField.of(amount))

                    /**
                     * Sets [Builder.amount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.amount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun amount(amount: JsonField<String>) = apply { this.amount = amount }

                    /** The card network specific interchange code. */
                    fun code(code: String?) = code(JsonField.ofNullable(code))

                    /**
                     * Sets [Builder.code] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.code] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun code(code: JsonField<String>) = apply { this.code = code }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                     * interchange reimbursement.
                     */
                    fun currency(currency: Currency) = currency(JsonField.of(currency))

                    /**
                     * Sets [Builder.currency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.currency] with a well-typed [Currency] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Interchange].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .code()
                     * .currency()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Interchange =
                        Interchange(
                            checkRequired("amount", amount),
                            checkRequired("code", code),
                            checkRequired("currency", currency),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Interchange = apply {
                    if (validated) {
                        return@apply
                    }

                    amount()
                    code()
                    currency().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (amount.asKnown() == null) 0 else 1) +
                        (if (code.asKnown() == null) 0 else 1) +
                        (currency.asKnown()?.validity() ?: 0)

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the interchange
                 * reimbursement.
                 */
                class Currency
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Canadian Dollar (CAD) */
                        val CAD = of("CAD")

                        /** Swiss Franc (CHF) */
                        val CHF = of("CHF")

                        /** Euro (EUR) */
                        val EUR = of("EUR")

                        /** British Pound (GBP) */
                        val GBP = of("GBP")

                        /** Japanese Yen (JPY) */
                        val JPY = of("JPY")

                        /** US Dollar (USD) */
                        val USD = of("USD")

                        fun of(value: String) = Currency(JsonField.of(value))
                    }

                    /** An enum containing [Currency]'s known values. */
                    enum class Known {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                    }

                    /**
                     * An enum containing [Currency]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [Currency] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                        /**
                         * An enum member indicating that [Currency] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CAD -> Value.CAD
                            CHF -> Value.CHF
                            EUR -> Value.EUR
                            GBP -> Value.GBP
                            JPY -> Value.JPY
                            USD -> Value.USD
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CAD -> Known.CAD
                            CHF -> Known.CHF
                            EUR -> Known.EUR
                            GBP -> Known.GBP
                            JPY -> Known.JPY
                            USD -> Known.USD
                            else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Currency = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Currency && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Interchange &&
                        amount == other.amount &&
                        code == other.code &&
                        currency == other.currency &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(amount, code, currency, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Interchange{amount=$amount, code=$code, currency=$currency, additionalProperties=$additionalProperties}"
            }

            /** Network-specific identifiers for this refund. */
            class NetworkIdentifiers
            private constructor(
                private val acquirerBusinessId: JsonField<String>,
                private val acquirerReferenceNumber: JsonField<String>,
                private val transactionId: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("acquirer_business_id")
                    @ExcludeMissing
                    acquirerBusinessId: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("acquirer_reference_number")
                    @ExcludeMissing
                    acquirerReferenceNumber: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("transaction_id")
                    @ExcludeMissing
                    transactionId: JsonField<String> = JsonMissing.of(),
                ) : this(acquirerBusinessId, acquirerReferenceNumber, transactionId, mutableMapOf())

                /**
                 * A network assigned business ID that identifies the acquirer that processed this
                 * transaction.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun acquirerBusinessId(): String =
                    acquirerBusinessId.getRequired("acquirer_business_id")

                /**
                 * A globally unique identifier for this settlement.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun acquirerReferenceNumber(): String =
                    acquirerReferenceNumber.getRequired("acquirer_reference_number")

                /**
                 * A globally unique transaction identifier provided by the card network, used
                 * across multiple life-cycle requests.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun transactionId(): String? = transactionId.getNullable("transaction_id")

                /**
                 * Returns the raw JSON value of [acquirerBusinessId].
                 *
                 * Unlike [acquirerBusinessId], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("acquirer_business_id")
                @ExcludeMissing
                fun _acquirerBusinessId(): JsonField<String> = acquirerBusinessId

                /**
                 * Returns the raw JSON value of [acquirerReferenceNumber].
                 *
                 * Unlike [acquirerReferenceNumber], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("acquirer_reference_number")
                @ExcludeMissing
                fun _acquirerReferenceNumber(): JsonField<String> = acquirerReferenceNumber

                /**
                 * Returns the raw JSON value of [transactionId].
                 *
                 * Unlike [transactionId], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("transaction_id")
                @ExcludeMissing
                fun _transactionId(): JsonField<String> = transactionId

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [NetworkIdentifiers].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .acquirerBusinessId()
                     * .acquirerReferenceNumber()
                     * .transactionId()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [NetworkIdentifiers]. */
                class Builder internal constructor() {

                    private var acquirerBusinessId: JsonField<String>? = null
                    private var acquirerReferenceNumber: JsonField<String>? = null
                    private var transactionId: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(networkIdentifiers: NetworkIdentifiers) = apply {
                        acquirerBusinessId = networkIdentifiers.acquirerBusinessId
                        acquirerReferenceNumber = networkIdentifiers.acquirerReferenceNumber
                        transactionId = networkIdentifiers.transactionId
                        additionalProperties =
                            networkIdentifiers.additionalProperties.toMutableMap()
                    }

                    /**
                     * A network assigned business ID that identifies the acquirer that processed
                     * this transaction.
                     */
                    fun acquirerBusinessId(acquirerBusinessId: String) =
                        acquirerBusinessId(JsonField.of(acquirerBusinessId))

                    /**
                     * Sets [Builder.acquirerBusinessId] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.acquirerBusinessId] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun acquirerBusinessId(acquirerBusinessId: JsonField<String>) = apply {
                        this.acquirerBusinessId = acquirerBusinessId
                    }

                    /** A globally unique identifier for this settlement. */
                    fun acquirerReferenceNumber(acquirerReferenceNumber: String) =
                        acquirerReferenceNumber(JsonField.of(acquirerReferenceNumber))

                    /**
                     * Sets [Builder.acquirerReferenceNumber] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.acquirerReferenceNumber] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun acquirerReferenceNumber(acquirerReferenceNumber: JsonField<String>) =
                        apply {
                            this.acquirerReferenceNumber = acquirerReferenceNumber
                        }

                    /**
                     * A globally unique transaction identifier provided by the card network, used
                     * across multiple life-cycle requests.
                     */
                    fun transactionId(transactionId: String?) =
                        transactionId(JsonField.ofNullable(transactionId))

                    /**
                     * Sets [Builder.transactionId] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.transactionId] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun transactionId(transactionId: JsonField<String>) = apply {
                        this.transactionId = transactionId
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [NetworkIdentifiers].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .acquirerBusinessId()
                     * .acquirerReferenceNumber()
                     * .transactionId()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): NetworkIdentifiers =
                        NetworkIdentifiers(
                            checkRequired("acquirerBusinessId", acquirerBusinessId),
                            checkRequired("acquirerReferenceNumber", acquirerReferenceNumber),
                            checkRequired("transactionId", transactionId),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): NetworkIdentifiers = apply {
                    if (validated) {
                        return@apply
                    }

                    acquirerBusinessId()
                    acquirerReferenceNumber()
                    transactionId()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (acquirerBusinessId.asKnown() == null) 0 else 1) +
                        (if (acquirerReferenceNumber.asKnown() == null) 0 else 1) +
                        (if (transactionId.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NetworkIdentifiers &&
                        acquirerBusinessId == other.acquirerBusinessId &&
                        acquirerReferenceNumber == other.acquirerReferenceNumber &&
                        transactionId == other.transactionId &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        acquirerBusinessId,
                        acquirerReferenceNumber,
                        transactionId,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "NetworkIdentifiers{acquirerBusinessId=$acquirerBusinessId, acquirerReferenceNumber=$acquirerReferenceNumber, transactionId=$transactionId, additionalProperties=$additionalProperties}"
            }

            /**
             * Additional details about the card purchase, such as tax and industry-specific fields.
             */
            class PurchaseDetails
            private constructor(
                private val carRental: JsonField<CarRental>,
                private val customerReferenceIdentifier: JsonField<String>,
                private val localTaxAmount: JsonField<Long>,
                private val localTaxCurrency: JsonField<String>,
                private val lodging: JsonField<Lodging>,
                private val nationalTaxAmount: JsonField<Long>,
                private val nationalTaxCurrency: JsonField<String>,
                private val purchaseIdentifier: JsonField<String>,
                private val purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat>,
                private val travel: JsonField<Travel>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("car_rental")
                    @ExcludeMissing
                    carRental: JsonField<CarRental> = JsonMissing.of(),
                    @JsonProperty("customer_reference_identifier")
                    @ExcludeMissing
                    customerReferenceIdentifier: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("local_tax_amount")
                    @ExcludeMissing
                    localTaxAmount: JsonField<Long> = JsonMissing.of(),
                    @JsonProperty("local_tax_currency")
                    @ExcludeMissing
                    localTaxCurrency: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("lodging")
                    @ExcludeMissing
                    lodging: JsonField<Lodging> = JsonMissing.of(),
                    @JsonProperty("national_tax_amount")
                    @ExcludeMissing
                    nationalTaxAmount: JsonField<Long> = JsonMissing.of(),
                    @JsonProperty("national_tax_currency")
                    @ExcludeMissing
                    nationalTaxCurrency: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("purchase_identifier")
                    @ExcludeMissing
                    purchaseIdentifier: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("purchase_identifier_format")
                    @ExcludeMissing
                    purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat> =
                        JsonMissing.of(),
                    @JsonProperty("travel")
                    @ExcludeMissing
                    travel: JsonField<Travel> = JsonMissing.of(),
                ) : this(
                    carRental,
                    customerReferenceIdentifier,
                    localTaxAmount,
                    localTaxCurrency,
                    lodging,
                    nationalTaxAmount,
                    nationalTaxCurrency,
                    purchaseIdentifier,
                    purchaseIdentifierFormat,
                    travel,
                    mutableMapOf(),
                )

                /**
                 * Fields specific to car rentals.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun carRental(): CarRental? = carRental.getNullable("car_rental")

                /**
                 * An identifier from the merchant for the customer or consumer.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun customerReferenceIdentifier(): String? =
                    customerReferenceIdentifier.getNullable("customer_reference_identifier")

                /**
                 * The state or provincial tax amount in minor units.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun localTaxAmount(): Long? = localTaxAmount.getNullable("local_tax_amount")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                 * assessed.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun localTaxCurrency(): String? = localTaxCurrency.getNullable("local_tax_currency")

                /**
                 * Fields specific to lodging.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun lodging(): Lodging? = lodging.getNullable("lodging")

                /**
                 * The national tax amount in minor units.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun nationalTaxAmount(): Long? =
                    nationalTaxAmount.getNullable("national_tax_amount")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                 * assessed.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun nationalTaxCurrency(): String? =
                    nationalTaxCurrency.getNullable("national_tax_currency")

                /**
                 * An identifier from the merchant for the purchase to the issuer and cardholder.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun purchaseIdentifier(): String? =
                    purchaseIdentifier.getNullable("purchase_identifier")

                /**
                 * The format of the purchase identifier.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun purchaseIdentifierFormat(): PurchaseIdentifierFormat? =
                    purchaseIdentifierFormat.getNullable("purchase_identifier_format")

                /**
                 * Fields specific to travel.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun travel(): Travel? = travel.getNullable("travel")

                /**
                 * Returns the raw JSON value of [carRental].
                 *
                 * Unlike [carRental], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("car_rental")
                @ExcludeMissing
                fun _carRental(): JsonField<CarRental> = carRental

                /**
                 * Returns the raw JSON value of [customerReferenceIdentifier].
                 *
                 * Unlike [customerReferenceIdentifier], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("customer_reference_identifier")
                @ExcludeMissing
                fun _customerReferenceIdentifier(): JsonField<String> = customerReferenceIdentifier

                /**
                 * Returns the raw JSON value of [localTaxAmount].
                 *
                 * Unlike [localTaxAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("local_tax_amount")
                @ExcludeMissing
                fun _localTaxAmount(): JsonField<Long> = localTaxAmount

                /**
                 * Returns the raw JSON value of [localTaxCurrency].
                 *
                 * Unlike [localTaxCurrency], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("local_tax_currency")
                @ExcludeMissing
                fun _localTaxCurrency(): JsonField<String> = localTaxCurrency

                /**
                 * Returns the raw JSON value of [lodging].
                 *
                 * Unlike [lodging], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("lodging")
                @ExcludeMissing
                fun _lodging(): JsonField<Lodging> = lodging

                /**
                 * Returns the raw JSON value of [nationalTaxAmount].
                 *
                 * Unlike [nationalTaxAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("national_tax_amount")
                @ExcludeMissing
                fun _nationalTaxAmount(): JsonField<Long> = nationalTaxAmount

                /**
                 * Returns the raw JSON value of [nationalTaxCurrency].
                 *
                 * Unlike [nationalTaxCurrency], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("national_tax_currency")
                @ExcludeMissing
                fun _nationalTaxCurrency(): JsonField<String> = nationalTaxCurrency

                /**
                 * Returns the raw JSON value of [purchaseIdentifier].
                 *
                 * Unlike [purchaseIdentifier], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("purchase_identifier")
                @ExcludeMissing
                fun _purchaseIdentifier(): JsonField<String> = purchaseIdentifier

                /**
                 * Returns the raw JSON value of [purchaseIdentifierFormat].
                 *
                 * Unlike [purchaseIdentifierFormat], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("purchase_identifier_format")
                @ExcludeMissing
                fun _purchaseIdentifierFormat(): JsonField<PurchaseIdentifierFormat> =
                    purchaseIdentifierFormat

                /**
                 * Returns the raw JSON value of [travel].
                 *
                 * Unlike [travel], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("travel") @ExcludeMissing fun _travel(): JsonField<Travel> = travel

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [PurchaseDetails].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .carRental()
                     * .customerReferenceIdentifier()
                     * .localTaxAmount()
                     * .localTaxCurrency()
                     * .lodging()
                     * .nationalTaxAmount()
                     * .nationalTaxCurrency()
                     * .purchaseIdentifier()
                     * .purchaseIdentifierFormat()
                     * .travel()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [PurchaseDetails]. */
                class Builder internal constructor() {

                    private var carRental: JsonField<CarRental>? = null
                    private var customerReferenceIdentifier: JsonField<String>? = null
                    private var localTaxAmount: JsonField<Long>? = null
                    private var localTaxCurrency: JsonField<String>? = null
                    private var lodging: JsonField<Lodging>? = null
                    private var nationalTaxAmount: JsonField<Long>? = null
                    private var nationalTaxCurrency: JsonField<String>? = null
                    private var purchaseIdentifier: JsonField<String>? = null
                    private var purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat>? =
                        null
                    private var travel: JsonField<Travel>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(purchaseDetails: PurchaseDetails) = apply {
                        carRental = purchaseDetails.carRental
                        customerReferenceIdentifier = purchaseDetails.customerReferenceIdentifier
                        localTaxAmount = purchaseDetails.localTaxAmount
                        localTaxCurrency = purchaseDetails.localTaxCurrency
                        lodging = purchaseDetails.lodging
                        nationalTaxAmount = purchaseDetails.nationalTaxAmount
                        nationalTaxCurrency = purchaseDetails.nationalTaxCurrency
                        purchaseIdentifier = purchaseDetails.purchaseIdentifier
                        purchaseIdentifierFormat = purchaseDetails.purchaseIdentifierFormat
                        travel = purchaseDetails.travel
                        additionalProperties = purchaseDetails.additionalProperties.toMutableMap()
                    }

                    /** Fields specific to car rentals. */
                    fun carRental(carRental: CarRental?) =
                        carRental(JsonField.ofNullable(carRental))

                    /**
                     * Sets [Builder.carRental] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.carRental] with a well-typed [CarRental]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun carRental(carRental: JsonField<CarRental>) = apply {
                        this.carRental = carRental
                    }

                    /** An identifier from the merchant for the customer or consumer. */
                    fun customerReferenceIdentifier(customerReferenceIdentifier: String?) =
                        customerReferenceIdentifier(
                            JsonField.ofNullable(customerReferenceIdentifier)
                        )

                    /**
                     * Sets [Builder.customerReferenceIdentifier] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.customerReferenceIdentifier] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun customerReferenceIdentifier(
                        customerReferenceIdentifier: JsonField<String>
                    ) = apply { this.customerReferenceIdentifier = customerReferenceIdentifier }

                    /** The state or provincial tax amount in minor units. */
                    fun localTaxAmount(localTaxAmount: Long?) =
                        localTaxAmount(JsonField.ofNullable(localTaxAmount))

                    /**
                     * Alias for [Builder.localTaxAmount].
                     *
                     * This unboxed primitive overload exists for backwards compatibility.
                     */
                    fun localTaxAmount(localTaxAmount: Long) =
                        localTaxAmount(localTaxAmount as Long?)

                    /**
                     * Sets [Builder.localTaxAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.localTaxAmount] with a well-typed [Long]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun localTaxAmount(localTaxAmount: JsonField<Long>) = apply {
                        this.localTaxAmount = localTaxAmount
                    }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                     * assessed.
                     */
                    fun localTaxCurrency(localTaxCurrency: String?) =
                        localTaxCurrency(JsonField.ofNullable(localTaxCurrency))

                    /**
                     * Sets [Builder.localTaxCurrency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.localTaxCurrency] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun localTaxCurrency(localTaxCurrency: JsonField<String>) = apply {
                        this.localTaxCurrency = localTaxCurrency
                    }

                    /** Fields specific to lodging. */
                    fun lodging(lodging: Lodging?) = lodging(JsonField.ofNullable(lodging))

                    /**
                     * Sets [Builder.lodging] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.lodging] with a well-typed [Lodging] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun lodging(lodging: JsonField<Lodging>) = apply { this.lodging = lodging }

                    /** The national tax amount in minor units. */
                    fun nationalTaxAmount(nationalTaxAmount: Long?) =
                        nationalTaxAmount(JsonField.ofNullable(nationalTaxAmount))

                    /**
                     * Alias for [Builder.nationalTaxAmount].
                     *
                     * This unboxed primitive overload exists for backwards compatibility.
                     */
                    fun nationalTaxAmount(nationalTaxAmount: Long) =
                        nationalTaxAmount(nationalTaxAmount as Long?)

                    /**
                     * Sets [Builder.nationalTaxAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.nationalTaxAmount] with a well-typed [Long]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun nationalTaxAmount(nationalTaxAmount: JsonField<Long>) = apply {
                        this.nationalTaxAmount = nationalTaxAmount
                    }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                     * assessed.
                     */
                    fun nationalTaxCurrency(nationalTaxCurrency: String?) =
                        nationalTaxCurrency(JsonField.ofNullable(nationalTaxCurrency))

                    /**
                     * Sets [Builder.nationalTaxCurrency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.nationalTaxCurrency] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun nationalTaxCurrency(nationalTaxCurrency: JsonField<String>) = apply {
                        this.nationalTaxCurrency = nationalTaxCurrency
                    }

                    /**
                     * An identifier from the merchant for the purchase to the issuer and
                     * cardholder.
                     */
                    fun purchaseIdentifier(purchaseIdentifier: String?) =
                        purchaseIdentifier(JsonField.ofNullable(purchaseIdentifier))

                    /**
                     * Sets [Builder.purchaseIdentifier] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseIdentifier] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun purchaseIdentifier(purchaseIdentifier: JsonField<String>) = apply {
                        this.purchaseIdentifier = purchaseIdentifier
                    }

                    /** The format of the purchase identifier. */
                    fun purchaseIdentifierFormat(
                        purchaseIdentifierFormat: PurchaseIdentifierFormat?
                    ) = purchaseIdentifierFormat(JsonField.ofNullable(purchaseIdentifierFormat))

                    /**
                     * Sets [Builder.purchaseIdentifierFormat] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseIdentifierFormat] with a well-typed
                     * [PurchaseIdentifierFormat] value instead. This method is primarily for
                     * setting the field to an undocumented or not yet supported value.
                     */
                    fun purchaseIdentifierFormat(
                        purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat>
                    ) = apply { this.purchaseIdentifierFormat = purchaseIdentifierFormat }

                    /** Fields specific to travel. */
                    fun travel(travel: Travel?) = travel(JsonField.ofNullable(travel))

                    /**
                     * Sets [Builder.travel] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.travel] with a well-typed [Travel] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun travel(travel: JsonField<Travel>) = apply { this.travel = travel }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [PurchaseDetails].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .carRental()
                     * .customerReferenceIdentifier()
                     * .localTaxAmount()
                     * .localTaxCurrency()
                     * .lodging()
                     * .nationalTaxAmount()
                     * .nationalTaxCurrency()
                     * .purchaseIdentifier()
                     * .purchaseIdentifierFormat()
                     * .travel()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): PurchaseDetails =
                        PurchaseDetails(
                            checkRequired("carRental", carRental),
                            checkRequired(
                                "customerReferenceIdentifier",
                                customerReferenceIdentifier,
                            ),
                            checkRequired("localTaxAmount", localTaxAmount),
                            checkRequired("localTaxCurrency", localTaxCurrency),
                            checkRequired("lodging", lodging),
                            checkRequired("nationalTaxAmount", nationalTaxAmount),
                            checkRequired("nationalTaxCurrency", nationalTaxCurrency),
                            checkRequired("purchaseIdentifier", purchaseIdentifier),
                            checkRequired("purchaseIdentifierFormat", purchaseIdentifierFormat),
                            checkRequired("travel", travel),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): PurchaseDetails = apply {
                    if (validated) {
                        return@apply
                    }

                    carRental()?.validate()
                    customerReferenceIdentifier()
                    localTaxAmount()
                    localTaxCurrency()
                    lodging()?.validate()
                    nationalTaxAmount()
                    nationalTaxCurrency()
                    purchaseIdentifier()
                    purchaseIdentifierFormat()?.validate()
                    travel()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (carRental.asKnown()?.validity() ?: 0) +
                        (if (customerReferenceIdentifier.asKnown() == null) 0 else 1) +
                        (if (localTaxAmount.asKnown() == null) 0 else 1) +
                        (if (localTaxCurrency.asKnown() == null) 0 else 1) +
                        (lodging.asKnown()?.validity() ?: 0) +
                        (if (nationalTaxAmount.asKnown() == null) 0 else 1) +
                        (if (nationalTaxCurrency.asKnown() == null) 0 else 1) +
                        (if (purchaseIdentifier.asKnown() == null) 0 else 1) +
                        (purchaseIdentifierFormat.asKnown()?.validity() ?: 0) +
                        (travel.asKnown()?.validity() ?: 0)

                /** Fields specific to car rentals. */
                class CarRental
                private constructor(
                    private val carClassCode: JsonField<String>,
                    private val checkoutDate: JsonField<LocalDate>,
                    private val dailyRentalRateAmount: JsonField<Long>,
                    private val dailyRentalRateCurrency: JsonField<String>,
                    private val daysRented: JsonField<Long>,
                    private val extraCharges: JsonField<ExtraCharges>,
                    private val fuelChargesAmount: JsonField<Long>,
                    private val fuelChargesCurrency: JsonField<String>,
                    private val insuranceChargesAmount: JsonField<Long>,
                    private val insuranceChargesCurrency: JsonField<String>,
                    private val noShowIndicator: JsonField<NoShowIndicator>,
                    private val oneWayDropOffChargesAmount: JsonField<Long>,
                    private val oneWayDropOffChargesCurrency: JsonField<String>,
                    private val renterName: JsonField<String>,
                    private val weeklyRentalRateAmount: JsonField<Long>,
                    private val weeklyRentalRateCurrency: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("car_class_code")
                        @ExcludeMissing
                        carClassCode: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("checkout_date")
                        @ExcludeMissing
                        checkoutDate: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("daily_rental_rate_amount")
                        @ExcludeMissing
                        dailyRentalRateAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("daily_rental_rate_currency")
                        @ExcludeMissing
                        dailyRentalRateCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("days_rented")
                        @ExcludeMissing
                        daysRented: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("extra_charges")
                        @ExcludeMissing
                        extraCharges: JsonField<ExtraCharges> = JsonMissing.of(),
                        @JsonProperty("fuel_charges_amount")
                        @ExcludeMissing
                        fuelChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("fuel_charges_currency")
                        @ExcludeMissing
                        fuelChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("insurance_charges_amount")
                        @ExcludeMissing
                        insuranceChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("insurance_charges_currency")
                        @ExcludeMissing
                        insuranceChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("no_show_indicator")
                        @ExcludeMissing
                        noShowIndicator: JsonField<NoShowIndicator> = JsonMissing.of(),
                        @JsonProperty("one_way_drop_off_charges_amount")
                        @ExcludeMissing
                        oneWayDropOffChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("one_way_drop_off_charges_currency")
                        @ExcludeMissing
                        oneWayDropOffChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("renter_name")
                        @ExcludeMissing
                        renterName: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("weekly_rental_rate_amount")
                        @ExcludeMissing
                        weeklyRentalRateAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("weekly_rental_rate_currency")
                        @ExcludeMissing
                        weeklyRentalRateCurrency: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        carClassCode,
                        checkoutDate,
                        dailyRentalRateAmount,
                        dailyRentalRateCurrency,
                        daysRented,
                        extraCharges,
                        fuelChargesAmount,
                        fuelChargesCurrency,
                        insuranceChargesAmount,
                        insuranceChargesCurrency,
                        noShowIndicator,
                        oneWayDropOffChargesAmount,
                        oneWayDropOffChargesCurrency,
                        renterName,
                        weeklyRentalRateAmount,
                        weeklyRentalRateCurrency,
                        mutableMapOf(),
                    )

                    /**
                     * Code indicating the vehicle's class.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun carClassCode(): String? = carClassCode.getNullable("car_class_code")

                    /**
                     * Date the customer picked up the car or, in the case of a no-show or pre-pay
                     * transaction, the scheduled pick up date.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun checkoutDate(): LocalDate? = checkoutDate.getNullable("checkout_date")

                    /**
                     * Daily rate being charged for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRentalRateAmount(): Long? =
                        dailyRentalRateAmount.getNullable("daily_rental_rate_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                     * rental rate.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRentalRateCurrency(): String? =
                        dailyRentalRateCurrency.getNullable("daily_rental_rate_currency")

                    /**
                     * Number of days the vehicle was rented.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun daysRented(): Long? = daysRented.getNullable("days_rented")

                    /**
                     * Additional charges (gas, late fee, etc.) being billed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun extraCharges(): ExtraCharges? = extraCharges.getNullable("extra_charges")

                    /**
                     * Fuel charges for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun fuelChargesAmount(): Long? =
                        fuelChargesAmount.getNullable("fuel_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the fuel
                     * charges assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun fuelChargesCurrency(): String? =
                        fuelChargesCurrency.getNullable("fuel_charges_currency")

                    /**
                     * Any insurance being charged for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun insuranceChargesAmount(): Long? =
                        insuranceChargesAmount.getNullable("insurance_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the insurance
                     * charges assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun insuranceChargesCurrency(): String? =
                        insuranceChargesCurrency.getNullable("insurance_charges_currency")

                    /**
                     * An indicator that the cardholder is being billed for a reserved vehicle that
                     * was not actually rented (that is, a "no-show" charge).
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun noShowIndicator(): NoShowIndicator? =
                        noShowIndicator.getNullable("no_show_indicator")

                    /**
                     * Charges for returning the vehicle at a different location than where it was
                     * picked up.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun oneWayDropOffChargesAmount(): Long? =
                        oneWayDropOffChargesAmount.getNullable("one_way_drop_off_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the one-way
                     * drop-off charges assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun oneWayDropOffChargesCurrency(): String? =
                        oneWayDropOffChargesCurrency.getNullable(
                            "one_way_drop_off_charges_currency"
                        )

                    /**
                     * Name of the person renting the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun renterName(): String? = renterName.getNullable("renter_name")

                    /**
                     * Weekly rate being charged for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun weeklyRentalRateAmount(): Long? =
                        weeklyRentalRateAmount.getNullable("weekly_rental_rate_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the weekly
                     * rental rate.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun weeklyRentalRateCurrency(): String? =
                        weeklyRentalRateCurrency.getNullable("weekly_rental_rate_currency")

                    /**
                     * Returns the raw JSON value of [carClassCode].
                     *
                     * Unlike [carClassCode], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("car_class_code")
                    @ExcludeMissing
                    fun _carClassCode(): JsonField<String> = carClassCode

                    /**
                     * Returns the raw JSON value of [checkoutDate].
                     *
                     * Unlike [checkoutDate], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("checkout_date")
                    @ExcludeMissing
                    fun _checkoutDate(): JsonField<LocalDate> = checkoutDate

                    /**
                     * Returns the raw JSON value of [dailyRentalRateAmount].
                     *
                     * Unlike [dailyRentalRateAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("daily_rental_rate_amount")
                    @ExcludeMissing
                    fun _dailyRentalRateAmount(): JsonField<Long> = dailyRentalRateAmount

                    /**
                     * Returns the raw JSON value of [dailyRentalRateCurrency].
                     *
                     * Unlike [dailyRentalRateCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("daily_rental_rate_currency")
                    @ExcludeMissing
                    fun _dailyRentalRateCurrency(): JsonField<String> = dailyRentalRateCurrency

                    /**
                     * Returns the raw JSON value of [daysRented].
                     *
                     * Unlike [daysRented], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("days_rented")
                    @ExcludeMissing
                    fun _daysRented(): JsonField<Long> = daysRented

                    /**
                     * Returns the raw JSON value of [extraCharges].
                     *
                     * Unlike [extraCharges], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("extra_charges")
                    @ExcludeMissing
                    fun _extraCharges(): JsonField<ExtraCharges> = extraCharges

                    /**
                     * Returns the raw JSON value of [fuelChargesAmount].
                     *
                     * Unlike [fuelChargesAmount], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("fuel_charges_amount")
                    @ExcludeMissing
                    fun _fuelChargesAmount(): JsonField<Long> = fuelChargesAmount

                    /**
                     * Returns the raw JSON value of [fuelChargesCurrency].
                     *
                     * Unlike [fuelChargesCurrency], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("fuel_charges_currency")
                    @ExcludeMissing
                    fun _fuelChargesCurrency(): JsonField<String> = fuelChargesCurrency

                    /**
                     * Returns the raw JSON value of [insuranceChargesAmount].
                     *
                     * Unlike [insuranceChargesAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("insurance_charges_amount")
                    @ExcludeMissing
                    fun _insuranceChargesAmount(): JsonField<Long> = insuranceChargesAmount

                    /**
                     * Returns the raw JSON value of [insuranceChargesCurrency].
                     *
                     * Unlike [insuranceChargesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("insurance_charges_currency")
                    @ExcludeMissing
                    fun _insuranceChargesCurrency(): JsonField<String> = insuranceChargesCurrency

                    /**
                     * Returns the raw JSON value of [noShowIndicator].
                     *
                     * Unlike [noShowIndicator], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("no_show_indicator")
                    @ExcludeMissing
                    fun _noShowIndicator(): JsonField<NoShowIndicator> = noShowIndicator

                    /**
                     * Returns the raw JSON value of [oneWayDropOffChargesAmount].
                     *
                     * Unlike [oneWayDropOffChargesAmount], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("one_way_drop_off_charges_amount")
                    @ExcludeMissing
                    fun _oneWayDropOffChargesAmount(): JsonField<Long> = oneWayDropOffChargesAmount

                    /**
                     * Returns the raw JSON value of [oneWayDropOffChargesCurrency].
                     *
                     * Unlike [oneWayDropOffChargesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("one_way_drop_off_charges_currency")
                    @ExcludeMissing
                    fun _oneWayDropOffChargesCurrency(): JsonField<String> =
                        oneWayDropOffChargesCurrency

                    /**
                     * Returns the raw JSON value of [renterName].
                     *
                     * Unlike [renterName], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("renter_name")
                    @ExcludeMissing
                    fun _renterName(): JsonField<String> = renterName

                    /**
                     * Returns the raw JSON value of [weeklyRentalRateAmount].
                     *
                     * Unlike [weeklyRentalRateAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("weekly_rental_rate_amount")
                    @ExcludeMissing
                    fun _weeklyRentalRateAmount(): JsonField<Long> = weeklyRentalRateAmount

                    /**
                     * Returns the raw JSON value of [weeklyRentalRateCurrency].
                     *
                     * Unlike [weeklyRentalRateCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("weekly_rental_rate_currency")
                    @ExcludeMissing
                    fun _weeklyRentalRateCurrency(): JsonField<String> = weeklyRentalRateCurrency

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [CarRental].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .carClassCode()
                         * .checkoutDate()
                         * .dailyRentalRateAmount()
                         * .dailyRentalRateCurrency()
                         * .daysRented()
                         * .extraCharges()
                         * .fuelChargesAmount()
                         * .fuelChargesCurrency()
                         * .insuranceChargesAmount()
                         * .insuranceChargesCurrency()
                         * .noShowIndicator()
                         * .oneWayDropOffChargesAmount()
                         * .oneWayDropOffChargesCurrency()
                         * .renterName()
                         * .weeklyRentalRateAmount()
                         * .weeklyRentalRateCurrency()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CarRental]. */
                    class Builder internal constructor() {

                        private var carClassCode: JsonField<String>? = null
                        private var checkoutDate: JsonField<LocalDate>? = null
                        private var dailyRentalRateAmount: JsonField<Long>? = null
                        private var dailyRentalRateCurrency: JsonField<String>? = null
                        private var daysRented: JsonField<Long>? = null
                        private var extraCharges: JsonField<ExtraCharges>? = null
                        private var fuelChargesAmount: JsonField<Long>? = null
                        private var fuelChargesCurrency: JsonField<String>? = null
                        private var insuranceChargesAmount: JsonField<Long>? = null
                        private var insuranceChargesCurrency: JsonField<String>? = null
                        private var noShowIndicator: JsonField<NoShowIndicator>? = null
                        private var oneWayDropOffChargesAmount: JsonField<Long>? = null
                        private var oneWayDropOffChargesCurrency: JsonField<String>? = null
                        private var renterName: JsonField<String>? = null
                        private var weeklyRentalRateAmount: JsonField<Long>? = null
                        private var weeklyRentalRateCurrency: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(carRental: CarRental) = apply {
                            carClassCode = carRental.carClassCode
                            checkoutDate = carRental.checkoutDate
                            dailyRentalRateAmount = carRental.dailyRentalRateAmount
                            dailyRentalRateCurrency = carRental.dailyRentalRateCurrency
                            daysRented = carRental.daysRented
                            extraCharges = carRental.extraCharges
                            fuelChargesAmount = carRental.fuelChargesAmount
                            fuelChargesCurrency = carRental.fuelChargesCurrency
                            insuranceChargesAmount = carRental.insuranceChargesAmount
                            insuranceChargesCurrency = carRental.insuranceChargesCurrency
                            noShowIndicator = carRental.noShowIndicator
                            oneWayDropOffChargesAmount = carRental.oneWayDropOffChargesAmount
                            oneWayDropOffChargesCurrency = carRental.oneWayDropOffChargesCurrency
                            renterName = carRental.renterName
                            weeklyRentalRateAmount = carRental.weeklyRentalRateAmount
                            weeklyRentalRateCurrency = carRental.weeklyRentalRateCurrency
                            additionalProperties = carRental.additionalProperties.toMutableMap()
                        }

                        /** Code indicating the vehicle's class. */
                        fun carClassCode(carClassCode: String?) =
                            carClassCode(JsonField.ofNullable(carClassCode))

                        /**
                         * Sets [Builder.carClassCode] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.carClassCode] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun carClassCode(carClassCode: JsonField<String>) = apply {
                            this.carClassCode = carClassCode
                        }

                        /**
                         * Date the customer picked up the car or, in the case of a no-show or
                         * pre-pay transaction, the scheduled pick up date.
                         */
                        fun checkoutDate(checkoutDate: LocalDate?) =
                            checkoutDate(JsonField.ofNullable(checkoutDate))

                        /**
                         * Sets [Builder.checkoutDate] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.checkoutDate] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun checkoutDate(checkoutDate: JsonField<LocalDate>) = apply {
                            this.checkoutDate = checkoutDate
                        }

                        /** Daily rate being charged for the vehicle. */
                        fun dailyRentalRateAmount(dailyRentalRateAmount: Long?) =
                            dailyRentalRateAmount(JsonField.ofNullable(dailyRentalRateAmount))

                        /**
                         * Alias for [Builder.dailyRentalRateAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun dailyRentalRateAmount(dailyRentalRateAmount: Long) =
                            dailyRentalRateAmount(dailyRentalRateAmount as Long?)

                        /**
                         * Sets [Builder.dailyRentalRateAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRentalRateAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun dailyRentalRateAmount(dailyRentalRateAmount: JsonField<Long>) = apply {
                            this.dailyRentalRateAmount = dailyRentalRateAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                         * rental rate.
                         */
                        fun dailyRentalRateCurrency(dailyRentalRateCurrency: String?) =
                            dailyRentalRateCurrency(JsonField.ofNullable(dailyRentalRateCurrency))

                        /**
                         * Sets [Builder.dailyRentalRateCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRentalRateCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun dailyRentalRateCurrency(dailyRentalRateCurrency: JsonField<String>) =
                            apply {
                                this.dailyRentalRateCurrency = dailyRentalRateCurrency
                            }

                        /** Number of days the vehicle was rented. */
                        fun daysRented(daysRented: Long?) =
                            daysRented(JsonField.ofNullable(daysRented))

                        /**
                         * Alias for [Builder.daysRented].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun daysRented(daysRented: Long) = daysRented(daysRented as Long?)

                        /**
                         * Sets [Builder.daysRented] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.daysRented] with a well-typed [Long]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun daysRented(daysRented: JsonField<Long>) = apply {
                            this.daysRented = daysRented
                        }

                        /** Additional charges (gas, late fee, etc.) being billed. */
                        fun extraCharges(extraCharges: ExtraCharges?) =
                            extraCharges(JsonField.ofNullable(extraCharges))

                        /**
                         * Sets [Builder.extraCharges] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.extraCharges] with a well-typed
                         * [ExtraCharges] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun extraCharges(extraCharges: JsonField<ExtraCharges>) = apply {
                            this.extraCharges = extraCharges
                        }

                        /** Fuel charges for the vehicle. */
                        fun fuelChargesAmount(fuelChargesAmount: Long?) =
                            fuelChargesAmount(JsonField.ofNullable(fuelChargesAmount))

                        /**
                         * Alias for [Builder.fuelChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun fuelChargesAmount(fuelChargesAmount: Long) =
                            fuelChargesAmount(fuelChargesAmount as Long?)

                        /**
                         * Sets [Builder.fuelChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.fuelChargesAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun fuelChargesAmount(fuelChargesAmount: JsonField<Long>) = apply {
                            this.fuelChargesAmount = fuelChargesAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the fuel
                         * charges assessed.
                         */
                        fun fuelChargesCurrency(fuelChargesCurrency: String?) =
                            fuelChargesCurrency(JsonField.ofNullable(fuelChargesCurrency))

                        /**
                         * Sets [Builder.fuelChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.fuelChargesCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun fuelChargesCurrency(fuelChargesCurrency: JsonField<String>) = apply {
                            this.fuelChargesCurrency = fuelChargesCurrency
                        }

                        /** Any insurance being charged for the vehicle. */
                        fun insuranceChargesAmount(insuranceChargesAmount: Long?) =
                            insuranceChargesAmount(JsonField.ofNullable(insuranceChargesAmount))

                        /**
                         * Alias for [Builder.insuranceChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun insuranceChargesAmount(insuranceChargesAmount: Long) =
                            insuranceChargesAmount(insuranceChargesAmount as Long?)

                        /**
                         * Sets [Builder.insuranceChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.insuranceChargesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun insuranceChargesAmount(insuranceChargesAmount: JsonField<Long>) =
                            apply {
                                this.insuranceChargesAmount = insuranceChargesAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * insurance charges assessed.
                         */
                        fun insuranceChargesCurrency(insuranceChargesCurrency: String?) =
                            insuranceChargesCurrency(JsonField.ofNullable(insuranceChargesCurrency))

                        /**
                         * Sets [Builder.insuranceChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.insuranceChargesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun insuranceChargesCurrency(insuranceChargesCurrency: JsonField<String>) =
                            apply {
                                this.insuranceChargesCurrency = insuranceChargesCurrency
                            }

                        /**
                         * An indicator that the cardholder is being billed for a reserved vehicle
                         * that was not actually rented (that is, a "no-show" charge).
                         */
                        fun noShowIndicator(noShowIndicator: NoShowIndicator?) =
                            noShowIndicator(JsonField.ofNullable(noShowIndicator))

                        /**
                         * Sets [Builder.noShowIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.noShowIndicator] with a well-typed
                         * [NoShowIndicator] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun noShowIndicator(noShowIndicator: JsonField<NoShowIndicator>) = apply {
                            this.noShowIndicator = noShowIndicator
                        }

                        /**
                         * Charges for returning the vehicle at a different location than where it
                         * was picked up.
                         */
                        fun oneWayDropOffChargesAmount(oneWayDropOffChargesAmount: Long?) =
                            oneWayDropOffChargesAmount(
                                JsonField.ofNullable(oneWayDropOffChargesAmount)
                            )

                        /**
                         * Alias for [Builder.oneWayDropOffChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun oneWayDropOffChargesAmount(oneWayDropOffChargesAmount: Long) =
                            oneWayDropOffChargesAmount(oneWayDropOffChargesAmount as Long?)

                        /**
                         * Sets [Builder.oneWayDropOffChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.oneWayDropOffChargesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun oneWayDropOffChargesAmount(
                            oneWayDropOffChargesAmount: JsonField<Long>
                        ) = apply { this.oneWayDropOffChargesAmount = oneWayDropOffChargesAmount }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * one-way drop-off charges assessed.
                         */
                        fun oneWayDropOffChargesCurrency(oneWayDropOffChargesCurrency: String?) =
                            oneWayDropOffChargesCurrency(
                                JsonField.ofNullable(oneWayDropOffChargesCurrency)
                            )

                        /**
                         * Sets [Builder.oneWayDropOffChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.oneWayDropOffChargesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun oneWayDropOffChargesCurrency(
                            oneWayDropOffChargesCurrency: JsonField<String>
                        ) = apply {
                            this.oneWayDropOffChargesCurrency = oneWayDropOffChargesCurrency
                        }

                        /** Name of the person renting the vehicle. */
                        fun renterName(renterName: String?) =
                            renterName(JsonField.ofNullable(renterName))

                        /**
                         * Sets [Builder.renterName] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.renterName] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun renterName(renterName: JsonField<String>) = apply {
                            this.renterName = renterName
                        }

                        /** Weekly rate being charged for the vehicle. */
                        fun weeklyRentalRateAmount(weeklyRentalRateAmount: Long?) =
                            weeklyRentalRateAmount(JsonField.ofNullable(weeklyRentalRateAmount))

                        /**
                         * Alias for [Builder.weeklyRentalRateAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun weeklyRentalRateAmount(weeklyRentalRateAmount: Long) =
                            weeklyRentalRateAmount(weeklyRentalRateAmount as Long?)

                        /**
                         * Sets [Builder.weeklyRentalRateAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.weeklyRentalRateAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun weeklyRentalRateAmount(weeklyRentalRateAmount: JsonField<Long>) =
                            apply {
                                this.weeklyRentalRateAmount = weeklyRentalRateAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * weekly rental rate.
                         */
                        fun weeklyRentalRateCurrency(weeklyRentalRateCurrency: String?) =
                            weeklyRentalRateCurrency(JsonField.ofNullable(weeklyRentalRateCurrency))

                        /**
                         * Sets [Builder.weeklyRentalRateCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.weeklyRentalRateCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun weeklyRentalRateCurrency(weeklyRentalRateCurrency: JsonField<String>) =
                            apply {
                                this.weeklyRentalRateCurrency = weeklyRentalRateCurrency
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CarRental].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .carClassCode()
                         * .checkoutDate()
                         * .dailyRentalRateAmount()
                         * .dailyRentalRateCurrency()
                         * .daysRented()
                         * .extraCharges()
                         * .fuelChargesAmount()
                         * .fuelChargesCurrency()
                         * .insuranceChargesAmount()
                         * .insuranceChargesCurrency()
                         * .noShowIndicator()
                         * .oneWayDropOffChargesAmount()
                         * .oneWayDropOffChargesCurrency()
                         * .renterName()
                         * .weeklyRentalRateAmount()
                         * .weeklyRentalRateCurrency()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CarRental =
                            CarRental(
                                checkRequired("carClassCode", carClassCode),
                                checkRequired("checkoutDate", checkoutDate),
                                checkRequired("dailyRentalRateAmount", dailyRentalRateAmount),
                                checkRequired("dailyRentalRateCurrency", dailyRentalRateCurrency),
                                checkRequired("daysRented", daysRented),
                                checkRequired("extraCharges", extraCharges),
                                checkRequired("fuelChargesAmount", fuelChargesAmount),
                                checkRequired("fuelChargesCurrency", fuelChargesCurrency),
                                checkRequired("insuranceChargesAmount", insuranceChargesAmount),
                                checkRequired("insuranceChargesCurrency", insuranceChargesCurrency),
                                checkRequired("noShowIndicator", noShowIndicator),
                                checkRequired(
                                    "oneWayDropOffChargesAmount",
                                    oneWayDropOffChargesAmount,
                                ),
                                checkRequired(
                                    "oneWayDropOffChargesCurrency",
                                    oneWayDropOffChargesCurrency,
                                ),
                                checkRequired("renterName", renterName),
                                checkRequired("weeklyRentalRateAmount", weeklyRentalRateAmount),
                                checkRequired("weeklyRentalRateCurrency", weeklyRentalRateCurrency),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CarRental = apply {
                        if (validated) {
                            return@apply
                        }

                        carClassCode()
                        checkoutDate()
                        dailyRentalRateAmount()
                        dailyRentalRateCurrency()
                        daysRented()
                        extraCharges()?.validate()
                        fuelChargesAmount()
                        fuelChargesCurrency()
                        insuranceChargesAmount()
                        insuranceChargesCurrency()
                        noShowIndicator()?.validate()
                        oneWayDropOffChargesAmount()
                        oneWayDropOffChargesCurrency()
                        renterName()
                        weeklyRentalRateAmount()
                        weeklyRentalRateCurrency()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (carClassCode.asKnown() == null) 0 else 1) +
                            (if (checkoutDate.asKnown() == null) 0 else 1) +
                            (if (dailyRentalRateAmount.asKnown() == null) 0 else 1) +
                            (if (dailyRentalRateCurrency.asKnown() == null) 0 else 1) +
                            (if (daysRented.asKnown() == null) 0 else 1) +
                            (extraCharges.asKnown()?.validity() ?: 0) +
                            (if (fuelChargesAmount.asKnown() == null) 0 else 1) +
                            (if (fuelChargesCurrency.asKnown() == null) 0 else 1) +
                            (if (insuranceChargesAmount.asKnown() == null) 0 else 1) +
                            (if (insuranceChargesCurrency.asKnown() == null) 0 else 1) +
                            (noShowIndicator.asKnown()?.validity() ?: 0) +
                            (if (oneWayDropOffChargesAmount.asKnown() == null) 0 else 1) +
                            (if (oneWayDropOffChargesCurrency.asKnown() == null) 0 else 1) +
                            (if (renterName.asKnown() == null) 0 else 1) +
                            (if (weeklyRentalRateAmount.asKnown() == null) 0 else 1) +
                            (if (weeklyRentalRateCurrency.asKnown() == null) 0 else 1)

                    /** Additional charges (gas, late fee, etc.) being billed. */
                    class ExtraCharges
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No extra charge */
                            val NO_EXTRA_CHARGE = of("no_extra_charge")

                            /** Gas */
                            val GAS = of("gas")

                            /** Extra mileage */
                            val EXTRA_MILEAGE = of("extra_mileage")

                            /** Late return */
                            val LATE_RETURN = of("late_return")

                            /** One way service fee */
                            val ONE_WAY_SERVICE_FEE = of("one_way_service_fee")

                            /** Parking violation */
                            val PARKING_VIOLATION = of("parking_violation")

                            fun of(value: String) = ExtraCharges(JsonField.of(value))
                        }

                        /** An enum containing [ExtraCharges]'s known values. */
                        enum class Known {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Gas */
                            GAS,
                            /** Extra mileage */
                            EXTRA_MILEAGE,
                            /** Late return */
                            LATE_RETURN,
                            /** One way service fee */
                            ONE_WAY_SERVICE_FEE,
                            /** Parking violation */
                            PARKING_VIOLATION,
                        }

                        /**
                         * An enum containing [ExtraCharges]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ExtraCharges] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Gas */
                            GAS,
                            /** Extra mileage */
                            EXTRA_MILEAGE,
                            /** Late return */
                            LATE_RETURN,
                            /** One way service fee */
                            ONE_WAY_SERVICE_FEE,
                            /** Parking violation */
                            PARKING_VIOLATION,
                            /**
                             * An enum member indicating that [ExtraCharges] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_EXTRA_CHARGE -> Value.NO_EXTRA_CHARGE
                                GAS -> Value.GAS
                                EXTRA_MILEAGE -> Value.EXTRA_MILEAGE
                                LATE_RETURN -> Value.LATE_RETURN
                                ONE_WAY_SERVICE_FEE -> Value.ONE_WAY_SERVICE_FEE
                                PARKING_VIOLATION -> Value.PARKING_VIOLATION
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_EXTRA_CHARGE -> Known.NO_EXTRA_CHARGE
                                GAS -> Known.GAS
                                EXTRA_MILEAGE -> Known.EXTRA_MILEAGE
                                LATE_RETURN -> Known.LATE_RETURN
                                ONE_WAY_SERVICE_FEE -> Known.ONE_WAY_SERVICE_FEE
                                PARKING_VIOLATION -> Known.PARKING_VIOLATION
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ExtraCharges: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ExtraCharges = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ExtraCharges && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * An indicator that the cardholder is being billed for a reserved vehicle that
                     * was not actually rented (that is, a "no-show" charge).
                     */
                    class NoShowIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not applicable */
                            val NOT_APPLICABLE = of("not_applicable")

                            /** No show for specialized vehicle */
                            val NO_SHOW_FOR_SPECIALIZED_VEHICLE =
                                of("no_show_for_specialized_vehicle")

                            fun of(value: String) = NoShowIndicator(JsonField.of(value))
                        }

                        /** An enum containing [NoShowIndicator]'s known values. */
                        enum class Known {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show for specialized vehicle */
                            NO_SHOW_FOR_SPECIALIZED_VEHICLE,
                        }

                        /**
                         * An enum containing [NoShowIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [NoShowIndicator] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show for specialized vehicle */
                            NO_SHOW_FOR_SPECIALIZED_VEHICLE,
                            /**
                             * An enum member indicating that [NoShowIndicator] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_APPLICABLE -> Value.NOT_APPLICABLE
                                NO_SHOW_FOR_SPECIALIZED_VEHICLE ->
                                    Value.NO_SHOW_FOR_SPECIALIZED_VEHICLE
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_APPLICABLE -> Known.NOT_APPLICABLE
                                NO_SHOW_FOR_SPECIALIZED_VEHICLE ->
                                    Known.NO_SHOW_FOR_SPECIALIZED_VEHICLE
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown NoShowIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): NoShowIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is NoShowIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CarRental &&
                            carClassCode == other.carClassCode &&
                            checkoutDate == other.checkoutDate &&
                            dailyRentalRateAmount == other.dailyRentalRateAmount &&
                            dailyRentalRateCurrency == other.dailyRentalRateCurrency &&
                            daysRented == other.daysRented &&
                            extraCharges == other.extraCharges &&
                            fuelChargesAmount == other.fuelChargesAmount &&
                            fuelChargesCurrency == other.fuelChargesCurrency &&
                            insuranceChargesAmount == other.insuranceChargesAmount &&
                            insuranceChargesCurrency == other.insuranceChargesCurrency &&
                            noShowIndicator == other.noShowIndicator &&
                            oneWayDropOffChargesAmount == other.oneWayDropOffChargesAmount &&
                            oneWayDropOffChargesCurrency == other.oneWayDropOffChargesCurrency &&
                            renterName == other.renterName &&
                            weeklyRentalRateAmount == other.weeklyRentalRateAmount &&
                            weeklyRentalRateCurrency == other.weeklyRentalRateCurrency &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            carClassCode,
                            checkoutDate,
                            dailyRentalRateAmount,
                            dailyRentalRateCurrency,
                            daysRented,
                            extraCharges,
                            fuelChargesAmount,
                            fuelChargesCurrency,
                            insuranceChargesAmount,
                            insuranceChargesCurrency,
                            noShowIndicator,
                            oneWayDropOffChargesAmount,
                            oneWayDropOffChargesCurrency,
                            renterName,
                            weeklyRentalRateAmount,
                            weeklyRentalRateCurrency,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CarRental{carClassCode=$carClassCode, checkoutDate=$checkoutDate, dailyRentalRateAmount=$dailyRentalRateAmount, dailyRentalRateCurrency=$dailyRentalRateCurrency, daysRented=$daysRented, extraCharges=$extraCharges, fuelChargesAmount=$fuelChargesAmount, fuelChargesCurrency=$fuelChargesCurrency, insuranceChargesAmount=$insuranceChargesAmount, insuranceChargesCurrency=$insuranceChargesCurrency, noShowIndicator=$noShowIndicator, oneWayDropOffChargesAmount=$oneWayDropOffChargesAmount, oneWayDropOffChargesCurrency=$oneWayDropOffChargesCurrency, renterName=$renterName, weeklyRentalRateAmount=$weeklyRentalRateAmount, weeklyRentalRateCurrency=$weeklyRentalRateCurrency, additionalProperties=$additionalProperties}"
                }

                /** Fields specific to lodging. */
                class Lodging
                private constructor(
                    private val checkInDate: JsonField<LocalDate>,
                    private val dailyRoomRateAmount: JsonField<Long>,
                    private val dailyRoomRateCurrency: JsonField<String>,
                    private val extraCharges: JsonField<ExtraCharges>,
                    private val folioCashAdvancesAmount: JsonField<Long>,
                    private val folioCashAdvancesCurrency: JsonField<String>,
                    private val foodBeverageChargesAmount: JsonField<Long>,
                    private val foodBeverageChargesCurrency: JsonField<String>,
                    private val noShowIndicator: JsonField<NoShowIndicator>,
                    private val prepaidExpensesAmount: JsonField<Long>,
                    private val prepaidExpensesCurrency: JsonField<String>,
                    private val roomNights: JsonField<Long>,
                    private val totalRoomTaxAmount: JsonField<Long>,
                    private val totalRoomTaxCurrency: JsonField<String>,
                    private val totalTaxAmount: JsonField<Long>,
                    private val totalTaxCurrency: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("check_in_date")
                        @ExcludeMissing
                        checkInDate: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("daily_room_rate_amount")
                        @ExcludeMissing
                        dailyRoomRateAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("daily_room_rate_currency")
                        @ExcludeMissing
                        dailyRoomRateCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("extra_charges")
                        @ExcludeMissing
                        extraCharges: JsonField<ExtraCharges> = JsonMissing.of(),
                        @JsonProperty("folio_cash_advances_amount")
                        @ExcludeMissing
                        folioCashAdvancesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("folio_cash_advances_currency")
                        @ExcludeMissing
                        folioCashAdvancesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("food_beverage_charges_amount")
                        @ExcludeMissing
                        foodBeverageChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("food_beverage_charges_currency")
                        @ExcludeMissing
                        foodBeverageChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("no_show_indicator")
                        @ExcludeMissing
                        noShowIndicator: JsonField<NoShowIndicator> = JsonMissing.of(),
                        @JsonProperty("prepaid_expenses_amount")
                        @ExcludeMissing
                        prepaidExpensesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("prepaid_expenses_currency")
                        @ExcludeMissing
                        prepaidExpensesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("room_nights")
                        @ExcludeMissing
                        roomNights: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("total_room_tax_amount")
                        @ExcludeMissing
                        totalRoomTaxAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("total_room_tax_currency")
                        @ExcludeMissing
                        totalRoomTaxCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("total_tax_amount")
                        @ExcludeMissing
                        totalTaxAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("total_tax_currency")
                        @ExcludeMissing
                        totalTaxCurrency: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        checkInDate,
                        dailyRoomRateAmount,
                        dailyRoomRateCurrency,
                        extraCharges,
                        folioCashAdvancesAmount,
                        folioCashAdvancesCurrency,
                        foodBeverageChargesAmount,
                        foodBeverageChargesCurrency,
                        noShowIndicator,
                        prepaidExpensesAmount,
                        prepaidExpensesCurrency,
                        roomNights,
                        totalRoomTaxAmount,
                        totalRoomTaxCurrency,
                        totalTaxAmount,
                        totalTaxCurrency,
                        mutableMapOf(),
                    )

                    /**
                     * Date the customer checked in.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun checkInDate(): LocalDate? = checkInDate.getNullable("check_in_date")

                    /**
                     * Daily rate being charged for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRoomRateAmount(): Long? =
                        dailyRoomRateAmount.getNullable("daily_room_rate_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                     * room rate.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRoomRateCurrency(): String? =
                        dailyRoomRateCurrency.getNullable("daily_room_rate_currency")

                    /**
                     * Additional charges (phone, late check-out, etc.) being billed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun extraCharges(): ExtraCharges? = extraCharges.getNullable("extra_charges")

                    /**
                     * Folio cash advances for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun folioCashAdvancesAmount(): Long? =
                        folioCashAdvancesAmount.getNullable("folio_cash_advances_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the folio
                     * cash advances.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun folioCashAdvancesCurrency(): String? =
                        folioCashAdvancesCurrency.getNullable("folio_cash_advances_currency")

                    /**
                     * Food and beverage charges for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun foodBeverageChargesAmount(): Long? =
                        foodBeverageChargesAmount.getNullable("food_beverage_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the food and
                     * beverage charges.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun foodBeverageChargesCurrency(): String? =
                        foodBeverageChargesCurrency.getNullable("food_beverage_charges_currency")

                    /**
                     * Indicator that the cardholder is being billed for a reserved room that was
                     * not actually used.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun noShowIndicator(): NoShowIndicator? =
                        noShowIndicator.getNullable("no_show_indicator")

                    /**
                     * Prepaid expenses being charged for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun prepaidExpensesAmount(): Long? =
                        prepaidExpensesAmount.getNullable("prepaid_expenses_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the prepaid
                     * expenses.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun prepaidExpensesCurrency(): String? =
                        prepaidExpensesCurrency.getNullable("prepaid_expenses_currency")

                    /**
                     * Number of nights the room was rented.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun roomNights(): Long? = roomNights.getNullable("room_nights")

                    /**
                     * Total room tax being charged.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalRoomTaxAmount(): Long? =
                        totalRoomTaxAmount.getNullable("total_room_tax_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total
                     * room tax.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalRoomTaxCurrency(): String? =
                        totalRoomTaxCurrency.getNullable("total_room_tax_currency")

                    /**
                     * Total tax being charged for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalTaxAmount(): Long? = totalTaxAmount.getNullable("total_tax_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total tax
                     * assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalTaxCurrency(): String? =
                        totalTaxCurrency.getNullable("total_tax_currency")

                    /**
                     * Returns the raw JSON value of [checkInDate].
                     *
                     * Unlike [checkInDate], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("check_in_date")
                    @ExcludeMissing
                    fun _checkInDate(): JsonField<LocalDate> = checkInDate

                    /**
                     * Returns the raw JSON value of [dailyRoomRateAmount].
                     *
                     * Unlike [dailyRoomRateAmount], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("daily_room_rate_amount")
                    @ExcludeMissing
                    fun _dailyRoomRateAmount(): JsonField<Long> = dailyRoomRateAmount

                    /**
                     * Returns the raw JSON value of [dailyRoomRateCurrency].
                     *
                     * Unlike [dailyRoomRateCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("daily_room_rate_currency")
                    @ExcludeMissing
                    fun _dailyRoomRateCurrency(): JsonField<String> = dailyRoomRateCurrency

                    /**
                     * Returns the raw JSON value of [extraCharges].
                     *
                     * Unlike [extraCharges], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("extra_charges")
                    @ExcludeMissing
                    fun _extraCharges(): JsonField<ExtraCharges> = extraCharges

                    /**
                     * Returns the raw JSON value of [folioCashAdvancesAmount].
                     *
                     * Unlike [folioCashAdvancesAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("folio_cash_advances_amount")
                    @ExcludeMissing
                    fun _folioCashAdvancesAmount(): JsonField<Long> = folioCashAdvancesAmount

                    /**
                     * Returns the raw JSON value of [folioCashAdvancesCurrency].
                     *
                     * Unlike [folioCashAdvancesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("folio_cash_advances_currency")
                    @ExcludeMissing
                    fun _folioCashAdvancesCurrency(): JsonField<String> = folioCashAdvancesCurrency

                    /**
                     * Returns the raw JSON value of [foodBeverageChargesAmount].
                     *
                     * Unlike [foodBeverageChargesAmount], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("food_beverage_charges_amount")
                    @ExcludeMissing
                    fun _foodBeverageChargesAmount(): JsonField<Long> = foodBeverageChargesAmount

                    /**
                     * Returns the raw JSON value of [foodBeverageChargesCurrency].
                     *
                     * Unlike [foodBeverageChargesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("food_beverage_charges_currency")
                    @ExcludeMissing
                    fun _foodBeverageChargesCurrency(): JsonField<String> =
                        foodBeverageChargesCurrency

                    /**
                     * Returns the raw JSON value of [noShowIndicator].
                     *
                     * Unlike [noShowIndicator], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("no_show_indicator")
                    @ExcludeMissing
                    fun _noShowIndicator(): JsonField<NoShowIndicator> = noShowIndicator

                    /**
                     * Returns the raw JSON value of [prepaidExpensesAmount].
                     *
                     * Unlike [prepaidExpensesAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("prepaid_expenses_amount")
                    @ExcludeMissing
                    fun _prepaidExpensesAmount(): JsonField<Long> = prepaidExpensesAmount

                    /**
                     * Returns the raw JSON value of [prepaidExpensesCurrency].
                     *
                     * Unlike [prepaidExpensesCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("prepaid_expenses_currency")
                    @ExcludeMissing
                    fun _prepaidExpensesCurrency(): JsonField<String> = prepaidExpensesCurrency

                    /**
                     * Returns the raw JSON value of [roomNights].
                     *
                     * Unlike [roomNights], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("room_nights")
                    @ExcludeMissing
                    fun _roomNights(): JsonField<Long> = roomNights

                    /**
                     * Returns the raw JSON value of [totalRoomTaxAmount].
                     *
                     * Unlike [totalRoomTaxAmount], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("total_room_tax_amount")
                    @ExcludeMissing
                    fun _totalRoomTaxAmount(): JsonField<Long> = totalRoomTaxAmount

                    /**
                     * Returns the raw JSON value of [totalRoomTaxCurrency].
                     *
                     * Unlike [totalRoomTaxCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("total_room_tax_currency")
                    @ExcludeMissing
                    fun _totalRoomTaxCurrency(): JsonField<String> = totalRoomTaxCurrency

                    /**
                     * Returns the raw JSON value of [totalTaxAmount].
                     *
                     * Unlike [totalTaxAmount], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("total_tax_amount")
                    @ExcludeMissing
                    fun _totalTaxAmount(): JsonField<Long> = totalTaxAmount

                    /**
                     * Returns the raw JSON value of [totalTaxCurrency].
                     *
                     * Unlike [totalTaxCurrency], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("total_tax_currency")
                    @ExcludeMissing
                    fun _totalTaxCurrency(): JsonField<String> = totalTaxCurrency

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Lodging].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .checkInDate()
                         * .dailyRoomRateAmount()
                         * .dailyRoomRateCurrency()
                         * .extraCharges()
                         * .folioCashAdvancesAmount()
                         * .folioCashAdvancesCurrency()
                         * .foodBeverageChargesAmount()
                         * .foodBeverageChargesCurrency()
                         * .noShowIndicator()
                         * .prepaidExpensesAmount()
                         * .prepaidExpensesCurrency()
                         * .roomNights()
                         * .totalRoomTaxAmount()
                         * .totalRoomTaxCurrency()
                         * .totalTaxAmount()
                         * .totalTaxCurrency()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Lodging]. */
                    class Builder internal constructor() {

                        private var checkInDate: JsonField<LocalDate>? = null
                        private var dailyRoomRateAmount: JsonField<Long>? = null
                        private var dailyRoomRateCurrency: JsonField<String>? = null
                        private var extraCharges: JsonField<ExtraCharges>? = null
                        private var folioCashAdvancesAmount: JsonField<Long>? = null
                        private var folioCashAdvancesCurrency: JsonField<String>? = null
                        private var foodBeverageChargesAmount: JsonField<Long>? = null
                        private var foodBeverageChargesCurrency: JsonField<String>? = null
                        private var noShowIndicator: JsonField<NoShowIndicator>? = null
                        private var prepaidExpensesAmount: JsonField<Long>? = null
                        private var prepaidExpensesCurrency: JsonField<String>? = null
                        private var roomNights: JsonField<Long>? = null
                        private var totalRoomTaxAmount: JsonField<Long>? = null
                        private var totalRoomTaxCurrency: JsonField<String>? = null
                        private var totalTaxAmount: JsonField<Long>? = null
                        private var totalTaxCurrency: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(lodging: Lodging) = apply {
                            checkInDate = lodging.checkInDate
                            dailyRoomRateAmount = lodging.dailyRoomRateAmount
                            dailyRoomRateCurrency = lodging.dailyRoomRateCurrency
                            extraCharges = lodging.extraCharges
                            folioCashAdvancesAmount = lodging.folioCashAdvancesAmount
                            folioCashAdvancesCurrency = lodging.folioCashAdvancesCurrency
                            foodBeverageChargesAmount = lodging.foodBeverageChargesAmount
                            foodBeverageChargesCurrency = lodging.foodBeverageChargesCurrency
                            noShowIndicator = lodging.noShowIndicator
                            prepaidExpensesAmount = lodging.prepaidExpensesAmount
                            prepaidExpensesCurrency = lodging.prepaidExpensesCurrency
                            roomNights = lodging.roomNights
                            totalRoomTaxAmount = lodging.totalRoomTaxAmount
                            totalRoomTaxCurrency = lodging.totalRoomTaxCurrency
                            totalTaxAmount = lodging.totalTaxAmount
                            totalTaxCurrency = lodging.totalTaxCurrency
                            additionalProperties = lodging.additionalProperties.toMutableMap()
                        }

                        /** Date the customer checked in. */
                        fun checkInDate(checkInDate: LocalDate?) =
                            checkInDate(JsonField.ofNullable(checkInDate))

                        /**
                         * Sets [Builder.checkInDate] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.checkInDate] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun checkInDate(checkInDate: JsonField<LocalDate>) = apply {
                            this.checkInDate = checkInDate
                        }

                        /** Daily rate being charged for the room. */
                        fun dailyRoomRateAmount(dailyRoomRateAmount: Long?) =
                            dailyRoomRateAmount(JsonField.ofNullable(dailyRoomRateAmount))

                        /**
                         * Alias for [Builder.dailyRoomRateAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun dailyRoomRateAmount(dailyRoomRateAmount: Long) =
                            dailyRoomRateAmount(dailyRoomRateAmount as Long?)

                        /**
                         * Sets [Builder.dailyRoomRateAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRoomRateAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun dailyRoomRateAmount(dailyRoomRateAmount: JsonField<Long>) = apply {
                            this.dailyRoomRateAmount = dailyRoomRateAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                         * room rate.
                         */
                        fun dailyRoomRateCurrency(dailyRoomRateCurrency: String?) =
                            dailyRoomRateCurrency(JsonField.ofNullable(dailyRoomRateCurrency))

                        /**
                         * Sets [Builder.dailyRoomRateCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRoomRateCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun dailyRoomRateCurrency(dailyRoomRateCurrency: JsonField<String>) =
                            apply {
                                this.dailyRoomRateCurrency = dailyRoomRateCurrency
                            }

                        /** Additional charges (phone, late check-out, etc.) being billed. */
                        fun extraCharges(extraCharges: ExtraCharges?) =
                            extraCharges(JsonField.ofNullable(extraCharges))

                        /**
                         * Sets [Builder.extraCharges] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.extraCharges] with a well-typed
                         * [ExtraCharges] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun extraCharges(extraCharges: JsonField<ExtraCharges>) = apply {
                            this.extraCharges = extraCharges
                        }

                        /** Folio cash advances for the room. */
                        fun folioCashAdvancesAmount(folioCashAdvancesAmount: Long?) =
                            folioCashAdvancesAmount(JsonField.ofNullable(folioCashAdvancesAmount))

                        /**
                         * Alias for [Builder.folioCashAdvancesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun folioCashAdvancesAmount(folioCashAdvancesAmount: Long) =
                            folioCashAdvancesAmount(folioCashAdvancesAmount as Long?)

                        /**
                         * Sets [Builder.folioCashAdvancesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.folioCashAdvancesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun folioCashAdvancesAmount(folioCashAdvancesAmount: JsonField<Long>) =
                            apply {
                                this.folioCashAdvancesAmount = folioCashAdvancesAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the folio
                         * cash advances.
                         */
                        fun folioCashAdvancesCurrency(folioCashAdvancesCurrency: String?) =
                            folioCashAdvancesCurrency(
                                JsonField.ofNullable(folioCashAdvancesCurrency)
                            )

                        /**
                         * Sets [Builder.folioCashAdvancesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.folioCashAdvancesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun folioCashAdvancesCurrency(
                            folioCashAdvancesCurrency: JsonField<String>
                        ) = apply { this.folioCashAdvancesCurrency = folioCashAdvancesCurrency }

                        /** Food and beverage charges for the room. */
                        fun foodBeverageChargesAmount(foodBeverageChargesAmount: Long?) =
                            foodBeverageChargesAmount(
                                JsonField.ofNullable(foodBeverageChargesAmount)
                            )

                        /**
                         * Alias for [Builder.foodBeverageChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun foodBeverageChargesAmount(foodBeverageChargesAmount: Long) =
                            foodBeverageChargesAmount(foodBeverageChargesAmount as Long?)

                        /**
                         * Sets [Builder.foodBeverageChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.foodBeverageChargesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun foodBeverageChargesAmount(foodBeverageChargesAmount: JsonField<Long>) =
                            apply {
                                this.foodBeverageChargesAmount = foodBeverageChargesAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the food
                         * and beverage charges.
                         */
                        fun foodBeverageChargesCurrency(foodBeverageChargesCurrency: String?) =
                            foodBeverageChargesCurrency(
                                JsonField.ofNullable(foodBeverageChargesCurrency)
                            )

                        /**
                         * Sets [Builder.foodBeverageChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.foodBeverageChargesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun foodBeverageChargesCurrency(
                            foodBeverageChargesCurrency: JsonField<String>
                        ) = apply { this.foodBeverageChargesCurrency = foodBeverageChargesCurrency }

                        /**
                         * Indicator that the cardholder is being billed for a reserved room that
                         * was not actually used.
                         */
                        fun noShowIndicator(noShowIndicator: NoShowIndicator?) =
                            noShowIndicator(JsonField.ofNullable(noShowIndicator))

                        /**
                         * Sets [Builder.noShowIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.noShowIndicator] with a well-typed
                         * [NoShowIndicator] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun noShowIndicator(noShowIndicator: JsonField<NoShowIndicator>) = apply {
                            this.noShowIndicator = noShowIndicator
                        }

                        /** Prepaid expenses being charged for the room. */
                        fun prepaidExpensesAmount(prepaidExpensesAmount: Long?) =
                            prepaidExpensesAmount(JsonField.ofNullable(prepaidExpensesAmount))

                        /**
                         * Alias for [Builder.prepaidExpensesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun prepaidExpensesAmount(prepaidExpensesAmount: Long) =
                            prepaidExpensesAmount(prepaidExpensesAmount as Long?)

                        /**
                         * Sets [Builder.prepaidExpensesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.prepaidExpensesAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun prepaidExpensesAmount(prepaidExpensesAmount: JsonField<Long>) = apply {
                            this.prepaidExpensesAmount = prepaidExpensesAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * prepaid expenses.
                         */
                        fun prepaidExpensesCurrency(prepaidExpensesCurrency: String?) =
                            prepaidExpensesCurrency(JsonField.ofNullable(prepaidExpensesCurrency))

                        /**
                         * Sets [Builder.prepaidExpensesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.prepaidExpensesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun prepaidExpensesCurrency(prepaidExpensesCurrency: JsonField<String>) =
                            apply {
                                this.prepaidExpensesCurrency = prepaidExpensesCurrency
                            }

                        /** Number of nights the room was rented. */
                        fun roomNights(roomNights: Long?) =
                            roomNights(JsonField.ofNullable(roomNights))

                        /**
                         * Alias for [Builder.roomNights].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun roomNights(roomNights: Long) = roomNights(roomNights as Long?)

                        /**
                         * Sets [Builder.roomNights] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.roomNights] with a well-typed [Long]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun roomNights(roomNights: JsonField<Long>) = apply {
                            this.roomNights = roomNights
                        }

                        /** Total room tax being charged. */
                        fun totalRoomTaxAmount(totalRoomTaxAmount: Long?) =
                            totalRoomTaxAmount(JsonField.ofNullable(totalRoomTaxAmount))

                        /**
                         * Alias for [Builder.totalRoomTaxAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun totalRoomTaxAmount(totalRoomTaxAmount: Long) =
                            totalRoomTaxAmount(totalRoomTaxAmount as Long?)

                        /**
                         * Sets [Builder.totalRoomTaxAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalRoomTaxAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun totalRoomTaxAmount(totalRoomTaxAmount: JsonField<Long>) = apply {
                            this.totalRoomTaxAmount = totalRoomTaxAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total
                         * room tax.
                         */
                        fun totalRoomTaxCurrency(totalRoomTaxCurrency: String?) =
                            totalRoomTaxCurrency(JsonField.ofNullable(totalRoomTaxCurrency))

                        /**
                         * Sets [Builder.totalRoomTaxCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalRoomTaxCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun totalRoomTaxCurrency(totalRoomTaxCurrency: JsonField<String>) = apply {
                            this.totalRoomTaxCurrency = totalRoomTaxCurrency
                        }

                        /** Total tax being charged for the room. */
                        fun totalTaxAmount(totalTaxAmount: Long?) =
                            totalTaxAmount(JsonField.ofNullable(totalTaxAmount))

                        /**
                         * Alias for [Builder.totalTaxAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun totalTaxAmount(totalTaxAmount: Long) =
                            totalTaxAmount(totalTaxAmount as Long?)

                        /**
                         * Sets [Builder.totalTaxAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalTaxAmount] with a well-typed [Long]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun totalTaxAmount(totalTaxAmount: JsonField<Long>) = apply {
                            this.totalTaxAmount = totalTaxAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total
                         * tax assessed.
                         */
                        fun totalTaxCurrency(totalTaxCurrency: String?) =
                            totalTaxCurrency(JsonField.ofNullable(totalTaxCurrency))

                        /**
                         * Sets [Builder.totalTaxCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalTaxCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun totalTaxCurrency(totalTaxCurrency: JsonField<String>) = apply {
                            this.totalTaxCurrency = totalTaxCurrency
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Lodging].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .checkInDate()
                         * .dailyRoomRateAmount()
                         * .dailyRoomRateCurrency()
                         * .extraCharges()
                         * .folioCashAdvancesAmount()
                         * .folioCashAdvancesCurrency()
                         * .foodBeverageChargesAmount()
                         * .foodBeverageChargesCurrency()
                         * .noShowIndicator()
                         * .prepaidExpensesAmount()
                         * .prepaidExpensesCurrency()
                         * .roomNights()
                         * .totalRoomTaxAmount()
                         * .totalRoomTaxCurrency()
                         * .totalTaxAmount()
                         * .totalTaxCurrency()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Lodging =
                            Lodging(
                                checkRequired("checkInDate", checkInDate),
                                checkRequired("dailyRoomRateAmount", dailyRoomRateAmount),
                                checkRequired("dailyRoomRateCurrency", dailyRoomRateCurrency),
                                checkRequired("extraCharges", extraCharges),
                                checkRequired("folioCashAdvancesAmount", folioCashAdvancesAmount),
                                checkRequired(
                                    "folioCashAdvancesCurrency",
                                    folioCashAdvancesCurrency,
                                ),
                                checkRequired(
                                    "foodBeverageChargesAmount",
                                    foodBeverageChargesAmount,
                                ),
                                checkRequired(
                                    "foodBeverageChargesCurrency",
                                    foodBeverageChargesCurrency,
                                ),
                                checkRequired("noShowIndicator", noShowIndicator),
                                checkRequired("prepaidExpensesAmount", prepaidExpensesAmount),
                                checkRequired("prepaidExpensesCurrency", prepaidExpensesCurrency),
                                checkRequired("roomNights", roomNights),
                                checkRequired("totalRoomTaxAmount", totalRoomTaxAmount),
                                checkRequired("totalRoomTaxCurrency", totalRoomTaxCurrency),
                                checkRequired("totalTaxAmount", totalTaxAmount),
                                checkRequired("totalTaxCurrency", totalTaxCurrency),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Lodging = apply {
                        if (validated) {
                            return@apply
                        }

                        checkInDate()
                        dailyRoomRateAmount()
                        dailyRoomRateCurrency()
                        extraCharges()?.validate()
                        folioCashAdvancesAmount()
                        folioCashAdvancesCurrency()
                        foodBeverageChargesAmount()
                        foodBeverageChargesCurrency()
                        noShowIndicator()?.validate()
                        prepaidExpensesAmount()
                        prepaidExpensesCurrency()
                        roomNights()
                        totalRoomTaxAmount()
                        totalRoomTaxCurrency()
                        totalTaxAmount()
                        totalTaxCurrency()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (checkInDate.asKnown() == null) 0 else 1) +
                            (if (dailyRoomRateAmount.asKnown() == null) 0 else 1) +
                            (if (dailyRoomRateCurrency.asKnown() == null) 0 else 1) +
                            (extraCharges.asKnown()?.validity() ?: 0) +
                            (if (folioCashAdvancesAmount.asKnown() == null) 0 else 1) +
                            (if (folioCashAdvancesCurrency.asKnown() == null) 0 else 1) +
                            (if (foodBeverageChargesAmount.asKnown() == null) 0 else 1) +
                            (if (foodBeverageChargesCurrency.asKnown() == null) 0 else 1) +
                            (noShowIndicator.asKnown()?.validity() ?: 0) +
                            (if (prepaidExpensesAmount.asKnown() == null) 0 else 1) +
                            (if (prepaidExpensesCurrency.asKnown() == null) 0 else 1) +
                            (if (roomNights.asKnown() == null) 0 else 1) +
                            (if (totalRoomTaxAmount.asKnown() == null) 0 else 1) +
                            (if (totalRoomTaxCurrency.asKnown() == null) 0 else 1) +
                            (if (totalTaxAmount.asKnown() == null) 0 else 1) +
                            (if (totalTaxCurrency.asKnown() == null) 0 else 1)

                    /** Additional charges (phone, late check-out, etc.) being billed. */
                    class ExtraCharges
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No extra charge */
                            val NO_EXTRA_CHARGE = of("no_extra_charge")

                            /** Restaurant */
                            val RESTAURANT = of("restaurant")

                            /** Gift shop */
                            val GIFT_SHOP = of("gift_shop")

                            /** Mini bar */
                            val MINI_BAR = of("mini_bar")

                            /** Telephone */
                            val TELEPHONE = of("telephone")

                            /** Other */
                            val OTHER = of("other")

                            /** Laundry */
                            val LAUNDRY = of("laundry")

                            fun of(value: String) = ExtraCharges(JsonField.of(value))
                        }

                        /** An enum containing [ExtraCharges]'s known values. */
                        enum class Known {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Restaurant */
                            RESTAURANT,
                            /** Gift shop */
                            GIFT_SHOP,
                            /** Mini bar */
                            MINI_BAR,
                            /** Telephone */
                            TELEPHONE,
                            /** Other */
                            OTHER,
                            /** Laundry */
                            LAUNDRY,
                        }

                        /**
                         * An enum containing [ExtraCharges]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ExtraCharges] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Restaurant */
                            RESTAURANT,
                            /** Gift shop */
                            GIFT_SHOP,
                            /** Mini bar */
                            MINI_BAR,
                            /** Telephone */
                            TELEPHONE,
                            /** Other */
                            OTHER,
                            /** Laundry */
                            LAUNDRY,
                            /**
                             * An enum member indicating that [ExtraCharges] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_EXTRA_CHARGE -> Value.NO_EXTRA_CHARGE
                                RESTAURANT -> Value.RESTAURANT
                                GIFT_SHOP -> Value.GIFT_SHOP
                                MINI_BAR -> Value.MINI_BAR
                                TELEPHONE -> Value.TELEPHONE
                                OTHER -> Value.OTHER
                                LAUNDRY -> Value.LAUNDRY
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_EXTRA_CHARGE -> Known.NO_EXTRA_CHARGE
                                RESTAURANT -> Known.RESTAURANT
                                GIFT_SHOP -> Known.GIFT_SHOP
                                MINI_BAR -> Known.MINI_BAR
                                TELEPHONE -> Known.TELEPHONE
                                OTHER -> Known.OTHER
                                LAUNDRY -> Known.LAUNDRY
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ExtraCharges: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ExtraCharges = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ExtraCharges && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Indicator that the cardholder is being billed for a reserved room that was
                     * not actually used.
                     */
                    class NoShowIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not applicable */
                            val NOT_APPLICABLE = of("not_applicable")

                            /** No show */
                            val NO_SHOW = of("no_show")

                            fun of(value: String) = NoShowIndicator(JsonField.of(value))
                        }

                        /** An enum containing [NoShowIndicator]'s known values. */
                        enum class Known {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show */
                            NO_SHOW,
                        }

                        /**
                         * An enum containing [NoShowIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [NoShowIndicator] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show */
                            NO_SHOW,
                            /**
                             * An enum member indicating that [NoShowIndicator] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_APPLICABLE -> Value.NOT_APPLICABLE
                                NO_SHOW -> Value.NO_SHOW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_APPLICABLE -> Known.NOT_APPLICABLE
                                NO_SHOW -> Known.NO_SHOW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown NoShowIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): NoShowIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is NoShowIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Lodging &&
                            checkInDate == other.checkInDate &&
                            dailyRoomRateAmount == other.dailyRoomRateAmount &&
                            dailyRoomRateCurrency == other.dailyRoomRateCurrency &&
                            extraCharges == other.extraCharges &&
                            folioCashAdvancesAmount == other.folioCashAdvancesAmount &&
                            folioCashAdvancesCurrency == other.folioCashAdvancesCurrency &&
                            foodBeverageChargesAmount == other.foodBeverageChargesAmount &&
                            foodBeverageChargesCurrency == other.foodBeverageChargesCurrency &&
                            noShowIndicator == other.noShowIndicator &&
                            prepaidExpensesAmount == other.prepaidExpensesAmount &&
                            prepaidExpensesCurrency == other.prepaidExpensesCurrency &&
                            roomNights == other.roomNights &&
                            totalRoomTaxAmount == other.totalRoomTaxAmount &&
                            totalRoomTaxCurrency == other.totalRoomTaxCurrency &&
                            totalTaxAmount == other.totalTaxAmount &&
                            totalTaxCurrency == other.totalTaxCurrency &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            checkInDate,
                            dailyRoomRateAmount,
                            dailyRoomRateCurrency,
                            extraCharges,
                            folioCashAdvancesAmount,
                            folioCashAdvancesCurrency,
                            foodBeverageChargesAmount,
                            foodBeverageChargesCurrency,
                            noShowIndicator,
                            prepaidExpensesAmount,
                            prepaidExpensesCurrency,
                            roomNights,
                            totalRoomTaxAmount,
                            totalRoomTaxCurrency,
                            totalTaxAmount,
                            totalTaxCurrency,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Lodging{checkInDate=$checkInDate, dailyRoomRateAmount=$dailyRoomRateAmount, dailyRoomRateCurrency=$dailyRoomRateCurrency, extraCharges=$extraCharges, folioCashAdvancesAmount=$folioCashAdvancesAmount, folioCashAdvancesCurrency=$folioCashAdvancesCurrency, foodBeverageChargesAmount=$foodBeverageChargesAmount, foodBeverageChargesCurrency=$foodBeverageChargesCurrency, noShowIndicator=$noShowIndicator, prepaidExpensesAmount=$prepaidExpensesAmount, prepaidExpensesCurrency=$prepaidExpensesCurrency, roomNights=$roomNights, totalRoomTaxAmount=$totalRoomTaxAmount, totalRoomTaxCurrency=$totalRoomTaxCurrency, totalTaxAmount=$totalTaxAmount, totalTaxCurrency=$totalTaxCurrency, additionalProperties=$additionalProperties}"
                }

                /** The format of the purchase identifier. */
                class PurchaseIdentifierFormat
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Free text */
                        val FREE_TEXT = of("free_text")

                        /** Order number */
                        val ORDER_NUMBER = of("order_number")

                        /** Rental agreement number */
                        val RENTAL_AGREEMENT_NUMBER = of("rental_agreement_number")

                        /** Hotel folio number */
                        val HOTEL_FOLIO_NUMBER = of("hotel_folio_number")

                        /** Invoice number */
                        val INVOICE_NUMBER = of("invoice_number")

                        fun of(value: String) = PurchaseIdentifierFormat(JsonField.of(value))
                    }

                    /** An enum containing [PurchaseIdentifierFormat]'s known values. */
                    enum class Known {
                        /** Free text */
                        FREE_TEXT,
                        /** Order number */
                        ORDER_NUMBER,
                        /** Rental agreement number */
                        RENTAL_AGREEMENT_NUMBER,
                        /** Hotel folio number */
                        HOTEL_FOLIO_NUMBER,
                        /** Invoice number */
                        INVOICE_NUMBER,
                    }

                    /**
                     * An enum containing [PurchaseIdentifierFormat]'s known values, as well as an
                     * [_UNKNOWN] member.
                     *
                     * An instance of [PurchaseIdentifierFormat] can contain an unknown value in a
                     * couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Free text */
                        FREE_TEXT,
                        /** Order number */
                        ORDER_NUMBER,
                        /** Rental agreement number */
                        RENTAL_AGREEMENT_NUMBER,
                        /** Hotel folio number */
                        HOTEL_FOLIO_NUMBER,
                        /** Invoice number */
                        INVOICE_NUMBER,
                        /**
                         * An enum member indicating that [PurchaseIdentifierFormat] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            FREE_TEXT -> Value.FREE_TEXT
                            ORDER_NUMBER -> Value.ORDER_NUMBER
                            RENTAL_AGREEMENT_NUMBER -> Value.RENTAL_AGREEMENT_NUMBER
                            HOTEL_FOLIO_NUMBER -> Value.HOTEL_FOLIO_NUMBER
                            INVOICE_NUMBER -> Value.INVOICE_NUMBER
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            FREE_TEXT -> Known.FREE_TEXT
                            ORDER_NUMBER -> Known.ORDER_NUMBER
                            RENTAL_AGREEMENT_NUMBER -> Known.RENTAL_AGREEMENT_NUMBER
                            HOTEL_FOLIO_NUMBER -> Known.HOTEL_FOLIO_NUMBER
                            INVOICE_NUMBER -> Known.INVOICE_NUMBER
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown PurchaseIdentifierFormat: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): PurchaseIdentifierFormat = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PurchaseIdentifierFormat && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Fields specific to travel. */
                class Travel
                private constructor(
                    private val ancillary: JsonField<Ancillary>,
                    private val computerizedReservationSystem: JsonField<String>,
                    private val creditReasonIndicator: JsonField<CreditReasonIndicator>,
                    private val departureDate: JsonField<LocalDate>,
                    private val originationCityAirportCode: JsonField<String>,
                    private val passengerName: JsonField<String>,
                    private val restrictedTicketIndicator: JsonField<RestrictedTicketIndicator>,
                    private val ticketChangeIndicator: JsonField<TicketChangeIndicator>,
                    private val ticketNumber: JsonField<String>,
                    private val travelAgencyCode: JsonField<String>,
                    private val travelAgencyName: JsonField<String>,
                    private val tripLegs: JsonField<List<TripLeg>>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("ancillary")
                        @ExcludeMissing
                        ancillary: JsonField<Ancillary> = JsonMissing.of(),
                        @JsonProperty("computerized_reservation_system")
                        @ExcludeMissing
                        computerizedReservationSystem: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("credit_reason_indicator")
                        @ExcludeMissing
                        creditReasonIndicator: JsonField<CreditReasonIndicator> = JsonMissing.of(),
                        @JsonProperty("departure_date")
                        @ExcludeMissing
                        departureDate: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("origination_city_airport_code")
                        @ExcludeMissing
                        originationCityAirportCode: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("passenger_name")
                        @ExcludeMissing
                        passengerName: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("restricted_ticket_indicator")
                        @ExcludeMissing
                        restrictedTicketIndicator: JsonField<RestrictedTicketIndicator> =
                            JsonMissing.of(),
                        @JsonProperty("ticket_change_indicator")
                        @ExcludeMissing
                        ticketChangeIndicator: JsonField<TicketChangeIndicator> = JsonMissing.of(),
                        @JsonProperty("ticket_number")
                        @ExcludeMissing
                        ticketNumber: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("travel_agency_code")
                        @ExcludeMissing
                        travelAgencyCode: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("travel_agency_name")
                        @ExcludeMissing
                        travelAgencyName: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("trip_legs")
                        @ExcludeMissing
                        tripLegs: JsonField<List<TripLeg>> = JsonMissing.of(),
                    ) : this(
                        ancillary,
                        computerizedReservationSystem,
                        creditReasonIndicator,
                        departureDate,
                        originationCityAirportCode,
                        passengerName,
                        restrictedTicketIndicator,
                        ticketChangeIndicator,
                        ticketNumber,
                        travelAgencyCode,
                        travelAgencyName,
                        tripLegs,
                        mutableMapOf(),
                    )

                    /**
                     * Ancillary purchases in addition to the airfare.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ancillary(): Ancillary? = ancillary.getNullable("ancillary")

                    /**
                     * Indicates the computerized reservation system used to book the ticket.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun computerizedReservationSystem(): String? =
                        computerizedReservationSystem.getNullable("computerized_reservation_system")

                    /**
                     * Indicates the reason for a credit to the cardholder.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun creditReasonIndicator(): CreditReasonIndicator? =
                        creditReasonIndicator.getNullable("credit_reason_indicator")

                    /**
                     * Date of departure.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun departureDate(): LocalDate? = departureDate.getNullable("departure_date")

                    /**
                     * Code for the originating city or airport.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun originationCityAirportCode(): String? =
                        originationCityAirportCode.getNullable("origination_city_airport_code")

                    /**
                     * Name of the passenger.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun passengerName(): String? = passengerName.getNullable("passenger_name")

                    /**
                     * Indicates whether this ticket is non-refundable.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun restrictedTicketIndicator(): RestrictedTicketIndicator? =
                        restrictedTicketIndicator.getNullable("restricted_ticket_indicator")

                    /**
                     * Indicates why a ticket was changed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ticketChangeIndicator(): TicketChangeIndicator? =
                        ticketChangeIndicator.getNullable("ticket_change_indicator")

                    /**
                     * Ticket number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ticketNumber(): String? = ticketNumber.getNullable("ticket_number")

                    /**
                     * Code for the travel agency if the ticket was issued by a travel agency.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun travelAgencyCode(): String? =
                        travelAgencyCode.getNullable("travel_agency_code")

                    /**
                     * Name of the travel agency if the ticket was issued by a travel agency.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun travelAgencyName(): String? =
                        travelAgencyName.getNullable("travel_agency_name")

                    /**
                     * Fields specific to each leg of the journey.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun tripLegs(): List<TripLeg>? = tripLegs.getNullable("trip_legs")

                    /**
                     * Returns the raw JSON value of [ancillary].
                     *
                     * Unlike [ancillary], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("ancillary")
                    @ExcludeMissing
                    fun _ancillary(): JsonField<Ancillary> = ancillary

                    /**
                     * Returns the raw JSON value of [computerizedReservationSystem].
                     *
                     * Unlike [computerizedReservationSystem], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("computerized_reservation_system")
                    @ExcludeMissing
                    fun _computerizedReservationSystem(): JsonField<String> =
                        computerizedReservationSystem

                    /**
                     * Returns the raw JSON value of [creditReasonIndicator].
                     *
                     * Unlike [creditReasonIndicator], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("credit_reason_indicator")
                    @ExcludeMissing
                    fun _creditReasonIndicator(): JsonField<CreditReasonIndicator> =
                        creditReasonIndicator

                    /**
                     * Returns the raw JSON value of [departureDate].
                     *
                     * Unlike [departureDate], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("departure_date")
                    @ExcludeMissing
                    fun _departureDate(): JsonField<LocalDate> = departureDate

                    /**
                     * Returns the raw JSON value of [originationCityAirportCode].
                     *
                     * Unlike [originationCityAirportCode], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("origination_city_airport_code")
                    @ExcludeMissing
                    fun _originationCityAirportCode(): JsonField<String> =
                        originationCityAirportCode

                    /**
                     * Returns the raw JSON value of [passengerName].
                     *
                     * Unlike [passengerName], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("passenger_name")
                    @ExcludeMissing
                    fun _passengerName(): JsonField<String> = passengerName

                    /**
                     * Returns the raw JSON value of [restrictedTicketIndicator].
                     *
                     * Unlike [restrictedTicketIndicator], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("restricted_ticket_indicator")
                    @ExcludeMissing
                    fun _restrictedTicketIndicator(): JsonField<RestrictedTicketIndicator> =
                        restrictedTicketIndicator

                    /**
                     * Returns the raw JSON value of [ticketChangeIndicator].
                     *
                     * Unlike [ticketChangeIndicator], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("ticket_change_indicator")
                    @ExcludeMissing
                    fun _ticketChangeIndicator(): JsonField<TicketChangeIndicator> =
                        ticketChangeIndicator

                    /**
                     * Returns the raw JSON value of [ticketNumber].
                     *
                     * Unlike [ticketNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("ticket_number")
                    @ExcludeMissing
                    fun _ticketNumber(): JsonField<String> = ticketNumber

                    /**
                     * Returns the raw JSON value of [travelAgencyCode].
                     *
                     * Unlike [travelAgencyCode], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("travel_agency_code")
                    @ExcludeMissing
                    fun _travelAgencyCode(): JsonField<String> = travelAgencyCode

                    /**
                     * Returns the raw JSON value of [travelAgencyName].
                     *
                     * Unlike [travelAgencyName], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("travel_agency_name")
                    @ExcludeMissing
                    fun _travelAgencyName(): JsonField<String> = travelAgencyName

                    /**
                     * Returns the raw JSON value of [tripLegs].
                     *
                     * Unlike [tripLegs], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("trip_legs")
                    @ExcludeMissing
                    fun _tripLegs(): JsonField<List<TripLeg>> = tripLegs

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Travel].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .ancillary()
                         * .computerizedReservationSystem()
                         * .creditReasonIndicator()
                         * .departureDate()
                         * .originationCityAirportCode()
                         * .passengerName()
                         * .restrictedTicketIndicator()
                         * .ticketChangeIndicator()
                         * .ticketNumber()
                         * .travelAgencyCode()
                         * .travelAgencyName()
                         * .tripLegs()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Travel]. */
                    class Builder internal constructor() {

                        private var ancillary: JsonField<Ancillary>? = null
                        private var computerizedReservationSystem: JsonField<String>? = null
                        private var creditReasonIndicator: JsonField<CreditReasonIndicator>? = null
                        private var departureDate: JsonField<LocalDate>? = null
                        private var originationCityAirportCode: JsonField<String>? = null
                        private var passengerName: JsonField<String>? = null
                        private var restrictedTicketIndicator:
                            JsonField<RestrictedTicketIndicator>? =
                            null
                        private var ticketChangeIndicator: JsonField<TicketChangeIndicator>? = null
                        private var ticketNumber: JsonField<String>? = null
                        private var travelAgencyCode: JsonField<String>? = null
                        private var travelAgencyName: JsonField<String>? = null
                        private var tripLegs: JsonField<MutableList<TripLeg>>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(travel: Travel) = apply {
                            ancillary = travel.ancillary
                            computerizedReservationSystem = travel.computerizedReservationSystem
                            creditReasonIndicator = travel.creditReasonIndicator
                            departureDate = travel.departureDate
                            originationCityAirportCode = travel.originationCityAirportCode
                            passengerName = travel.passengerName
                            restrictedTicketIndicator = travel.restrictedTicketIndicator
                            ticketChangeIndicator = travel.ticketChangeIndicator
                            ticketNumber = travel.ticketNumber
                            travelAgencyCode = travel.travelAgencyCode
                            travelAgencyName = travel.travelAgencyName
                            tripLegs = travel.tripLegs.map { it.toMutableList() }
                            additionalProperties = travel.additionalProperties.toMutableMap()
                        }

                        /** Ancillary purchases in addition to the airfare. */
                        fun ancillary(ancillary: Ancillary?) =
                            ancillary(JsonField.ofNullable(ancillary))

                        /**
                         * Sets [Builder.ancillary] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ancillary] with a well-typed [Ancillary]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun ancillary(ancillary: JsonField<Ancillary>) = apply {
                            this.ancillary = ancillary
                        }

                        /**
                         * Indicates the computerized reservation system used to book the ticket.
                         */
                        fun computerizedReservationSystem(computerizedReservationSystem: String?) =
                            computerizedReservationSystem(
                                JsonField.ofNullable(computerizedReservationSystem)
                            )

                        /**
                         * Sets [Builder.computerizedReservationSystem] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.computerizedReservationSystem] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun computerizedReservationSystem(
                            computerizedReservationSystem: JsonField<String>
                        ) = apply {
                            this.computerizedReservationSystem = computerizedReservationSystem
                        }

                        /** Indicates the reason for a credit to the cardholder. */
                        fun creditReasonIndicator(creditReasonIndicator: CreditReasonIndicator?) =
                            creditReasonIndicator(JsonField.ofNullable(creditReasonIndicator))

                        /**
                         * Sets [Builder.creditReasonIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.creditReasonIndicator] with a well-typed
                         * [CreditReasonIndicator] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun creditReasonIndicator(
                            creditReasonIndicator: JsonField<CreditReasonIndicator>
                        ) = apply { this.creditReasonIndicator = creditReasonIndicator }

                        /** Date of departure. */
                        fun departureDate(departureDate: LocalDate?) =
                            departureDate(JsonField.ofNullable(departureDate))

                        /**
                         * Sets [Builder.departureDate] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.departureDate] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun departureDate(departureDate: JsonField<LocalDate>) = apply {
                            this.departureDate = departureDate
                        }

                        /** Code for the originating city or airport. */
                        fun originationCityAirportCode(originationCityAirportCode: String?) =
                            originationCityAirportCode(
                                JsonField.ofNullable(originationCityAirportCode)
                            )

                        /**
                         * Sets [Builder.originationCityAirportCode] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.originationCityAirportCode] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun originationCityAirportCode(
                            originationCityAirportCode: JsonField<String>
                        ) = apply { this.originationCityAirportCode = originationCityAirportCode }

                        /** Name of the passenger. */
                        fun passengerName(passengerName: String?) =
                            passengerName(JsonField.ofNullable(passengerName))

                        /**
                         * Sets [Builder.passengerName] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.passengerName] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun passengerName(passengerName: JsonField<String>) = apply {
                            this.passengerName = passengerName
                        }

                        /** Indicates whether this ticket is non-refundable. */
                        fun restrictedTicketIndicator(
                            restrictedTicketIndicator: RestrictedTicketIndicator?
                        ) =
                            restrictedTicketIndicator(
                                JsonField.ofNullable(restrictedTicketIndicator)
                            )

                        /**
                         * Sets [Builder.restrictedTicketIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.restrictedTicketIndicator] with a
                         * well-typed [RestrictedTicketIndicator] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun restrictedTicketIndicator(
                            restrictedTicketIndicator: JsonField<RestrictedTicketIndicator>
                        ) = apply { this.restrictedTicketIndicator = restrictedTicketIndicator }

                        /** Indicates why a ticket was changed. */
                        fun ticketChangeIndicator(ticketChangeIndicator: TicketChangeIndicator?) =
                            ticketChangeIndicator(JsonField.ofNullable(ticketChangeIndicator))

                        /**
                         * Sets [Builder.ticketChangeIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ticketChangeIndicator] with a well-typed
                         * [TicketChangeIndicator] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun ticketChangeIndicator(
                            ticketChangeIndicator: JsonField<TicketChangeIndicator>
                        ) = apply { this.ticketChangeIndicator = ticketChangeIndicator }

                        /** Ticket number. */
                        fun ticketNumber(ticketNumber: String?) =
                            ticketNumber(JsonField.ofNullable(ticketNumber))

                        /**
                         * Sets [Builder.ticketNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ticketNumber] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun ticketNumber(ticketNumber: JsonField<String>) = apply {
                            this.ticketNumber = ticketNumber
                        }

                        /**
                         * Code for the travel agency if the ticket was issued by a travel agency.
                         */
                        fun travelAgencyCode(travelAgencyCode: String?) =
                            travelAgencyCode(JsonField.ofNullable(travelAgencyCode))

                        /**
                         * Sets [Builder.travelAgencyCode] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.travelAgencyCode] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun travelAgencyCode(travelAgencyCode: JsonField<String>) = apply {
                            this.travelAgencyCode = travelAgencyCode
                        }

                        /**
                         * Name of the travel agency if the ticket was issued by a travel agency.
                         */
                        fun travelAgencyName(travelAgencyName: String?) =
                            travelAgencyName(JsonField.ofNullable(travelAgencyName))

                        /**
                         * Sets [Builder.travelAgencyName] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.travelAgencyName] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun travelAgencyName(travelAgencyName: JsonField<String>) = apply {
                            this.travelAgencyName = travelAgencyName
                        }

                        /** Fields specific to each leg of the journey. */
                        fun tripLegs(tripLegs: List<TripLeg>?) =
                            tripLegs(JsonField.ofNullable(tripLegs))

                        /**
                         * Sets [Builder.tripLegs] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.tripLegs] with a well-typed
                         * `List<TripLeg>` value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun tripLegs(tripLegs: JsonField<List<TripLeg>>) = apply {
                            this.tripLegs = tripLegs.map { it.toMutableList() }
                        }

                        /**
                         * Adds a single [TripLeg] to [tripLegs].
                         *
                         * @throws IllegalStateException if the field was previously set to a
                         *   non-list.
                         */
                        fun addTripLeg(tripLeg: TripLeg) = apply {
                            tripLegs =
                                (tripLegs ?: JsonField.of(mutableListOf())).also {
                                    checkKnown("tripLegs", it).add(tripLeg)
                                }
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Travel].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .ancillary()
                         * .computerizedReservationSystem()
                         * .creditReasonIndicator()
                         * .departureDate()
                         * .originationCityAirportCode()
                         * .passengerName()
                         * .restrictedTicketIndicator()
                         * .ticketChangeIndicator()
                         * .ticketNumber()
                         * .travelAgencyCode()
                         * .travelAgencyName()
                         * .tripLegs()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Travel =
                            Travel(
                                checkRequired("ancillary", ancillary),
                                checkRequired(
                                    "computerizedReservationSystem",
                                    computerizedReservationSystem,
                                ),
                                checkRequired("creditReasonIndicator", creditReasonIndicator),
                                checkRequired("departureDate", departureDate),
                                checkRequired(
                                    "originationCityAirportCode",
                                    originationCityAirportCode,
                                ),
                                checkRequired("passengerName", passengerName),
                                checkRequired(
                                    "restrictedTicketIndicator",
                                    restrictedTicketIndicator,
                                ),
                                checkRequired("ticketChangeIndicator", ticketChangeIndicator),
                                checkRequired("ticketNumber", ticketNumber),
                                checkRequired("travelAgencyCode", travelAgencyCode),
                                checkRequired("travelAgencyName", travelAgencyName),
                                checkRequired("tripLegs", tripLegs).map { it.toImmutable() },
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Travel = apply {
                        if (validated) {
                            return@apply
                        }

                        ancillary()?.validate()
                        computerizedReservationSystem()
                        creditReasonIndicator()?.validate()
                        departureDate()
                        originationCityAirportCode()
                        passengerName()
                        restrictedTicketIndicator()?.validate()
                        ticketChangeIndicator()?.validate()
                        ticketNumber()
                        travelAgencyCode()
                        travelAgencyName()
                        tripLegs()?.forEach { it.validate() }
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (ancillary.asKnown()?.validity() ?: 0) +
                            (if (computerizedReservationSystem.asKnown() == null) 0 else 1) +
                            (creditReasonIndicator.asKnown()?.validity() ?: 0) +
                            (if (departureDate.asKnown() == null) 0 else 1) +
                            (if (originationCityAirportCode.asKnown() == null) 0 else 1) +
                            (if (passengerName.asKnown() == null) 0 else 1) +
                            (restrictedTicketIndicator.asKnown()?.validity() ?: 0) +
                            (ticketChangeIndicator.asKnown()?.validity() ?: 0) +
                            (if (ticketNumber.asKnown() == null) 0 else 1) +
                            (if (travelAgencyCode.asKnown() == null) 0 else 1) +
                            (if (travelAgencyName.asKnown() == null) 0 else 1) +
                            (tripLegs.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

                    /** Ancillary purchases in addition to the airfare. */
                    class Ancillary
                    private constructor(
                        private val connectedTicketDocumentNumber: JsonField<String>,
                        private val creditReasonIndicator: JsonField<CreditReasonIndicator>,
                        private val passengerNameOrDescription: JsonField<String>,
                        private val services: JsonField<List<Service>>,
                        private val ticketDocumentNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("connected_ticket_document_number")
                            @ExcludeMissing
                            connectedTicketDocumentNumber: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("credit_reason_indicator")
                            @ExcludeMissing
                            creditReasonIndicator: JsonField<CreditReasonIndicator> =
                                JsonMissing.of(),
                            @JsonProperty("passenger_name_or_description")
                            @ExcludeMissing
                            passengerNameOrDescription: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("services")
                            @ExcludeMissing
                            services: JsonField<List<Service>> = JsonMissing.of(),
                            @JsonProperty("ticket_document_number")
                            @ExcludeMissing
                            ticketDocumentNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            connectedTicketDocumentNumber,
                            creditReasonIndicator,
                            passengerNameOrDescription,
                            services,
                            ticketDocumentNumber,
                            mutableMapOf(),
                        )

                        /**
                         * If this purchase has a connection or relationship to another purchase,
                         * such as a baggage fee for a passenger transport ticket, this field should
                         * contain the ticket document number for the other purchase.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun connectedTicketDocumentNumber(): String? =
                            connectedTicketDocumentNumber.getNullable(
                                "connected_ticket_document_number"
                            )

                        /**
                         * Indicates the reason for a credit to the cardholder.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun creditReasonIndicator(): CreditReasonIndicator? =
                            creditReasonIndicator.getNullable("credit_reason_indicator")

                        /**
                         * Name of the passenger or description of the ancillary purchase.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun passengerNameOrDescription(): String? =
                            passengerNameOrDescription.getNullable("passenger_name_or_description")

                        /**
                         * Additional travel charges, such as baggage fees.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun services(): List<Service> = services.getRequired("services")

                        /**
                         * Ticket document number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun ticketDocumentNumber(): String? =
                            ticketDocumentNumber.getNullable("ticket_document_number")

                        /**
                         * Returns the raw JSON value of [connectedTicketDocumentNumber].
                         *
                         * Unlike [connectedTicketDocumentNumber], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("connected_ticket_document_number")
                        @ExcludeMissing
                        fun _connectedTicketDocumentNumber(): JsonField<String> =
                            connectedTicketDocumentNumber

                        /**
                         * Returns the raw JSON value of [creditReasonIndicator].
                         *
                         * Unlike [creditReasonIndicator], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("credit_reason_indicator")
                        @ExcludeMissing
                        fun _creditReasonIndicator(): JsonField<CreditReasonIndicator> =
                            creditReasonIndicator

                        /**
                         * Returns the raw JSON value of [passengerNameOrDescription].
                         *
                         * Unlike [passengerNameOrDescription], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("passenger_name_or_description")
                        @ExcludeMissing
                        fun _passengerNameOrDescription(): JsonField<String> =
                            passengerNameOrDescription

                        /**
                         * Returns the raw JSON value of [services].
                         *
                         * Unlike [services], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("services")
                        @ExcludeMissing
                        fun _services(): JsonField<List<Service>> = services

                        /**
                         * Returns the raw JSON value of [ticketDocumentNumber].
                         *
                         * Unlike [ticketDocumentNumber], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("ticket_document_number")
                        @ExcludeMissing
                        fun _ticketDocumentNumber(): JsonField<String> = ticketDocumentNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [Ancillary].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .connectedTicketDocumentNumber()
                             * .creditReasonIndicator()
                             * .passengerNameOrDescription()
                             * .services()
                             * .ticketDocumentNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Ancillary]. */
                        class Builder internal constructor() {

                            private var connectedTicketDocumentNumber: JsonField<String>? = null
                            private var creditReasonIndicator: JsonField<CreditReasonIndicator>? =
                                null
                            private var passengerNameOrDescription: JsonField<String>? = null
                            private var services: JsonField<MutableList<Service>>? = null
                            private var ticketDocumentNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(ancillary: Ancillary) = apply {
                                connectedTicketDocumentNumber =
                                    ancillary.connectedTicketDocumentNumber
                                creditReasonIndicator = ancillary.creditReasonIndicator
                                passengerNameOrDescription = ancillary.passengerNameOrDescription
                                services = ancillary.services.map { it.toMutableList() }
                                ticketDocumentNumber = ancillary.ticketDocumentNumber
                                additionalProperties = ancillary.additionalProperties.toMutableMap()
                            }

                            /**
                             * If this purchase has a connection or relationship to another
                             * purchase, such as a baggage fee for a passenger transport ticket,
                             * this field should contain the ticket document number for the other
                             * purchase.
                             */
                            fun connectedTicketDocumentNumber(
                                connectedTicketDocumentNumber: String?
                            ) =
                                connectedTicketDocumentNumber(
                                    JsonField.ofNullable(connectedTicketDocumentNumber)
                                )

                            /**
                             * Sets [Builder.connectedTicketDocumentNumber] to an arbitrary JSON
                             * value.
                             *
                             * You should usually call [Builder.connectedTicketDocumentNumber] with
                             * a well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun connectedTicketDocumentNumber(
                                connectedTicketDocumentNumber: JsonField<String>
                            ) = apply {
                                this.connectedTicketDocumentNumber = connectedTicketDocumentNumber
                            }

                            /** Indicates the reason for a credit to the cardholder. */
                            fun creditReasonIndicator(
                                creditReasonIndicator: CreditReasonIndicator?
                            ) = creditReasonIndicator(JsonField.ofNullable(creditReasonIndicator))

                            /**
                             * Sets [Builder.creditReasonIndicator] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.creditReasonIndicator] with a
                             * well-typed [CreditReasonIndicator] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun creditReasonIndicator(
                                creditReasonIndicator: JsonField<CreditReasonIndicator>
                            ) = apply { this.creditReasonIndicator = creditReasonIndicator }

                            /** Name of the passenger or description of the ancillary purchase. */
                            fun passengerNameOrDescription(passengerNameOrDescription: String?) =
                                passengerNameOrDescription(
                                    JsonField.ofNullable(passengerNameOrDescription)
                                )

                            /**
                             * Sets [Builder.passengerNameOrDescription] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.passengerNameOrDescription] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun passengerNameOrDescription(
                                passengerNameOrDescription: JsonField<String>
                            ) = apply {
                                this.passengerNameOrDescription = passengerNameOrDescription
                            }

                            /** Additional travel charges, such as baggage fees. */
                            fun services(services: List<Service>) = services(JsonField.of(services))

                            /**
                             * Sets [Builder.services] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.services] with a well-typed
                             * `List<Service>` value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun services(services: JsonField<List<Service>>) = apply {
                                this.services = services.map { it.toMutableList() }
                            }

                            /**
                             * Adds a single [Service] to [services].
                             *
                             * @throws IllegalStateException if the field was previously set to a
                             *   non-list.
                             */
                            fun addService(service: Service) = apply {
                                services =
                                    (services ?: JsonField.of(mutableListOf())).also {
                                        checkKnown("services", it).add(service)
                                    }
                            }

                            /** Ticket document number. */
                            fun ticketDocumentNumber(ticketDocumentNumber: String?) =
                                ticketDocumentNumber(JsonField.ofNullable(ticketDocumentNumber))

                            /**
                             * Sets [Builder.ticketDocumentNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.ticketDocumentNumber] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun ticketDocumentNumber(ticketDocumentNumber: JsonField<String>) =
                                apply {
                                    this.ticketDocumentNumber = ticketDocumentNumber
                                }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Ancillary].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .connectedTicketDocumentNumber()
                             * .creditReasonIndicator()
                             * .passengerNameOrDescription()
                             * .services()
                             * .ticketDocumentNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Ancillary =
                                Ancillary(
                                    checkRequired(
                                        "connectedTicketDocumentNumber",
                                        connectedTicketDocumentNumber,
                                    ),
                                    checkRequired("creditReasonIndicator", creditReasonIndicator),
                                    checkRequired(
                                        "passengerNameOrDescription",
                                        passengerNameOrDescription,
                                    ),
                                    checkRequired("services", services).map { it.toImmutable() },
                                    checkRequired("ticketDocumentNumber", ticketDocumentNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Ancillary = apply {
                            if (validated) {
                                return@apply
                            }

                            connectedTicketDocumentNumber()
                            creditReasonIndicator()?.validate()
                            passengerNameOrDescription()
                            services().forEach { it.validate() }
                            ticketDocumentNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (connectedTicketDocumentNumber.asKnown() == null) 0 else 1) +
                                (creditReasonIndicator.asKnown()?.validity() ?: 0) +
                                (if (passengerNameOrDescription.asKnown() == null) 0 else 1) +
                                (services.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                                (if (ticketDocumentNumber.asKnown() == null) 0 else 1)

                        /** Indicates the reason for a credit to the cardholder. */
                        class CreditReasonIndicator
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** No credit */
                                val NO_CREDIT = of("no_credit")

                                /** Passenger transport ancillary purchase cancellation */
                                val PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                    of("passenger_transport_ancillary_purchase_cancellation")

                                /**
                                 * Airline ticket and passenger transport ancillary purchase
                                 * cancellation
                                 */
                                val AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                    of(
                                        "airline_ticket_and_passenger_transport_ancillary_purchase_cancellation"
                                    )

                                /** Other */
                                val OTHER = of("other")

                                fun of(value: String) = CreditReasonIndicator(JsonField.of(value))
                            }

                            /** An enum containing [CreditReasonIndicator]'s known values. */
                            enum class Known {
                                /** No credit */
                                NO_CREDIT,
                                /** Passenger transport ancillary purchase cancellation */
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /**
                                 * Airline ticket and passenger transport ancillary purchase
                                 * cancellation
                                 */
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /** Other */
                                OTHER,
                            }

                            /**
                             * An enum containing [CreditReasonIndicator]'s known values, as well as
                             * an [_UNKNOWN] member.
                             *
                             * An instance of [CreditReasonIndicator] can contain an unknown value
                             * in a couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** No credit */
                                NO_CREDIT,
                                /** Passenger transport ancillary purchase cancellation */
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /**
                                 * Airline ticket and passenger transport ancillary purchase
                                 * cancellation
                                 */
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /** Other */
                                OTHER,
                                /**
                                 * An enum member indicating that [CreditReasonIndicator] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    NO_CREDIT -> Value.NO_CREDIT
                                    PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Value.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Value
                                            .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    OTHER -> Value.OTHER
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    NO_CREDIT -> Known.NO_CREDIT
                                    PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Known.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Known
                                            .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    OTHER -> Known.OTHER
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown CreditReasonIndicator: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): CreditReasonIndicator = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is CreditReasonIndicator && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        class Service
                        private constructor(
                            private val category: JsonField<Category>,
                            private val subCategory: JsonField<String>,
                            private val additionalProperties: MutableMap<String, JsonValue>,
                        ) {

                            @JsonCreator
                            private constructor(
                                @JsonProperty("category")
                                @ExcludeMissing
                                category: JsonField<Category> = JsonMissing.of(),
                                @JsonProperty("sub_category")
                                @ExcludeMissing
                                subCategory: JsonField<String> = JsonMissing.of(),
                            ) : this(category, subCategory, mutableMapOf())

                            /**
                             * Category of the ancillary service.
                             *
                             * @throws IncreaseInvalidDataException if the JSON field has an
                             *   unexpected type (e.g. if the server responded with an unexpected
                             *   value).
                             */
                            fun category(): Category? = category.getNullable("category")

                            /**
                             * Sub-category of the ancillary service, free-form.
                             *
                             * @throws IncreaseInvalidDataException if the JSON field has an
                             *   unexpected type (e.g. if the server responded with an unexpected
                             *   value).
                             */
                            fun subCategory(): String? = subCategory.getNullable("sub_category")

                            /**
                             * Returns the raw JSON value of [category].
                             *
                             * Unlike [category], this method doesn't throw if the JSON field has an
                             * unexpected type.
                             */
                            @JsonProperty("category")
                            @ExcludeMissing
                            fun _category(): JsonField<Category> = category

                            /**
                             * Returns the raw JSON value of [subCategory].
                             *
                             * Unlike [subCategory], this method doesn't throw if the JSON field has
                             * an unexpected type.
                             */
                            @JsonProperty("sub_category")
                            @ExcludeMissing
                            fun _subCategory(): JsonField<String> = subCategory

                            @JsonAnySetter
                            private fun putAdditionalProperty(key: String, value: JsonValue) {
                                additionalProperties.put(key, value)
                            }

                            @JsonAnyGetter
                            @ExcludeMissing
                            fun _additionalProperties(): Map<String, JsonValue> =
                                Collections.unmodifiableMap(additionalProperties)

                            fun toBuilder() = Builder().from(this)

                            companion object {

                                /**
                                 * Returns a mutable builder for constructing an instance of
                                 * [Service].
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .category()
                                 * .subCategory()
                                 * ```
                                 */
                                fun builder() = Builder()
                            }

                            /** A builder for [Service]. */
                            class Builder internal constructor() {

                                private var category: JsonField<Category>? = null
                                private var subCategory: JsonField<String>? = null
                                private var additionalProperties: MutableMap<String, JsonValue> =
                                    mutableMapOf()

                                internal fun from(service: Service) = apply {
                                    category = service.category
                                    subCategory = service.subCategory
                                    additionalProperties =
                                        service.additionalProperties.toMutableMap()
                                }

                                /** Category of the ancillary service. */
                                fun category(category: Category?) =
                                    category(JsonField.ofNullable(category))

                                /**
                                 * Sets [Builder.category] to an arbitrary JSON value.
                                 *
                                 * You should usually call [Builder.category] with a well-typed
                                 * [Category] value instead. This method is primarily for setting
                                 * the field to an undocumented or not yet supported value.
                                 */
                                fun category(category: JsonField<Category>) = apply {
                                    this.category = category
                                }

                                /** Sub-category of the ancillary service, free-form. */
                                fun subCategory(subCategory: String?) =
                                    subCategory(JsonField.ofNullable(subCategory))

                                /**
                                 * Sets [Builder.subCategory] to an arbitrary JSON value.
                                 *
                                 * You should usually call [Builder.subCategory] with a well-typed
                                 * [String] value instead. This method is primarily for setting the
                                 * field to an undocumented or not yet supported value.
                                 */
                                fun subCategory(subCategory: JsonField<String>) = apply {
                                    this.subCategory = subCategory
                                }

                                fun additionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                    additionalProperties.put(key, value)
                                }

                                fun putAllAdditionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply { this.additionalProperties.putAll(additionalProperties) }

                                fun removeAdditionalProperty(key: String) = apply {
                                    additionalProperties.remove(key)
                                }

                                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                    keys.forEach(::removeAdditionalProperty)
                                }

                                /**
                                 * Returns an immutable instance of [Service].
                                 *
                                 * Further updates to this [Builder] will not mutate the returned
                                 * instance.
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .category()
                                 * .subCategory()
                                 * ```
                                 *
                                 * @throws IllegalStateException if any required field is unset.
                                 */
                                fun build(): Service =
                                    Service(
                                        checkRequired("category", category),
                                        checkRequired("subCategory", subCategory),
                                        additionalProperties.toMutableMap(),
                                    )
                            }

                            private var validated: Boolean = false

                            fun validate(): Service = apply {
                                if (validated) {
                                    return@apply
                                }

                                category()?.validate()
                                subCategory()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int =
                                (category.asKnown()?.validity() ?: 0) +
                                    (if (subCategory.asKnown() == null) 0 else 1)

                            /** Category of the ancillary service. */
                            class Category
                            @JsonCreator
                            private constructor(private val value: JsonField<String>) : Enum {

                                /**
                                 * Returns this class instance's raw value.
                                 *
                                 * This is usually only useful if this instance was deserialized
                                 * from data that doesn't match any known member, and you want to
                                 * know that value. For example, if the SDK is on an older version
                                 * than the API, then the API may respond with new members that the
                                 * SDK is unaware of.
                                 */
                                @com.fasterxml.jackson.annotation.JsonValue
                                fun _value(): JsonField<String> = value

                                companion object {

                                    /** None */
                                    val NONE = of("none")

                                    /** Bundled service */
                                    val BUNDLED_SERVICE = of("bundled_service")

                                    /** Baggage fee */
                                    val BAGGAGE_FEE = of("baggage_fee")

                                    /** Change fee */
                                    val CHANGE_FEE = of("change_fee")

                                    /** Cargo */
                                    val CARGO = of("cargo")

                                    /** Carbon offset */
                                    val CARBON_OFFSET = of("carbon_offset")

                                    /** Frequent flyer */
                                    val FREQUENT_FLYER = of("frequent_flyer")

                                    /** Gift card */
                                    val GIFT_CARD = of("gift_card")

                                    /** Ground transport */
                                    val GROUND_TRANSPORT = of("ground_transport")

                                    /** In-flight entertainment */
                                    val IN_FLIGHT_ENTERTAINMENT = of("in_flight_entertainment")

                                    /** Lounge */
                                    val LOUNGE = of("lounge")

                                    /** Medical */
                                    val MEDICAL = of("medical")

                                    /** Meal beverage */
                                    val MEAL_BEVERAGE = of("meal_beverage")

                                    /** Other */
                                    val OTHER = of("other")

                                    /** Passenger assist fee */
                                    val PASSENGER_ASSIST_FEE = of("passenger_assist_fee")

                                    /** Pets */
                                    val PETS = of("pets")

                                    /** Seat fees */
                                    val SEAT_FEES = of("seat_fees")

                                    /** Standby */
                                    val STANDBY = of("standby")

                                    /** Service fee */
                                    val SERVICE_FEE = of("service_fee")

                                    /** Store */
                                    val STORE = of("store")

                                    /** Travel service */
                                    val TRAVEL_SERVICE = of("travel_service")

                                    /** Unaccompanied travel */
                                    val UNACCOMPANIED_TRAVEL = of("unaccompanied_travel")

                                    /** Upgrades */
                                    val UPGRADES = of("upgrades")

                                    /** Wi-fi */
                                    val WIFI = of("wifi")

                                    fun of(value: String) = Category(JsonField.of(value))
                                }

                                /** An enum containing [Category]'s known values. */
                                enum class Known {
                                    /** None */
                                    NONE,
                                    /** Bundled service */
                                    BUNDLED_SERVICE,
                                    /** Baggage fee */
                                    BAGGAGE_FEE,
                                    /** Change fee */
                                    CHANGE_FEE,
                                    /** Cargo */
                                    CARGO,
                                    /** Carbon offset */
                                    CARBON_OFFSET,
                                    /** Frequent flyer */
                                    FREQUENT_FLYER,
                                    /** Gift card */
                                    GIFT_CARD,
                                    /** Ground transport */
                                    GROUND_TRANSPORT,
                                    /** In-flight entertainment */
                                    IN_FLIGHT_ENTERTAINMENT,
                                    /** Lounge */
                                    LOUNGE,
                                    /** Medical */
                                    MEDICAL,
                                    /** Meal beverage */
                                    MEAL_BEVERAGE,
                                    /** Other */
                                    OTHER,
                                    /** Passenger assist fee */
                                    PASSENGER_ASSIST_FEE,
                                    /** Pets */
                                    PETS,
                                    /** Seat fees */
                                    SEAT_FEES,
                                    /** Standby */
                                    STANDBY,
                                    /** Service fee */
                                    SERVICE_FEE,
                                    /** Store */
                                    STORE,
                                    /** Travel service */
                                    TRAVEL_SERVICE,
                                    /** Unaccompanied travel */
                                    UNACCOMPANIED_TRAVEL,
                                    /** Upgrades */
                                    UPGRADES,
                                    /** Wi-fi */
                                    WIFI,
                                }

                                /**
                                 * An enum containing [Category]'s known values, as well as an
                                 * [_UNKNOWN] member.
                                 *
                                 * An instance of [Category] can contain an unknown value in a
                                 * couple of cases:
                                 * - It was deserialized from data that doesn't match any known
                                 *   member. For example, if the SDK is on an older version than the
                                 *   API, then the API may respond with new members that the SDK is
                                 *   unaware of.
                                 * - It was constructed with an arbitrary value using the [of]
                                 *   method.
                                 */
                                enum class Value {
                                    /** None */
                                    NONE,
                                    /** Bundled service */
                                    BUNDLED_SERVICE,
                                    /** Baggage fee */
                                    BAGGAGE_FEE,
                                    /** Change fee */
                                    CHANGE_FEE,
                                    /** Cargo */
                                    CARGO,
                                    /** Carbon offset */
                                    CARBON_OFFSET,
                                    /** Frequent flyer */
                                    FREQUENT_FLYER,
                                    /** Gift card */
                                    GIFT_CARD,
                                    /** Ground transport */
                                    GROUND_TRANSPORT,
                                    /** In-flight entertainment */
                                    IN_FLIGHT_ENTERTAINMENT,
                                    /** Lounge */
                                    LOUNGE,
                                    /** Medical */
                                    MEDICAL,
                                    /** Meal beverage */
                                    MEAL_BEVERAGE,
                                    /** Other */
                                    OTHER,
                                    /** Passenger assist fee */
                                    PASSENGER_ASSIST_FEE,
                                    /** Pets */
                                    PETS,
                                    /** Seat fees */
                                    SEAT_FEES,
                                    /** Standby */
                                    STANDBY,
                                    /** Service fee */
                                    SERVICE_FEE,
                                    /** Store */
                                    STORE,
                                    /** Travel service */
                                    TRAVEL_SERVICE,
                                    /** Unaccompanied travel */
                                    UNACCOMPANIED_TRAVEL,
                                    /** Upgrades */
                                    UPGRADES,
                                    /** Wi-fi */
                                    WIFI,
                                    /**
                                     * An enum member indicating that [Category] was instantiated
                                     * with an unknown value.
                                     */
                                    _UNKNOWN,
                                }

                                /**
                                 * Returns an enum member corresponding to this class instance's
                                 * value, or [Value._UNKNOWN] if the class was instantiated with an
                                 * unknown value.
                                 *
                                 * Use the [known] method instead if you're certain the value is
                                 * always known or if you want to throw for the unknown case.
                                 */
                                fun value(): Value =
                                    when (this) {
                                        NONE -> Value.NONE
                                        BUNDLED_SERVICE -> Value.BUNDLED_SERVICE
                                        BAGGAGE_FEE -> Value.BAGGAGE_FEE
                                        CHANGE_FEE -> Value.CHANGE_FEE
                                        CARGO -> Value.CARGO
                                        CARBON_OFFSET -> Value.CARBON_OFFSET
                                        FREQUENT_FLYER -> Value.FREQUENT_FLYER
                                        GIFT_CARD -> Value.GIFT_CARD
                                        GROUND_TRANSPORT -> Value.GROUND_TRANSPORT
                                        IN_FLIGHT_ENTERTAINMENT -> Value.IN_FLIGHT_ENTERTAINMENT
                                        LOUNGE -> Value.LOUNGE
                                        MEDICAL -> Value.MEDICAL
                                        MEAL_BEVERAGE -> Value.MEAL_BEVERAGE
                                        OTHER -> Value.OTHER
                                        PASSENGER_ASSIST_FEE -> Value.PASSENGER_ASSIST_FEE
                                        PETS -> Value.PETS
                                        SEAT_FEES -> Value.SEAT_FEES
                                        STANDBY -> Value.STANDBY
                                        SERVICE_FEE -> Value.SERVICE_FEE
                                        STORE -> Value.STORE
                                        TRAVEL_SERVICE -> Value.TRAVEL_SERVICE
                                        UNACCOMPANIED_TRAVEL -> Value.UNACCOMPANIED_TRAVEL
                                        UPGRADES -> Value.UPGRADES
                                        WIFI -> Value.WIFI
                                        else -> Value._UNKNOWN
                                    }

                                /**
                                 * Returns an enum member corresponding to this class instance's
                                 * value.
                                 *
                                 * Use the [value] method instead if you're uncertain the value is
                                 * always known and don't want to throw for the unknown case.
                                 *
                                 * @throws IncreaseInvalidDataException if this class instance's
                                 *   value is a not a known member.
                                 */
                                fun known(): Known =
                                    when (this) {
                                        NONE -> Known.NONE
                                        BUNDLED_SERVICE -> Known.BUNDLED_SERVICE
                                        BAGGAGE_FEE -> Known.BAGGAGE_FEE
                                        CHANGE_FEE -> Known.CHANGE_FEE
                                        CARGO -> Known.CARGO
                                        CARBON_OFFSET -> Known.CARBON_OFFSET
                                        FREQUENT_FLYER -> Known.FREQUENT_FLYER
                                        GIFT_CARD -> Known.GIFT_CARD
                                        GROUND_TRANSPORT -> Known.GROUND_TRANSPORT
                                        IN_FLIGHT_ENTERTAINMENT -> Known.IN_FLIGHT_ENTERTAINMENT
                                        LOUNGE -> Known.LOUNGE
                                        MEDICAL -> Known.MEDICAL
                                        MEAL_BEVERAGE -> Known.MEAL_BEVERAGE
                                        OTHER -> Known.OTHER
                                        PASSENGER_ASSIST_FEE -> Known.PASSENGER_ASSIST_FEE
                                        PETS -> Known.PETS
                                        SEAT_FEES -> Known.SEAT_FEES
                                        STANDBY -> Known.STANDBY
                                        SERVICE_FEE -> Known.SERVICE_FEE
                                        STORE -> Known.STORE
                                        TRAVEL_SERVICE -> Known.TRAVEL_SERVICE
                                        UNACCOMPANIED_TRAVEL -> Known.UNACCOMPANIED_TRAVEL
                                        UPGRADES -> Known.UPGRADES
                                        WIFI -> Known.WIFI
                                        else ->
                                            throw IncreaseInvalidDataException(
                                                "Unknown Category: $value"
                                            )
                                    }

                                /**
                                 * Returns this class instance's primitive wire representation.
                                 *
                                 * This differs from the [toString] method because that method is
                                 * primarily for debugging and generally doesn't throw.
                                 *
                                 * @throws IncreaseInvalidDataException if this class instance's
                                 *   value does not have the expected primitive type.
                                 */
                                fun asString(): String =
                                    _value().asString()
                                        ?: throw IncreaseInvalidDataException(
                                            "Value is not a String"
                                        )

                                private var validated: Boolean = false

                                fun validate(): Category = apply {
                                    if (validated) {
                                        return@apply
                                    }

                                    known()
                                    validated = true
                                }

                                fun isValid(): Boolean =
                                    try {
                                        validate()
                                        true
                                    } catch (e: IncreaseInvalidDataException) {
                                        false
                                    }

                                /**
                                 * Returns a score indicating how many valid values are contained in
                                 * this object recursively.
                                 *
                                 * Used for best match union deserialization.
                                 */
                                internal fun validity(): Int =
                                    if (value() == Value._UNKNOWN) 0 else 1

                                override fun equals(other: Any?): Boolean {
                                    if (this === other) {
                                        return true
                                    }

                                    return other is Category && value == other.value
                                }

                                override fun hashCode() = value.hashCode()

                                override fun toString() = value.toString()
                            }

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is Service &&
                                    category == other.category &&
                                    subCategory == other.subCategory &&
                                    additionalProperties == other.additionalProperties
                            }

                            private val hashCode: Int by lazy {
                                Objects.hash(category, subCategory, additionalProperties)
                            }

                            override fun hashCode(): Int = hashCode

                            override fun toString() =
                                "Service{category=$category, subCategory=$subCategory, additionalProperties=$additionalProperties}"
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Ancillary &&
                                connectedTicketDocumentNumber ==
                                    other.connectedTicketDocumentNumber &&
                                creditReasonIndicator == other.creditReasonIndicator &&
                                passengerNameOrDescription == other.passengerNameOrDescription &&
                                services == other.services &&
                                ticketDocumentNumber == other.ticketDocumentNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                connectedTicketDocumentNumber,
                                creditReasonIndicator,
                                passengerNameOrDescription,
                                services,
                                ticketDocumentNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Ancillary{connectedTicketDocumentNumber=$connectedTicketDocumentNumber, creditReasonIndicator=$creditReasonIndicator, passengerNameOrDescription=$passengerNameOrDescription, services=$services, ticketDocumentNumber=$ticketDocumentNumber, additionalProperties=$additionalProperties}"
                    }

                    /** Indicates the reason for a credit to the cardholder. */
                    class CreditReasonIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No credit */
                            val NO_CREDIT = of("no_credit")

                            /** Passenger transport ancillary purchase cancellation */
                            val PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                of("passenger_transport_ancillary_purchase_cancellation")

                            /**
                             * Airline ticket and passenger transport ancillary purchase
                             * cancellation
                             */
                            val AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                of(
                                    "airline_ticket_and_passenger_transport_ancillary_purchase_cancellation"
                                )

                            /** Airline ticket cancellation */
                            val AIRLINE_TICKET_CANCELLATION = of("airline_ticket_cancellation")

                            /** Other */
                            val OTHER = of("other")

                            /** Partial refund of airline ticket */
                            val PARTIAL_REFUND_OF_AIRLINE_TICKET =
                                of("partial_refund_of_airline_ticket")

                            fun of(value: String) = CreditReasonIndicator(JsonField.of(value))
                        }

                        /** An enum containing [CreditReasonIndicator]'s known values. */
                        enum class Known {
                            /** No credit */
                            NO_CREDIT,
                            /** Passenger transport ancillary purchase cancellation */
                            PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /**
                             * Airline ticket and passenger transport ancillary purchase
                             * cancellation
                             */
                            AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /** Airline ticket cancellation */
                            AIRLINE_TICKET_CANCELLATION,
                            /** Other */
                            OTHER,
                            /** Partial refund of airline ticket */
                            PARTIAL_REFUND_OF_AIRLINE_TICKET,
                        }

                        /**
                         * An enum containing [CreditReasonIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [CreditReasonIndicator] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No credit */
                            NO_CREDIT,
                            /** Passenger transport ancillary purchase cancellation */
                            PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /**
                             * Airline ticket and passenger transport ancillary purchase
                             * cancellation
                             */
                            AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /** Airline ticket cancellation */
                            AIRLINE_TICKET_CANCELLATION,
                            /** Other */
                            OTHER,
                            /** Partial refund of airline ticket */
                            PARTIAL_REFUND_OF_AIRLINE_TICKET,
                            /**
                             * An enum member indicating that [CreditReasonIndicator] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_CREDIT -> Value.NO_CREDIT
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Value.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Value
                                        .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_CANCELLATION -> Value.AIRLINE_TICKET_CANCELLATION
                                OTHER -> Value.OTHER
                                PARTIAL_REFUND_OF_AIRLINE_TICKET ->
                                    Value.PARTIAL_REFUND_OF_AIRLINE_TICKET
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_CREDIT -> Known.NO_CREDIT
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Known.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Known
                                        .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_CANCELLATION -> Known.AIRLINE_TICKET_CANCELLATION
                                OTHER -> Known.OTHER
                                PARTIAL_REFUND_OF_AIRLINE_TICKET ->
                                    Known.PARTIAL_REFUND_OF_AIRLINE_TICKET
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CreditReasonIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CreditReasonIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CreditReasonIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Indicates whether this ticket is non-refundable. */
                    class RestrictedTicketIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No restrictions */
                            val NO_RESTRICTIONS = of("no_restrictions")

                            /** Restricted non-refundable ticket */
                            val RESTRICTED_NON_REFUNDABLE_TICKET =
                                of("restricted_non_refundable_ticket")

                            fun of(value: String) = RestrictedTicketIndicator(JsonField.of(value))
                        }

                        /** An enum containing [RestrictedTicketIndicator]'s known values. */
                        enum class Known {
                            /** No restrictions */
                            NO_RESTRICTIONS,
                            /** Restricted non-refundable ticket */
                            RESTRICTED_NON_REFUNDABLE_TICKET,
                        }

                        /**
                         * An enum containing [RestrictedTicketIndicator]'s known values, as well as
                         * an [_UNKNOWN] member.
                         *
                         * An instance of [RestrictedTicketIndicator] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No restrictions */
                            NO_RESTRICTIONS,
                            /** Restricted non-refundable ticket */
                            RESTRICTED_NON_REFUNDABLE_TICKET,
                            /**
                             * An enum member indicating that [RestrictedTicketIndicator] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_RESTRICTIONS -> Value.NO_RESTRICTIONS
                                RESTRICTED_NON_REFUNDABLE_TICKET ->
                                    Value.RESTRICTED_NON_REFUNDABLE_TICKET
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_RESTRICTIONS -> Known.NO_RESTRICTIONS
                                RESTRICTED_NON_REFUNDABLE_TICKET ->
                                    Known.RESTRICTED_NON_REFUNDABLE_TICKET
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown RestrictedTicketIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): RestrictedTicketIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is RestrictedTicketIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Indicates why a ticket was changed. */
                    class TicketChangeIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** None */
                            val NONE = of("none")

                            /** Change to existing ticket */
                            val CHANGE_TO_EXISTING_TICKET = of("change_to_existing_ticket")

                            /** New ticket */
                            val NEW_TICKET = of("new_ticket")

                            fun of(value: String) = TicketChangeIndicator(JsonField.of(value))
                        }

                        /** An enum containing [TicketChangeIndicator]'s known values. */
                        enum class Known {
                            /** None */
                            NONE,
                            /** Change to existing ticket */
                            CHANGE_TO_EXISTING_TICKET,
                            /** New ticket */
                            NEW_TICKET,
                        }

                        /**
                         * An enum containing [TicketChangeIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [TicketChangeIndicator] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** None */
                            NONE,
                            /** Change to existing ticket */
                            CHANGE_TO_EXISTING_TICKET,
                            /** New ticket */
                            NEW_TICKET,
                            /**
                             * An enum member indicating that [TicketChangeIndicator] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NONE -> Value.NONE
                                CHANGE_TO_EXISTING_TICKET -> Value.CHANGE_TO_EXISTING_TICKET
                                NEW_TICKET -> Value.NEW_TICKET
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NONE -> Known.NONE
                                CHANGE_TO_EXISTING_TICKET -> Known.CHANGE_TO_EXISTING_TICKET
                                NEW_TICKET -> Known.NEW_TICKET
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown TicketChangeIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): TicketChangeIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is TicketChangeIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    class TripLeg
                    private constructor(
                        private val carrierCode: JsonField<String>,
                        private val destinationCityAirportCode: JsonField<String>,
                        private val fareBasisCode: JsonField<String>,
                        private val flightNumber: JsonField<String>,
                        private val serviceClass: JsonField<String>,
                        private val stopOverCode: JsonField<StopOverCode>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("carrier_code")
                            @ExcludeMissing
                            carrierCode: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("destination_city_airport_code")
                            @ExcludeMissing
                            destinationCityAirportCode: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("fare_basis_code")
                            @ExcludeMissing
                            fareBasisCode: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("flight_number")
                            @ExcludeMissing
                            flightNumber: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("service_class")
                            @ExcludeMissing
                            serviceClass: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("stop_over_code")
                            @ExcludeMissing
                            stopOverCode: JsonField<StopOverCode> = JsonMissing.of(),
                        ) : this(
                            carrierCode,
                            destinationCityAirportCode,
                            fareBasisCode,
                            flightNumber,
                            serviceClass,
                            stopOverCode,
                            mutableMapOf(),
                        )

                        /**
                         * Carrier code (e.g., United Airlines, Jet Blue, etc.).
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun carrierCode(): String? = carrierCode.getNullable("carrier_code")

                        /**
                         * Code for the destination city or airport.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun destinationCityAirportCode(): String? =
                            destinationCityAirportCode.getNullable("destination_city_airport_code")

                        /**
                         * Fare basis code.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun fareBasisCode(): String? = fareBasisCode.getNullable("fare_basis_code")

                        /**
                         * Flight number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun flightNumber(): String? = flightNumber.getNullable("flight_number")

                        /**
                         * Service class (e.g., first class, business class, etc.).
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun serviceClass(): String? = serviceClass.getNullable("service_class")

                        /**
                         * Indicates whether a stopover is allowed on this ticket.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun stopOverCode(): StopOverCode? =
                            stopOverCode.getNullable("stop_over_code")

                        /**
                         * Returns the raw JSON value of [carrierCode].
                         *
                         * Unlike [carrierCode], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("carrier_code")
                        @ExcludeMissing
                        fun _carrierCode(): JsonField<String> = carrierCode

                        /**
                         * Returns the raw JSON value of [destinationCityAirportCode].
                         *
                         * Unlike [destinationCityAirportCode], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("destination_city_airport_code")
                        @ExcludeMissing
                        fun _destinationCityAirportCode(): JsonField<String> =
                            destinationCityAirportCode

                        /**
                         * Returns the raw JSON value of [fareBasisCode].
                         *
                         * Unlike [fareBasisCode], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("fare_basis_code")
                        @ExcludeMissing
                        fun _fareBasisCode(): JsonField<String> = fareBasisCode

                        /**
                         * Returns the raw JSON value of [flightNumber].
                         *
                         * Unlike [flightNumber], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("flight_number")
                        @ExcludeMissing
                        fun _flightNumber(): JsonField<String> = flightNumber

                        /**
                         * Returns the raw JSON value of [serviceClass].
                         *
                         * Unlike [serviceClass], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("service_class")
                        @ExcludeMissing
                        fun _serviceClass(): JsonField<String> = serviceClass

                        /**
                         * Returns the raw JSON value of [stopOverCode].
                         *
                         * Unlike [stopOverCode], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("stop_over_code")
                        @ExcludeMissing
                        fun _stopOverCode(): JsonField<StopOverCode> = stopOverCode

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [TripLeg].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .carrierCode()
                             * .destinationCityAirportCode()
                             * .fareBasisCode()
                             * .flightNumber()
                             * .serviceClass()
                             * .stopOverCode()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [TripLeg]. */
                        class Builder internal constructor() {

                            private var carrierCode: JsonField<String>? = null
                            private var destinationCityAirportCode: JsonField<String>? = null
                            private var fareBasisCode: JsonField<String>? = null
                            private var flightNumber: JsonField<String>? = null
                            private var serviceClass: JsonField<String>? = null
                            private var stopOverCode: JsonField<StopOverCode>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(tripLeg: TripLeg) = apply {
                                carrierCode = tripLeg.carrierCode
                                destinationCityAirportCode = tripLeg.destinationCityAirportCode
                                fareBasisCode = tripLeg.fareBasisCode
                                flightNumber = tripLeg.flightNumber
                                serviceClass = tripLeg.serviceClass
                                stopOverCode = tripLeg.stopOverCode
                                additionalProperties = tripLeg.additionalProperties.toMutableMap()
                            }

                            /** Carrier code (e.g., United Airlines, Jet Blue, etc.). */
                            fun carrierCode(carrierCode: String?) =
                                carrierCode(JsonField.ofNullable(carrierCode))

                            /**
                             * Sets [Builder.carrierCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.carrierCode] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun carrierCode(carrierCode: JsonField<String>) = apply {
                                this.carrierCode = carrierCode
                            }

                            /** Code for the destination city or airport. */
                            fun destinationCityAirportCode(destinationCityAirportCode: String?) =
                                destinationCityAirportCode(
                                    JsonField.ofNullable(destinationCityAirportCode)
                                )

                            /**
                             * Sets [Builder.destinationCityAirportCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.destinationCityAirportCode] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun destinationCityAirportCode(
                                destinationCityAirportCode: JsonField<String>
                            ) = apply {
                                this.destinationCityAirportCode = destinationCityAirportCode
                            }

                            /** Fare basis code. */
                            fun fareBasisCode(fareBasisCode: String?) =
                                fareBasisCode(JsonField.ofNullable(fareBasisCode))

                            /**
                             * Sets [Builder.fareBasisCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.fareBasisCode] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun fareBasisCode(fareBasisCode: JsonField<String>) = apply {
                                this.fareBasisCode = fareBasisCode
                            }

                            /** Flight number. */
                            fun flightNumber(flightNumber: String?) =
                                flightNumber(JsonField.ofNullable(flightNumber))

                            /**
                             * Sets [Builder.flightNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.flightNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun flightNumber(flightNumber: JsonField<String>) = apply {
                                this.flightNumber = flightNumber
                            }

                            /** Service class (e.g., first class, business class, etc.). */
                            fun serviceClass(serviceClass: String?) =
                                serviceClass(JsonField.ofNullable(serviceClass))

                            /**
                             * Sets [Builder.serviceClass] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.serviceClass] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun serviceClass(serviceClass: JsonField<String>) = apply {
                                this.serviceClass = serviceClass
                            }

                            /** Indicates whether a stopover is allowed on this ticket. */
                            fun stopOverCode(stopOverCode: StopOverCode?) =
                                stopOverCode(JsonField.ofNullable(stopOverCode))

                            /**
                             * Sets [Builder.stopOverCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.stopOverCode] with a well-typed
                             * [StopOverCode] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun stopOverCode(stopOverCode: JsonField<StopOverCode>) = apply {
                                this.stopOverCode = stopOverCode
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [TripLeg].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .carrierCode()
                             * .destinationCityAirportCode()
                             * .fareBasisCode()
                             * .flightNumber()
                             * .serviceClass()
                             * .stopOverCode()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): TripLeg =
                                TripLeg(
                                    checkRequired("carrierCode", carrierCode),
                                    checkRequired(
                                        "destinationCityAirportCode",
                                        destinationCityAirportCode,
                                    ),
                                    checkRequired("fareBasisCode", fareBasisCode),
                                    checkRequired("flightNumber", flightNumber),
                                    checkRequired("serviceClass", serviceClass),
                                    checkRequired("stopOverCode", stopOverCode),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): TripLeg = apply {
                            if (validated) {
                                return@apply
                            }

                            carrierCode()
                            destinationCityAirportCode()
                            fareBasisCode()
                            flightNumber()
                            serviceClass()
                            stopOverCode()?.validate()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (carrierCode.asKnown() == null) 0 else 1) +
                                (if (destinationCityAirportCode.asKnown() == null) 0 else 1) +
                                (if (fareBasisCode.asKnown() == null) 0 else 1) +
                                (if (flightNumber.asKnown() == null) 0 else 1) +
                                (if (serviceClass.asKnown() == null) 0 else 1) +
                                (stopOverCode.asKnown()?.validity() ?: 0)

                        /** Indicates whether a stopover is allowed on this ticket. */
                        class StopOverCode
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** None */
                                val NONE = of("none")

                                /** Stop over allowed */
                                val STOP_OVER_ALLOWED = of("stop_over_allowed")

                                /** Stop over not allowed */
                                val STOP_OVER_NOT_ALLOWED = of("stop_over_not_allowed")

                                fun of(value: String) = StopOverCode(JsonField.of(value))
                            }

                            /** An enum containing [StopOverCode]'s known values. */
                            enum class Known {
                                /** None */
                                NONE,
                                /** Stop over allowed */
                                STOP_OVER_ALLOWED,
                                /** Stop over not allowed */
                                STOP_OVER_NOT_ALLOWED,
                            }

                            /**
                             * An enum containing [StopOverCode]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [StopOverCode] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** None */
                                NONE,
                                /** Stop over allowed */
                                STOP_OVER_ALLOWED,
                                /** Stop over not allowed */
                                STOP_OVER_NOT_ALLOWED,
                                /**
                                 * An enum member indicating that [StopOverCode] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    NONE -> Value.NONE
                                    STOP_OVER_ALLOWED -> Value.STOP_OVER_ALLOWED
                                    STOP_OVER_NOT_ALLOWED -> Value.STOP_OVER_NOT_ALLOWED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    NONE -> Known.NONE
                                    STOP_OVER_ALLOWED -> Known.STOP_OVER_ALLOWED
                                    STOP_OVER_NOT_ALLOWED -> Known.STOP_OVER_NOT_ALLOWED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown StopOverCode: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): StopOverCode = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is StopOverCode && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is TripLeg &&
                                carrierCode == other.carrierCode &&
                                destinationCityAirportCode == other.destinationCityAirportCode &&
                                fareBasisCode == other.fareBasisCode &&
                                flightNumber == other.flightNumber &&
                                serviceClass == other.serviceClass &&
                                stopOverCode == other.stopOverCode &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                carrierCode,
                                destinationCityAirportCode,
                                fareBasisCode,
                                flightNumber,
                                serviceClass,
                                stopOverCode,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "TripLeg{carrierCode=$carrierCode, destinationCityAirportCode=$destinationCityAirportCode, fareBasisCode=$fareBasisCode, flightNumber=$flightNumber, serviceClass=$serviceClass, stopOverCode=$stopOverCode, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Travel &&
                            ancillary == other.ancillary &&
                            computerizedReservationSystem == other.computerizedReservationSystem &&
                            creditReasonIndicator == other.creditReasonIndicator &&
                            departureDate == other.departureDate &&
                            originationCityAirportCode == other.originationCityAirportCode &&
                            passengerName == other.passengerName &&
                            restrictedTicketIndicator == other.restrictedTicketIndicator &&
                            ticketChangeIndicator == other.ticketChangeIndicator &&
                            ticketNumber == other.ticketNumber &&
                            travelAgencyCode == other.travelAgencyCode &&
                            travelAgencyName == other.travelAgencyName &&
                            tripLegs == other.tripLegs &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            ancillary,
                            computerizedReservationSystem,
                            creditReasonIndicator,
                            departureDate,
                            originationCityAirportCode,
                            passengerName,
                            restrictedTicketIndicator,
                            ticketChangeIndicator,
                            ticketNumber,
                            travelAgencyCode,
                            travelAgencyName,
                            tripLegs,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Travel{ancillary=$ancillary, computerizedReservationSystem=$computerizedReservationSystem, creditReasonIndicator=$creditReasonIndicator, departureDate=$departureDate, originationCityAirportCode=$originationCityAirportCode, passengerName=$passengerName, restrictedTicketIndicator=$restrictedTicketIndicator, ticketChangeIndicator=$ticketChangeIndicator, ticketNumber=$ticketNumber, travelAgencyCode=$travelAgencyCode, travelAgencyName=$travelAgencyName, tripLegs=$tripLegs, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is PurchaseDetails &&
                        carRental == other.carRental &&
                        customerReferenceIdentifier == other.customerReferenceIdentifier &&
                        localTaxAmount == other.localTaxAmount &&
                        localTaxCurrency == other.localTaxCurrency &&
                        lodging == other.lodging &&
                        nationalTaxAmount == other.nationalTaxAmount &&
                        nationalTaxCurrency == other.nationalTaxCurrency &&
                        purchaseIdentifier == other.purchaseIdentifier &&
                        purchaseIdentifierFormat == other.purchaseIdentifierFormat &&
                        travel == other.travel &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        carRental,
                        customerReferenceIdentifier,
                        localTaxAmount,
                        localTaxCurrency,
                        lodging,
                        nationalTaxAmount,
                        nationalTaxCurrency,
                        purchaseIdentifier,
                        purchaseIdentifierFormat,
                        travel,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "PurchaseDetails{carRental=$carRental, customerReferenceIdentifier=$customerReferenceIdentifier, localTaxAmount=$localTaxAmount, localTaxCurrency=$localTaxCurrency, lodging=$lodging, nationalTaxAmount=$nationalTaxAmount, nationalTaxCurrency=$nationalTaxCurrency, purchaseIdentifier=$purchaseIdentifier, purchaseIdentifierFormat=$purchaseIdentifierFormat, travel=$travel, additionalProperties=$additionalProperties}"
            }

            /**
             * A constant representing the object's type. For this resource it will always be
             * `card_refund`.
             */
            class Type @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    val CARD_REFUND = of("card_refund")

                    fun of(value: String) = Type(JsonField.of(value))
                }

                /** An enum containing [Type]'s known values. */
                enum class Known {
                    CARD_REFUND
                }

                /**
                 * An enum containing [Type]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Type] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    CARD_REFUND,
                    /**
                     * An enum member indicating that [Type] was instantiated with an unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CARD_REFUND -> Value.CARD_REFUND
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CARD_REFUND -> Known.CARD_REFUND
                        else -> throw IncreaseInvalidDataException("Unknown Type: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Type = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Type && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CardRefund &&
                    id == other.id &&
                    amount == other.amount &&
                    cardPaymentId == other.cardPaymentId &&
                    cashback == other.cashback &&
                    currency == other.currency &&
                    interchange == other.interchange &&
                    merchantAcceptorId == other.merchantAcceptorId &&
                    merchantCategoryCode == other.merchantCategoryCode &&
                    merchantCity == other.merchantCity &&
                    merchantCountry == other.merchantCountry &&
                    merchantName == other.merchantName &&
                    merchantPostalCode == other.merchantPostalCode &&
                    merchantState == other.merchantState &&
                    networkIdentifiers == other.networkIdentifiers &&
                    presentmentAmount == other.presentmentAmount &&
                    presentmentCurrency == other.presentmentCurrency &&
                    purchaseDetails == other.purchaseDetails &&
                    transactionId == other.transactionId &&
                    type == other.type &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    id,
                    amount,
                    cardPaymentId,
                    cashback,
                    currency,
                    interchange,
                    merchantAcceptorId,
                    merchantCategoryCode,
                    merchantCity,
                    merchantCountry,
                    merchantName,
                    merchantPostalCode,
                    merchantState,
                    networkIdentifiers,
                    presentmentAmount,
                    presentmentCurrency,
                    purchaseDetails,
                    transactionId,
                    type,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CardRefund{id=$id, amount=$amount, cardPaymentId=$cardPaymentId, cashback=$cashback, currency=$currency, interchange=$interchange, merchantAcceptorId=$merchantAcceptorId, merchantCategoryCode=$merchantCategoryCode, merchantCity=$merchantCity, merchantCountry=$merchantCountry, merchantName=$merchantName, merchantPostalCode=$merchantPostalCode, merchantState=$merchantState, networkIdentifiers=$networkIdentifiers, presentmentAmount=$presentmentAmount, presentmentCurrency=$presentmentCurrency, purchaseDetails=$purchaseDetails, transactionId=$transactionId, type=$type, additionalProperties=$additionalProperties}"
        }

        /**
         * A Card Revenue Payment object. This field will be present in the JSON response if and
         * only if `category` is equal to `card_revenue_payment`. Card Revenue Payments reflect
         * earnings from fees on card transactions.
         */
        class CardRevenuePayment
        private constructor(
            private val amount: JsonField<Long>,
            private val currency: JsonField<Currency>,
            private val periodEnd: JsonField<OffsetDateTime>,
            private val periodStart: JsonField<OffsetDateTime>,
            private val transactedOnAccountId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("period_end")
                @ExcludeMissing
                periodEnd: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("period_start")
                @ExcludeMissing
                periodStart: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("transacted_on_account_id")
                @ExcludeMissing
                transactedOnAccountId: JsonField<String> = JsonMissing.of(),
            ) : this(
                amount,
                currency,
                periodEnd,
                periodStart,
                transactedOnAccountId,
                mutableMapOf(),
            )

            /**
             * The amount in the minor unit of the transaction's currency. For dollars, for example,
             * this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * The end of the period for which this transaction paid interest.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodEnd(): OffsetDateTime = periodEnd.getRequired("period_end")

            /**
             * The start of the period for which this transaction paid interest.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodStart(): OffsetDateTime = periodStart.getRequired("period_start")

            /**
             * The account the card belonged to.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun transactedOnAccountId(): String? =
                transactedOnAccountId.getNullable("transacted_on_account_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [periodEnd].
             *
             * Unlike [periodEnd], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_end")
            @ExcludeMissing
            fun _periodEnd(): JsonField<OffsetDateTime> = periodEnd

            /**
             * Returns the raw JSON value of [periodStart].
             *
             * Unlike [periodStart], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_start")
            @ExcludeMissing
            fun _periodStart(): JsonField<OffsetDateTime> = periodStart

            /**
             * Returns the raw JSON value of [transactedOnAccountId].
             *
             * Unlike [transactedOnAccountId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("transacted_on_account_id")
            @ExcludeMissing
            fun _transactedOnAccountId(): JsonField<String> = transactedOnAccountId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CardRevenuePayment].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .periodEnd()
                 * .periodStart()
                 * .transactedOnAccountId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CardRevenuePayment]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var currency: JsonField<Currency>? = null
                private var periodEnd: JsonField<OffsetDateTime>? = null
                private var periodStart: JsonField<OffsetDateTime>? = null
                private var transactedOnAccountId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cardRevenuePayment: CardRevenuePayment) = apply {
                    amount = cardRevenuePayment.amount
                    currency = cardRevenuePayment.currency
                    periodEnd = cardRevenuePayment.periodEnd
                    periodStart = cardRevenuePayment.periodStart
                    transactedOnAccountId = cardRevenuePayment.transactedOnAccountId
                    additionalProperties = cardRevenuePayment.additionalProperties.toMutableMap()
                }

                /**
                 * The amount in the minor unit of the transaction's currency. For dollars, for
                 * example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
                 * currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** The end of the period for which this transaction paid interest. */
                fun periodEnd(periodEnd: OffsetDateTime) = periodEnd(JsonField.of(periodEnd))

                /**
                 * Sets [Builder.periodEnd] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodEnd] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodEnd(periodEnd: JsonField<OffsetDateTime>) = apply {
                    this.periodEnd = periodEnd
                }

                /** The start of the period for which this transaction paid interest. */
                fun periodStart(periodStart: OffsetDateTime) =
                    periodStart(JsonField.of(periodStart))

                /**
                 * Sets [Builder.periodStart] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodStart] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodStart(periodStart: JsonField<OffsetDateTime>) = apply {
                    this.periodStart = periodStart
                }

                /** The account the card belonged to. */
                fun transactedOnAccountId(transactedOnAccountId: String?) =
                    transactedOnAccountId(JsonField.ofNullable(transactedOnAccountId))

                /**
                 * Sets [Builder.transactedOnAccountId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactedOnAccountId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun transactedOnAccountId(transactedOnAccountId: JsonField<String>) = apply {
                    this.transactedOnAccountId = transactedOnAccountId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CardRevenuePayment].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .periodEnd()
                 * .periodStart()
                 * .transactedOnAccountId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CardRevenuePayment =
                    CardRevenuePayment(
                        checkRequired("amount", amount),
                        checkRequired("currency", currency),
                        checkRequired("periodEnd", periodEnd),
                        checkRequired("periodStart", periodStart),
                        checkRequired("transactedOnAccountId", transactedOnAccountId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CardRevenuePayment = apply {
                if (validated) {
                    return@apply
                }

                amount()
                currency().validate()
                periodEnd()
                periodStart()
                transactedOnAccountId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (if (periodEnd.asKnown() == null) 0 else 1) +
                    (if (periodStart.asKnown() == null) 0 else 1) +
                    (if (transactedOnAccountId.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CardRevenuePayment &&
                    amount == other.amount &&
                    currency == other.currency &&
                    periodEnd == other.periodEnd &&
                    periodStart == other.periodStart &&
                    transactedOnAccountId == other.transactedOnAccountId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    currency,
                    periodEnd,
                    periodStart,
                    transactedOnAccountId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CardRevenuePayment{amount=$amount, currency=$currency, periodEnd=$periodEnd, periodStart=$periodStart, transactedOnAccountId=$transactedOnAccountId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Card Settlement object. This field will be present in the JSON response if and only if
         * `category` is equal to `card_settlement`. Card Settlements are card transactions that
         * have cleared and settled. While a settlement is usually preceded by an authorization, an
         * acquirer can also directly clear a transaction without first authorizing it.
         */
        class CardSettlement
        private constructor(
            private val id: JsonField<String>,
            private val amount: JsonField<Long>,
            private val cardAuthorization: JsonField<String>,
            private val cardPaymentId: JsonField<String>,
            private val cashback: JsonField<Cashback>,
            private val currency: JsonField<Currency>,
            private val interchange: JsonField<Interchange>,
            private val merchantAcceptorId: JsonField<String>,
            private val merchantCategoryCode: JsonField<String>,
            private val merchantCity: JsonField<String>,
            private val merchantCountry: JsonField<String>,
            private val merchantName: JsonField<String>,
            private val merchantPostalCode: JsonField<String>,
            private val merchantState: JsonField<String>,
            private val network: JsonField<Network>,
            private val networkIdentifiers: JsonField<NetworkIdentifiers>,
            private val pendingTransactionId: JsonField<String>,
            private val presentmentAmount: JsonField<Long>,
            private val presentmentCurrency: JsonField<String>,
            private val purchaseDetails: JsonField<PurchaseDetails>,
            private val transactionId: JsonField<String>,
            private val type: JsonField<Type>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("card_authorization")
                @ExcludeMissing
                cardAuthorization: JsonField<String> = JsonMissing.of(),
                @JsonProperty("card_payment_id")
                @ExcludeMissing
                cardPaymentId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("cashback")
                @ExcludeMissing
                cashback: JsonField<Cashback> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("interchange")
                @ExcludeMissing
                interchange: JsonField<Interchange> = JsonMissing.of(),
                @JsonProperty("merchant_acceptor_id")
                @ExcludeMissing
                merchantAcceptorId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_category_code")
                @ExcludeMissing
                merchantCategoryCode: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_city")
                @ExcludeMissing
                merchantCity: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_country")
                @ExcludeMissing
                merchantCountry: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_name")
                @ExcludeMissing
                merchantName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_postal_code")
                @ExcludeMissing
                merchantPostalCode: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_state")
                @ExcludeMissing
                merchantState: JsonField<String> = JsonMissing.of(),
                @JsonProperty("network")
                @ExcludeMissing
                network: JsonField<Network> = JsonMissing.of(),
                @JsonProperty("network_identifiers")
                @ExcludeMissing
                networkIdentifiers: JsonField<NetworkIdentifiers> = JsonMissing.of(),
                @JsonProperty("pending_transaction_id")
                @ExcludeMissing
                pendingTransactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("presentment_amount")
                @ExcludeMissing
                presentmentAmount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("presentment_currency")
                @ExcludeMissing
                presentmentCurrency: JsonField<String> = JsonMissing.of(),
                @JsonProperty("purchase_details")
                @ExcludeMissing
                purchaseDetails: JsonField<PurchaseDetails> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("type") @ExcludeMissing type: JsonField<Type> = JsonMissing.of(),
            ) : this(
                id,
                amount,
                cardAuthorization,
                cardPaymentId,
                cashback,
                currency,
                interchange,
                merchantAcceptorId,
                merchantCategoryCode,
                merchantCity,
                merchantCountry,
                merchantName,
                merchantPostalCode,
                merchantState,
                network,
                networkIdentifiers,
                pendingTransactionId,
                presentmentAmount,
                presentmentCurrency,
                purchaseDetails,
                transactionId,
                type,
                mutableMapOf(),
            )

            /**
             * The Card Settlement identifier.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * The amount in the minor unit of the transaction's settlement currency. For dollars,
             * for example, this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The Card Authorization that was created prior to this Card Settlement, if one exists.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun cardAuthorization(): String? = cardAuthorization.getNullable("card_authorization")

            /**
             * The ID of the Card Payment this transaction belongs to.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun cardPaymentId(): String = cardPaymentId.getRequired("card_payment_id")

            /**
             * Cashback earned on this transaction, if eligible. Cashback is paid out in aggregate,
             * monthly.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun cashback(): Cashback? = cashback.getNullable("cashback")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * settlement currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * Interchange assessed as a part of this transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun interchange(): Interchange? = interchange.getNullable("interchange")

            /**
             * The merchant identifier (commonly abbreviated as MID) of the merchant the card is
             * transacting with.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantAcceptorId(): String =
                merchantAcceptorId.getRequired("merchant_acceptor_id")

            /**
             * The 4-digit MCC describing the merchant's business.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantCategoryCode(): String =
                merchantCategoryCode.getRequired("merchant_category_code")

            /**
             * The city the merchant resides in.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantCity(): String = merchantCity.getRequired("merchant_city")

            /**
             * The country the merchant resides in.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantCountry(): String = merchantCountry.getRequired("merchant_country")

            /**
             * The name of the merchant.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun merchantName(): String = merchantName.getRequired("merchant_name")

            /**
             * The merchant's postal code. For US merchants this is always a 5-digit ZIP code.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun merchantPostalCode(): String? =
                merchantPostalCode.getNullable("merchant_postal_code")

            /**
             * The state the merchant resides in.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun merchantState(): String? = merchantState.getNullable("merchant_state")

            /**
             * The card network on which this transaction was processed.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun network(): Network = network.getRequired("network")

            /**
             * Network-specific identifiers for this refund.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun networkIdentifiers(): NetworkIdentifiers =
                networkIdentifiers.getRequired("network_identifiers")

            /**
             * The identifier of the Pending Transaction associated with this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun pendingTransactionId(): String? =
                pendingTransactionId.getNullable("pending_transaction_id")

            /**
             * The amount in the minor unit of the transaction's presentment currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun presentmentAmount(): Long = presentmentAmount.getRequired("presentment_amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * presentment currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun presentmentCurrency(): String =
                presentmentCurrency.getRequired("presentment_currency")

            /**
             * Additional details about the card purchase, such as tax and industry-specific fields.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun purchaseDetails(): PurchaseDetails? =
                purchaseDetails.getNullable("purchase_details")

            /**
             * The identifier of the Transaction associated with this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * A constant representing the object's type. For this resource it will always be
             * `card_settlement`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun type(): Type = type.getRequired("type")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [cardAuthorization].
             *
             * Unlike [cardAuthorization], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("card_authorization")
            @ExcludeMissing
            fun _cardAuthorization(): JsonField<String> = cardAuthorization

            /**
             * Returns the raw JSON value of [cardPaymentId].
             *
             * Unlike [cardPaymentId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("card_payment_id")
            @ExcludeMissing
            fun _cardPaymentId(): JsonField<String> = cardPaymentId

            /**
             * Returns the raw JSON value of [cashback].
             *
             * Unlike [cashback], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("cashback")
            @ExcludeMissing
            fun _cashback(): JsonField<Cashback> = cashback

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [interchange].
             *
             * Unlike [interchange], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("interchange")
            @ExcludeMissing
            fun _interchange(): JsonField<Interchange> = interchange

            /**
             * Returns the raw JSON value of [merchantAcceptorId].
             *
             * Unlike [merchantAcceptorId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_acceptor_id")
            @ExcludeMissing
            fun _merchantAcceptorId(): JsonField<String> = merchantAcceptorId

            /**
             * Returns the raw JSON value of [merchantCategoryCode].
             *
             * Unlike [merchantCategoryCode], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_category_code")
            @ExcludeMissing
            fun _merchantCategoryCode(): JsonField<String> = merchantCategoryCode

            /**
             * Returns the raw JSON value of [merchantCity].
             *
             * Unlike [merchantCity], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("merchant_city")
            @ExcludeMissing
            fun _merchantCity(): JsonField<String> = merchantCity

            /**
             * Returns the raw JSON value of [merchantCountry].
             *
             * Unlike [merchantCountry], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_country")
            @ExcludeMissing
            fun _merchantCountry(): JsonField<String> = merchantCountry

            /**
             * Returns the raw JSON value of [merchantName].
             *
             * Unlike [merchantName], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("merchant_name")
            @ExcludeMissing
            fun _merchantName(): JsonField<String> = merchantName

            /**
             * Returns the raw JSON value of [merchantPostalCode].
             *
             * Unlike [merchantPostalCode], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("merchant_postal_code")
            @ExcludeMissing
            fun _merchantPostalCode(): JsonField<String> = merchantPostalCode

            /**
             * Returns the raw JSON value of [merchantState].
             *
             * Unlike [merchantState], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("merchant_state")
            @ExcludeMissing
            fun _merchantState(): JsonField<String> = merchantState

            /**
             * Returns the raw JSON value of [network].
             *
             * Unlike [network], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("network") @ExcludeMissing fun _network(): JsonField<Network> = network

            /**
             * Returns the raw JSON value of [networkIdentifiers].
             *
             * Unlike [networkIdentifiers], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("network_identifiers")
            @ExcludeMissing
            fun _networkIdentifiers(): JsonField<NetworkIdentifiers> = networkIdentifiers

            /**
             * Returns the raw JSON value of [pendingTransactionId].
             *
             * Unlike [pendingTransactionId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("pending_transaction_id")
            @ExcludeMissing
            fun _pendingTransactionId(): JsonField<String> = pendingTransactionId

            /**
             * Returns the raw JSON value of [presentmentAmount].
             *
             * Unlike [presentmentAmount], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("presentment_amount")
            @ExcludeMissing
            fun _presentmentAmount(): JsonField<Long> = presentmentAmount

            /**
             * Returns the raw JSON value of [presentmentCurrency].
             *
             * Unlike [presentmentCurrency], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("presentment_currency")
            @ExcludeMissing
            fun _presentmentCurrency(): JsonField<String> = presentmentCurrency

            /**
             * Returns the raw JSON value of [purchaseDetails].
             *
             * Unlike [purchaseDetails], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("purchase_details")
            @ExcludeMissing
            fun _purchaseDetails(): JsonField<PurchaseDetails> = purchaseDetails

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            /**
             * Returns the raw JSON value of [type].
             *
             * Unlike [type], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("type") @ExcludeMissing fun _type(): JsonField<Type> = type

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CardSettlement].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .id()
                 * .amount()
                 * .cardAuthorization()
                 * .cardPaymentId()
                 * .cashback()
                 * .currency()
                 * .interchange()
                 * .merchantAcceptorId()
                 * .merchantCategoryCode()
                 * .merchantCity()
                 * .merchantCountry()
                 * .merchantName()
                 * .merchantPostalCode()
                 * .merchantState()
                 * .network()
                 * .networkIdentifiers()
                 * .pendingTransactionId()
                 * .presentmentAmount()
                 * .presentmentCurrency()
                 * .purchaseDetails()
                 * .transactionId()
                 * .type()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CardSettlement]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var cardAuthorization: JsonField<String>? = null
                private var cardPaymentId: JsonField<String>? = null
                private var cashback: JsonField<Cashback>? = null
                private var currency: JsonField<Currency>? = null
                private var interchange: JsonField<Interchange>? = null
                private var merchantAcceptorId: JsonField<String>? = null
                private var merchantCategoryCode: JsonField<String>? = null
                private var merchantCity: JsonField<String>? = null
                private var merchantCountry: JsonField<String>? = null
                private var merchantName: JsonField<String>? = null
                private var merchantPostalCode: JsonField<String>? = null
                private var merchantState: JsonField<String>? = null
                private var network: JsonField<Network>? = null
                private var networkIdentifiers: JsonField<NetworkIdentifiers>? = null
                private var pendingTransactionId: JsonField<String>? = null
                private var presentmentAmount: JsonField<Long>? = null
                private var presentmentCurrency: JsonField<String>? = null
                private var purchaseDetails: JsonField<PurchaseDetails>? = null
                private var transactionId: JsonField<String>? = null
                private var type: JsonField<Type>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cardSettlement: CardSettlement) = apply {
                    id = cardSettlement.id
                    amount = cardSettlement.amount
                    cardAuthorization = cardSettlement.cardAuthorization
                    cardPaymentId = cardSettlement.cardPaymentId
                    cashback = cardSettlement.cashback
                    currency = cardSettlement.currency
                    interchange = cardSettlement.interchange
                    merchantAcceptorId = cardSettlement.merchantAcceptorId
                    merchantCategoryCode = cardSettlement.merchantCategoryCode
                    merchantCity = cardSettlement.merchantCity
                    merchantCountry = cardSettlement.merchantCountry
                    merchantName = cardSettlement.merchantName
                    merchantPostalCode = cardSettlement.merchantPostalCode
                    merchantState = cardSettlement.merchantState
                    network = cardSettlement.network
                    networkIdentifiers = cardSettlement.networkIdentifiers
                    pendingTransactionId = cardSettlement.pendingTransactionId
                    presentmentAmount = cardSettlement.presentmentAmount
                    presentmentCurrency = cardSettlement.presentmentCurrency
                    purchaseDetails = cardSettlement.purchaseDetails
                    transactionId = cardSettlement.transactionId
                    type = cardSettlement.type
                    additionalProperties = cardSettlement.additionalProperties.toMutableMap()
                }

                /** The Card Settlement identifier. */
                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                /**
                 * The amount in the minor unit of the transaction's settlement currency. For
                 * dollars, for example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The Card Authorization that was created prior to this Card Settlement, if one
                 * exists.
                 */
                fun cardAuthorization(cardAuthorization: String?) =
                    cardAuthorization(JsonField.ofNullable(cardAuthorization))

                /**
                 * Sets [Builder.cardAuthorization] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cardAuthorization] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun cardAuthorization(cardAuthorization: JsonField<String>) = apply {
                    this.cardAuthorization = cardAuthorization
                }

                /** The ID of the Card Payment this transaction belongs to. */
                fun cardPaymentId(cardPaymentId: String) =
                    cardPaymentId(JsonField.of(cardPaymentId))

                /**
                 * Sets [Builder.cardPaymentId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cardPaymentId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun cardPaymentId(cardPaymentId: JsonField<String>) = apply {
                    this.cardPaymentId = cardPaymentId
                }

                /**
                 * Cashback earned on this transaction, if eligible. Cashback is paid out in
                 * aggregate, monthly.
                 */
                fun cashback(cashback: Cashback?) = cashback(JsonField.ofNullable(cashback))

                /**
                 * Sets [Builder.cashback] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.cashback] with a well-typed [Cashback] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun cashback(cashback: JsonField<Cashback>) = apply { this.cashback = cashback }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
                 * settlement currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** Interchange assessed as a part of this transaction. */
                fun interchange(interchange: Interchange?) =
                    interchange(JsonField.ofNullable(interchange))

                /**
                 * Sets [Builder.interchange] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.interchange] with a well-typed [Interchange]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun interchange(interchange: JsonField<Interchange>) = apply {
                    this.interchange = interchange
                }

                /**
                 * The merchant identifier (commonly abbreviated as MID) of the merchant the card is
                 * transacting with.
                 */
                fun merchantAcceptorId(merchantAcceptorId: String) =
                    merchantAcceptorId(JsonField.of(merchantAcceptorId))

                /**
                 * Sets [Builder.merchantAcceptorId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantAcceptorId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantAcceptorId(merchantAcceptorId: JsonField<String>) = apply {
                    this.merchantAcceptorId = merchantAcceptorId
                }

                /** The 4-digit MCC describing the merchant's business. */
                fun merchantCategoryCode(merchantCategoryCode: String) =
                    merchantCategoryCode(JsonField.of(merchantCategoryCode))

                /**
                 * Sets [Builder.merchantCategoryCode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantCategoryCode] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantCategoryCode(merchantCategoryCode: JsonField<String>) = apply {
                    this.merchantCategoryCode = merchantCategoryCode
                }

                /** The city the merchant resides in. */
                fun merchantCity(merchantCity: String) = merchantCity(JsonField.of(merchantCity))

                /**
                 * Sets [Builder.merchantCity] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantCity] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun merchantCity(merchantCity: JsonField<String>) = apply {
                    this.merchantCity = merchantCity
                }

                /** The country the merchant resides in. */
                fun merchantCountry(merchantCountry: String) =
                    merchantCountry(JsonField.of(merchantCountry))

                /**
                 * Sets [Builder.merchantCountry] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantCountry] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantCountry(merchantCountry: JsonField<String>) = apply {
                    this.merchantCountry = merchantCountry
                }

                /** The name of the merchant. */
                fun merchantName(merchantName: String) = merchantName(JsonField.of(merchantName))

                /**
                 * Sets [Builder.merchantName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantName] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun merchantName(merchantName: JsonField<String>) = apply {
                    this.merchantName = merchantName
                }

                /**
                 * The merchant's postal code. For US merchants this is always a 5-digit ZIP code.
                 */
                fun merchantPostalCode(merchantPostalCode: String?) =
                    merchantPostalCode(JsonField.ofNullable(merchantPostalCode))

                /**
                 * Sets [Builder.merchantPostalCode] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantPostalCode] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun merchantPostalCode(merchantPostalCode: JsonField<String>) = apply {
                    this.merchantPostalCode = merchantPostalCode
                }

                /** The state the merchant resides in. */
                fun merchantState(merchantState: String?) =
                    merchantState(JsonField.ofNullable(merchantState))

                /**
                 * Sets [Builder.merchantState] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantState] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun merchantState(merchantState: JsonField<String>) = apply {
                    this.merchantState = merchantState
                }

                /** The card network on which this transaction was processed. */
                fun network(network: Network) = network(JsonField.of(network))

                /**
                 * Sets [Builder.network] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.network] with a well-typed [Network] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun network(network: JsonField<Network>) = apply { this.network = network }

                /** Network-specific identifiers for this refund. */
                fun networkIdentifiers(networkIdentifiers: NetworkIdentifiers) =
                    networkIdentifiers(JsonField.of(networkIdentifiers))

                /**
                 * Sets [Builder.networkIdentifiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.networkIdentifiers] with a well-typed
                 * [NetworkIdentifiers] value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun networkIdentifiers(networkIdentifiers: JsonField<NetworkIdentifiers>) = apply {
                    this.networkIdentifiers = networkIdentifiers
                }

                /** The identifier of the Pending Transaction associated with this Transaction. */
                fun pendingTransactionId(pendingTransactionId: String?) =
                    pendingTransactionId(JsonField.ofNullable(pendingTransactionId))

                /**
                 * Sets [Builder.pendingTransactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.pendingTransactionId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun pendingTransactionId(pendingTransactionId: JsonField<String>) = apply {
                    this.pendingTransactionId = pendingTransactionId
                }

                /** The amount in the minor unit of the transaction's presentment currency. */
                fun presentmentAmount(presentmentAmount: Long) =
                    presentmentAmount(JsonField.of(presentmentAmount))

                /**
                 * Sets [Builder.presentmentAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.presentmentAmount] with a well-typed [Long]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun presentmentAmount(presentmentAmount: JsonField<Long>) = apply {
                    this.presentmentAmount = presentmentAmount
                }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
                 * presentment currency.
                 */
                fun presentmentCurrency(presentmentCurrency: String) =
                    presentmentCurrency(JsonField.of(presentmentCurrency))

                /**
                 * Sets [Builder.presentmentCurrency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.presentmentCurrency] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun presentmentCurrency(presentmentCurrency: JsonField<String>) = apply {
                    this.presentmentCurrency = presentmentCurrency
                }

                /**
                 * Additional details about the card purchase, such as tax and industry-specific
                 * fields.
                 */
                fun purchaseDetails(purchaseDetails: PurchaseDetails?) =
                    purchaseDetails(JsonField.ofNullable(purchaseDetails))

                /**
                 * Sets [Builder.purchaseDetails] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.purchaseDetails] with a well-typed
                 * [PurchaseDetails] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun purchaseDetails(purchaseDetails: JsonField<PurchaseDetails>) = apply {
                    this.purchaseDetails = purchaseDetails
                }

                /** The identifier of the Transaction associated with this Transaction. */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                /**
                 * A constant representing the object's type. For this resource it will always be
                 * `card_settlement`.
                 */
                fun type(type: Type) = type(JsonField.of(type))

                /**
                 * Sets [Builder.type] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.type] with a well-typed [Type] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun type(type: JsonField<Type>) = apply { this.type = type }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CardSettlement].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .id()
                 * .amount()
                 * .cardAuthorization()
                 * .cardPaymentId()
                 * .cashback()
                 * .currency()
                 * .interchange()
                 * .merchantAcceptorId()
                 * .merchantCategoryCode()
                 * .merchantCity()
                 * .merchantCountry()
                 * .merchantName()
                 * .merchantPostalCode()
                 * .merchantState()
                 * .network()
                 * .networkIdentifiers()
                 * .pendingTransactionId()
                 * .presentmentAmount()
                 * .presentmentCurrency()
                 * .purchaseDetails()
                 * .transactionId()
                 * .type()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CardSettlement =
                    CardSettlement(
                        checkRequired("id", id),
                        checkRequired("amount", amount),
                        checkRequired("cardAuthorization", cardAuthorization),
                        checkRequired("cardPaymentId", cardPaymentId),
                        checkRequired("cashback", cashback),
                        checkRequired("currency", currency),
                        checkRequired("interchange", interchange),
                        checkRequired("merchantAcceptorId", merchantAcceptorId),
                        checkRequired("merchantCategoryCode", merchantCategoryCode),
                        checkRequired("merchantCity", merchantCity),
                        checkRequired("merchantCountry", merchantCountry),
                        checkRequired("merchantName", merchantName),
                        checkRequired("merchantPostalCode", merchantPostalCode),
                        checkRequired("merchantState", merchantState),
                        checkRequired("network", network),
                        checkRequired("networkIdentifiers", networkIdentifiers),
                        checkRequired("pendingTransactionId", pendingTransactionId),
                        checkRequired("presentmentAmount", presentmentAmount),
                        checkRequired("presentmentCurrency", presentmentCurrency),
                        checkRequired("purchaseDetails", purchaseDetails),
                        checkRequired("transactionId", transactionId),
                        checkRequired("type", type),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CardSettlement = apply {
                if (validated) {
                    return@apply
                }

                id()
                amount()
                cardAuthorization()
                cardPaymentId()
                cashback()?.validate()
                currency().validate()
                interchange()?.validate()
                merchantAcceptorId()
                merchantCategoryCode()
                merchantCity()
                merchantCountry()
                merchantName()
                merchantPostalCode()
                merchantState()
                network().validate()
                networkIdentifiers().validate()
                pendingTransactionId()
                presentmentAmount()
                presentmentCurrency()
                purchaseDetails()?.validate()
                transactionId()
                type().validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (id.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (if (cardAuthorization.asKnown() == null) 0 else 1) +
                    (if (cardPaymentId.asKnown() == null) 0 else 1) +
                    (cashback.asKnown()?.validity() ?: 0) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (interchange.asKnown()?.validity() ?: 0) +
                    (if (merchantAcceptorId.asKnown() == null) 0 else 1) +
                    (if (merchantCategoryCode.asKnown() == null) 0 else 1) +
                    (if (merchantCity.asKnown() == null) 0 else 1) +
                    (if (merchantCountry.asKnown() == null) 0 else 1) +
                    (if (merchantName.asKnown() == null) 0 else 1) +
                    (if (merchantPostalCode.asKnown() == null) 0 else 1) +
                    (if (merchantState.asKnown() == null) 0 else 1) +
                    (network.asKnown()?.validity() ?: 0) +
                    (networkIdentifiers.asKnown()?.validity() ?: 0) +
                    (if (pendingTransactionId.asKnown() == null) 0 else 1) +
                    (if (presentmentAmount.asKnown() == null) 0 else 1) +
                    (if (presentmentCurrency.asKnown() == null) 0 else 1) +
                    (purchaseDetails.asKnown()?.validity() ?: 0) +
                    (if (transactionId.asKnown() == null) 0 else 1) +
                    (type.asKnown()?.validity() ?: 0)

            /**
             * Cashback earned on this transaction, if eligible. Cashback is paid out in aggregate,
             * monthly.
             */
            class Cashback
            private constructor(
                private val amount: JsonField<String>,
                private val currency: JsonField<Currency>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("amount")
                    @ExcludeMissing
                    amount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("currency")
                    @ExcludeMissing
                    currency: JsonField<Currency> = JsonMissing.of(),
                ) : this(amount, currency, mutableMapOf())

                /**
                 * The cashback amount given as a string containing a decimal number. The amount is
                 * a positive number if it will be credited to you (e.g., settlements) and a
                 * negative number if it will be debited (e.g., refunds).
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun amount(): String = amount.getRequired("amount")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the cashback.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun currency(): Currency = currency.getRequired("currency")

                /**
                 * Returns the raw JSON value of [amount].
                 *
                 * Unlike [amount], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<String> = amount

                /**
                 * Returns the raw JSON value of [currency].
                 *
                 * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun _currency(): JsonField<Currency> = currency

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Cashback].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .currency()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Cashback]. */
                class Builder internal constructor() {

                    private var amount: JsonField<String>? = null
                    private var currency: JsonField<Currency>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(cashback: Cashback) = apply {
                        amount = cashback.amount
                        currency = cashback.currency
                        additionalProperties = cashback.additionalProperties.toMutableMap()
                    }

                    /**
                     * The cashback amount given as a string containing a decimal number. The amount
                     * is a positive number if it will be credited to you (e.g., settlements) and a
                     * negative number if it will be debited (e.g., refunds).
                     */
                    fun amount(amount: String) = amount(JsonField.of(amount))

                    /**
                     * Sets [Builder.amount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.amount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun amount(amount: JsonField<String>) = apply { this.amount = amount }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the cashback.
                     */
                    fun currency(currency: Currency) = currency(JsonField.of(currency))

                    /**
                     * Sets [Builder.currency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.currency] with a well-typed [Currency] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Cashback].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .currency()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Cashback =
                        Cashback(
                            checkRequired("amount", amount),
                            checkRequired("currency", currency),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Cashback = apply {
                    if (validated) {
                        return@apply
                    }

                    amount()
                    currency().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (amount.asKnown() == null) 0 else 1) + (currency.asKnown()?.validity() ?: 0)

                /** The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the cashback. */
                class Currency
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Canadian Dollar (CAD) */
                        val CAD = of("CAD")

                        /** Swiss Franc (CHF) */
                        val CHF = of("CHF")

                        /** Euro (EUR) */
                        val EUR = of("EUR")

                        /** British Pound (GBP) */
                        val GBP = of("GBP")

                        /** Japanese Yen (JPY) */
                        val JPY = of("JPY")

                        /** US Dollar (USD) */
                        val USD = of("USD")

                        fun of(value: String) = Currency(JsonField.of(value))
                    }

                    /** An enum containing [Currency]'s known values. */
                    enum class Known {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                    }

                    /**
                     * An enum containing [Currency]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [Currency] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                        /**
                         * An enum member indicating that [Currency] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CAD -> Value.CAD
                            CHF -> Value.CHF
                            EUR -> Value.EUR
                            GBP -> Value.GBP
                            JPY -> Value.JPY
                            USD -> Value.USD
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CAD -> Known.CAD
                            CHF -> Known.CHF
                            EUR -> Known.EUR
                            GBP -> Known.GBP
                            JPY -> Known.JPY
                            USD -> Known.USD
                            else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Currency = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Currency && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Cashback &&
                        amount == other.amount &&
                        currency == other.currency &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(amount, currency, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Cashback{amount=$amount, currency=$currency, additionalProperties=$additionalProperties}"
            }

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * settlement currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /** Interchange assessed as a part of this transaction. */
            class Interchange
            private constructor(
                private val amount: JsonField<String>,
                private val code: JsonField<String>,
                private val currency: JsonField<Currency>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("amount")
                    @ExcludeMissing
                    amount: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("code")
                    @ExcludeMissing
                    code: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("currency")
                    @ExcludeMissing
                    currency: JsonField<Currency> = JsonMissing.of(),
                ) : this(amount, code, currency, mutableMapOf())

                /**
                 * The interchange amount given as a string containing a decimal number in major
                 * units (so e.g., "3.14" for $3.14). The amount is a positive number if it is
                 * credited to Increase (e.g., settlements) and a negative number if it is debited
                 * (e.g., refunds).
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun amount(): String = amount.getRequired("amount")

                /**
                 * The card network specific interchange code.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun code(): String? = code.getNullable("code")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the interchange
                 * reimbursement.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun currency(): Currency = currency.getRequired("currency")

                /**
                 * Returns the raw JSON value of [amount].
                 *
                 * Unlike [amount], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<String> = amount

                /**
                 * Returns the raw JSON value of [code].
                 *
                 * Unlike [code], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("code") @ExcludeMissing fun _code(): JsonField<String> = code

                /**
                 * Returns the raw JSON value of [currency].
                 *
                 * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("currency")
                @ExcludeMissing
                fun _currency(): JsonField<Currency> = currency

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Interchange].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .code()
                     * .currency()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Interchange]. */
                class Builder internal constructor() {

                    private var amount: JsonField<String>? = null
                    private var code: JsonField<String>? = null
                    private var currency: JsonField<Currency>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(interchange: Interchange) = apply {
                        amount = interchange.amount
                        code = interchange.code
                        currency = interchange.currency
                        additionalProperties = interchange.additionalProperties.toMutableMap()
                    }

                    /**
                     * The interchange amount given as a string containing a decimal number in major
                     * units (so e.g., "3.14" for $3.14). The amount is a positive number if it is
                     * credited to Increase (e.g., settlements) and a negative number if it is
                     * debited (e.g., refunds).
                     */
                    fun amount(amount: String) = amount(JsonField.of(amount))

                    /**
                     * Sets [Builder.amount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.amount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun amount(amount: JsonField<String>) = apply { this.amount = amount }

                    /** The card network specific interchange code. */
                    fun code(code: String?) = code(JsonField.ofNullable(code))

                    /**
                     * Sets [Builder.code] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.code] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun code(code: JsonField<String>) = apply { this.code = code }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                     * interchange reimbursement.
                     */
                    fun currency(currency: Currency) = currency(JsonField.of(currency))

                    /**
                     * Sets [Builder.currency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.currency] with a well-typed [Currency] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Interchange].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .amount()
                     * .code()
                     * .currency()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Interchange =
                        Interchange(
                            checkRequired("amount", amount),
                            checkRequired("code", code),
                            checkRequired("currency", currency),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Interchange = apply {
                    if (validated) {
                        return@apply
                    }

                    amount()
                    code()
                    currency().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (amount.asKnown() == null) 0 else 1) +
                        (if (code.asKnown() == null) 0 else 1) +
                        (currency.asKnown()?.validity() ?: 0)

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the interchange
                 * reimbursement.
                 */
                class Currency
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Canadian Dollar (CAD) */
                        val CAD = of("CAD")

                        /** Swiss Franc (CHF) */
                        val CHF = of("CHF")

                        /** Euro (EUR) */
                        val EUR = of("EUR")

                        /** British Pound (GBP) */
                        val GBP = of("GBP")

                        /** Japanese Yen (JPY) */
                        val JPY = of("JPY")

                        /** US Dollar (USD) */
                        val USD = of("USD")

                        fun of(value: String) = Currency(JsonField.of(value))
                    }

                    /** An enum containing [Currency]'s known values. */
                    enum class Known {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                    }

                    /**
                     * An enum containing [Currency]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [Currency] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Canadian Dollar (CAD) */
                        CAD,
                        /** Swiss Franc (CHF) */
                        CHF,
                        /** Euro (EUR) */
                        EUR,
                        /** British Pound (GBP) */
                        GBP,
                        /** Japanese Yen (JPY) */
                        JPY,
                        /** US Dollar (USD) */
                        USD,
                        /**
                         * An enum member indicating that [Currency] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CAD -> Value.CAD
                            CHF -> Value.CHF
                            EUR -> Value.EUR
                            GBP -> Value.GBP
                            JPY -> Value.JPY
                            USD -> Value.USD
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CAD -> Known.CAD
                            CHF -> Known.CHF
                            EUR -> Known.EUR
                            GBP -> Known.GBP
                            JPY -> Known.JPY
                            USD -> Known.USD
                            else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Currency = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Currency && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Interchange &&
                        amount == other.amount &&
                        code == other.code &&
                        currency == other.currency &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(amount, code, currency, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Interchange{amount=$amount, code=$code, currency=$currency, additionalProperties=$additionalProperties}"
            }

            /** The card network on which this transaction was processed. */
            class Network @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Visa */
                    val VISA = of("visa")

                    fun of(value: String) = Network(JsonField.of(value))
                }

                /** An enum containing [Network]'s known values. */
                enum class Known {
                    /** Visa */
                    VISA
                }

                /**
                 * An enum containing [Network]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Network] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Visa */
                    VISA,
                    /**
                     * An enum member indicating that [Network] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        VISA -> Value.VISA
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        VISA -> Known.VISA
                        else -> throw IncreaseInvalidDataException("Unknown Network: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Network = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Network && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /** Network-specific identifiers for this refund. */
            class NetworkIdentifiers
            private constructor(
                private val acquirerBusinessId: JsonField<String>,
                private val acquirerReferenceNumber: JsonField<String>,
                private val transactionId: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("acquirer_business_id")
                    @ExcludeMissing
                    acquirerBusinessId: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("acquirer_reference_number")
                    @ExcludeMissing
                    acquirerReferenceNumber: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("transaction_id")
                    @ExcludeMissing
                    transactionId: JsonField<String> = JsonMissing.of(),
                ) : this(acquirerBusinessId, acquirerReferenceNumber, transactionId, mutableMapOf())

                /**
                 * A network assigned business ID that identifies the acquirer that processed this
                 * transaction.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun acquirerBusinessId(): String =
                    acquirerBusinessId.getRequired("acquirer_business_id")

                /**
                 * A globally unique identifier for this settlement.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun acquirerReferenceNumber(): String =
                    acquirerReferenceNumber.getRequired("acquirer_reference_number")

                /**
                 * A globally unique transaction identifier provided by the card network, used
                 * across multiple life-cycle requests.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun transactionId(): String? = transactionId.getNullable("transaction_id")

                /**
                 * Returns the raw JSON value of [acquirerBusinessId].
                 *
                 * Unlike [acquirerBusinessId], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("acquirer_business_id")
                @ExcludeMissing
                fun _acquirerBusinessId(): JsonField<String> = acquirerBusinessId

                /**
                 * Returns the raw JSON value of [acquirerReferenceNumber].
                 *
                 * Unlike [acquirerReferenceNumber], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("acquirer_reference_number")
                @ExcludeMissing
                fun _acquirerReferenceNumber(): JsonField<String> = acquirerReferenceNumber

                /**
                 * Returns the raw JSON value of [transactionId].
                 *
                 * Unlike [transactionId], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("transaction_id")
                @ExcludeMissing
                fun _transactionId(): JsonField<String> = transactionId

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [NetworkIdentifiers].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .acquirerBusinessId()
                     * .acquirerReferenceNumber()
                     * .transactionId()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [NetworkIdentifiers]. */
                class Builder internal constructor() {

                    private var acquirerBusinessId: JsonField<String>? = null
                    private var acquirerReferenceNumber: JsonField<String>? = null
                    private var transactionId: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(networkIdentifiers: NetworkIdentifiers) = apply {
                        acquirerBusinessId = networkIdentifiers.acquirerBusinessId
                        acquirerReferenceNumber = networkIdentifiers.acquirerReferenceNumber
                        transactionId = networkIdentifiers.transactionId
                        additionalProperties =
                            networkIdentifiers.additionalProperties.toMutableMap()
                    }

                    /**
                     * A network assigned business ID that identifies the acquirer that processed
                     * this transaction.
                     */
                    fun acquirerBusinessId(acquirerBusinessId: String) =
                        acquirerBusinessId(JsonField.of(acquirerBusinessId))

                    /**
                     * Sets [Builder.acquirerBusinessId] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.acquirerBusinessId] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun acquirerBusinessId(acquirerBusinessId: JsonField<String>) = apply {
                        this.acquirerBusinessId = acquirerBusinessId
                    }

                    /** A globally unique identifier for this settlement. */
                    fun acquirerReferenceNumber(acquirerReferenceNumber: String) =
                        acquirerReferenceNumber(JsonField.of(acquirerReferenceNumber))

                    /**
                     * Sets [Builder.acquirerReferenceNumber] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.acquirerReferenceNumber] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun acquirerReferenceNumber(acquirerReferenceNumber: JsonField<String>) =
                        apply {
                            this.acquirerReferenceNumber = acquirerReferenceNumber
                        }

                    /**
                     * A globally unique transaction identifier provided by the card network, used
                     * across multiple life-cycle requests.
                     */
                    fun transactionId(transactionId: String?) =
                        transactionId(JsonField.ofNullable(transactionId))

                    /**
                     * Sets [Builder.transactionId] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.transactionId] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun transactionId(transactionId: JsonField<String>) = apply {
                        this.transactionId = transactionId
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [NetworkIdentifiers].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .acquirerBusinessId()
                     * .acquirerReferenceNumber()
                     * .transactionId()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): NetworkIdentifiers =
                        NetworkIdentifiers(
                            checkRequired("acquirerBusinessId", acquirerBusinessId),
                            checkRequired("acquirerReferenceNumber", acquirerReferenceNumber),
                            checkRequired("transactionId", transactionId),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): NetworkIdentifiers = apply {
                    if (validated) {
                        return@apply
                    }

                    acquirerBusinessId()
                    acquirerReferenceNumber()
                    transactionId()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (if (acquirerBusinessId.asKnown() == null) 0 else 1) +
                        (if (acquirerReferenceNumber.asKnown() == null) 0 else 1) +
                        (if (transactionId.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is NetworkIdentifiers &&
                        acquirerBusinessId == other.acquirerBusinessId &&
                        acquirerReferenceNumber == other.acquirerReferenceNumber &&
                        transactionId == other.transactionId &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        acquirerBusinessId,
                        acquirerReferenceNumber,
                        transactionId,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "NetworkIdentifiers{acquirerBusinessId=$acquirerBusinessId, acquirerReferenceNumber=$acquirerReferenceNumber, transactionId=$transactionId, additionalProperties=$additionalProperties}"
            }

            /**
             * Additional details about the card purchase, such as tax and industry-specific fields.
             */
            class PurchaseDetails
            private constructor(
                private val carRental: JsonField<CarRental>,
                private val customerReferenceIdentifier: JsonField<String>,
                private val localTaxAmount: JsonField<Long>,
                private val localTaxCurrency: JsonField<String>,
                private val lodging: JsonField<Lodging>,
                private val nationalTaxAmount: JsonField<Long>,
                private val nationalTaxCurrency: JsonField<String>,
                private val purchaseIdentifier: JsonField<String>,
                private val purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat>,
                private val travel: JsonField<Travel>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("car_rental")
                    @ExcludeMissing
                    carRental: JsonField<CarRental> = JsonMissing.of(),
                    @JsonProperty("customer_reference_identifier")
                    @ExcludeMissing
                    customerReferenceIdentifier: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("local_tax_amount")
                    @ExcludeMissing
                    localTaxAmount: JsonField<Long> = JsonMissing.of(),
                    @JsonProperty("local_tax_currency")
                    @ExcludeMissing
                    localTaxCurrency: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("lodging")
                    @ExcludeMissing
                    lodging: JsonField<Lodging> = JsonMissing.of(),
                    @JsonProperty("national_tax_amount")
                    @ExcludeMissing
                    nationalTaxAmount: JsonField<Long> = JsonMissing.of(),
                    @JsonProperty("national_tax_currency")
                    @ExcludeMissing
                    nationalTaxCurrency: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("purchase_identifier")
                    @ExcludeMissing
                    purchaseIdentifier: JsonField<String> = JsonMissing.of(),
                    @JsonProperty("purchase_identifier_format")
                    @ExcludeMissing
                    purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat> =
                        JsonMissing.of(),
                    @JsonProperty("travel")
                    @ExcludeMissing
                    travel: JsonField<Travel> = JsonMissing.of(),
                ) : this(
                    carRental,
                    customerReferenceIdentifier,
                    localTaxAmount,
                    localTaxCurrency,
                    lodging,
                    nationalTaxAmount,
                    nationalTaxCurrency,
                    purchaseIdentifier,
                    purchaseIdentifierFormat,
                    travel,
                    mutableMapOf(),
                )

                /**
                 * Fields specific to car rentals.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun carRental(): CarRental? = carRental.getNullable("car_rental")

                /**
                 * An identifier from the merchant for the customer or consumer.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun customerReferenceIdentifier(): String? =
                    customerReferenceIdentifier.getNullable("customer_reference_identifier")

                /**
                 * The state or provincial tax amount in minor units.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun localTaxAmount(): Long? = localTaxAmount.getNullable("local_tax_amount")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                 * assessed.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun localTaxCurrency(): String? = localTaxCurrency.getNullable("local_tax_currency")

                /**
                 * Fields specific to lodging.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun lodging(): Lodging? = lodging.getNullable("lodging")

                /**
                 * The national tax amount in minor units.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun nationalTaxAmount(): Long? =
                    nationalTaxAmount.getNullable("national_tax_amount")

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                 * assessed.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun nationalTaxCurrency(): String? =
                    nationalTaxCurrency.getNullable("national_tax_currency")

                /**
                 * An identifier from the merchant for the purchase to the issuer and cardholder.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun purchaseIdentifier(): String? =
                    purchaseIdentifier.getNullable("purchase_identifier")

                /**
                 * The format of the purchase identifier.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun purchaseIdentifierFormat(): PurchaseIdentifierFormat? =
                    purchaseIdentifierFormat.getNullable("purchase_identifier_format")

                /**
                 * Fields specific to travel.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun travel(): Travel? = travel.getNullable("travel")

                /**
                 * Returns the raw JSON value of [carRental].
                 *
                 * Unlike [carRental], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("car_rental")
                @ExcludeMissing
                fun _carRental(): JsonField<CarRental> = carRental

                /**
                 * Returns the raw JSON value of [customerReferenceIdentifier].
                 *
                 * Unlike [customerReferenceIdentifier], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("customer_reference_identifier")
                @ExcludeMissing
                fun _customerReferenceIdentifier(): JsonField<String> = customerReferenceIdentifier

                /**
                 * Returns the raw JSON value of [localTaxAmount].
                 *
                 * Unlike [localTaxAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("local_tax_amount")
                @ExcludeMissing
                fun _localTaxAmount(): JsonField<Long> = localTaxAmount

                /**
                 * Returns the raw JSON value of [localTaxCurrency].
                 *
                 * Unlike [localTaxCurrency], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("local_tax_currency")
                @ExcludeMissing
                fun _localTaxCurrency(): JsonField<String> = localTaxCurrency

                /**
                 * Returns the raw JSON value of [lodging].
                 *
                 * Unlike [lodging], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("lodging")
                @ExcludeMissing
                fun _lodging(): JsonField<Lodging> = lodging

                /**
                 * Returns the raw JSON value of [nationalTaxAmount].
                 *
                 * Unlike [nationalTaxAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("national_tax_amount")
                @ExcludeMissing
                fun _nationalTaxAmount(): JsonField<Long> = nationalTaxAmount

                /**
                 * Returns the raw JSON value of [nationalTaxCurrency].
                 *
                 * Unlike [nationalTaxCurrency], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("national_tax_currency")
                @ExcludeMissing
                fun _nationalTaxCurrency(): JsonField<String> = nationalTaxCurrency

                /**
                 * Returns the raw JSON value of [purchaseIdentifier].
                 *
                 * Unlike [purchaseIdentifier], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("purchase_identifier")
                @ExcludeMissing
                fun _purchaseIdentifier(): JsonField<String> = purchaseIdentifier

                /**
                 * Returns the raw JSON value of [purchaseIdentifierFormat].
                 *
                 * Unlike [purchaseIdentifierFormat], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("purchase_identifier_format")
                @ExcludeMissing
                fun _purchaseIdentifierFormat(): JsonField<PurchaseIdentifierFormat> =
                    purchaseIdentifierFormat

                /**
                 * Returns the raw JSON value of [travel].
                 *
                 * Unlike [travel], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("travel") @ExcludeMissing fun _travel(): JsonField<Travel> = travel

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [PurchaseDetails].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .carRental()
                     * .customerReferenceIdentifier()
                     * .localTaxAmount()
                     * .localTaxCurrency()
                     * .lodging()
                     * .nationalTaxAmount()
                     * .nationalTaxCurrency()
                     * .purchaseIdentifier()
                     * .purchaseIdentifierFormat()
                     * .travel()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [PurchaseDetails]. */
                class Builder internal constructor() {

                    private var carRental: JsonField<CarRental>? = null
                    private var customerReferenceIdentifier: JsonField<String>? = null
                    private var localTaxAmount: JsonField<Long>? = null
                    private var localTaxCurrency: JsonField<String>? = null
                    private var lodging: JsonField<Lodging>? = null
                    private var nationalTaxAmount: JsonField<Long>? = null
                    private var nationalTaxCurrency: JsonField<String>? = null
                    private var purchaseIdentifier: JsonField<String>? = null
                    private var purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat>? =
                        null
                    private var travel: JsonField<Travel>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(purchaseDetails: PurchaseDetails) = apply {
                        carRental = purchaseDetails.carRental
                        customerReferenceIdentifier = purchaseDetails.customerReferenceIdentifier
                        localTaxAmount = purchaseDetails.localTaxAmount
                        localTaxCurrency = purchaseDetails.localTaxCurrency
                        lodging = purchaseDetails.lodging
                        nationalTaxAmount = purchaseDetails.nationalTaxAmount
                        nationalTaxCurrency = purchaseDetails.nationalTaxCurrency
                        purchaseIdentifier = purchaseDetails.purchaseIdentifier
                        purchaseIdentifierFormat = purchaseDetails.purchaseIdentifierFormat
                        travel = purchaseDetails.travel
                        additionalProperties = purchaseDetails.additionalProperties.toMutableMap()
                    }

                    /** Fields specific to car rentals. */
                    fun carRental(carRental: CarRental?) =
                        carRental(JsonField.ofNullable(carRental))

                    /**
                     * Sets [Builder.carRental] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.carRental] with a well-typed [CarRental]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun carRental(carRental: JsonField<CarRental>) = apply {
                        this.carRental = carRental
                    }

                    /** An identifier from the merchant for the customer or consumer. */
                    fun customerReferenceIdentifier(customerReferenceIdentifier: String?) =
                        customerReferenceIdentifier(
                            JsonField.ofNullable(customerReferenceIdentifier)
                        )

                    /**
                     * Sets [Builder.customerReferenceIdentifier] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.customerReferenceIdentifier] with a
                     * well-typed [String] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun customerReferenceIdentifier(
                        customerReferenceIdentifier: JsonField<String>
                    ) = apply { this.customerReferenceIdentifier = customerReferenceIdentifier }

                    /** The state or provincial tax amount in minor units. */
                    fun localTaxAmount(localTaxAmount: Long?) =
                        localTaxAmount(JsonField.ofNullable(localTaxAmount))

                    /**
                     * Alias for [Builder.localTaxAmount].
                     *
                     * This unboxed primitive overload exists for backwards compatibility.
                     */
                    fun localTaxAmount(localTaxAmount: Long) =
                        localTaxAmount(localTaxAmount as Long?)

                    /**
                     * Sets [Builder.localTaxAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.localTaxAmount] with a well-typed [Long]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun localTaxAmount(localTaxAmount: JsonField<Long>) = apply {
                        this.localTaxAmount = localTaxAmount
                    }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                     * assessed.
                     */
                    fun localTaxCurrency(localTaxCurrency: String?) =
                        localTaxCurrency(JsonField.ofNullable(localTaxCurrency))

                    /**
                     * Sets [Builder.localTaxCurrency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.localTaxCurrency] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun localTaxCurrency(localTaxCurrency: JsonField<String>) = apply {
                        this.localTaxCurrency = localTaxCurrency
                    }

                    /** Fields specific to lodging. */
                    fun lodging(lodging: Lodging?) = lodging(JsonField.ofNullable(lodging))

                    /**
                     * Sets [Builder.lodging] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.lodging] with a well-typed [Lodging] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun lodging(lodging: JsonField<Lodging>) = apply { this.lodging = lodging }

                    /** The national tax amount in minor units. */
                    fun nationalTaxAmount(nationalTaxAmount: Long?) =
                        nationalTaxAmount(JsonField.ofNullable(nationalTaxAmount))

                    /**
                     * Alias for [Builder.nationalTaxAmount].
                     *
                     * This unboxed primitive overload exists for backwards compatibility.
                     */
                    fun nationalTaxAmount(nationalTaxAmount: Long) =
                        nationalTaxAmount(nationalTaxAmount as Long?)

                    /**
                     * Sets [Builder.nationalTaxAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.nationalTaxAmount] with a well-typed [Long]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun nationalTaxAmount(nationalTaxAmount: JsonField<Long>) = apply {
                        this.nationalTaxAmount = nationalTaxAmount
                    }

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the local tax
                     * assessed.
                     */
                    fun nationalTaxCurrency(nationalTaxCurrency: String?) =
                        nationalTaxCurrency(JsonField.ofNullable(nationalTaxCurrency))

                    /**
                     * Sets [Builder.nationalTaxCurrency] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.nationalTaxCurrency] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun nationalTaxCurrency(nationalTaxCurrency: JsonField<String>) = apply {
                        this.nationalTaxCurrency = nationalTaxCurrency
                    }

                    /**
                     * An identifier from the merchant for the purchase to the issuer and
                     * cardholder.
                     */
                    fun purchaseIdentifier(purchaseIdentifier: String?) =
                        purchaseIdentifier(JsonField.ofNullable(purchaseIdentifier))

                    /**
                     * Sets [Builder.purchaseIdentifier] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseIdentifier] with a well-typed
                     * [String] value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun purchaseIdentifier(purchaseIdentifier: JsonField<String>) = apply {
                        this.purchaseIdentifier = purchaseIdentifier
                    }

                    /** The format of the purchase identifier. */
                    fun purchaseIdentifierFormat(
                        purchaseIdentifierFormat: PurchaseIdentifierFormat?
                    ) = purchaseIdentifierFormat(JsonField.ofNullable(purchaseIdentifierFormat))

                    /**
                     * Sets [Builder.purchaseIdentifierFormat] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.purchaseIdentifierFormat] with a well-typed
                     * [PurchaseIdentifierFormat] value instead. This method is primarily for
                     * setting the field to an undocumented or not yet supported value.
                     */
                    fun purchaseIdentifierFormat(
                        purchaseIdentifierFormat: JsonField<PurchaseIdentifierFormat>
                    ) = apply { this.purchaseIdentifierFormat = purchaseIdentifierFormat }

                    /** Fields specific to travel. */
                    fun travel(travel: Travel?) = travel(JsonField.ofNullable(travel))

                    /**
                     * Sets [Builder.travel] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.travel] with a well-typed [Travel] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun travel(travel: JsonField<Travel>) = apply { this.travel = travel }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [PurchaseDetails].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .carRental()
                     * .customerReferenceIdentifier()
                     * .localTaxAmount()
                     * .localTaxCurrency()
                     * .lodging()
                     * .nationalTaxAmount()
                     * .nationalTaxCurrency()
                     * .purchaseIdentifier()
                     * .purchaseIdentifierFormat()
                     * .travel()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): PurchaseDetails =
                        PurchaseDetails(
                            checkRequired("carRental", carRental),
                            checkRequired(
                                "customerReferenceIdentifier",
                                customerReferenceIdentifier,
                            ),
                            checkRequired("localTaxAmount", localTaxAmount),
                            checkRequired("localTaxCurrency", localTaxCurrency),
                            checkRequired("lodging", lodging),
                            checkRequired("nationalTaxAmount", nationalTaxAmount),
                            checkRequired("nationalTaxCurrency", nationalTaxCurrency),
                            checkRequired("purchaseIdentifier", purchaseIdentifier),
                            checkRequired("purchaseIdentifierFormat", purchaseIdentifierFormat),
                            checkRequired("travel", travel),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): PurchaseDetails = apply {
                    if (validated) {
                        return@apply
                    }

                    carRental()?.validate()
                    customerReferenceIdentifier()
                    localTaxAmount()
                    localTaxCurrency()
                    lodging()?.validate()
                    nationalTaxAmount()
                    nationalTaxCurrency()
                    purchaseIdentifier()
                    purchaseIdentifierFormat()?.validate()
                    travel()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (carRental.asKnown()?.validity() ?: 0) +
                        (if (customerReferenceIdentifier.asKnown() == null) 0 else 1) +
                        (if (localTaxAmount.asKnown() == null) 0 else 1) +
                        (if (localTaxCurrency.asKnown() == null) 0 else 1) +
                        (lodging.asKnown()?.validity() ?: 0) +
                        (if (nationalTaxAmount.asKnown() == null) 0 else 1) +
                        (if (nationalTaxCurrency.asKnown() == null) 0 else 1) +
                        (if (purchaseIdentifier.asKnown() == null) 0 else 1) +
                        (purchaseIdentifierFormat.asKnown()?.validity() ?: 0) +
                        (travel.asKnown()?.validity() ?: 0)

                /** Fields specific to car rentals. */
                class CarRental
                private constructor(
                    private val carClassCode: JsonField<String>,
                    private val checkoutDate: JsonField<LocalDate>,
                    private val dailyRentalRateAmount: JsonField<Long>,
                    private val dailyRentalRateCurrency: JsonField<String>,
                    private val daysRented: JsonField<Long>,
                    private val extraCharges: JsonField<ExtraCharges>,
                    private val fuelChargesAmount: JsonField<Long>,
                    private val fuelChargesCurrency: JsonField<String>,
                    private val insuranceChargesAmount: JsonField<Long>,
                    private val insuranceChargesCurrency: JsonField<String>,
                    private val noShowIndicator: JsonField<NoShowIndicator>,
                    private val oneWayDropOffChargesAmount: JsonField<Long>,
                    private val oneWayDropOffChargesCurrency: JsonField<String>,
                    private val renterName: JsonField<String>,
                    private val weeklyRentalRateAmount: JsonField<Long>,
                    private val weeklyRentalRateCurrency: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("car_class_code")
                        @ExcludeMissing
                        carClassCode: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("checkout_date")
                        @ExcludeMissing
                        checkoutDate: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("daily_rental_rate_amount")
                        @ExcludeMissing
                        dailyRentalRateAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("daily_rental_rate_currency")
                        @ExcludeMissing
                        dailyRentalRateCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("days_rented")
                        @ExcludeMissing
                        daysRented: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("extra_charges")
                        @ExcludeMissing
                        extraCharges: JsonField<ExtraCharges> = JsonMissing.of(),
                        @JsonProperty("fuel_charges_amount")
                        @ExcludeMissing
                        fuelChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("fuel_charges_currency")
                        @ExcludeMissing
                        fuelChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("insurance_charges_amount")
                        @ExcludeMissing
                        insuranceChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("insurance_charges_currency")
                        @ExcludeMissing
                        insuranceChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("no_show_indicator")
                        @ExcludeMissing
                        noShowIndicator: JsonField<NoShowIndicator> = JsonMissing.of(),
                        @JsonProperty("one_way_drop_off_charges_amount")
                        @ExcludeMissing
                        oneWayDropOffChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("one_way_drop_off_charges_currency")
                        @ExcludeMissing
                        oneWayDropOffChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("renter_name")
                        @ExcludeMissing
                        renterName: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("weekly_rental_rate_amount")
                        @ExcludeMissing
                        weeklyRentalRateAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("weekly_rental_rate_currency")
                        @ExcludeMissing
                        weeklyRentalRateCurrency: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        carClassCode,
                        checkoutDate,
                        dailyRentalRateAmount,
                        dailyRentalRateCurrency,
                        daysRented,
                        extraCharges,
                        fuelChargesAmount,
                        fuelChargesCurrency,
                        insuranceChargesAmount,
                        insuranceChargesCurrency,
                        noShowIndicator,
                        oneWayDropOffChargesAmount,
                        oneWayDropOffChargesCurrency,
                        renterName,
                        weeklyRentalRateAmount,
                        weeklyRentalRateCurrency,
                        mutableMapOf(),
                    )

                    /**
                     * Code indicating the vehicle's class.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun carClassCode(): String? = carClassCode.getNullable("car_class_code")

                    /**
                     * Date the customer picked up the car or, in the case of a no-show or pre-pay
                     * transaction, the scheduled pick up date.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun checkoutDate(): LocalDate? = checkoutDate.getNullable("checkout_date")

                    /**
                     * Daily rate being charged for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRentalRateAmount(): Long? =
                        dailyRentalRateAmount.getNullable("daily_rental_rate_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                     * rental rate.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRentalRateCurrency(): String? =
                        dailyRentalRateCurrency.getNullable("daily_rental_rate_currency")

                    /**
                     * Number of days the vehicle was rented.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun daysRented(): Long? = daysRented.getNullable("days_rented")

                    /**
                     * Additional charges (gas, late fee, etc.) being billed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun extraCharges(): ExtraCharges? = extraCharges.getNullable("extra_charges")

                    /**
                     * Fuel charges for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun fuelChargesAmount(): Long? =
                        fuelChargesAmount.getNullable("fuel_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the fuel
                     * charges assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun fuelChargesCurrency(): String? =
                        fuelChargesCurrency.getNullable("fuel_charges_currency")

                    /**
                     * Any insurance being charged for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun insuranceChargesAmount(): Long? =
                        insuranceChargesAmount.getNullable("insurance_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the insurance
                     * charges assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun insuranceChargesCurrency(): String? =
                        insuranceChargesCurrency.getNullable("insurance_charges_currency")

                    /**
                     * An indicator that the cardholder is being billed for a reserved vehicle that
                     * was not actually rented (that is, a "no-show" charge).
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun noShowIndicator(): NoShowIndicator? =
                        noShowIndicator.getNullable("no_show_indicator")

                    /**
                     * Charges for returning the vehicle at a different location than where it was
                     * picked up.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun oneWayDropOffChargesAmount(): Long? =
                        oneWayDropOffChargesAmount.getNullable("one_way_drop_off_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the one-way
                     * drop-off charges assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun oneWayDropOffChargesCurrency(): String? =
                        oneWayDropOffChargesCurrency.getNullable(
                            "one_way_drop_off_charges_currency"
                        )

                    /**
                     * Name of the person renting the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun renterName(): String? = renterName.getNullable("renter_name")

                    /**
                     * Weekly rate being charged for the vehicle.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun weeklyRentalRateAmount(): Long? =
                        weeklyRentalRateAmount.getNullable("weekly_rental_rate_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the weekly
                     * rental rate.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun weeklyRentalRateCurrency(): String? =
                        weeklyRentalRateCurrency.getNullable("weekly_rental_rate_currency")

                    /**
                     * Returns the raw JSON value of [carClassCode].
                     *
                     * Unlike [carClassCode], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("car_class_code")
                    @ExcludeMissing
                    fun _carClassCode(): JsonField<String> = carClassCode

                    /**
                     * Returns the raw JSON value of [checkoutDate].
                     *
                     * Unlike [checkoutDate], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("checkout_date")
                    @ExcludeMissing
                    fun _checkoutDate(): JsonField<LocalDate> = checkoutDate

                    /**
                     * Returns the raw JSON value of [dailyRentalRateAmount].
                     *
                     * Unlike [dailyRentalRateAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("daily_rental_rate_amount")
                    @ExcludeMissing
                    fun _dailyRentalRateAmount(): JsonField<Long> = dailyRentalRateAmount

                    /**
                     * Returns the raw JSON value of [dailyRentalRateCurrency].
                     *
                     * Unlike [dailyRentalRateCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("daily_rental_rate_currency")
                    @ExcludeMissing
                    fun _dailyRentalRateCurrency(): JsonField<String> = dailyRentalRateCurrency

                    /**
                     * Returns the raw JSON value of [daysRented].
                     *
                     * Unlike [daysRented], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("days_rented")
                    @ExcludeMissing
                    fun _daysRented(): JsonField<Long> = daysRented

                    /**
                     * Returns the raw JSON value of [extraCharges].
                     *
                     * Unlike [extraCharges], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("extra_charges")
                    @ExcludeMissing
                    fun _extraCharges(): JsonField<ExtraCharges> = extraCharges

                    /**
                     * Returns the raw JSON value of [fuelChargesAmount].
                     *
                     * Unlike [fuelChargesAmount], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("fuel_charges_amount")
                    @ExcludeMissing
                    fun _fuelChargesAmount(): JsonField<Long> = fuelChargesAmount

                    /**
                     * Returns the raw JSON value of [fuelChargesCurrency].
                     *
                     * Unlike [fuelChargesCurrency], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("fuel_charges_currency")
                    @ExcludeMissing
                    fun _fuelChargesCurrency(): JsonField<String> = fuelChargesCurrency

                    /**
                     * Returns the raw JSON value of [insuranceChargesAmount].
                     *
                     * Unlike [insuranceChargesAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("insurance_charges_amount")
                    @ExcludeMissing
                    fun _insuranceChargesAmount(): JsonField<Long> = insuranceChargesAmount

                    /**
                     * Returns the raw JSON value of [insuranceChargesCurrency].
                     *
                     * Unlike [insuranceChargesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("insurance_charges_currency")
                    @ExcludeMissing
                    fun _insuranceChargesCurrency(): JsonField<String> = insuranceChargesCurrency

                    /**
                     * Returns the raw JSON value of [noShowIndicator].
                     *
                     * Unlike [noShowIndicator], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("no_show_indicator")
                    @ExcludeMissing
                    fun _noShowIndicator(): JsonField<NoShowIndicator> = noShowIndicator

                    /**
                     * Returns the raw JSON value of [oneWayDropOffChargesAmount].
                     *
                     * Unlike [oneWayDropOffChargesAmount], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("one_way_drop_off_charges_amount")
                    @ExcludeMissing
                    fun _oneWayDropOffChargesAmount(): JsonField<Long> = oneWayDropOffChargesAmount

                    /**
                     * Returns the raw JSON value of [oneWayDropOffChargesCurrency].
                     *
                     * Unlike [oneWayDropOffChargesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("one_way_drop_off_charges_currency")
                    @ExcludeMissing
                    fun _oneWayDropOffChargesCurrency(): JsonField<String> =
                        oneWayDropOffChargesCurrency

                    /**
                     * Returns the raw JSON value of [renterName].
                     *
                     * Unlike [renterName], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("renter_name")
                    @ExcludeMissing
                    fun _renterName(): JsonField<String> = renterName

                    /**
                     * Returns the raw JSON value of [weeklyRentalRateAmount].
                     *
                     * Unlike [weeklyRentalRateAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("weekly_rental_rate_amount")
                    @ExcludeMissing
                    fun _weeklyRentalRateAmount(): JsonField<Long> = weeklyRentalRateAmount

                    /**
                     * Returns the raw JSON value of [weeklyRentalRateCurrency].
                     *
                     * Unlike [weeklyRentalRateCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("weekly_rental_rate_currency")
                    @ExcludeMissing
                    fun _weeklyRentalRateCurrency(): JsonField<String> = weeklyRentalRateCurrency

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [CarRental].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .carClassCode()
                         * .checkoutDate()
                         * .dailyRentalRateAmount()
                         * .dailyRentalRateCurrency()
                         * .daysRented()
                         * .extraCharges()
                         * .fuelChargesAmount()
                         * .fuelChargesCurrency()
                         * .insuranceChargesAmount()
                         * .insuranceChargesCurrency()
                         * .noShowIndicator()
                         * .oneWayDropOffChargesAmount()
                         * .oneWayDropOffChargesCurrency()
                         * .renterName()
                         * .weeklyRentalRateAmount()
                         * .weeklyRentalRateCurrency()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CarRental]. */
                    class Builder internal constructor() {

                        private var carClassCode: JsonField<String>? = null
                        private var checkoutDate: JsonField<LocalDate>? = null
                        private var dailyRentalRateAmount: JsonField<Long>? = null
                        private var dailyRentalRateCurrency: JsonField<String>? = null
                        private var daysRented: JsonField<Long>? = null
                        private var extraCharges: JsonField<ExtraCharges>? = null
                        private var fuelChargesAmount: JsonField<Long>? = null
                        private var fuelChargesCurrency: JsonField<String>? = null
                        private var insuranceChargesAmount: JsonField<Long>? = null
                        private var insuranceChargesCurrency: JsonField<String>? = null
                        private var noShowIndicator: JsonField<NoShowIndicator>? = null
                        private var oneWayDropOffChargesAmount: JsonField<Long>? = null
                        private var oneWayDropOffChargesCurrency: JsonField<String>? = null
                        private var renterName: JsonField<String>? = null
                        private var weeklyRentalRateAmount: JsonField<Long>? = null
                        private var weeklyRentalRateCurrency: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(carRental: CarRental) = apply {
                            carClassCode = carRental.carClassCode
                            checkoutDate = carRental.checkoutDate
                            dailyRentalRateAmount = carRental.dailyRentalRateAmount
                            dailyRentalRateCurrency = carRental.dailyRentalRateCurrency
                            daysRented = carRental.daysRented
                            extraCharges = carRental.extraCharges
                            fuelChargesAmount = carRental.fuelChargesAmount
                            fuelChargesCurrency = carRental.fuelChargesCurrency
                            insuranceChargesAmount = carRental.insuranceChargesAmount
                            insuranceChargesCurrency = carRental.insuranceChargesCurrency
                            noShowIndicator = carRental.noShowIndicator
                            oneWayDropOffChargesAmount = carRental.oneWayDropOffChargesAmount
                            oneWayDropOffChargesCurrency = carRental.oneWayDropOffChargesCurrency
                            renterName = carRental.renterName
                            weeklyRentalRateAmount = carRental.weeklyRentalRateAmount
                            weeklyRentalRateCurrency = carRental.weeklyRentalRateCurrency
                            additionalProperties = carRental.additionalProperties.toMutableMap()
                        }

                        /** Code indicating the vehicle's class. */
                        fun carClassCode(carClassCode: String?) =
                            carClassCode(JsonField.ofNullable(carClassCode))

                        /**
                         * Sets [Builder.carClassCode] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.carClassCode] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun carClassCode(carClassCode: JsonField<String>) = apply {
                            this.carClassCode = carClassCode
                        }

                        /**
                         * Date the customer picked up the car or, in the case of a no-show or
                         * pre-pay transaction, the scheduled pick up date.
                         */
                        fun checkoutDate(checkoutDate: LocalDate?) =
                            checkoutDate(JsonField.ofNullable(checkoutDate))

                        /**
                         * Sets [Builder.checkoutDate] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.checkoutDate] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun checkoutDate(checkoutDate: JsonField<LocalDate>) = apply {
                            this.checkoutDate = checkoutDate
                        }

                        /** Daily rate being charged for the vehicle. */
                        fun dailyRentalRateAmount(dailyRentalRateAmount: Long?) =
                            dailyRentalRateAmount(JsonField.ofNullable(dailyRentalRateAmount))

                        /**
                         * Alias for [Builder.dailyRentalRateAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun dailyRentalRateAmount(dailyRentalRateAmount: Long) =
                            dailyRentalRateAmount(dailyRentalRateAmount as Long?)

                        /**
                         * Sets [Builder.dailyRentalRateAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRentalRateAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun dailyRentalRateAmount(dailyRentalRateAmount: JsonField<Long>) = apply {
                            this.dailyRentalRateAmount = dailyRentalRateAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                         * rental rate.
                         */
                        fun dailyRentalRateCurrency(dailyRentalRateCurrency: String?) =
                            dailyRentalRateCurrency(JsonField.ofNullable(dailyRentalRateCurrency))

                        /**
                         * Sets [Builder.dailyRentalRateCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRentalRateCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun dailyRentalRateCurrency(dailyRentalRateCurrency: JsonField<String>) =
                            apply {
                                this.dailyRentalRateCurrency = dailyRentalRateCurrency
                            }

                        /** Number of days the vehicle was rented. */
                        fun daysRented(daysRented: Long?) =
                            daysRented(JsonField.ofNullable(daysRented))

                        /**
                         * Alias for [Builder.daysRented].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun daysRented(daysRented: Long) = daysRented(daysRented as Long?)

                        /**
                         * Sets [Builder.daysRented] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.daysRented] with a well-typed [Long]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun daysRented(daysRented: JsonField<Long>) = apply {
                            this.daysRented = daysRented
                        }

                        /** Additional charges (gas, late fee, etc.) being billed. */
                        fun extraCharges(extraCharges: ExtraCharges?) =
                            extraCharges(JsonField.ofNullable(extraCharges))

                        /**
                         * Sets [Builder.extraCharges] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.extraCharges] with a well-typed
                         * [ExtraCharges] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun extraCharges(extraCharges: JsonField<ExtraCharges>) = apply {
                            this.extraCharges = extraCharges
                        }

                        /** Fuel charges for the vehicle. */
                        fun fuelChargesAmount(fuelChargesAmount: Long?) =
                            fuelChargesAmount(JsonField.ofNullable(fuelChargesAmount))

                        /**
                         * Alias for [Builder.fuelChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun fuelChargesAmount(fuelChargesAmount: Long) =
                            fuelChargesAmount(fuelChargesAmount as Long?)

                        /**
                         * Sets [Builder.fuelChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.fuelChargesAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun fuelChargesAmount(fuelChargesAmount: JsonField<Long>) = apply {
                            this.fuelChargesAmount = fuelChargesAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the fuel
                         * charges assessed.
                         */
                        fun fuelChargesCurrency(fuelChargesCurrency: String?) =
                            fuelChargesCurrency(JsonField.ofNullable(fuelChargesCurrency))

                        /**
                         * Sets [Builder.fuelChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.fuelChargesCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun fuelChargesCurrency(fuelChargesCurrency: JsonField<String>) = apply {
                            this.fuelChargesCurrency = fuelChargesCurrency
                        }

                        /** Any insurance being charged for the vehicle. */
                        fun insuranceChargesAmount(insuranceChargesAmount: Long?) =
                            insuranceChargesAmount(JsonField.ofNullable(insuranceChargesAmount))

                        /**
                         * Alias for [Builder.insuranceChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun insuranceChargesAmount(insuranceChargesAmount: Long) =
                            insuranceChargesAmount(insuranceChargesAmount as Long?)

                        /**
                         * Sets [Builder.insuranceChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.insuranceChargesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun insuranceChargesAmount(insuranceChargesAmount: JsonField<Long>) =
                            apply {
                                this.insuranceChargesAmount = insuranceChargesAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * insurance charges assessed.
                         */
                        fun insuranceChargesCurrency(insuranceChargesCurrency: String?) =
                            insuranceChargesCurrency(JsonField.ofNullable(insuranceChargesCurrency))

                        /**
                         * Sets [Builder.insuranceChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.insuranceChargesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun insuranceChargesCurrency(insuranceChargesCurrency: JsonField<String>) =
                            apply {
                                this.insuranceChargesCurrency = insuranceChargesCurrency
                            }

                        /**
                         * An indicator that the cardholder is being billed for a reserved vehicle
                         * that was not actually rented (that is, a "no-show" charge).
                         */
                        fun noShowIndicator(noShowIndicator: NoShowIndicator?) =
                            noShowIndicator(JsonField.ofNullable(noShowIndicator))

                        /**
                         * Sets [Builder.noShowIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.noShowIndicator] with a well-typed
                         * [NoShowIndicator] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun noShowIndicator(noShowIndicator: JsonField<NoShowIndicator>) = apply {
                            this.noShowIndicator = noShowIndicator
                        }

                        /**
                         * Charges for returning the vehicle at a different location than where it
                         * was picked up.
                         */
                        fun oneWayDropOffChargesAmount(oneWayDropOffChargesAmount: Long?) =
                            oneWayDropOffChargesAmount(
                                JsonField.ofNullable(oneWayDropOffChargesAmount)
                            )

                        /**
                         * Alias for [Builder.oneWayDropOffChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun oneWayDropOffChargesAmount(oneWayDropOffChargesAmount: Long) =
                            oneWayDropOffChargesAmount(oneWayDropOffChargesAmount as Long?)

                        /**
                         * Sets [Builder.oneWayDropOffChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.oneWayDropOffChargesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun oneWayDropOffChargesAmount(
                            oneWayDropOffChargesAmount: JsonField<Long>
                        ) = apply { this.oneWayDropOffChargesAmount = oneWayDropOffChargesAmount }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * one-way drop-off charges assessed.
                         */
                        fun oneWayDropOffChargesCurrency(oneWayDropOffChargesCurrency: String?) =
                            oneWayDropOffChargesCurrency(
                                JsonField.ofNullable(oneWayDropOffChargesCurrency)
                            )

                        /**
                         * Sets [Builder.oneWayDropOffChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.oneWayDropOffChargesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun oneWayDropOffChargesCurrency(
                            oneWayDropOffChargesCurrency: JsonField<String>
                        ) = apply {
                            this.oneWayDropOffChargesCurrency = oneWayDropOffChargesCurrency
                        }

                        /** Name of the person renting the vehicle. */
                        fun renterName(renterName: String?) =
                            renterName(JsonField.ofNullable(renterName))

                        /**
                         * Sets [Builder.renterName] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.renterName] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun renterName(renterName: JsonField<String>) = apply {
                            this.renterName = renterName
                        }

                        /** Weekly rate being charged for the vehicle. */
                        fun weeklyRentalRateAmount(weeklyRentalRateAmount: Long?) =
                            weeklyRentalRateAmount(JsonField.ofNullable(weeklyRentalRateAmount))

                        /**
                         * Alias for [Builder.weeklyRentalRateAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun weeklyRentalRateAmount(weeklyRentalRateAmount: Long) =
                            weeklyRentalRateAmount(weeklyRentalRateAmount as Long?)

                        /**
                         * Sets [Builder.weeklyRentalRateAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.weeklyRentalRateAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun weeklyRentalRateAmount(weeklyRentalRateAmount: JsonField<Long>) =
                            apply {
                                this.weeklyRentalRateAmount = weeklyRentalRateAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * weekly rental rate.
                         */
                        fun weeklyRentalRateCurrency(weeklyRentalRateCurrency: String?) =
                            weeklyRentalRateCurrency(JsonField.ofNullable(weeklyRentalRateCurrency))

                        /**
                         * Sets [Builder.weeklyRentalRateCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.weeklyRentalRateCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun weeklyRentalRateCurrency(weeklyRentalRateCurrency: JsonField<String>) =
                            apply {
                                this.weeklyRentalRateCurrency = weeklyRentalRateCurrency
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CarRental].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .carClassCode()
                         * .checkoutDate()
                         * .dailyRentalRateAmount()
                         * .dailyRentalRateCurrency()
                         * .daysRented()
                         * .extraCharges()
                         * .fuelChargesAmount()
                         * .fuelChargesCurrency()
                         * .insuranceChargesAmount()
                         * .insuranceChargesCurrency()
                         * .noShowIndicator()
                         * .oneWayDropOffChargesAmount()
                         * .oneWayDropOffChargesCurrency()
                         * .renterName()
                         * .weeklyRentalRateAmount()
                         * .weeklyRentalRateCurrency()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CarRental =
                            CarRental(
                                checkRequired("carClassCode", carClassCode),
                                checkRequired("checkoutDate", checkoutDate),
                                checkRequired("dailyRentalRateAmount", dailyRentalRateAmount),
                                checkRequired("dailyRentalRateCurrency", dailyRentalRateCurrency),
                                checkRequired("daysRented", daysRented),
                                checkRequired("extraCharges", extraCharges),
                                checkRequired("fuelChargesAmount", fuelChargesAmount),
                                checkRequired("fuelChargesCurrency", fuelChargesCurrency),
                                checkRequired("insuranceChargesAmount", insuranceChargesAmount),
                                checkRequired("insuranceChargesCurrency", insuranceChargesCurrency),
                                checkRequired("noShowIndicator", noShowIndicator),
                                checkRequired(
                                    "oneWayDropOffChargesAmount",
                                    oneWayDropOffChargesAmount,
                                ),
                                checkRequired(
                                    "oneWayDropOffChargesCurrency",
                                    oneWayDropOffChargesCurrency,
                                ),
                                checkRequired("renterName", renterName),
                                checkRequired("weeklyRentalRateAmount", weeklyRentalRateAmount),
                                checkRequired("weeklyRentalRateCurrency", weeklyRentalRateCurrency),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CarRental = apply {
                        if (validated) {
                            return@apply
                        }

                        carClassCode()
                        checkoutDate()
                        dailyRentalRateAmount()
                        dailyRentalRateCurrency()
                        daysRented()
                        extraCharges()?.validate()
                        fuelChargesAmount()
                        fuelChargesCurrency()
                        insuranceChargesAmount()
                        insuranceChargesCurrency()
                        noShowIndicator()?.validate()
                        oneWayDropOffChargesAmount()
                        oneWayDropOffChargesCurrency()
                        renterName()
                        weeklyRentalRateAmount()
                        weeklyRentalRateCurrency()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (carClassCode.asKnown() == null) 0 else 1) +
                            (if (checkoutDate.asKnown() == null) 0 else 1) +
                            (if (dailyRentalRateAmount.asKnown() == null) 0 else 1) +
                            (if (dailyRentalRateCurrency.asKnown() == null) 0 else 1) +
                            (if (daysRented.asKnown() == null) 0 else 1) +
                            (extraCharges.asKnown()?.validity() ?: 0) +
                            (if (fuelChargesAmount.asKnown() == null) 0 else 1) +
                            (if (fuelChargesCurrency.asKnown() == null) 0 else 1) +
                            (if (insuranceChargesAmount.asKnown() == null) 0 else 1) +
                            (if (insuranceChargesCurrency.asKnown() == null) 0 else 1) +
                            (noShowIndicator.asKnown()?.validity() ?: 0) +
                            (if (oneWayDropOffChargesAmount.asKnown() == null) 0 else 1) +
                            (if (oneWayDropOffChargesCurrency.asKnown() == null) 0 else 1) +
                            (if (renterName.asKnown() == null) 0 else 1) +
                            (if (weeklyRentalRateAmount.asKnown() == null) 0 else 1) +
                            (if (weeklyRentalRateCurrency.asKnown() == null) 0 else 1)

                    /** Additional charges (gas, late fee, etc.) being billed. */
                    class ExtraCharges
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No extra charge */
                            val NO_EXTRA_CHARGE = of("no_extra_charge")

                            /** Gas */
                            val GAS = of("gas")

                            /** Extra mileage */
                            val EXTRA_MILEAGE = of("extra_mileage")

                            /** Late return */
                            val LATE_RETURN = of("late_return")

                            /** One way service fee */
                            val ONE_WAY_SERVICE_FEE = of("one_way_service_fee")

                            /** Parking violation */
                            val PARKING_VIOLATION = of("parking_violation")

                            fun of(value: String) = ExtraCharges(JsonField.of(value))
                        }

                        /** An enum containing [ExtraCharges]'s known values. */
                        enum class Known {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Gas */
                            GAS,
                            /** Extra mileage */
                            EXTRA_MILEAGE,
                            /** Late return */
                            LATE_RETURN,
                            /** One way service fee */
                            ONE_WAY_SERVICE_FEE,
                            /** Parking violation */
                            PARKING_VIOLATION,
                        }

                        /**
                         * An enum containing [ExtraCharges]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ExtraCharges] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Gas */
                            GAS,
                            /** Extra mileage */
                            EXTRA_MILEAGE,
                            /** Late return */
                            LATE_RETURN,
                            /** One way service fee */
                            ONE_WAY_SERVICE_FEE,
                            /** Parking violation */
                            PARKING_VIOLATION,
                            /**
                             * An enum member indicating that [ExtraCharges] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_EXTRA_CHARGE -> Value.NO_EXTRA_CHARGE
                                GAS -> Value.GAS
                                EXTRA_MILEAGE -> Value.EXTRA_MILEAGE
                                LATE_RETURN -> Value.LATE_RETURN
                                ONE_WAY_SERVICE_FEE -> Value.ONE_WAY_SERVICE_FEE
                                PARKING_VIOLATION -> Value.PARKING_VIOLATION
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_EXTRA_CHARGE -> Known.NO_EXTRA_CHARGE
                                GAS -> Known.GAS
                                EXTRA_MILEAGE -> Known.EXTRA_MILEAGE
                                LATE_RETURN -> Known.LATE_RETURN
                                ONE_WAY_SERVICE_FEE -> Known.ONE_WAY_SERVICE_FEE
                                PARKING_VIOLATION -> Known.PARKING_VIOLATION
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ExtraCharges: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ExtraCharges = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ExtraCharges && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * An indicator that the cardholder is being billed for a reserved vehicle that
                     * was not actually rented (that is, a "no-show" charge).
                     */
                    class NoShowIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not applicable */
                            val NOT_APPLICABLE = of("not_applicable")

                            /** No show for specialized vehicle */
                            val NO_SHOW_FOR_SPECIALIZED_VEHICLE =
                                of("no_show_for_specialized_vehicle")

                            fun of(value: String) = NoShowIndicator(JsonField.of(value))
                        }

                        /** An enum containing [NoShowIndicator]'s known values. */
                        enum class Known {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show for specialized vehicle */
                            NO_SHOW_FOR_SPECIALIZED_VEHICLE,
                        }

                        /**
                         * An enum containing [NoShowIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [NoShowIndicator] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show for specialized vehicle */
                            NO_SHOW_FOR_SPECIALIZED_VEHICLE,
                            /**
                             * An enum member indicating that [NoShowIndicator] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_APPLICABLE -> Value.NOT_APPLICABLE
                                NO_SHOW_FOR_SPECIALIZED_VEHICLE ->
                                    Value.NO_SHOW_FOR_SPECIALIZED_VEHICLE
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_APPLICABLE -> Known.NOT_APPLICABLE
                                NO_SHOW_FOR_SPECIALIZED_VEHICLE ->
                                    Known.NO_SHOW_FOR_SPECIALIZED_VEHICLE
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown NoShowIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): NoShowIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is NoShowIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CarRental &&
                            carClassCode == other.carClassCode &&
                            checkoutDate == other.checkoutDate &&
                            dailyRentalRateAmount == other.dailyRentalRateAmount &&
                            dailyRentalRateCurrency == other.dailyRentalRateCurrency &&
                            daysRented == other.daysRented &&
                            extraCharges == other.extraCharges &&
                            fuelChargesAmount == other.fuelChargesAmount &&
                            fuelChargesCurrency == other.fuelChargesCurrency &&
                            insuranceChargesAmount == other.insuranceChargesAmount &&
                            insuranceChargesCurrency == other.insuranceChargesCurrency &&
                            noShowIndicator == other.noShowIndicator &&
                            oneWayDropOffChargesAmount == other.oneWayDropOffChargesAmount &&
                            oneWayDropOffChargesCurrency == other.oneWayDropOffChargesCurrency &&
                            renterName == other.renterName &&
                            weeklyRentalRateAmount == other.weeklyRentalRateAmount &&
                            weeklyRentalRateCurrency == other.weeklyRentalRateCurrency &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            carClassCode,
                            checkoutDate,
                            dailyRentalRateAmount,
                            dailyRentalRateCurrency,
                            daysRented,
                            extraCharges,
                            fuelChargesAmount,
                            fuelChargesCurrency,
                            insuranceChargesAmount,
                            insuranceChargesCurrency,
                            noShowIndicator,
                            oneWayDropOffChargesAmount,
                            oneWayDropOffChargesCurrency,
                            renterName,
                            weeklyRentalRateAmount,
                            weeklyRentalRateCurrency,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CarRental{carClassCode=$carClassCode, checkoutDate=$checkoutDate, dailyRentalRateAmount=$dailyRentalRateAmount, dailyRentalRateCurrency=$dailyRentalRateCurrency, daysRented=$daysRented, extraCharges=$extraCharges, fuelChargesAmount=$fuelChargesAmount, fuelChargesCurrency=$fuelChargesCurrency, insuranceChargesAmount=$insuranceChargesAmount, insuranceChargesCurrency=$insuranceChargesCurrency, noShowIndicator=$noShowIndicator, oneWayDropOffChargesAmount=$oneWayDropOffChargesAmount, oneWayDropOffChargesCurrency=$oneWayDropOffChargesCurrency, renterName=$renterName, weeklyRentalRateAmount=$weeklyRentalRateAmount, weeklyRentalRateCurrency=$weeklyRentalRateCurrency, additionalProperties=$additionalProperties}"
                }

                /** Fields specific to lodging. */
                class Lodging
                private constructor(
                    private val checkInDate: JsonField<LocalDate>,
                    private val dailyRoomRateAmount: JsonField<Long>,
                    private val dailyRoomRateCurrency: JsonField<String>,
                    private val extraCharges: JsonField<ExtraCharges>,
                    private val folioCashAdvancesAmount: JsonField<Long>,
                    private val folioCashAdvancesCurrency: JsonField<String>,
                    private val foodBeverageChargesAmount: JsonField<Long>,
                    private val foodBeverageChargesCurrency: JsonField<String>,
                    private val noShowIndicator: JsonField<NoShowIndicator>,
                    private val prepaidExpensesAmount: JsonField<Long>,
                    private val prepaidExpensesCurrency: JsonField<String>,
                    private val roomNights: JsonField<Long>,
                    private val totalRoomTaxAmount: JsonField<Long>,
                    private val totalRoomTaxCurrency: JsonField<String>,
                    private val totalTaxAmount: JsonField<Long>,
                    private val totalTaxCurrency: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("check_in_date")
                        @ExcludeMissing
                        checkInDate: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("daily_room_rate_amount")
                        @ExcludeMissing
                        dailyRoomRateAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("daily_room_rate_currency")
                        @ExcludeMissing
                        dailyRoomRateCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("extra_charges")
                        @ExcludeMissing
                        extraCharges: JsonField<ExtraCharges> = JsonMissing.of(),
                        @JsonProperty("folio_cash_advances_amount")
                        @ExcludeMissing
                        folioCashAdvancesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("folio_cash_advances_currency")
                        @ExcludeMissing
                        folioCashAdvancesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("food_beverage_charges_amount")
                        @ExcludeMissing
                        foodBeverageChargesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("food_beverage_charges_currency")
                        @ExcludeMissing
                        foodBeverageChargesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("no_show_indicator")
                        @ExcludeMissing
                        noShowIndicator: JsonField<NoShowIndicator> = JsonMissing.of(),
                        @JsonProperty("prepaid_expenses_amount")
                        @ExcludeMissing
                        prepaidExpensesAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("prepaid_expenses_currency")
                        @ExcludeMissing
                        prepaidExpensesCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("room_nights")
                        @ExcludeMissing
                        roomNights: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("total_room_tax_amount")
                        @ExcludeMissing
                        totalRoomTaxAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("total_room_tax_currency")
                        @ExcludeMissing
                        totalRoomTaxCurrency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("total_tax_amount")
                        @ExcludeMissing
                        totalTaxAmount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("total_tax_currency")
                        @ExcludeMissing
                        totalTaxCurrency: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        checkInDate,
                        dailyRoomRateAmount,
                        dailyRoomRateCurrency,
                        extraCharges,
                        folioCashAdvancesAmount,
                        folioCashAdvancesCurrency,
                        foodBeverageChargesAmount,
                        foodBeverageChargesCurrency,
                        noShowIndicator,
                        prepaidExpensesAmount,
                        prepaidExpensesCurrency,
                        roomNights,
                        totalRoomTaxAmount,
                        totalRoomTaxCurrency,
                        totalTaxAmount,
                        totalTaxCurrency,
                        mutableMapOf(),
                    )

                    /**
                     * Date the customer checked in.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun checkInDate(): LocalDate? = checkInDate.getNullable("check_in_date")

                    /**
                     * Daily rate being charged for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRoomRateAmount(): Long? =
                        dailyRoomRateAmount.getNullable("daily_room_rate_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                     * room rate.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun dailyRoomRateCurrency(): String? =
                        dailyRoomRateCurrency.getNullable("daily_room_rate_currency")

                    /**
                     * Additional charges (phone, late check-out, etc.) being billed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun extraCharges(): ExtraCharges? = extraCharges.getNullable("extra_charges")

                    /**
                     * Folio cash advances for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun folioCashAdvancesAmount(): Long? =
                        folioCashAdvancesAmount.getNullable("folio_cash_advances_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the folio
                     * cash advances.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun folioCashAdvancesCurrency(): String? =
                        folioCashAdvancesCurrency.getNullable("folio_cash_advances_currency")

                    /**
                     * Food and beverage charges for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun foodBeverageChargesAmount(): Long? =
                        foodBeverageChargesAmount.getNullable("food_beverage_charges_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the food and
                     * beverage charges.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun foodBeverageChargesCurrency(): String? =
                        foodBeverageChargesCurrency.getNullable("food_beverage_charges_currency")

                    /**
                     * Indicator that the cardholder is being billed for a reserved room that was
                     * not actually used.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun noShowIndicator(): NoShowIndicator? =
                        noShowIndicator.getNullable("no_show_indicator")

                    /**
                     * Prepaid expenses being charged for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun prepaidExpensesAmount(): Long? =
                        prepaidExpensesAmount.getNullable("prepaid_expenses_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the prepaid
                     * expenses.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun prepaidExpensesCurrency(): String? =
                        prepaidExpensesCurrency.getNullable("prepaid_expenses_currency")

                    /**
                     * Number of nights the room was rented.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun roomNights(): Long? = roomNights.getNullable("room_nights")

                    /**
                     * Total room tax being charged.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalRoomTaxAmount(): Long? =
                        totalRoomTaxAmount.getNullable("total_room_tax_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total
                     * room tax.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalRoomTaxCurrency(): String? =
                        totalRoomTaxCurrency.getNullable("total_room_tax_currency")

                    /**
                     * Total tax being charged for the room.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalTaxAmount(): Long? = totalTaxAmount.getNullable("total_tax_amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total tax
                     * assessed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun totalTaxCurrency(): String? =
                        totalTaxCurrency.getNullable("total_tax_currency")

                    /**
                     * Returns the raw JSON value of [checkInDate].
                     *
                     * Unlike [checkInDate], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("check_in_date")
                    @ExcludeMissing
                    fun _checkInDate(): JsonField<LocalDate> = checkInDate

                    /**
                     * Returns the raw JSON value of [dailyRoomRateAmount].
                     *
                     * Unlike [dailyRoomRateAmount], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("daily_room_rate_amount")
                    @ExcludeMissing
                    fun _dailyRoomRateAmount(): JsonField<Long> = dailyRoomRateAmount

                    /**
                     * Returns the raw JSON value of [dailyRoomRateCurrency].
                     *
                     * Unlike [dailyRoomRateCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("daily_room_rate_currency")
                    @ExcludeMissing
                    fun _dailyRoomRateCurrency(): JsonField<String> = dailyRoomRateCurrency

                    /**
                     * Returns the raw JSON value of [extraCharges].
                     *
                     * Unlike [extraCharges], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("extra_charges")
                    @ExcludeMissing
                    fun _extraCharges(): JsonField<ExtraCharges> = extraCharges

                    /**
                     * Returns the raw JSON value of [folioCashAdvancesAmount].
                     *
                     * Unlike [folioCashAdvancesAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("folio_cash_advances_amount")
                    @ExcludeMissing
                    fun _folioCashAdvancesAmount(): JsonField<Long> = folioCashAdvancesAmount

                    /**
                     * Returns the raw JSON value of [folioCashAdvancesCurrency].
                     *
                     * Unlike [folioCashAdvancesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("folio_cash_advances_currency")
                    @ExcludeMissing
                    fun _folioCashAdvancesCurrency(): JsonField<String> = folioCashAdvancesCurrency

                    /**
                     * Returns the raw JSON value of [foodBeverageChargesAmount].
                     *
                     * Unlike [foodBeverageChargesAmount], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("food_beverage_charges_amount")
                    @ExcludeMissing
                    fun _foodBeverageChargesAmount(): JsonField<Long> = foodBeverageChargesAmount

                    /**
                     * Returns the raw JSON value of [foodBeverageChargesCurrency].
                     *
                     * Unlike [foodBeverageChargesCurrency], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("food_beverage_charges_currency")
                    @ExcludeMissing
                    fun _foodBeverageChargesCurrency(): JsonField<String> =
                        foodBeverageChargesCurrency

                    /**
                     * Returns the raw JSON value of [noShowIndicator].
                     *
                     * Unlike [noShowIndicator], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("no_show_indicator")
                    @ExcludeMissing
                    fun _noShowIndicator(): JsonField<NoShowIndicator> = noShowIndicator

                    /**
                     * Returns the raw JSON value of [prepaidExpensesAmount].
                     *
                     * Unlike [prepaidExpensesAmount], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("prepaid_expenses_amount")
                    @ExcludeMissing
                    fun _prepaidExpensesAmount(): JsonField<Long> = prepaidExpensesAmount

                    /**
                     * Returns the raw JSON value of [prepaidExpensesCurrency].
                     *
                     * Unlike [prepaidExpensesCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("prepaid_expenses_currency")
                    @ExcludeMissing
                    fun _prepaidExpensesCurrency(): JsonField<String> = prepaidExpensesCurrency

                    /**
                     * Returns the raw JSON value of [roomNights].
                     *
                     * Unlike [roomNights], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("room_nights")
                    @ExcludeMissing
                    fun _roomNights(): JsonField<Long> = roomNights

                    /**
                     * Returns the raw JSON value of [totalRoomTaxAmount].
                     *
                     * Unlike [totalRoomTaxAmount], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("total_room_tax_amount")
                    @ExcludeMissing
                    fun _totalRoomTaxAmount(): JsonField<Long> = totalRoomTaxAmount

                    /**
                     * Returns the raw JSON value of [totalRoomTaxCurrency].
                     *
                     * Unlike [totalRoomTaxCurrency], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("total_room_tax_currency")
                    @ExcludeMissing
                    fun _totalRoomTaxCurrency(): JsonField<String> = totalRoomTaxCurrency

                    /**
                     * Returns the raw JSON value of [totalTaxAmount].
                     *
                     * Unlike [totalTaxAmount], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("total_tax_amount")
                    @ExcludeMissing
                    fun _totalTaxAmount(): JsonField<Long> = totalTaxAmount

                    /**
                     * Returns the raw JSON value of [totalTaxCurrency].
                     *
                     * Unlike [totalTaxCurrency], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("total_tax_currency")
                    @ExcludeMissing
                    fun _totalTaxCurrency(): JsonField<String> = totalTaxCurrency

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Lodging].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .checkInDate()
                         * .dailyRoomRateAmount()
                         * .dailyRoomRateCurrency()
                         * .extraCharges()
                         * .folioCashAdvancesAmount()
                         * .folioCashAdvancesCurrency()
                         * .foodBeverageChargesAmount()
                         * .foodBeverageChargesCurrency()
                         * .noShowIndicator()
                         * .prepaidExpensesAmount()
                         * .prepaidExpensesCurrency()
                         * .roomNights()
                         * .totalRoomTaxAmount()
                         * .totalRoomTaxCurrency()
                         * .totalTaxAmount()
                         * .totalTaxCurrency()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Lodging]. */
                    class Builder internal constructor() {

                        private var checkInDate: JsonField<LocalDate>? = null
                        private var dailyRoomRateAmount: JsonField<Long>? = null
                        private var dailyRoomRateCurrency: JsonField<String>? = null
                        private var extraCharges: JsonField<ExtraCharges>? = null
                        private var folioCashAdvancesAmount: JsonField<Long>? = null
                        private var folioCashAdvancesCurrency: JsonField<String>? = null
                        private var foodBeverageChargesAmount: JsonField<Long>? = null
                        private var foodBeverageChargesCurrency: JsonField<String>? = null
                        private var noShowIndicator: JsonField<NoShowIndicator>? = null
                        private var prepaidExpensesAmount: JsonField<Long>? = null
                        private var prepaidExpensesCurrency: JsonField<String>? = null
                        private var roomNights: JsonField<Long>? = null
                        private var totalRoomTaxAmount: JsonField<Long>? = null
                        private var totalRoomTaxCurrency: JsonField<String>? = null
                        private var totalTaxAmount: JsonField<Long>? = null
                        private var totalTaxCurrency: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(lodging: Lodging) = apply {
                            checkInDate = lodging.checkInDate
                            dailyRoomRateAmount = lodging.dailyRoomRateAmount
                            dailyRoomRateCurrency = lodging.dailyRoomRateCurrency
                            extraCharges = lodging.extraCharges
                            folioCashAdvancesAmount = lodging.folioCashAdvancesAmount
                            folioCashAdvancesCurrency = lodging.folioCashAdvancesCurrency
                            foodBeverageChargesAmount = lodging.foodBeverageChargesAmount
                            foodBeverageChargesCurrency = lodging.foodBeverageChargesCurrency
                            noShowIndicator = lodging.noShowIndicator
                            prepaidExpensesAmount = lodging.prepaidExpensesAmount
                            prepaidExpensesCurrency = lodging.prepaidExpensesCurrency
                            roomNights = lodging.roomNights
                            totalRoomTaxAmount = lodging.totalRoomTaxAmount
                            totalRoomTaxCurrency = lodging.totalRoomTaxCurrency
                            totalTaxAmount = lodging.totalTaxAmount
                            totalTaxCurrency = lodging.totalTaxCurrency
                            additionalProperties = lodging.additionalProperties.toMutableMap()
                        }

                        /** Date the customer checked in. */
                        fun checkInDate(checkInDate: LocalDate?) =
                            checkInDate(JsonField.ofNullable(checkInDate))

                        /**
                         * Sets [Builder.checkInDate] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.checkInDate] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun checkInDate(checkInDate: JsonField<LocalDate>) = apply {
                            this.checkInDate = checkInDate
                        }

                        /** Daily rate being charged for the room. */
                        fun dailyRoomRateAmount(dailyRoomRateAmount: Long?) =
                            dailyRoomRateAmount(JsonField.ofNullable(dailyRoomRateAmount))

                        /**
                         * Alias for [Builder.dailyRoomRateAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun dailyRoomRateAmount(dailyRoomRateAmount: Long) =
                            dailyRoomRateAmount(dailyRoomRateAmount as Long?)

                        /**
                         * Sets [Builder.dailyRoomRateAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRoomRateAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun dailyRoomRateAmount(dailyRoomRateAmount: JsonField<Long>) = apply {
                            this.dailyRoomRateAmount = dailyRoomRateAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the daily
                         * room rate.
                         */
                        fun dailyRoomRateCurrency(dailyRoomRateCurrency: String?) =
                            dailyRoomRateCurrency(JsonField.ofNullable(dailyRoomRateCurrency))

                        /**
                         * Sets [Builder.dailyRoomRateCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dailyRoomRateCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun dailyRoomRateCurrency(dailyRoomRateCurrency: JsonField<String>) =
                            apply {
                                this.dailyRoomRateCurrency = dailyRoomRateCurrency
                            }

                        /** Additional charges (phone, late check-out, etc.) being billed. */
                        fun extraCharges(extraCharges: ExtraCharges?) =
                            extraCharges(JsonField.ofNullable(extraCharges))

                        /**
                         * Sets [Builder.extraCharges] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.extraCharges] with a well-typed
                         * [ExtraCharges] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun extraCharges(extraCharges: JsonField<ExtraCharges>) = apply {
                            this.extraCharges = extraCharges
                        }

                        /** Folio cash advances for the room. */
                        fun folioCashAdvancesAmount(folioCashAdvancesAmount: Long?) =
                            folioCashAdvancesAmount(JsonField.ofNullable(folioCashAdvancesAmount))

                        /**
                         * Alias for [Builder.folioCashAdvancesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun folioCashAdvancesAmount(folioCashAdvancesAmount: Long) =
                            folioCashAdvancesAmount(folioCashAdvancesAmount as Long?)

                        /**
                         * Sets [Builder.folioCashAdvancesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.folioCashAdvancesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun folioCashAdvancesAmount(folioCashAdvancesAmount: JsonField<Long>) =
                            apply {
                                this.folioCashAdvancesAmount = folioCashAdvancesAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the folio
                         * cash advances.
                         */
                        fun folioCashAdvancesCurrency(folioCashAdvancesCurrency: String?) =
                            folioCashAdvancesCurrency(
                                JsonField.ofNullable(folioCashAdvancesCurrency)
                            )

                        /**
                         * Sets [Builder.folioCashAdvancesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.folioCashAdvancesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun folioCashAdvancesCurrency(
                            folioCashAdvancesCurrency: JsonField<String>
                        ) = apply { this.folioCashAdvancesCurrency = folioCashAdvancesCurrency }

                        /** Food and beverage charges for the room. */
                        fun foodBeverageChargesAmount(foodBeverageChargesAmount: Long?) =
                            foodBeverageChargesAmount(
                                JsonField.ofNullable(foodBeverageChargesAmount)
                            )

                        /**
                         * Alias for [Builder.foodBeverageChargesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun foodBeverageChargesAmount(foodBeverageChargesAmount: Long) =
                            foodBeverageChargesAmount(foodBeverageChargesAmount as Long?)

                        /**
                         * Sets [Builder.foodBeverageChargesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.foodBeverageChargesAmount] with a
                         * well-typed [Long] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun foodBeverageChargesAmount(foodBeverageChargesAmount: JsonField<Long>) =
                            apply {
                                this.foodBeverageChargesAmount = foodBeverageChargesAmount
                            }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the food
                         * and beverage charges.
                         */
                        fun foodBeverageChargesCurrency(foodBeverageChargesCurrency: String?) =
                            foodBeverageChargesCurrency(
                                JsonField.ofNullable(foodBeverageChargesCurrency)
                            )

                        /**
                         * Sets [Builder.foodBeverageChargesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.foodBeverageChargesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun foodBeverageChargesCurrency(
                            foodBeverageChargesCurrency: JsonField<String>
                        ) = apply { this.foodBeverageChargesCurrency = foodBeverageChargesCurrency }

                        /**
                         * Indicator that the cardholder is being billed for a reserved room that
                         * was not actually used.
                         */
                        fun noShowIndicator(noShowIndicator: NoShowIndicator?) =
                            noShowIndicator(JsonField.ofNullable(noShowIndicator))

                        /**
                         * Sets [Builder.noShowIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.noShowIndicator] with a well-typed
                         * [NoShowIndicator] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun noShowIndicator(noShowIndicator: JsonField<NoShowIndicator>) = apply {
                            this.noShowIndicator = noShowIndicator
                        }

                        /** Prepaid expenses being charged for the room. */
                        fun prepaidExpensesAmount(prepaidExpensesAmount: Long?) =
                            prepaidExpensesAmount(JsonField.ofNullable(prepaidExpensesAmount))

                        /**
                         * Alias for [Builder.prepaidExpensesAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun prepaidExpensesAmount(prepaidExpensesAmount: Long) =
                            prepaidExpensesAmount(prepaidExpensesAmount as Long?)

                        /**
                         * Sets [Builder.prepaidExpensesAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.prepaidExpensesAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun prepaidExpensesAmount(prepaidExpensesAmount: JsonField<Long>) = apply {
                            this.prepaidExpensesAmount = prepaidExpensesAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * prepaid expenses.
                         */
                        fun prepaidExpensesCurrency(prepaidExpensesCurrency: String?) =
                            prepaidExpensesCurrency(JsonField.ofNullable(prepaidExpensesCurrency))

                        /**
                         * Sets [Builder.prepaidExpensesCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.prepaidExpensesCurrency] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun prepaidExpensesCurrency(prepaidExpensesCurrency: JsonField<String>) =
                            apply {
                                this.prepaidExpensesCurrency = prepaidExpensesCurrency
                            }

                        /** Number of nights the room was rented. */
                        fun roomNights(roomNights: Long?) =
                            roomNights(JsonField.ofNullable(roomNights))

                        /**
                         * Alias for [Builder.roomNights].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun roomNights(roomNights: Long) = roomNights(roomNights as Long?)

                        /**
                         * Sets [Builder.roomNights] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.roomNights] with a well-typed [Long]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun roomNights(roomNights: JsonField<Long>) = apply {
                            this.roomNights = roomNights
                        }

                        /** Total room tax being charged. */
                        fun totalRoomTaxAmount(totalRoomTaxAmount: Long?) =
                            totalRoomTaxAmount(JsonField.ofNullable(totalRoomTaxAmount))

                        /**
                         * Alias for [Builder.totalRoomTaxAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun totalRoomTaxAmount(totalRoomTaxAmount: Long) =
                            totalRoomTaxAmount(totalRoomTaxAmount as Long?)

                        /**
                         * Sets [Builder.totalRoomTaxAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalRoomTaxAmount] with a well-typed
                         * [Long] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun totalRoomTaxAmount(totalRoomTaxAmount: JsonField<Long>) = apply {
                            this.totalRoomTaxAmount = totalRoomTaxAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total
                         * room tax.
                         */
                        fun totalRoomTaxCurrency(totalRoomTaxCurrency: String?) =
                            totalRoomTaxCurrency(JsonField.ofNullable(totalRoomTaxCurrency))

                        /**
                         * Sets [Builder.totalRoomTaxCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalRoomTaxCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun totalRoomTaxCurrency(totalRoomTaxCurrency: JsonField<String>) = apply {
                            this.totalRoomTaxCurrency = totalRoomTaxCurrency
                        }

                        /** Total tax being charged for the room. */
                        fun totalTaxAmount(totalTaxAmount: Long?) =
                            totalTaxAmount(JsonField.ofNullable(totalTaxAmount))

                        /**
                         * Alias for [Builder.totalTaxAmount].
                         *
                         * This unboxed primitive overload exists for backwards compatibility.
                         */
                        fun totalTaxAmount(totalTaxAmount: Long) =
                            totalTaxAmount(totalTaxAmount as Long?)

                        /**
                         * Sets [Builder.totalTaxAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalTaxAmount] with a well-typed [Long]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun totalTaxAmount(totalTaxAmount: JsonField<Long>) = apply {
                            this.totalTaxAmount = totalTaxAmount
                        }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the total
                         * tax assessed.
                         */
                        fun totalTaxCurrency(totalTaxCurrency: String?) =
                            totalTaxCurrency(JsonField.ofNullable(totalTaxCurrency))

                        /**
                         * Sets [Builder.totalTaxCurrency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.totalTaxCurrency] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun totalTaxCurrency(totalTaxCurrency: JsonField<String>) = apply {
                            this.totalTaxCurrency = totalTaxCurrency
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Lodging].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .checkInDate()
                         * .dailyRoomRateAmount()
                         * .dailyRoomRateCurrency()
                         * .extraCharges()
                         * .folioCashAdvancesAmount()
                         * .folioCashAdvancesCurrency()
                         * .foodBeverageChargesAmount()
                         * .foodBeverageChargesCurrency()
                         * .noShowIndicator()
                         * .prepaidExpensesAmount()
                         * .prepaidExpensesCurrency()
                         * .roomNights()
                         * .totalRoomTaxAmount()
                         * .totalRoomTaxCurrency()
                         * .totalTaxAmount()
                         * .totalTaxCurrency()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Lodging =
                            Lodging(
                                checkRequired("checkInDate", checkInDate),
                                checkRequired("dailyRoomRateAmount", dailyRoomRateAmount),
                                checkRequired("dailyRoomRateCurrency", dailyRoomRateCurrency),
                                checkRequired("extraCharges", extraCharges),
                                checkRequired("folioCashAdvancesAmount", folioCashAdvancesAmount),
                                checkRequired(
                                    "folioCashAdvancesCurrency",
                                    folioCashAdvancesCurrency,
                                ),
                                checkRequired(
                                    "foodBeverageChargesAmount",
                                    foodBeverageChargesAmount,
                                ),
                                checkRequired(
                                    "foodBeverageChargesCurrency",
                                    foodBeverageChargesCurrency,
                                ),
                                checkRequired("noShowIndicator", noShowIndicator),
                                checkRequired("prepaidExpensesAmount", prepaidExpensesAmount),
                                checkRequired("prepaidExpensesCurrency", prepaidExpensesCurrency),
                                checkRequired("roomNights", roomNights),
                                checkRequired("totalRoomTaxAmount", totalRoomTaxAmount),
                                checkRequired("totalRoomTaxCurrency", totalRoomTaxCurrency),
                                checkRequired("totalTaxAmount", totalTaxAmount),
                                checkRequired("totalTaxCurrency", totalTaxCurrency),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Lodging = apply {
                        if (validated) {
                            return@apply
                        }

                        checkInDate()
                        dailyRoomRateAmount()
                        dailyRoomRateCurrency()
                        extraCharges()?.validate()
                        folioCashAdvancesAmount()
                        folioCashAdvancesCurrency()
                        foodBeverageChargesAmount()
                        foodBeverageChargesCurrency()
                        noShowIndicator()?.validate()
                        prepaidExpensesAmount()
                        prepaidExpensesCurrency()
                        roomNights()
                        totalRoomTaxAmount()
                        totalRoomTaxCurrency()
                        totalTaxAmount()
                        totalTaxCurrency()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (checkInDate.asKnown() == null) 0 else 1) +
                            (if (dailyRoomRateAmount.asKnown() == null) 0 else 1) +
                            (if (dailyRoomRateCurrency.asKnown() == null) 0 else 1) +
                            (extraCharges.asKnown()?.validity() ?: 0) +
                            (if (folioCashAdvancesAmount.asKnown() == null) 0 else 1) +
                            (if (folioCashAdvancesCurrency.asKnown() == null) 0 else 1) +
                            (if (foodBeverageChargesAmount.asKnown() == null) 0 else 1) +
                            (if (foodBeverageChargesCurrency.asKnown() == null) 0 else 1) +
                            (noShowIndicator.asKnown()?.validity() ?: 0) +
                            (if (prepaidExpensesAmount.asKnown() == null) 0 else 1) +
                            (if (prepaidExpensesCurrency.asKnown() == null) 0 else 1) +
                            (if (roomNights.asKnown() == null) 0 else 1) +
                            (if (totalRoomTaxAmount.asKnown() == null) 0 else 1) +
                            (if (totalRoomTaxCurrency.asKnown() == null) 0 else 1) +
                            (if (totalTaxAmount.asKnown() == null) 0 else 1) +
                            (if (totalTaxCurrency.asKnown() == null) 0 else 1)

                    /** Additional charges (phone, late check-out, etc.) being billed. */
                    class ExtraCharges
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No extra charge */
                            val NO_EXTRA_CHARGE = of("no_extra_charge")

                            /** Restaurant */
                            val RESTAURANT = of("restaurant")

                            /** Gift shop */
                            val GIFT_SHOP = of("gift_shop")

                            /** Mini bar */
                            val MINI_BAR = of("mini_bar")

                            /** Telephone */
                            val TELEPHONE = of("telephone")

                            /** Other */
                            val OTHER = of("other")

                            /** Laundry */
                            val LAUNDRY = of("laundry")

                            fun of(value: String) = ExtraCharges(JsonField.of(value))
                        }

                        /** An enum containing [ExtraCharges]'s known values. */
                        enum class Known {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Restaurant */
                            RESTAURANT,
                            /** Gift shop */
                            GIFT_SHOP,
                            /** Mini bar */
                            MINI_BAR,
                            /** Telephone */
                            TELEPHONE,
                            /** Other */
                            OTHER,
                            /** Laundry */
                            LAUNDRY,
                        }

                        /**
                         * An enum containing [ExtraCharges]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ExtraCharges] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No extra charge */
                            NO_EXTRA_CHARGE,
                            /** Restaurant */
                            RESTAURANT,
                            /** Gift shop */
                            GIFT_SHOP,
                            /** Mini bar */
                            MINI_BAR,
                            /** Telephone */
                            TELEPHONE,
                            /** Other */
                            OTHER,
                            /** Laundry */
                            LAUNDRY,
                            /**
                             * An enum member indicating that [ExtraCharges] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_EXTRA_CHARGE -> Value.NO_EXTRA_CHARGE
                                RESTAURANT -> Value.RESTAURANT
                                GIFT_SHOP -> Value.GIFT_SHOP
                                MINI_BAR -> Value.MINI_BAR
                                TELEPHONE -> Value.TELEPHONE
                                OTHER -> Value.OTHER
                                LAUNDRY -> Value.LAUNDRY
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_EXTRA_CHARGE -> Known.NO_EXTRA_CHARGE
                                RESTAURANT -> Known.RESTAURANT
                                GIFT_SHOP -> Known.GIFT_SHOP
                                MINI_BAR -> Known.MINI_BAR
                                TELEPHONE -> Known.TELEPHONE
                                OTHER -> Known.OTHER
                                LAUNDRY -> Known.LAUNDRY
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ExtraCharges: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ExtraCharges = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ExtraCharges && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Indicator that the cardholder is being billed for a reserved room that was
                     * not actually used.
                     */
                    class NoShowIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not applicable */
                            val NOT_APPLICABLE = of("not_applicable")

                            /** No show */
                            val NO_SHOW = of("no_show")

                            fun of(value: String) = NoShowIndicator(JsonField.of(value))
                        }

                        /** An enum containing [NoShowIndicator]'s known values. */
                        enum class Known {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show */
                            NO_SHOW,
                        }

                        /**
                         * An enum containing [NoShowIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [NoShowIndicator] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not applicable */
                            NOT_APPLICABLE,
                            /** No show */
                            NO_SHOW,
                            /**
                             * An enum member indicating that [NoShowIndicator] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_APPLICABLE -> Value.NOT_APPLICABLE
                                NO_SHOW -> Value.NO_SHOW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_APPLICABLE -> Known.NOT_APPLICABLE
                                NO_SHOW -> Known.NO_SHOW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown NoShowIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): NoShowIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is NoShowIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Lodging &&
                            checkInDate == other.checkInDate &&
                            dailyRoomRateAmount == other.dailyRoomRateAmount &&
                            dailyRoomRateCurrency == other.dailyRoomRateCurrency &&
                            extraCharges == other.extraCharges &&
                            folioCashAdvancesAmount == other.folioCashAdvancesAmount &&
                            folioCashAdvancesCurrency == other.folioCashAdvancesCurrency &&
                            foodBeverageChargesAmount == other.foodBeverageChargesAmount &&
                            foodBeverageChargesCurrency == other.foodBeverageChargesCurrency &&
                            noShowIndicator == other.noShowIndicator &&
                            prepaidExpensesAmount == other.prepaidExpensesAmount &&
                            prepaidExpensesCurrency == other.prepaidExpensesCurrency &&
                            roomNights == other.roomNights &&
                            totalRoomTaxAmount == other.totalRoomTaxAmount &&
                            totalRoomTaxCurrency == other.totalRoomTaxCurrency &&
                            totalTaxAmount == other.totalTaxAmount &&
                            totalTaxCurrency == other.totalTaxCurrency &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            checkInDate,
                            dailyRoomRateAmount,
                            dailyRoomRateCurrency,
                            extraCharges,
                            folioCashAdvancesAmount,
                            folioCashAdvancesCurrency,
                            foodBeverageChargesAmount,
                            foodBeverageChargesCurrency,
                            noShowIndicator,
                            prepaidExpensesAmount,
                            prepaidExpensesCurrency,
                            roomNights,
                            totalRoomTaxAmount,
                            totalRoomTaxCurrency,
                            totalTaxAmount,
                            totalTaxCurrency,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Lodging{checkInDate=$checkInDate, dailyRoomRateAmount=$dailyRoomRateAmount, dailyRoomRateCurrency=$dailyRoomRateCurrency, extraCharges=$extraCharges, folioCashAdvancesAmount=$folioCashAdvancesAmount, folioCashAdvancesCurrency=$folioCashAdvancesCurrency, foodBeverageChargesAmount=$foodBeverageChargesAmount, foodBeverageChargesCurrency=$foodBeverageChargesCurrency, noShowIndicator=$noShowIndicator, prepaidExpensesAmount=$prepaidExpensesAmount, prepaidExpensesCurrency=$prepaidExpensesCurrency, roomNights=$roomNights, totalRoomTaxAmount=$totalRoomTaxAmount, totalRoomTaxCurrency=$totalRoomTaxCurrency, totalTaxAmount=$totalTaxAmount, totalTaxCurrency=$totalTaxCurrency, additionalProperties=$additionalProperties}"
                }

                /** The format of the purchase identifier. */
                class PurchaseIdentifierFormat
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Free text */
                        val FREE_TEXT = of("free_text")

                        /** Order number */
                        val ORDER_NUMBER = of("order_number")

                        /** Rental agreement number */
                        val RENTAL_AGREEMENT_NUMBER = of("rental_agreement_number")

                        /** Hotel folio number */
                        val HOTEL_FOLIO_NUMBER = of("hotel_folio_number")

                        /** Invoice number */
                        val INVOICE_NUMBER = of("invoice_number")

                        fun of(value: String) = PurchaseIdentifierFormat(JsonField.of(value))
                    }

                    /** An enum containing [PurchaseIdentifierFormat]'s known values. */
                    enum class Known {
                        /** Free text */
                        FREE_TEXT,
                        /** Order number */
                        ORDER_NUMBER,
                        /** Rental agreement number */
                        RENTAL_AGREEMENT_NUMBER,
                        /** Hotel folio number */
                        HOTEL_FOLIO_NUMBER,
                        /** Invoice number */
                        INVOICE_NUMBER,
                    }

                    /**
                     * An enum containing [PurchaseIdentifierFormat]'s known values, as well as an
                     * [_UNKNOWN] member.
                     *
                     * An instance of [PurchaseIdentifierFormat] can contain an unknown value in a
                     * couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Free text */
                        FREE_TEXT,
                        /** Order number */
                        ORDER_NUMBER,
                        /** Rental agreement number */
                        RENTAL_AGREEMENT_NUMBER,
                        /** Hotel folio number */
                        HOTEL_FOLIO_NUMBER,
                        /** Invoice number */
                        INVOICE_NUMBER,
                        /**
                         * An enum member indicating that [PurchaseIdentifierFormat] was
                         * instantiated with an unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            FREE_TEXT -> Value.FREE_TEXT
                            ORDER_NUMBER -> Value.ORDER_NUMBER
                            RENTAL_AGREEMENT_NUMBER -> Value.RENTAL_AGREEMENT_NUMBER
                            HOTEL_FOLIO_NUMBER -> Value.HOTEL_FOLIO_NUMBER
                            INVOICE_NUMBER -> Value.INVOICE_NUMBER
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            FREE_TEXT -> Known.FREE_TEXT
                            ORDER_NUMBER -> Known.ORDER_NUMBER
                            RENTAL_AGREEMENT_NUMBER -> Known.RENTAL_AGREEMENT_NUMBER
                            HOTEL_FOLIO_NUMBER -> Known.HOTEL_FOLIO_NUMBER
                            INVOICE_NUMBER -> Known.INVOICE_NUMBER
                            else ->
                                throw IncreaseInvalidDataException(
                                    "Unknown PurchaseIdentifierFormat: $value"
                                )
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): PurchaseIdentifierFormat = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PurchaseIdentifierFormat && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Fields specific to travel. */
                class Travel
                private constructor(
                    private val ancillary: JsonField<Ancillary>,
                    private val computerizedReservationSystem: JsonField<String>,
                    private val creditReasonIndicator: JsonField<CreditReasonIndicator>,
                    private val departureDate: JsonField<LocalDate>,
                    private val originationCityAirportCode: JsonField<String>,
                    private val passengerName: JsonField<String>,
                    private val restrictedTicketIndicator: JsonField<RestrictedTicketIndicator>,
                    private val ticketChangeIndicator: JsonField<TicketChangeIndicator>,
                    private val ticketNumber: JsonField<String>,
                    private val travelAgencyCode: JsonField<String>,
                    private val travelAgencyName: JsonField<String>,
                    private val tripLegs: JsonField<List<TripLeg>>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("ancillary")
                        @ExcludeMissing
                        ancillary: JsonField<Ancillary> = JsonMissing.of(),
                        @JsonProperty("computerized_reservation_system")
                        @ExcludeMissing
                        computerizedReservationSystem: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("credit_reason_indicator")
                        @ExcludeMissing
                        creditReasonIndicator: JsonField<CreditReasonIndicator> = JsonMissing.of(),
                        @JsonProperty("departure_date")
                        @ExcludeMissing
                        departureDate: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("origination_city_airport_code")
                        @ExcludeMissing
                        originationCityAirportCode: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("passenger_name")
                        @ExcludeMissing
                        passengerName: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("restricted_ticket_indicator")
                        @ExcludeMissing
                        restrictedTicketIndicator: JsonField<RestrictedTicketIndicator> =
                            JsonMissing.of(),
                        @JsonProperty("ticket_change_indicator")
                        @ExcludeMissing
                        ticketChangeIndicator: JsonField<TicketChangeIndicator> = JsonMissing.of(),
                        @JsonProperty("ticket_number")
                        @ExcludeMissing
                        ticketNumber: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("travel_agency_code")
                        @ExcludeMissing
                        travelAgencyCode: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("travel_agency_name")
                        @ExcludeMissing
                        travelAgencyName: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("trip_legs")
                        @ExcludeMissing
                        tripLegs: JsonField<List<TripLeg>> = JsonMissing.of(),
                    ) : this(
                        ancillary,
                        computerizedReservationSystem,
                        creditReasonIndicator,
                        departureDate,
                        originationCityAirportCode,
                        passengerName,
                        restrictedTicketIndicator,
                        ticketChangeIndicator,
                        ticketNumber,
                        travelAgencyCode,
                        travelAgencyName,
                        tripLegs,
                        mutableMapOf(),
                    )

                    /**
                     * Ancillary purchases in addition to the airfare.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ancillary(): Ancillary? = ancillary.getNullable("ancillary")

                    /**
                     * Indicates the computerized reservation system used to book the ticket.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun computerizedReservationSystem(): String? =
                        computerizedReservationSystem.getNullable("computerized_reservation_system")

                    /**
                     * Indicates the reason for a credit to the cardholder.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun creditReasonIndicator(): CreditReasonIndicator? =
                        creditReasonIndicator.getNullable("credit_reason_indicator")

                    /**
                     * Date of departure.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun departureDate(): LocalDate? = departureDate.getNullable("departure_date")

                    /**
                     * Code for the originating city or airport.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun originationCityAirportCode(): String? =
                        originationCityAirportCode.getNullable("origination_city_airport_code")

                    /**
                     * Name of the passenger.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun passengerName(): String? = passengerName.getNullable("passenger_name")

                    /**
                     * Indicates whether this ticket is non-refundable.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun restrictedTicketIndicator(): RestrictedTicketIndicator? =
                        restrictedTicketIndicator.getNullable("restricted_ticket_indicator")

                    /**
                     * Indicates why a ticket was changed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ticketChangeIndicator(): TicketChangeIndicator? =
                        ticketChangeIndicator.getNullable("ticket_change_indicator")

                    /**
                     * Ticket number.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ticketNumber(): String? = ticketNumber.getNullable("ticket_number")

                    /**
                     * Code for the travel agency if the ticket was issued by a travel agency.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun travelAgencyCode(): String? =
                        travelAgencyCode.getNullable("travel_agency_code")

                    /**
                     * Name of the travel agency if the ticket was issued by a travel agency.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun travelAgencyName(): String? =
                        travelAgencyName.getNullable("travel_agency_name")

                    /**
                     * Fields specific to each leg of the journey.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun tripLegs(): List<TripLeg>? = tripLegs.getNullable("trip_legs")

                    /**
                     * Returns the raw JSON value of [ancillary].
                     *
                     * Unlike [ancillary], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("ancillary")
                    @ExcludeMissing
                    fun _ancillary(): JsonField<Ancillary> = ancillary

                    /**
                     * Returns the raw JSON value of [computerizedReservationSystem].
                     *
                     * Unlike [computerizedReservationSystem], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("computerized_reservation_system")
                    @ExcludeMissing
                    fun _computerizedReservationSystem(): JsonField<String> =
                        computerizedReservationSystem

                    /**
                     * Returns the raw JSON value of [creditReasonIndicator].
                     *
                     * Unlike [creditReasonIndicator], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("credit_reason_indicator")
                    @ExcludeMissing
                    fun _creditReasonIndicator(): JsonField<CreditReasonIndicator> =
                        creditReasonIndicator

                    /**
                     * Returns the raw JSON value of [departureDate].
                     *
                     * Unlike [departureDate], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("departure_date")
                    @ExcludeMissing
                    fun _departureDate(): JsonField<LocalDate> = departureDate

                    /**
                     * Returns the raw JSON value of [originationCityAirportCode].
                     *
                     * Unlike [originationCityAirportCode], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("origination_city_airport_code")
                    @ExcludeMissing
                    fun _originationCityAirportCode(): JsonField<String> =
                        originationCityAirportCode

                    /**
                     * Returns the raw JSON value of [passengerName].
                     *
                     * Unlike [passengerName], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("passenger_name")
                    @ExcludeMissing
                    fun _passengerName(): JsonField<String> = passengerName

                    /**
                     * Returns the raw JSON value of [restrictedTicketIndicator].
                     *
                     * Unlike [restrictedTicketIndicator], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("restricted_ticket_indicator")
                    @ExcludeMissing
                    fun _restrictedTicketIndicator(): JsonField<RestrictedTicketIndicator> =
                        restrictedTicketIndicator

                    /**
                     * Returns the raw JSON value of [ticketChangeIndicator].
                     *
                     * Unlike [ticketChangeIndicator], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("ticket_change_indicator")
                    @ExcludeMissing
                    fun _ticketChangeIndicator(): JsonField<TicketChangeIndicator> =
                        ticketChangeIndicator

                    /**
                     * Returns the raw JSON value of [ticketNumber].
                     *
                     * Unlike [ticketNumber], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("ticket_number")
                    @ExcludeMissing
                    fun _ticketNumber(): JsonField<String> = ticketNumber

                    /**
                     * Returns the raw JSON value of [travelAgencyCode].
                     *
                     * Unlike [travelAgencyCode], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("travel_agency_code")
                    @ExcludeMissing
                    fun _travelAgencyCode(): JsonField<String> = travelAgencyCode

                    /**
                     * Returns the raw JSON value of [travelAgencyName].
                     *
                     * Unlike [travelAgencyName], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("travel_agency_name")
                    @ExcludeMissing
                    fun _travelAgencyName(): JsonField<String> = travelAgencyName

                    /**
                     * Returns the raw JSON value of [tripLegs].
                     *
                     * Unlike [tripLegs], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("trip_legs")
                    @ExcludeMissing
                    fun _tripLegs(): JsonField<List<TripLeg>> = tripLegs

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Travel].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .ancillary()
                         * .computerizedReservationSystem()
                         * .creditReasonIndicator()
                         * .departureDate()
                         * .originationCityAirportCode()
                         * .passengerName()
                         * .restrictedTicketIndicator()
                         * .ticketChangeIndicator()
                         * .ticketNumber()
                         * .travelAgencyCode()
                         * .travelAgencyName()
                         * .tripLegs()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Travel]. */
                    class Builder internal constructor() {

                        private var ancillary: JsonField<Ancillary>? = null
                        private var computerizedReservationSystem: JsonField<String>? = null
                        private var creditReasonIndicator: JsonField<CreditReasonIndicator>? = null
                        private var departureDate: JsonField<LocalDate>? = null
                        private var originationCityAirportCode: JsonField<String>? = null
                        private var passengerName: JsonField<String>? = null
                        private var restrictedTicketIndicator:
                            JsonField<RestrictedTicketIndicator>? =
                            null
                        private var ticketChangeIndicator: JsonField<TicketChangeIndicator>? = null
                        private var ticketNumber: JsonField<String>? = null
                        private var travelAgencyCode: JsonField<String>? = null
                        private var travelAgencyName: JsonField<String>? = null
                        private var tripLegs: JsonField<MutableList<TripLeg>>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(travel: Travel) = apply {
                            ancillary = travel.ancillary
                            computerizedReservationSystem = travel.computerizedReservationSystem
                            creditReasonIndicator = travel.creditReasonIndicator
                            departureDate = travel.departureDate
                            originationCityAirportCode = travel.originationCityAirportCode
                            passengerName = travel.passengerName
                            restrictedTicketIndicator = travel.restrictedTicketIndicator
                            ticketChangeIndicator = travel.ticketChangeIndicator
                            ticketNumber = travel.ticketNumber
                            travelAgencyCode = travel.travelAgencyCode
                            travelAgencyName = travel.travelAgencyName
                            tripLegs = travel.tripLegs.map { it.toMutableList() }
                            additionalProperties = travel.additionalProperties.toMutableMap()
                        }

                        /** Ancillary purchases in addition to the airfare. */
                        fun ancillary(ancillary: Ancillary?) =
                            ancillary(JsonField.ofNullable(ancillary))

                        /**
                         * Sets [Builder.ancillary] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ancillary] with a well-typed [Ancillary]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun ancillary(ancillary: JsonField<Ancillary>) = apply {
                            this.ancillary = ancillary
                        }

                        /**
                         * Indicates the computerized reservation system used to book the ticket.
                         */
                        fun computerizedReservationSystem(computerizedReservationSystem: String?) =
                            computerizedReservationSystem(
                                JsonField.ofNullable(computerizedReservationSystem)
                            )

                        /**
                         * Sets [Builder.computerizedReservationSystem] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.computerizedReservationSystem] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun computerizedReservationSystem(
                            computerizedReservationSystem: JsonField<String>
                        ) = apply {
                            this.computerizedReservationSystem = computerizedReservationSystem
                        }

                        /** Indicates the reason for a credit to the cardholder. */
                        fun creditReasonIndicator(creditReasonIndicator: CreditReasonIndicator?) =
                            creditReasonIndicator(JsonField.ofNullable(creditReasonIndicator))

                        /**
                         * Sets [Builder.creditReasonIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.creditReasonIndicator] with a well-typed
                         * [CreditReasonIndicator] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun creditReasonIndicator(
                            creditReasonIndicator: JsonField<CreditReasonIndicator>
                        ) = apply { this.creditReasonIndicator = creditReasonIndicator }

                        /** Date of departure. */
                        fun departureDate(departureDate: LocalDate?) =
                            departureDate(JsonField.ofNullable(departureDate))

                        /**
                         * Sets [Builder.departureDate] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.departureDate] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun departureDate(departureDate: JsonField<LocalDate>) = apply {
                            this.departureDate = departureDate
                        }

                        /** Code for the originating city or airport. */
                        fun originationCityAirportCode(originationCityAirportCode: String?) =
                            originationCityAirportCode(
                                JsonField.ofNullable(originationCityAirportCode)
                            )

                        /**
                         * Sets [Builder.originationCityAirportCode] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.originationCityAirportCode] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun originationCityAirportCode(
                            originationCityAirportCode: JsonField<String>
                        ) = apply { this.originationCityAirportCode = originationCityAirportCode }

                        /** Name of the passenger. */
                        fun passengerName(passengerName: String?) =
                            passengerName(JsonField.ofNullable(passengerName))

                        /**
                         * Sets [Builder.passengerName] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.passengerName] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun passengerName(passengerName: JsonField<String>) = apply {
                            this.passengerName = passengerName
                        }

                        /** Indicates whether this ticket is non-refundable. */
                        fun restrictedTicketIndicator(
                            restrictedTicketIndicator: RestrictedTicketIndicator?
                        ) =
                            restrictedTicketIndicator(
                                JsonField.ofNullable(restrictedTicketIndicator)
                            )

                        /**
                         * Sets [Builder.restrictedTicketIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.restrictedTicketIndicator] with a
                         * well-typed [RestrictedTicketIndicator] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun restrictedTicketIndicator(
                            restrictedTicketIndicator: JsonField<RestrictedTicketIndicator>
                        ) = apply { this.restrictedTicketIndicator = restrictedTicketIndicator }

                        /** Indicates why a ticket was changed. */
                        fun ticketChangeIndicator(ticketChangeIndicator: TicketChangeIndicator?) =
                            ticketChangeIndicator(JsonField.ofNullable(ticketChangeIndicator))

                        /**
                         * Sets [Builder.ticketChangeIndicator] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ticketChangeIndicator] with a well-typed
                         * [TicketChangeIndicator] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun ticketChangeIndicator(
                            ticketChangeIndicator: JsonField<TicketChangeIndicator>
                        ) = apply { this.ticketChangeIndicator = ticketChangeIndicator }

                        /** Ticket number. */
                        fun ticketNumber(ticketNumber: String?) =
                            ticketNumber(JsonField.ofNullable(ticketNumber))

                        /**
                         * Sets [Builder.ticketNumber] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ticketNumber] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun ticketNumber(ticketNumber: JsonField<String>) = apply {
                            this.ticketNumber = ticketNumber
                        }

                        /**
                         * Code for the travel agency if the ticket was issued by a travel agency.
                         */
                        fun travelAgencyCode(travelAgencyCode: String?) =
                            travelAgencyCode(JsonField.ofNullable(travelAgencyCode))

                        /**
                         * Sets [Builder.travelAgencyCode] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.travelAgencyCode] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun travelAgencyCode(travelAgencyCode: JsonField<String>) = apply {
                            this.travelAgencyCode = travelAgencyCode
                        }

                        /**
                         * Name of the travel agency if the ticket was issued by a travel agency.
                         */
                        fun travelAgencyName(travelAgencyName: String?) =
                            travelAgencyName(JsonField.ofNullable(travelAgencyName))

                        /**
                         * Sets [Builder.travelAgencyName] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.travelAgencyName] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun travelAgencyName(travelAgencyName: JsonField<String>) = apply {
                            this.travelAgencyName = travelAgencyName
                        }

                        /** Fields specific to each leg of the journey. */
                        fun tripLegs(tripLegs: List<TripLeg>?) =
                            tripLegs(JsonField.ofNullable(tripLegs))

                        /**
                         * Sets [Builder.tripLegs] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.tripLegs] with a well-typed
                         * `List<TripLeg>` value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun tripLegs(tripLegs: JsonField<List<TripLeg>>) = apply {
                            this.tripLegs = tripLegs.map { it.toMutableList() }
                        }

                        /**
                         * Adds a single [TripLeg] to [tripLegs].
                         *
                         * @throws IllegalStateException if the field was previously set to a
                         *   non-list.
                         */
                        fun addTripLeg(tripLeg: TripLeg) = apply {
                            tripLegs =
                                (tripLegs ?: JsonField.of(mutableListOf())).also {
                                    checkKnown("tripLegs", it).add(tripLeg)
                                }
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Travel].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .ancillary()
                         * .computerizedReservationSystem()
                         * .creditReasonIndicator()
                         * .departureDate()
                         * .originationCityAirportCode()
                         * .passengerName()
                         * .restrictedTicketIndicator()
                         * .ticketChangeIndicator()
                         * .ticketNumber()
                         * .travelAgencyCode()
                         * .travelAgencyName()
                         * .tripLegs()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Travel =
                            Travel(
                                checkRequired("ancillary", ancillary),
                                checkRequired(
                                    "computerizedReservationSystem",
                                    computerizedReservationSystem,
                                ),
                                checkRequired("creditReasonIndicator", creditReasonIndicator),
                                checkRequired("departureDate", departureDate),
                                checkRequired(
                                    "originationCityAirportCode",
                                    originationCityAirportCode,
                                ),
                                checkRequired("passengerName", passengerName),
                                checkRequired(
                                    "restrictedTicketIndicator",
                                    restrictedTicketIndicator,
                                ),
                                checkRequired("ticketChangeIndicator", ticketChangeIndicator),
                                checkRequired("ticketNumber", ticketNumber),
                                checkRequired("travelAgencyCode", travelAgencyCode),
                                checkRequired("travelAgencyName", travelAgencyName),
                                checkRequired("tripLegs", tripLegs).map { it.toImmutable() },
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Travel = apply {
                        if (validated) {
                            return@apply
                        }

                        ancillary()?.validate()
                        computerizedReservationSystem()
                        creditReasonIndicator()?.validate()
                        departureDate()
                        originationCityAirportCode()
                        passengerName()
                        restrictedTicketIndicator()?.validate()
                        ticketChangeIndicator()?.validate()
                        ticketNumber()
                        travelAgencyCode()
                        travelAgencyName()
                        tripLegs()?.forEach { it.validate() }
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (ancillary.asKnown()?.validity() ?: 0) +
                            (if (computerizedReservationSystem.asKnown() == null) 0 else 1) +
                            (creditReasonIndicator.asKnown()?.validity() ?: 0) +
                            (if (departureDate.asKnown() == null) 0 else 1) +
                            (if (originationCityAirportCode.asKnown() == null) 0 else 1) +
                            (if (passengerName.asKnown() == null) 0 else 1) +
                            (restrictedTicketIndicator.asKnown()?.validity() ?: 0) +
                            (ticketChangeIndicator.asKnown()?.validity() ?: 0) +
                            (if (ticketNumber.asKnown() == null) 0 else 1) +
                            (if (travelAgencyCode.asKnown() == null) 0 else 1) +
                            (if (travelAgencyName.asKnown() == null) 0 else 1) +
                            (tripLegs.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

                    /** Ancillary purchases in addition to the airfare. */
                    class Ancillary
                    private constructor(
                        private val connectedTicketDocumentNumber: JsonField<String>,
                        private val creditReasonIndicator: JsonField<CreditReasonIndicator>,
                        private val passengerNameOrDescription: JsonField<String>,
                        private val services: JsonField<List<Service>>,
                        private val ticketDocumentNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("connected_ticket_document_number")
                            @ExcludeMissing
                            connectedTicketDocumentNumber: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("credit_reason_indicator")
                            @ExcludeMissing
                            creditReasonIndicator: JsonField<CreditReasonIndicator> =
                                JsonMissing.of(),
                            @JsonProperty("passenger_name_or_description")
                            @ExcludeMissing
                            passengerNameOrDescription: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("services")
                            @ExcludeMissing
                            services: JsonField<List<Service>> = JsonMissing.of(),
                            @JsonProperty("ticket_document_number")
                            @ExcludeMissing
                            ticketDocumentNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            connectedTicketDocumentNumber,
                            creditReasonIndicator,
                            passengerNameOrDescription,
                            services,
                            ticketDocumentNumber,
                            mutableMapOf(),
                        )

                        /**
                         * If this purchase has a connection or relationship to another purchase,
                         * such as a baggage fee for a passenger transport ticket, this field should
                         * contain the ticket document number for the other purchase.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun connectedTicketDocumentNumber(): String? =
                            connectedTicketDocumentNumber.getNullable(
                                "connected_ticket_document_number"
                            )

                        /**
                         * Indicates the reason for a credit to the cardholder.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun creditReasonIndicator(): CreditReasonIndicator? =
                            creditReasonIndicator.getNullable("credit_reason_indicator")

                        /**
                         * Name of the passenger or description of the ancillary purchase.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun passengerNameOrDescription(): String? =
                            passengerNameOrDescription.getNullable("passenger_name_or_description")

                        /**
                         * Additional travel charges, such as baggage fees.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun services(): List<Service> = services.getRequired("services")

                        /**
                         * Ticket document number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun ticketDocumentNumber(): String? =
                            ticketDocumentNumber.getNullable("ticket_document_number")

                        /**
                         * Returns the raw JSON value of [connectedTicketDocumentNumber].
                         *
                         * Unlike [connectedTicketDocumentNumber], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("connected_ticket_document_number")
                        @ExcludeMissing
                        fun _connectedTicketDocumentNumber(): JsonField<String> =
                            connectedTicketDocumentNumber

                        /**
                         * Returns the raw JSON value of [creditReasonIndicator].
                         *
                         * Unlike [creditReasonIndicator], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("credit_reason_indicator")
                        @ExcludeMissing
                        fun _creditReasonIndicator(): JsonField<CreditReasonIndicator> =
                            creditReasonIndicator

                        /**
                         * Returns the raw JSON value of [passengerNameOrDescription].
                         *
                         * Unlike [passengerNameOrDescription], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("passenger_name_or_description")
                        @ExcludeMissing
                        fun _passengerNameOrDescription(): JsonField<String> =
                            passengerNameOrDescription

                        /**
                         * Returns the raw JSON value of [services].
                         *
                         * Unlike [services], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("services")
                        @ExcludeMissing
                        fun _services(): JsonField<List<Service>> = services

                        /**
                         * Returns the raw JSON value of [ticketDocumentNumber].
                         *
                         * Unlike [ticketDocumentNumber], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("ticket_document_number")
                        @ExcludeMissing
                        fun _ticketDocumentNumber(): JsonField<String> = ticketDocumentNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [Ancillary].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .connectedTicketDocumentNumber()
                             * .creditReasonIndicator()
                             * .passengerNameOrDescription()
                             * .services()
                             * .ticketDocumentNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Ancillary]. */
                        class Builder internal constructor() {

                            private var connectedTicketDocumentNumber: JsonField<String>? = null
                            private var creditReasonIndicator: JsonField<CreditReasonIndicator>? =
                                null
                            private var passengerNameOrDescription: JsonField<String>? = null
                            private var services: JsonField<MutableList<Service>>? = null
                            private var ticketDocumentNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(ancillary: Ancillary) = apply {
                                connectedTicketDocumentNumber =
                                    ancillary.connectedTicketDocumentNumber
                                creditReasonIndicator = ancillary.creditReasonIndicator
                                passengerNameOrDescription = ancillary.passengerNameOrDescription
                                services = ancillary.services.map { it.toMutableList() }
                                ticketDocumentNumber = ancillary.ticketDocumentNumber
                                additionalProperties = ancillary.additionalProperties.toMutableMap()
                            }

                            /**
                             * If this purchase has a connection or relationship to another
                             * purchase, such as a baggage fee for a passenger transport ticket,
                             * this field should contain the ticket document number for the other
                             * purchase.
                             */
                            fun connectedTicketDocumentNumber(
                                connectedTicketDocumentNumber: String?
                            ) =
                                connectedTicketDocumentNumber(
                                    JsonField.ofNullable(connectedTicketDocumentNumber)
                                )

                            /**
                             * Sets [Builder.connectedTicketDocumentNumber] to an arbitrary JSON
                             * value.
                             *
                             * You should usually call [Builder.connectedTicketDocumentNumber] with
                             * a well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun connectedTicketDocumentNumber(
                                connectedTicketDocumentNumber: JsonField<String>
                            ) = apply {
                                this.connectedTicketDocumentNumber = connectedTicketDocumentNumber
                            }

                            /** Indicates the reason for a credit to the cardholder. */
                            fun creditReasonIndicator(
                                creditReasonIndicator: CreditReasonIndicator?
                            ) = creditReasonIndicator(JsonField.ofNullable(creditReasonIndicator))

                            /**
                             * Sets [Builder.creditReasonIndicator] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.creditReasonIndicator] with a
                             * well-typed [CreditReasonIndicator] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun creditReasonIndicator(
                                creditReasonIndicator: JsonField<CreditReasonIndicator>
                            ) = apply { this.creditReasonIndicator = creditReasonIndicator }

                            /** Name of the passenger or description of the ancillary purchase. */
                            fun passengerNameOrDescription(passengerNameOrDescription: String?) =
                                passengerNameOrDescription(
                                    JsonField.ofNullable(passengerNameOrDescription)
                                )

                            /**
                             * Sets [Builder.passengerNameOrDescription] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.passengerNameOrDescription] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun passengerNameOrDescription(
                                passengerNameOrDescription: JsonField<String>
                            ) = apply {
                                this.passengerNameOrDescription = passengerNameOrDescription
                            }

                            /** Additional travel charges, such as baggage fees. */
                            fun services(services: List<Service>) = services(JsonField.of(services))

                            /**
                             * Sets [Builder.services] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.services] with a well-typed
                             * `List<Service>` value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun services(services: JsonField<List<Service>>) = apply {
                                this.services = services.map { it.toMutableList() }
                            }

                            /**
                             * Adds a single [Service] to [services].
                             *
                             * @throws IllegalStateException if the field was previously set to a
                             *   non-list.
                             */
                            fun addService(service: Service) = apply {
                                services =
                                    (services ?: JsonField.of(mutableListOf())).also {
                                        checkKnown("services", it).add(service)
                                    }
                            }

                            /** Ticket document number. */
                            fun ticketDocumentNumber(ticketDocumentNumber: String?) =
                                ticketDocumentNumber(JsonField.ofNullable(ticketDocumentNumber))

                            /**
                             * Sets [Builder.ticketDocumentNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.ticketDocumentNumber] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun ticketDocumentNumber(ticketDocumentNumber: JsonField<String>) =
                                apply {
                                    this.ticketDocumentNumber = ticketDocumentNumber
                                }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Ancillary].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .connectedTicketDocumentNumber()
                             * .creditReasonIndicator()
                             * .passengerNameOrDescription()
                             * .services()
                             * .ticketDocumentNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Ancillary =
                                Ancillary(
                                    checkRequired(
                                        "connectedTicketDocumentNumber",
                                        connectedTicketDocumentNumber,
                                    ),
                                    checkRequired("creditReasonIndicator", creditReasonIndicator),
                                    checkRequired(
                                        "passengerNameOrDescription",
                                        passengerNameOrDescription,
                                    ),
                                    checkRequired("services", services).map { it.toImmutable() },
                                    checkRequired("ticketDocumentNumber", ticketDocumentNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Ancillary = apply {
                            if (validated) {
                                return@apply
                            }

                            connectedTicketDocumentNumber()
                            creditReasonIndicator()?.validate()
                            passengerNameOrDescription()
                            services().forEach { it.validate() }
                            ticketDocumentNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (connectedTicketDocumentNumber.asKnown() == null) 0 else 1) +
                                (creditReasonIndicator.asKnown()?.validity() ?: 0) +
                                (if (passengerNameOrDescription.asKnown() == null) 0 else 1) +
                                (services.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                                (if (ticketDocumentNumber.asKnown() == null) 0 else 1)

                        /** Indicates the reason for a credit to the cardholder. */
                        class CreditReasonIndicator
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** No credit */
                                val NO_CREDIT = of("no_credit")

                                /** Passenger transport ancillary purchase cancellation */
                                val PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                    of("passenger_transport_ancillary_purchase_cancellation")

                                /**
                                 * Airline ticket and passenger transport ancillary purchase
                                 * cancellation
                                 */
                                val AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                    of(
                                        "airline_ticket_and_passenger_transport_ancillary_purchase_cancellation"
                                    )

                                /** Other */
                                val OTHER = of("other")

                                fun of(value: String) = CreditReasonIndicator(JsonField.of(value))
                            }

                            /** An enum containing [CreditReasonIndicator]'s known values. */
                            enum class Known {
                                /** No credit */
                                NO_CREDIT,
                                /** Passenger transport ancillary purchase cancellation */
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /**
                                 * Airline ticket and passenger transport ancillary purchase
                                 * cancellation
                                 */
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /** Other */
                                OTHER,
                            }

                            /**
                             * An enum containing [CreditReasonIndicator]'s known values, as well as
                             * an [_UNKNOWN] member.
                             *
                             * An instance of [CreditReasonIndicator] can contain an unknown value
                             * in a couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** No credit */
                                NO_CREDIT,
                                /** Passenger transport ancillary purchase cancellation */
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /**
                                 * Airline ticket and passenger transport ancillary purchase
                                 * cancellation
                                 */
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                                /** Other */
                                OTHER,
                                /**
                                 * An enum member indicating that [CreditReasonIndicator] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    NO_CREDIT -> Value.NO_CREDIT
                                    PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Value.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Value
                                            .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    OTHER -> Value.OTHER
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    NO_CREDIT -> Known.NO_CREDIT
                                    PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Known.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                        Known
                                            .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                    OTHER -> Known.OTHER
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown CreditReasonIndicator: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): CreditReasonIndicator = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is CreditReasonIndicator && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        class Service
                        private constructor(
                            private val category: JsonField<Category>,
                            private val subCategory: JsonField<String>,
                            private val additionalProperties: MutableMap<String, JsonValue>,
                        ) {

                            @JsonCreator
                            private constructor(
                                @JsonProperty("category")
                                @ExcludeMissing
                                category: JsonField<Category> = JsonMissing.of(),
                                @JsonProperty("sub_category")
                                @ExcludeMissing
                                subCategory: JsonField<String> = JsonMissing.of(),
                            ) : this(category, subCategory, mutableMapOf())

                            /**
                             * Category of the ancillary service.
                             *
                             * @throws IncreaseInvalidDataException if the JSON field has an
                             *   unexpected type (e.g. if the server responded with an unexpected
                             *   value).
                             */
                            fun category(): Category? = category.getNullable("category")

                            /**
                             * Sub-category of the ancillary service, free-form.
                             *
                             * @throws IncreaseInvalidDataException if the JSON field has an
                             *   unexpected type (e.g. if the server responded with an unexpected
                             *   value).
                             */
                            fun subCategory(): String? = subCategory.getNullable("sub_category")

                            /**
                             * Returns the raw JSON value of [category].
                             *
                             * Unlike [category], this method doesn't throw if the JSON field has an
                             * unexpected type.
                             */
                            @JsonProperty("category")
                            @ExcludeMissing
                            fun _category(): JsonField<Category> = category

                            /**
                             * Returns the raw JSON value of [subCategory].
                             *
                             * Unlike [subCategory], this method doesn't throw if the JSON field has
                             * an unexpected type.
                             */
                            @JsonProperty("sub_category")
                            @ExcludeMissing
                            fun _subCategory(): JsonField<String> = subCategory

                            @JsonAnySetter
                            private fun putAdditionalProperty(key: String, value: JsonValue) {
                                additionalProperties.put(key, value)
                            }

                            @JsonAnyGetter
                            @ExcludeMissing
                            fun _additionalProperties(): Map<String, JsonValue> =
                                Collections.unmodifiableMap(additionalProperties)

                            fun toBuilder() = Builder().from(this)

                            companion object {

                                /**
                                 * Returns a mutable builder for constructing an instance of
                                 * [Service].
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .category()
                                 * .subCategory()
                                 * ```
                                 */
                                fun builder() = Builder()
                            }

                            /** A builder for [Service]. */
                            class Builder internal constructor() {

                                private var category: JsonField<Category>? = null
                                private var subCategory: JsonField<String>? = null
                                private var additionalProperties: MutableMap<String, JsonValue> =
                                    mutableMapOf()

                                internal fun from(service: Service) = apply {
                                    category = service.category
                                    subCategory = service.subCategory
                                    additionalProperties =
                                        service.additionalProperties.toMutableMap()
                                }

                                /** Category of the ancillary service. */
                                fun category(category: Category?) =
                                    category(JsonField.ofNullable(category))

                                /**
                                 * Sets [Builder.category] to an arbitrary JSON value.
                                 *
                                 * You should usually call [Builder.category] with a well-typed
                                 * [Category] value instead. This method is primarily for setting
                                 * the field to an undocumented or not yet supported value.
                                 */
                                fun category(category: JsonField<Category>) = apply {
                                    this.category = category
                                }

                                /** Sub-category of the ancillary service, free-form. */
                                fun subCategory(subCategory: String?) =
                                    subCategory(JsonField.ofNullable(subCategory))

                                /**
                                 * Sets [Builder.subCategory] to an arbitrary JSON value.
                                 *
                                 * You should usually call [Builder.subCategory] with a well-typed
                                 * [String] value instead. This method is primarily for setting the
                                 * field to an undocumented or not yet supported value.
                                 */
                                fun subCategory(subCategory: JsonField<String>) = apply {
                                    this.subCategory = subCategory
                                }

                                fun additionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                    additionalProperties.put(key, value)
                                }

                                fun putAllAdditionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply { this.additionalProperties.putAll(additionalProperties) }

                                fun removeAdditionalProperty(key: String) = apply {
                                    additionalProperties.remove(key)
                                }

                                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                    keys.forEach(::removeAdditionalProperty)
                                }

                                /**
                                 * Returns an immutable instance of [Service].
                                 *
                                 * Further updates to this [Builder] will not mutate the returned
                                 * instance.
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .category()
                                 * .subCategory()
                                 * ```
                                 *
                                 * @throws IllegalStateException if any required field is unset.
                                 */
                                fun build(): Service =
                                    Service(
                                        checkRequired("category", category),
                                        checkRequired("subCategory", subCategory),
                                        additionalProperties.toMutableMap(),
                                    )
                            }

                            private var validated: Boolean = false

                            fun validate(): Service = apply {
                                if (validated) {
                                    return@apply
                                }

                                category()?.validate()
                                subCategory()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int =
                                (category.asKnown()?.validity() ?: 0) +
                                    (if (subCategory.asKnown() == null) 0 else 1)

                            /** Category of the ancillary service. */
                            class Category
                            @JsonCreator
                            private constructor(private val value: JsonField<String>) : Enum {

                                /**
                                 * Returns this class instance's raw value.
                                 *
                                 * This is usually only useful if this instance was deserialized
                                 * from data that doesn't match any known member, and you want to
                                 * know that value. For example, if the SDK is on an older version
                                 * than the API, then the API may respond with new members that the
                                 * SDK is unaware of.
                                 */
                                @com.fasterxml.jackson.annotation.JsonValue
                                fun _value(): JsonField<String> = value

                                companion object {

                                    /** None */
                                    val NONE = of("none")

                                    /** Bundled service */
                                    val BUNDLED_SERVICE = of("bundled_service")

                                    /** Baggage fee */
                                    val BAGGAGE_FEE = of("baggage_fee")

                                    /** Change fee */
                                    val CHANGE_FEE = of("change_fee")

                                    /** Cargo */
                                    val CARGO = of("cargo")

                                    /** Carbon offset */
                                    val CARBON_OFFSET = of("carbon_offset")

                                    /** Frequent flyer */
                                    val FREQUENT_FLYER = of("frequent_flyer")

                                    /** Gift card */
                                    val GIFT_CARD = of("gift_card")

                                    /** Ground transport */
                                    val GROUND_TRANSPORT = of("ground_transport")

                                    /** In-flight entertainment */
                                    val IN_FLIGHT_ENTERTAINMENT = of("in_flight_entertainment")

                                    /** Lounge */
                                    val LOUNGE = of("lounge")

                                    /** Medical */
                                    val MEDICAL = of("medical")

                                    /** Meal beverage */
                                    val MEAL_BEVERAGE = of("meal_beverage")

                                    /** Other */
                                    val OTHER = of("other")

                                    /** Passenger assist fee */
                                    val PASSENGER_ASSIST_FEE = of("passenger_assist_fee")

                                    /** Pets */
                                    val PETS = of("pets")

                                    /** Seat fees */
                                    val SEAT_FEES = of("seat_fees")

                                    /** Standby */
                                    val STANDBY = of("standby")

                                    /** Service fee */
                                    val SERVICE_FEE = of("service_fee")

                                    /** Store */
                                    val STORE = of("store")

                                    /** Travel service */
                                    val TRAVEL_SERVICE = of("travel_service")

                                    /** Unaccompanied travel */
                                    val UNACCOMPANIED_TRAVEL = of("unaccompanied_travel")

                                    /** Upgrades */
                                    val UPGRADES = of("upgrades")

                                    /** Wi-fi */
                                    val WIFI = of("wifi")

                                    fun of(value: String) = Category(JsonField.of(value))
                                }

                                /** An enum containing [Category]'s known values. */
                                enum class Known {
                                    /** None */
                                    NONE,
                                    /** Bundled service */
                                    BUNDLED_SERVICE,
                                    /** Baggage fee */
                                    BAGGAGE_FEE,
                                    /** Change fee */
                                    CHANGE_FEE,
                                    /** Cargo */
                                    CARGO,
                                    /** Carbon offset */
                                    CARBON_OFFSET,
                                    /** Frequent flyer */
                                    FREQUENT_FLYER,
                                    /** Gift card */
                                    GIFT_CARD,
                                    /** Ground transport */
                                    GROUND_TRANSPORT,
                                    /** In-flight entertainment */
                                    IN_FLIGHT_ENTERTAINMENT,
                                    /** Lounge */
                                    LOUNGE,
                                    /** Medical */
                                    MEDICAL,
                                    /** Meal beverage */
                                    MEAL_BEVERAGE,
                                    /** Other */
                                    OTHER,
                                    /** Passenger assist fee */
                                    PASSENGER_ASSIST_FEE,
                                    /** Pets */
                                    PETS,
                                    /** Seat fees */
                                    SEAT_FEES,
                                    /** Standby */
                                    STANDBY,
                                    /** Service fee */
                                    SERVICE_FEE,
                                    /** Store */
                                    STORE,
                                    /** Travel service */
                                    TRAVEL_SERVICE,
                                    /** Unaccompanied travel */
                                    UNACCOMPANIED_TRAVEL,
                                    /** Upgrades */
                                    UPGRADES,
                                    /** Wi-fi */
                                    WIFI,
                                }

                                /**
                                 * An enum containing [Category]'s known values, as well as an
                                 * [_UNKNOWN] member.
                                 *
                                 * An instance of [Category] can contain an unknown value in a
                                 * couple of cases:
                                 * - It was deserialized from data that doesn't match any known
                                 *   member. For example, if the SDK is on an older version than the
                                 *   API, then the API may respond with new members that the SDK is
                                 *   unaware of.
                                 * - It was constructed with an arbitrary value using the [of]
                                 *   method.
                                 */
                                enum class Value {
                                    /** None */
                                    NONE,
                                    /** Bundled service */
                                    BUNDLED_SERVICE,
                                    /** Baggage fee */
                                    BAGGAGE_FEE,
                                    /** Change fee */
                                    CHANGE_FEE,
                                    /** Cargo */
                                    CARGO,
                                    /** Carbon offset */
                                    CARBON_OFFSET,
                                    /** Frequent flyer */
                                    FREQUENT_FLYER,
                                    /** Gift card */
                                    GIFT_CARD,
                                    /** Ground transport */
                                    GROUND_TRANSPORT,
                                    /** In-flight entertainment */
                                    IN_FLIGHT_ENTERTAINMENT,
                                    /** Lounge */
                                    LOUNGE,
                                    /** Medical */
                                    MEDICAL,
                                    /** Meal beverage */
                                    MEAL_BEVERAGE,
                                    /** Other */
                                    OTHER,
                                    /** Passenger assist fee */
                                    PASSENGER_ASSIST_FEE,
                                    /** Pets */
                                    PETS,
                                    /** Seat fees */
                                    SEAT_FEES,
                                    /** Standby */
                                    STANDBY,
                                    /** Service fee */
                                    SERVICE_FEE,
                                    /** Store */
                                    STORE,
                                    /** Travel service */
                                    TRAVEL_SERVICE,
                                    /** Unaccompanied travel */
                                    UNACCOMPANIED_TRAVEL,
                                    /** Upgrades */
                                    UPGRADES,
                                    /** Wi-fi */
                                    WIFI,
                                    /**
                                     * An enum member indicating that [Category] was instantiated
                                     * with an unknown value.
                                     */
                                    _UNKNOWN,
                                }

                                /**
                                 * Returns an enum member corresponding to this class instance's
                                 * value, or [Value._UNKNOWN] if the class was instantiated with an
                                 * unknown value.
                                 *
                                 * Use the [known] method instead if you're certain the value is
                                 * always known or if you want to throw for the unknown case.
                                 */
                                fun value(): Value =
                                    when (this) {
                                        NONE -> Value.NONE
                                        BUNDLED_SERVICE -> Value.BUNDLED_SERVICE
                                        BAGGAGE_FEE -> Value.BAGGAGE_FEE
                                        CHANGE_FEE -> Value.CHANGE_FEE
                                        CARGO -> Value.CARGO
                                        CARBON_OFFSET -> Value.CARBON_OFFSET
                                        FREQUENT_FLYER -> Value.FREQUENT_FLYER
                                        GIFT_CARD -> Value.GIFT_CARD
                                        GROUND_TRANSPORT -> Value.GROUND_TRANSPORT
                                        IN_FLIGHT_ENTERTAINMENT -> Value.IN_FLIGHT_ENTERTAINMENT
                                        LOUNGE -> Value.LOUNGE
                                        MEDICAL -> Value.MEDICAL
                                        MEAL_BEVERAGE -> Value.MEAL_BEVERAGE
                                        OTHER -> Value.OTHER
                                        PASSENGER_ASSIST_FEE -> Value.PASSENGER_ASSIST_FEE
                                        PETS -> Value.PETS
                                        SEAT_FEES -> Value.SEAT_FEES
                                        STANDBY -> Value.STANDBY
                                        SERVICE_FEE -> Value.SERVICE_FEE
                                        STORE -> Value.STORE
                                        TRAVEL_SERVICE -> Value.TRAVEL_SERVICE
                                        UNACCOMPANIED_TRAVEL -> Value.UNACCOMPANIED_TRAVEL
                                        UPGRADES -> Value.UPGRADES
                                        WIFI -> Value.WIFI
                                        else -> Value._UNKNOWN
                                    }

                                /**
                                 * Returns an enum member corresponding to this class instance's
                                 * value.
                                 *
                                 * Use the [value] method instead if you're uncertain the value is
                                 * always known and don't want to throw for the unknown case.
                                 *
                                 * @throws IncreaseInvalidDataException if this class instance's
                                 *   value is a not a known member.
                                 */
                                fun known(): Known =
                                    when (this) {
                                        NONE -> Known.NONE
                                        BUNDLED_SERVICE -> Known.BUNDLED_SERVICE
                                        BAGGAGE_FEE -> Known.BAGGAGE_FEE
                                        CHANGE_FEE -> Known.CHANGE_FEE
                                        CARGO -> Known.CARGO
                                        CARBON_OFFSET -> Known.CARBON_OFFSET
                                        FREQUENT_FLYER -> Known.FREQUENT_FLYER
                                        GIFT_CARD -> Known.GIFT_CARD
                                        GROUND_TRANSPORT -> Known.GROUND_TRANSPORT
                                        IN_FLIGHT_ENTERTAINMENT -> Known.IN_FLIGHT_ENTERTAINMENT
                                        LOUNGE -> Known.LOUNGE
                                        MEDICAL -> Known.MEDICAL
                                        MEAL_BEVERAGE -> Known.MEAL_BEVERAGE
                                        OTHER -> Known.OTHER
                                        PASSENGER_ASSIST_FEE -> Known.PASSENGER_ASSIST_FEE
                                        PETS -> Known.PETS
                                        SEAT_FEES -> Known.SEAT_FEES
                                        STANDBY -> Known.STANDBY
                                        SERVICE_FEE -> Known.SERVICE_FEE
                                        STORE -> Known.STORE
                                        TRAVEL_SERVICE -> Known.TRAVEL_SERVICE
                                        UNACCOMPANIED_TRAVEL -> Known.UNACCOMPANIED_TRAVEL
                                        UPGRADES -> Known.UPGRADES
                                        WIFI -> Known.WIFI
                                        else ->
                                            throw IncreaseInvalidDataException(
                                                "Unknown Category: $value"
                                            )
                                    }

                                /**
                                 * Returns this class instance's primitive wire representation.
                                 *
                                 * This differs from the [toString] method because that method is
                                 * primarily for debugging and generally doesn't throw.
                                 *
                                 * @throws IncreaseInvalidDataException if this class instance's
                                 *   value does not have the expected primitive type.
                                 */
                                fun asString(): String =
                                    _value().asString()
                                        ?: throw IncreaseInvalidDataException(
                                            "Value is not a String"
                                        )

                                private var validated: Boolean = false

                                fun validate(): Category = apply {
                                    if (validated) {
                                        return@apply
                                    }

                                    known()
                                    validated = true
                                }

                                fun isValid(): Boolean =
                                    try {
                                        validate()
                                        true
                                    } catch (e: IncreaseInvalidDataException) {
                                        false
                                    }

                                /**
                                 * Returns a score indicating how many valid values are contained in
                                 * this object recursively.
                                 *
                                 * Used for best match union deserialization.
                                 */
                                internal fun validity(): Int =
                                    if (value() == Value._UNKNOWN) 0 else 1

                                override fun equals(other: Any?): Boolean {
                                    if (this === other) {
                                        return true
                                    }

                                    return other is Category && value == other.value
                                }

                                override fun hashCode() = value.hashCode()

                                override fun toString() = value.toString()
                            }

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is Service &&
                                    category == other.category &&
                                    subCategory == other.subCategory &&
                                    additionalProperties == other.additionalProperties
                            }

                            private val hashCode: Int by lazy {
                                Objects.hash(category, subCategory, additionalProperties)
                            }

                            override fun hashCode(): Int = hashCode

                            override fun toString() =
                                "Service{category=$category, subCategory=$subCategory, additionalProperties=$additionalProperties}"
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Ancillary &&
                                connectedTicketDocumentNumber ==
                                    other.connectedTicketDocumentNumber &&
                                creditReasonIndicator == other.creditReasonIndicator &&
                                passengerNameOrDescription == other.passengerNameOrDescription &&
                                services == other.services &&
                                ticketDocumentNumber == other.ticketDocumentNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                connectedTicketDocumentNumber,
                                creditReasonIndicator,
                                passengerNameOrDescription,
                                services,
                                ticketDocumentNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Ancillary{connectedTicketDocumentNumber=$connectedTicketDocumentNumber, creditReasonIndicator=$creditReasonIndicator, passengerNameOrDescription=$passengerNameOrDescription, services=$services, ticketDocumentNumber=$ticketDocumentNumber, additionalProperties=$additionalProperties}"
                    }

                    /** Indicates the reason for a credit to the cardholder. */
                    class CreditReasonIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No credit */
                            val NO_CREDIT = of("no_credit")

                            /** Passenger transport ancillary purchase cancellation */
                            val PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                of("passenger_transport_ancillary_purchase_cancellation")

                            /**
                             * Airline ticket and passenger transport ancillary purchase
                             * cancellation
                             */
                            val AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION =
                                of(
                                    "airline_ticket_and_passenger_transport_ancillary_purchase_cancellation"
                                )

                            /** Airline ticket cancellation */
                            val AIRLINE_TICKET_CANCELLATION = of("airline_ticket_cancellation")

                            /** Other */
                            val OTHER = of("other")

                            /** Partial refund of airline ticket */
                            val PARTIAL_REFUND_OF_AIRLINE_TICKET =
                                of("partial_refund_of_airline_ticket")

                            fun of(value: String) = CreditReasonIndicator(JsonField.of(value))
                        }

                        /** An enum containing [CreditReasonIndicator]'s known values. */
                        enum class Known {
                            /** No credit */
                            NO_CREDIT,
                            /** Passenger transport ancillary purchase cancellation */
                            PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /**
                             * Airline ticket and passenger transport ancillary purchase
                             * cancellation
                             */
                            AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /** Airline ticket cancellation */
                            AIRLINE_TICKET_CANCELLATION,
                            /** Other */
                            OTHER,
                            /** Partial refund of airline ticket */
                            PARTIAL_REFUND_OF_AIRLINE_TICKET,
                        }

                        /**
                         * An enum containing [CreditReasonIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [CreditReasonIndicator] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No credit */
                            NO_CREDIT,
                            /** Passenger transport ancillary purchase cancellation */
                            PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /**
                             * Airline ticket and passenger transport ancillary purchase
                             * cancellation
                             */
                            AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION,
                            /** Airline ticket cancellation */
                            AIRLINE_TICKET_CANCELLATION,
                            /** Other */
                            OTHER,
                            /** Partial refund of airline ticket */
                            PARTIAL_REFUND_OF_AIRLINE_TICKET,
                            /**
                             * An enum member indicating that [CreditReasonIndicator] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_CREDIT -> Value.NO_CREDIT
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Value.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Value
                                        .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_CANCELLATION -> Value.AIRLINE_TICKET_CANCELLATION
                                OTHER -> Value.OTHER
                                PARTIAL_REFUND_OF_AIRLINE_TICKET ->
                                    Value.PARTIAL_REFUND_OF_AIRLINE_TICKET
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_CREDIT -> Known.NO_CREDIT
                                PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Known.PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION ->
                                    Known
                                        .AIRLINE_TICKET_AND_PASSENGER_TRANSPORT_ANCILLARY_PURCHASE_CANCELLATION
                                AIRLINE_TICKET_CANCELLATION -> Known.AIRLINE_TICKET_CANCELLATION
                                OTHER -> Known.OTHER
                                PARTIAL_REFUND_OF_AIRLINE_TICKET ->
                                    Known.PARTIAL_REFUND_OF_AIRLINE_TICKET
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CreditReasonIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CreditReasonIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CreditReasonIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Indicates whether this ticket is non-refundable. */
                    class RestrictedTicketIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** No restrictions */
                            val NO_RESTRICTIONS = of("no_restrictions")

                            /** Restricted non-refundable ticket */
                            val RESTRICTED_NON_REFUNDABLE_TICKET =
                                of("restricted_non_refundable_ticket")

                            fun of(value: String) = RestrictedTicketIndicator(JsonField.of(value))
                        }

                        /** An enum containing [RestrictedTicketIndicator]'s known values. */
                        enum class Known {
                            /** No restrictions */
                            NO_RESTRICTIONS,
                            /** Restricted non-refundable ticket */
                            RESTRICTED_NON_REFUNDABLE_TICKET,
                        }

                        /**
                         * An enum containing [RestrictedTicketIndicator]'s known values, as well as
                         * an [_UNKNOWN] member.
                         *
                         * An instance of [RestrictedTicketIndicator] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** No restrictions */
                            NO_RESTRICTIONS,
                            /** Restricted non-refundable ticket */
                            RESTRICTED_NON_REFUNDABLE_TICKET,
                            /**
                             * An enum member indicating that [RestrictedTicketIndicator] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NO_RESTRICTIONS -> Value.NO_RESTRICTIONS
                                RESTRICTED_NON_REFUNDABLE_TICKET ->
                                    Value.RESTRICTED_NON_REFUNDABLE_TICKET
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NO_RESTRICTIONS -> Known.NO_RESTRICTIONS
                                RESTRICTED_NON_REFUNDABLE_TICKET ->
                                    Known.RESTRICTED_NON_REFUNDABLE_TICKET
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown RestrictedTicketIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): RestrictedTicketIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is RestrictedTicketIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Indicates why a ticket was changed. */
                    class TicketChangeIndicator
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** None */
                            val NONE = of("none")

                            /** Change to existing ticket */
                            val CHANGE_TO_EXISTING_TICKET = of("change_to_existing_ticket")

                            /** New ticket */
                            val NEW_TICKET = of("new_ticket")

                            fun of(value: String) = TicketChangeIndicator(JsonField.of(value))
                        }

                        /** An enum containing [TicketChangeIndicator]'s known values. */
                        enum class Known {
                            /** None */
                            NONE,
                            /** Change to existing ticket */
                            CHANGE_TO_EXISTING_TICKET,
                            /** New ticket */
                            NEW_TICKET,
                        }

                        /**
                         * An enum containing [TicketChangeIndicator]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [TicketChangeIndicator] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** None */
                            NONE,
                            /** Change to existing ticket */
                            CHANGE_TO_EXISTING_TICKET,
                            /** New ticket */
                            NEW_TICKET,
                            /**
                             * An enum member indicating that [TicketChangeIndicator] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NONE -> Value.NONE
                                CHANGE_TO_EXISTING_TICKET -> Value.CHANGE_TO_EXISTING_TICKET
                                NEW_TICKET -> Value.NEW_TICKET
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NONE -> Known.NONE
                                CHANGE_TO_EXISTING_TICKET -> Known.CHANGE_TO_EXISTING_TICKET
                                NEW_TICKET -> Known.NEW_TICKET
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown TicketChangeIndicator: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): TicketChangeIndicator = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is TicketChangeIndicator && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    class TripLeg
                    private constructor(
                        private val carrierCode: JsonField<String>,
                        private val destinationCityAirportCode: JsonField<String>,
                        private val fareBasisCode: JsonField<String>,
                        private val flightNumber: JsonField<String>,
                        private val serviceClass: JsonField<String>,
                        private val stopOverCode: JsonField<StopOverCode>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("carrier_code")
                            @ExcludeMissing
                            carrierCode: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("destination_city_airport_code")
                            @ExcludeMissing
                            destinationCityAirportCode: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("fare_basis_code")
                            @ExcludeMissing
                            fareBasisCode: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("flight_number")
                            @ExcludeMissing
                            flightNumber: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("service_class")
                            @ExcludeMissing
                            serviceClass: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("stop_over_code")
                            @ExcludeMissing
                            stopOverCode: JsonField<StopOverCode> = JsonMissing.of(),
                        ) : this(
                            carrierCode,
                            destinationCityAirportCode,
                            fareBasisCode,
                            flightNumber,
                            serviceClass,
                            stopOverCode,
                            mutableMapOf(),
                        )

                        /**
                         * Carrier code (e.g., United Airlines, Jet Blue, etc.).
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun carrierCode(): String? = carrierCode.getNullable("carrier_code")

                        /**
                         * Code for the destination city or airport.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun destinationCityAirportCode(): String? =
                            destinationCityAirportCode.getNullable("destination_city_airport_code")

                        /**
                         * Fare basis code.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun fareBasisCode(): String? = fareBasisCode.getNullable("fare_basis_code")

                        /**
                         * Flight number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun flightNumber(): String? = flightNumber.getNullable("flight_number")

                        /**
                         * Service class (e.g., first class, business class, etc.).
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun serviceClass(): String? = serviceClass.getNullable("service_class")

                        /**
                         * Indicates whether a stopover is allowed on this ticket.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun stopOverCode(): StopOverCode? =
                            stopOverCode.getNullable("stop_over_code")

                        /**
                         * Returns the raw JSON value of [carrierCode].
                         *
                         * Unlike [carrierCode], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("carrier_code")
                        @ExcludeMissing
                        fun _carrierCode(): JsonField<String> = carrierCode

                        /**
                         * Returns the raw JSON value of [destinationCityAirportCode].
                         *
                         * Unlike [destinationCityAirportCode], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("destination_city_airport_code")
                        @ExcludeMissing
                        fun _destinationCityAirportCode(): JsonField<String> =
                            destinationCityAirportCode

                        /**
                         * Returns the raw JSON value of [fareBasisCode].
                         *
                         * Unlike [fareBasisCode], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("fare_basis_code")
                        @ExcludeMissing
                        fun _fareBasisCode(): JsonField<String> = fareBasisCode

                        /**
                         * Returns the raw JSON value of [flightNumber].
                         *
                         * Unlike [flightNumber], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("flight_number")
                        @ExcludeMissing
                        fun _flightNumber(): JsonField<String> = flightNumber

                        /**
                         * Returns the raw JSON value of [serviceClass].
                         *
                         * Unlike [serviceClass], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("service_class")
                        @ExcludeMissing
                        fun _serviceClass(): JsonField<String> = serviceClass

                        /**
                         * Returns the raw JSON value of [stopOverCode].
                         *
                         * Unlike [stopOverCode], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("stop_over_code")
                        @ExcludeMissing
                        fun _stopOverCode(): JsonField<StopOverCode> = stopOverCode

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [TripLeg].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .carrierCode()
                             * .destinationCityAirportCode()
                             * .fareBasisCode()
                             * .flightNumber()
                             * .serviceClass()
                             * .stopOverCode()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [TripLeg]. */
                        class Builder internal constructor() {

                            private var carrierCode: JsonField<String>? = null
                            private var destinationCityAirportCode: JsonField<String>? = null
                            private var fareBasisCode: JsonField<String>? = null
                            private var flightNumber: JsonField<String>? = null
                            private var serviceClass: JsonField<String>? = null
                            private var stopOverCode: JsonField<StopOverCode>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(tripLeg: TripLeg) = apply {
                                carrierCode = tripLeg.carrierCode
                                destinationCityAirportCode = tripLeg.destinationCityAirportCode
                                fareBasisCode = tripLeg.fareBasisCode
                                flightNumber = tripLeg.flightNumber
                                serviceClass = tripLeg.serviceClass
                                stopOverCode = tripLeg.stopOverCode
                                additionalProperties = tripLeg.additionalProperties.toMutableMap()
                            }

                            /** Carrier code (e.g., United Airlines, Jet Blue, etc.). */
                            fun carrierCode(carrierCode: String?) =
                                carrierCode(JsonField.ofNullable(carrierCode))

                            /**
                             * Sets [Builder.carrierCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.carrierCode] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun carrierCode(carrierCode: JsonField<String>) = apply {
                                this.carrierCode = carrierCode
                            }

                            /** Code for the destination city or airport. */
                            fun destinationCityAirportCode(destinationCityAirportCode: String?) =
                                destinationCityAirportCode(
                                    JsonField.ofNullable(destinationCityAirportCode)
                                )

                            /**
                             * Sets [Builder.destinationCityAirportCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.destinationCityAirportCode] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun destinationCityAirportCode(
                                destinationCityAirportCode: JsonField<String>
                            ) = apply {
                                this.destinationCityAirportCode = destinationCityAirportCode
                            }

                            /** Fare basis code. */
                            fun fareBasisCode(fareBasisCode: String?) =
                                fareBasisCode(JsonField.ofNullable(fareBasisCode))

                            /**
                             * Sets [Builder.fareBasisCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.fareBasisCode] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun fareBasisCode(fareBasisCode: JsonField<String>) = apply {
                                this.fareBasisCode = fareBasisCode
                            }

                            /** Flight number. */
                            fun flightNumber(flightNumber: String?) =
                                flightNumber(JsonField.ofNullable(flightNumber))

                            /**
                             * Sets [Builder.flightNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.flightNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun flightNumber(flightNumber: JsonField<String>) = apply {
                                this.flightNumber = flightNumber
                            }

                            /** Service class (e.g., first class, business class, etc.). */
                            fun serviceClass(serviceClass: String?) =
                                serviceClass(JsonField.ofNullable(serviceClass))

                            /**
                             * Sets [Builder.serviceClass] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.serviceClass] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun serviceClass(serviceClass: JsonField<String>) = apply {
                                this.serviceClass = serviceClass
                            }

                            /** Indicates whether a stopover is allowed on this ticket. */
                            fun stopOverCode(stopOverCode: StopOverCode?) =
                                stopOverCode(JsonField.ofNullable(stopOverCode))

                            /**
                             * Sets [Builder.stopOverCode] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.stopOverCode] with a well-typed
                             * [StopOverCode] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun stopOverCode(stopOverCode: JsonField<StopOverCode>) = apply {
                                this.stopOverCode = stopOverCode
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [TripLeg].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .carrierCode()
                             * .destinationCityAirportCode()
                             * .fareBasisCode()
                             * .flightNumber()
                             * .serviceClass()
                             * .stopOverCode()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): TripLeg =
                                TripLeg(
                                    checkRequired("carrierCode", carrierCode),
                                    checkRequired(
                                        "destinationCityAirportCode",
                                        destinationCityAirportCode,
                                    ),
                                    checkRequired("fareBasisCode", fareBasisCode),
                                    checkRequired("flightNumber", flightNumber),
                                    checkRequired("serviceClass", serviceClass),
                                    checkRequired("stopOverCode", stopOverCode),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): TripLeg = apply {
                            if (validated) {
                                return@apply
                            }

                            carrierCode()
                            destinationCityAirportCode()
                            fareBasisCode()
                            flightNumber()
                            serviceClass()
                            stopOverCode()?.validate()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (carrierCode.asKnown() == null) 0 else 1) +
                                (if (destinationCityAirportCode.asKnown() == null) 0 else 1) +
                                (if (fareBasisCode.asKnown() == null) 0 else 1) +
                                (if (flightNumber.asKnown() == null) 0 else 1) +
                                (if (serviceClass.asKnown() == null) 0 else 1) +
                                (stopOverCode.asKnown()?.validity() ?: 0)

                        /** Indicates whether a stopover is allowed on this ticket. */
                        class StopOverCode
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** None */
                                val NONE = of("none")

                                /** Stop over allowed */
                                val STOP_OVER_ALLOWED = of("stop_over_allowed")

                                /** Stop over not allowed */
                                val STOP_OVER_NOT_ALLOWED = of("stop_over_not_allowed")

                                fun of(value: String) = StopOverCode(JsonField.of(value))
                            }

                            /** An enum containing [StopOverCode]'s known values. */
                            enum class Known {
                                /** None */
                                NONE,
                                /** Stop over allowed */
                                STOP_OVER_ALLOWED,
                                /** Stop over not allowed */
                                STOP_OVER_NOT_ALLOWED,
                            }

                            /**
                             * An enum containing [StopOverCode]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [StopOverCode] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** None */
                                NONE,
                                /** Stop over allowed */
                                STOP_OVER_ALLOWED,
                                /** Stop over not allowed */
                                STOP_OVER_NOT_ALLOWED,
                                /**
                                 * An enum member indicating that [StopOverCode] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    NONE -> Value.NONE
                                    STOP_OVER_ALLOWED -> Value.STOP_OVER_ALLOWED
                                    STOP_OVER_NOT_ALLOWED -> Value.STOP_OVER_NOT_ALLOWED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    NONE -> Known.NONE
                                    STOP_OVER_ALLOWED -> Known.STOP_OVER_ALLOWED
                                    STOP_OVER_NOT_ALLOWED -> Known.STOP_OVER_NOT_ALLOWED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown StopOverCode: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): StopOverCode = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is StopOverCode && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is TripLeg &&
                                carrierCode == other.carrierCode &&
                                destinationCityAirportCode == other.destinationCityAirportCode &&
                                fareBasisCode == other.fareBasisCode &&
                                flightNumber == other.flightNumber &&
                                serviceClass == other.serviceClass &&
                                stopOverCode == other.stopOverCode &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                carrierCode,
                                destinationCityAirportCode,
                                fareBasisCode,
                                flightNumber,
                                serviceClass,
                                stopOverCode,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "TripLeg{carrierCode=$carrierCode, destinationCityAirportCode=$destinationCityAirportCode, fareBasisCode=$fareBasisCode, flightNumber=$flightNumber, serviceClass=$serviceClass, stopOverCode=$stopOverCode, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Travel &&
                            ancillary == other.ancillary &&
                            computerizedReservationSystem == other.computerizedReservationSystem &&
                            creditReasonIndicator == other.creditReasonIndicator &&
                            departureDate == other.departureDate &&
                            originationCityAirportCode == other.originationCityAirportCode &&
                            passengerName == other.passengerName &&
                            restrictedTicketIndicator == other.restrictedTicketIndicator &&
                            ticketChangeIndicator == other.ticketChangeIndicator &&
                            ticketNumber == other.ticketNumber &&
                            travelAgencyCode == other.travelAgencyCode &&
                            travelAgencyName == other.travelAgencyName &&
                            tripLegs == other.tripLegs &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            ancillary,
                            computerizedReservationSystem,
                            creditReasonIndicator,
                            departureDate,
                            originationCityAirportCode,
                            passengerName,
                            restrictedTicketIndicator,
                            ticketChangeIndicator,
                            ticketNumber,
                            travelAgencyCode,
                            travelAgencyName,
                            tripLegs,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Travel{ancillary=$ancillary, computerizedReservationSystem=$computerizedReservationSystem, creditReasonIndicator=$creditReasonIndicator, departureDate=$departureDate, originationCityAirportCode=$originationCityAirportCode, passengerName=$passengerName, restrictedTicketIndicator=$restrictedTicketIndicator, ticketChangeIndicator=$ticketChangeIndicator, ticketNumber=$ticketNumber, travelAgencyCode=$travelAgencyCode, travelAgencyName=$travelAgencyName, tripLegs=$tripLegs, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is PurchaseDetails &&
                        carRental == other.carRental &&
                        customerReferenceIdentifier == other.customerReferenceIdentifier &&
                        localTaxAmount == other.localTaxAmount &&
                        localTaxCurrency == other.localTaxCurrency &&
                        lodging == other.lodging &&
                        nationalTaxAmount == other.nationalTaxAmount &&
                        nationalTaxCurrency == other.nationalTaxCurrency &&
                        purchaseIdentifier == other.purchaseIdentifier &&
                        purchaseIdentifierFormat == other.purchaseIdentifierFormat &&
                        travel == other.travel &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        carRental,
                        customerReferenceIdentifier,
                        localTaxAmount,
                        localTaxCurrency,
                        lodging,
                        nationalTaxAmount,
                        nationalTaxCurrency,
                        purchaseIdentifier,
                        purchaseIdentifierFormat,
                        travel,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "PurchaseDetails{carRental=$carRental, customerReferenceIdentifier=$customerReferenceIdentifier, localTaxAmount=$localTaxAmount, localTaxCurrency=$localTaxCurrency, lodging=$lodging, nationalTaxAmount=$nationalTaxAmount, nationalTaxCurrency=$nationalTaxCurrency, purchaseIdentifier=$purchaseIdentifier, purchaseIdentifierFormat=$purchaseIdentifierFormat, travel=$travel, additionalProperties=$additionalProperties}"
            }

            /**
             * A constant representing the object's type. For this resource it will always be
             * `card_settlement`.
             */
            class Type @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    val CARD_SETTLEMENT = of("card_settlement")

                    fun of(value: String) = Type(JsonField.of(value))
                }

                /** An enum containing [Type]'s known values. */
                enum class Known {
                    CARD_SETTLEMENT
                }

                /**
                 * An enum containing [Type]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Type] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    CARD_SETTLEMENT,
                    /**
                     * An enum member indicating that [Type] was instantiated with an unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CARD_SETTLEMENT -> Value.CARD_SETTLEMENT
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CARD_SETTLEMENT -> Known.CARD_SETTLEMENT
                        else -> throw IncreaseInvalidDataException("Unknown Type: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Type = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Type && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CardSettlement &&
                    id == other.id &&
                    amount == other.amount &&
                    cardAuthorization == other.cardAuthorization &&
                    cardPaymentId == other.cardPaymentId &&
                    cashback == other.cashback &&
                    currency == other.currency &&
                    interchange == other.interchange &&
                    merchantAcceptorId == other.merchantAcceptorId &&
                    merchantCategoryCode == other.merchantCategoryCode &&
                    merchantCity == other.merchantCity &&
                    merchantCountry == other.merchantCountry &&
                    merchantName == other.merchantName &&
                    merchantPostalCode == other.merchantPostalCode &&
                    merchantState == other.merchantState &&
                    network == other.network &&
                    networkIdentifiers == other.networkIdentifiers &&
                    pendingTransactionId == other.pendingTransactionId &&
                    presentmentAmount == other.presentmentAmount &&
                    presentmentCurrency == other.presentmentCurrency &&
                    purchaseDetails == other.purchaseDetails &&
                    transactionId == other.transactionId &&
                    type == other.type &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    id,
                    amount,
                    cardAuthorization,
                    cardPaymentId,
                    cashback,
                    currency,
                    interchange,
                    merchantAcceptorId,
                    merchantCategoryCode,
                    merchantCity,
                    merchantCountry,
                    merchantName,
                    merchantPostalCode,
                    merchantState,
                    network,
                    networkIdentifiers,
                    pendingTransactionId,
                    presentmentAmount,
                    presentmentCurrency,
                    purchaseDetails,
                    transactionId,
                    type,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CardSettlement{id=$id, amount=$amount, cardAuthorization=$cardAuthorization, cardPaymentId=$cardPaymentId, cashback=$cashback, currency=$currency, interchange=$interchange, merchantAcceptorId=$merchantAcceptorId, merchantCategoryCode=$merchantCategoryCode, merchantCity=$merchantCity, merchantCountry=$merchantCountry, merchantName=$merchantName, merchantPostalCode=$merchantPostalCode, merchantState=$merchantState, network=$network, networkIdentifiers=$networkIdentifiers, pendingTransactionId=$pendingTransactionId, presentmentAmount=$presentmentAmount, presentmentCurrency=$presentmentCurrency, purchaseDetails=$purchaseDetails, transactionId=$transactionId, type=$type, additionalProperties=$additionalProperties}"
        }

        /**
         * A Cashback Payment object. This field will be present in the JSON response if and only if
         * `category` is equal to `cashback_payment`. A Cashback Payment represents the cashback
         * paid to a cardholder for a given period. Cashback is usually paid monthly for the prior
         * month's transactions.
         */
        class CashbackPayment
        private constructor(
            private val accruedOnCardId: JsonField<String>,
            private val amount: JsonField<Long>,
            private val currency: JsonField<Currency>,
            private val periodEnd: JsonField<OffsetDateTime>,
            private val periodStart: JsonField<OffsetDateTime>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("accrued_on_card_id")
                @ExcludeMissing
                accruedOnCardId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("period_end")
                @ExcludeMissing
                periodEnd: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("period_start")
                @ExcludeMissing
                periodStart: JsonField<OffsetDateTime> = JsonMissing.of(),
            ) : this(accruedOnCardId, amount, currency, periodEnd, periodStart, mutableMapOf())

            /**
             * The card on which the cashback was accrued.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun accruedOnCardId(): String? = accruedOnCardId.getNullable("accrued_on_card_id")

            /**
             * The amount in the minor unit of the transaction's currency. For dollars, for example,
             * this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * The end of the period for which this transaction paid cashback.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodEnd(): OffsetDateTime = periodEnd.getRequired("period_end")

            /**
             * The start of the period for which this transaction paid cashback.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodStart(): OffsetDateTime = periodStart.getRequired("period_start")

            /**
             * Returns the raw JSON value of [accruedOnCardId].
             *
             * Unlike [accruedOnCardId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("accrued_on_card_id")
            @ExcludeMissing
            fun _accruedOnCardId(): JsonField<String> = accruedOnCardId

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [periodEnd].
             *
             * Unlike [periodEnd], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_end")
            @ExcludeMissing
            fun _periodEnd(): JsonField<OffsetDateTime> = periodEnd

            /**
             * Returns the raw JSON value of [periodStart].
             *
             * Unlike [periodStart], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_start")
            @ExcludeMissing
            fun _periodStart(): JsonField<OffsetDateTime> = periodStart

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CashbackPayment].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accruedOnCardId()
                 * .amount()
                 * .currency()
                 * .periodEnd()
                 * .periodStart()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CashbackPayment]. */
            class Builder internal constructor() {

                private var accruedOnCardId: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var currency: JsonField<Currency>? = null
                private var periodEnd: JsonField<OffsetDateTime>? = null
                private var periodStart: JsonField<OffsetDateTime>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(cashbackPayment: CashbackPayment) = apply {
                    accruedOnCardId = cashbackPayment.accruedOnCardId
                    amount = cashbackPayment.amount
                    currency = cashbackPayment.currency
                    periodEnd = cashbackPayment.periodEnd
                    periodStart = cashbackPayment.periodStart
                    additionalProperties = cashbackPayment.additionalProperties.toMutableMap()
                }

                /** The card on which the cashback was accrued. */
                fun accruedOnCardId(accruedOnCardId: String?) =
                    accruedOnCardId(JsonField.ofNullable(accruedOnCardId))

                /**
                 * Sets [Builder.accruedOnCardId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.accruedOnCardId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun accruedOnCardId(accruedOnCardId: JsonField<String>) = apply {
                    this.accruedOnCardId = accruedOnCardId
                }

                /**
                 * The amount in the minor unit of the transaction's currency. For dollars, for
                 * example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
                 * currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** The end of the period for which this transaction paid cashback. */
                fun periodEnd(periodEnd: OffsetDateTime) = periodEnd(JsonField.of(periodEnd))

                /**
                 * Sets [Builder.periodEnd] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodEnd] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodEnd(periodEnd: JsonField<OffsetDateTime>) = apply {
                    this.periodEnd = periodEnd
                }

                /** The start of the period for which this transaction paid cashback. */
                fun periodStart(periodStart: OffsetDateTime) =
                    periodStart(JsonField.of(periodStart))

                /**
                 * Sets [Builder.periodStart] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodStart] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodStart(periodStart: JsonField<OffsetDateTime>) = apply {
                    this.periodStart = periodStart
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CashbackPayment].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accruedOnCardId()
                 * .amount()
                 * .currency()
                 * .periodEnd()
                 * .periodStart()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CashbackPayment =
                    CashbackPayment(
                        checkRequired("accruedOnCardId", accruedOnCardId),
                        checkRequired("amount", amount),
                        checkRequired("currency", currency),
                        checkRequired("periodEnd", periodEnd),
                        checkRequired("periodStart", periodStart),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CashbackPayment = apply {
                if (validated) {
                    return@apply
                }

                accruedOnCardId()
                amount()
                currency().validate()
                periodEnd()
                periodStart()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (accruedOnCardId.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (if (periodEnd.asKnown() == null) 0 else 1) +
                    (if (periodStart.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CashbackPayment &&
                    accruedOnCardId == other.accruedOnCardId &&
                    amount == other.amount &&
                    currency == other.currency &&
                    periodEnd == other.periodEnd &&
                    periodStart == other.periodStart &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    accruedOnCardId,
                    amount,
                    currency,
                    periodEnd,
                    periodStart,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CashbackPayment{accruedOnCardId=$accruedOnCardId, amount=$amount, currency=$currency, periodEnd=$periodEnd, periodStart=$periodStart, additionalProperties=$additionalProperties}"
        }

        /**
         * The type of the resource. We may add additional possible values for this enum over time;
         * your application should be able to handle such additions gracefully.
         */
        class Category @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                /**
                 * Account Transfer Intention: details will be under the
                 * `account_transfer_intention` object.
                 */
                val ACCOUNT_TRANSFER_INTENTION = of("account_transfer_intention")

                /**
                 * ACH Transfer Intention: details will be under the `ach_transfer_intention`
                 * object.
                 */
                val ACH_TRANSFER_INTENTION = of("ach_transfer_intention")

                /**
                 * ACH Transfer Rejection: details will be under the `ach_transfer_rejection`
                 * object.
                 */
                val ACH_TRANSFER_REJECTION = of("ach_transfer_rejection")

                /** ACH Transfer Return: details will be under the `ach_transfer_return` object. */
                val ACH_TRANSFER_RETURN = of("ach_transfer_return")

                /** Cashback Payment: details will be under the `cashback_payment` object. */
                val CASHBACK_PAYMENT = of("cashback_payment")

                /**
                 * Card Dispute Acceptance: details will be under the `card_dispute_acceptance`
                 * object.
                 */
                val CARD_DISPUTE_ACCEPTANCE = of("card_dispute_acceptance")

                /**
                 * Card Dispute Financial: details will be under the `card_dispute_financial`
                 * object.
                 */
                val CARD_DISPUTE_FINANCIAL = of("card_dispute_financial")

                /** Card Dispute Loss: details will be under the `card_dispute_loss` object. */
                val CARD_DISPUTE_LOSS = of("card_dispute_loss")

                /** Card Refund: details will be under the `card_refund` object. */
                val CARD_REFUND = of("card_refund")

                /** Card Settlement: details will be under the `card_settlement` object. */
                val CARD_SETTLEMENT = of("card_settlement")

                /**
                 * Card Revenue Payment: details will be under the `card_revenue_payment` object.
                 */
                val CARD_REVENUE_PAYMENT = of("card_revenue_payment")

                /**
                 * Check Deposit Acceptance: details will be under the `check_deposit_acceptance`
                 * object.
                 */
                val CHECK_DEPOSIT_ACCEPTANCE = of("check_deposit_acceptance")

                /**
                 * Check Deposit Return: details will be under the `check_deposit_return` object.
                 */
                val CHECK_DEPOSIT_RETURN = of("check_deposit_return")

                /**
                 * Check Transfer Deposit: details will be under the `check_transfer_deposit`
                 * object.
                 */
                val CHECK_TRANSFER_DEPOSIT = of("check_transfer_deposit")

                /** Fee Payment: details will be under the `fee_payment` object. */
                val FEE_PAYMENT = of("fee_payment")

                /**
                 * Inbound ACH Transfer Intention: details will be under the `inbound_ach_transfer`
                 * object.
                 */
                val INBOUND_ACH_TRANSFER = of("inbound_ach_transfer")

                /**
                 * Inbound ACH Transfer Return Intention: details will be under the
                 * `inbound_ach_transfer_return_intention` object.
                 */
                val INBOUND_ACH_TRANSFER_RETURN_INTENTION =
                    of("inbound_ach_transfer_return_intention")

                /**
                 * Inbound Check Deposit Return Intention: details will be under the
                 * `inbound_check_deposit_return_intention` object.
                 */
                val INBOUND_CHECK_DEPOSIT_RETURN_INTENTION =
                    of("inbound_check_deposit_return_intention")

                /**
                 * Inbound Check Adjustment: details will be under the `inbound_check_adjustment`
                 * object.
                 */
                val INBOUND_CHECK_ADJUSTMENT = of("inbound_check_adjustment")

                /**
                 * Inbound Real-Time Payments Transfer Confirmation: details will be under the
                 * `inbound_real_time_payments_transfer_confirmation` object.
                 */
                val INBOUND_REAL_TIME_PAYMENTS_TRANSFER_CONFIRMATION =
                    of("inbound_real_time_payments_transfer_confirmation")

                /**
                 * Inbound Wire Reversal: details will be under the `inbound_wire_reversal` object.
                 */
                val INBOUND_WIRE_REVERSAL = of("inbound_wire_reversal")

                /**
                 * Inbound Wire Transfer Intention: details will be under the
                 * `inbound_wire_transfer` object.
                 */
                val INBOUND_WIRE_TRANSFER = of("inbound_wire_transfer")

                /**
                 * Inbound Wire Transfer Reversal Intention: details will be under the
                 * `inbound_wire_transfer_reversal` object.
                 */
                val INBOUND_WIRE_TRANSFER_REVERSAL = of("inbound_wire_transfer_reversal")

                /** Interest Payment: details will be under the `interest_payment` object. */
                val INTEREST_PAYMENT = of("interest_payment")

                /** Internal Source: details will be under the `internal_source` object. */
                val INTERNAL_SOURCE = of("internal_source")

                /**
                 * Real-Time Payments Transfer Acknowledgement: details will be under the
                 * `real_time_payments_transfer_acknowledgement` object.
                 */
                val REAL_TIME_PAYMENTS_TRANSFER_ACKNOWLEDGEMENT =
                    of("real_time_payments_transfer_acknowledgement")

                /** Sample Funds: details will be under the `sample_funds` object. */
                val SAMPLE_FUNDS = of("sample_funds")

                /**
                 * Wire Transfer Intention: details will be under the `wire_transfer_intention`
                 * object.
                 */
                val WIRE_TRANSFER_INTENTION = of("wire_transfer_intention")

                /**
                 * Swift Transfer Intention: details will be under the `swift_transfer_intention`
                 * object.
                 */
                val SWIFT_TRANSFER_INTENTION = of("swift_transfer_intention")

                /**
                 * Swift Transfer Return: details will be under the `swift_transfer_return` object.
                 */
                val SWIFT_TRANSFER_RETURN = of("swift_transfer_return")

                /**
                 * Card Push Transfer Acceptance: details will be under the
                 * `card_push_transfer_acceptance` object.
                 */
                val CARD_PUSH_TRANSFER_ACCEPTANCE = of("card_push_transfer_acceptance")

                /**
                 * Account Revenue Payment: details will be under the `account_revenue_payment`
                 * object.
                 */
                val ACCOUNT_REVENUE_PAYMENT = of("account_revenue_payment")

                /** The Transaction was made for an undocumented or deprecated reason. */
                val OTHER = of("other")

                fun of(value: String) = Category(JsonField.of(value))
            }

            /** An enum containing [Category]'s known values. */
            enum class Known {
                /**
                 * Account Transfer Intention: details will be under the
                 * `account_transfer_intention` object.
                 */
                ACCOUNT_TRANSFER_INTENTION,
                /**
                 * ACH Transfer Intention: details will be under the `ach_transfer_intention`
                 * object.
                 */
                ACH_TRANSFER_INTENTION,
                /**
                 * ACH Transfer Rejection: details will be under the `ach_transfer_rejection`
                 * object.
                 */
                ACH_TRANSFER_REJECTION,
                /** ACH Transfer Return: details will be under the `ach_transfer_return` object. */
                ACH_TRANSFER_RETURN,
                /** Cashback Payment: details will be under the `cashback_payment` object. */
                CASHBACK_PAYMENT,
                /**
                 * Card Dispute Acceptance: details will be under the `card_dispute_acceptance`
                 * object.
                 */
                CARD_DISPUTE_ACCEPTANCE,
                /**
                 * Card Dispute Financial: details will be under the `card_dispute_financial`
                 * object.
                 */
                CARD_DISPUTE_FINANCIAL,
                /** Card Dispute Loss: details will be under the `card_dispute_loss` object. */
                CARD_DISPUTE_LOSS,
                /** Card Refund: details will be under the `card_refund` object. */
                CARD_REFUND,
                /** Card Settlement: details will be under the `card_settlement` object. */
                CARD_SETTLEMENT,
                /**
                 * Card Revenue Payment: details will be under the `card_revenue_payment` object.
                 */
                CARD_REVENUE_PAYMENT,
                /**
                 * Check Deposit Acceptance: details will be under the `check_deposit_acceptance`
                 * object.
                 */
                CHECK_DEPOSIT_ACCEPTANCE,
                /**
                 * Check Deposit Return: details will be under the `check_deposit_return` object.
                 */
                CHECK_DEPOSIT_RETURN,
                /**
                 * Check Transfer Deposit: details will be under the `check_transfer_deposit`
                 * object.
                 */
                CHECK_TRANSFER_DEPOSIT,
                /** Fee Payment: details will be under the `fee_payment` object. */
                FEE_PAYMENT,
                /**
                 * Inbound ACH Transfer Intention: details will be under the `inbound_ach_transfer`
                 * object.
                 */
                INBOUND_ACH_TRANSFER,
                /**
                 * Inbound ACH Transfer Return Intention: details will be under the
                 * `inbound_ach_transfer_return_intention` object.
                 */
                INBOUND_ACH_TRANSFER_RETURN_INTENTION,
                /**
                 * Inbound Check Deposit Return Intention: details will be under the
                 * `inbound_check_deposit_return_intention` object.
                 */
                INBOUND_CHECK_DEPOSIT_RETURN_INTENTION,
                /**
                 * Inbound Check Adjustment: details will be under the `inbound_check_adjustment`
                 * object.
                 */
                INBOUND_CHECK_ADJUSTMENT,
                /**
                 * Inbound Real-Time Payments Transfer Confirmation: details will be under the
                 * `inbound_real_time_payments_transfer_confirmation` object.
                 */
                INBOUND_REAL_TIME_PAYMENTS_TRANSFER_CONFIRMATION,
                /**
                 * Inbound Wire Reversal: details will be under the `inbound_wire_reversal` object.
                 */
                INBOUND_WIRE_REVERSAL,
                /**
                 * Inbound Wire Transfer Intention: details will be under the
                 * `inbound_wire_transfer` object.
                 */
                INBOUND_WIRE_TRANSFER,
                /**
                 * Inbound Wire Transfer Reversal Intention: details will be under the
                 * `inbound_wire_transfer_reversal` object.
                 */
                INBOUND_WIRE_TRANSFER_REVERSAL,
                /** Interest Payment: details will be under the `interest_payment` object. */
                INTEREST_PAYMENT,
                /** Internal Source: details will be under the `internal_source` object. */
                INTERNAL_SOURCE,
                /**
                 * Real-Time Payments Transfer Acknowledgement: details will be under the
                 * `real_time_payments_transfer_acknowledgement` object.
                 */
                REAL_TIME_PAYMENTS_TRANSFER_ACKNOWLEDGEMENT,
                /** Sample Funds: details will be under the `sample_funds` object. */
                SAMPLE_FUNDS,
                /**
                 * Wire Transfer Intention: details will be under the `wire_transfer_intention`
                 * object.
                 */
                WIRE_TRANSFER_INTENTION,
                /**
                 * Swift Transfer Intention: details will be under the `swift_transfer_intention`
                 * object.
                 */
                SWIFT_TRANSFER_INTENTION,
                /**
                 * Swift Transfer Return: details will be under the `swift_transfer_return` object.
                 */
                SWIFT_TRANSFER_RETURN,
                /**
                 * Card Push Transfer Acceptance: details will be under the
                 * `card_push_transfer_acceptance` object.
                 */
                CARD_PUSH_TRANSFER_ACCEPTANCE,
                /**
                 * Account Revenue Payment: details will be under the `account_revenue_payment`
                 * object.
                 */
                ACCOUNT_REVENUE_PAYMENT,
                /** The Transaction was made for an undocumented or deprecated reason. */
                OTHER,
            }

            /**
             * An enum containing [Category]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Category] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                /**
                 * Account Transfer Intention: details will be under the
                 * `account_transfer_intention` object.
                 */
                ACCOUNT_TRANSFER_INTENTION,
                /**
                 * ACH Transfer Intention: details will be under the `ach_transfer_intention`
                 * object.
                 */
                ACH_TRANSFER_INTENTION,
                /**
                 * ACH Transfer Rejection: details will be under the `ach_transfer_rejection`
                 * object.
                 */
                ACH_TRANSFER_REJECTION,
                /** ACH Transfer Return: details will be under the `ach_transfer_return` object. */
                ACH_TRANSFER_RETURN,
                /** Cashback Payment: details will be under the `cashback_payment` object. */
                CASHBACK_PAYMENT,
                /**
                 * Card Dispute Acceptance: details will be under the `card_dispute_acceptance`
                 * object.
                 */
                CARD_DISPUTE_ACCEPTANCE,
                /**
                 * Card Dispute Financial: details will be under the `card_dispute_financial`
                 * object.
                 */
                CARD_DISPUTE_FINANCIAL,
                /** Card Dispute Loss: details will be under the `card_dispute_loss` object. */
                CARD_DISPUTE_LOSS,
                /** Card Refund: details will be under the `card_refund` object. */
                CARD_REFUND,
                /** Card Settlement: details will be under the `card_settlement` object. */
                CARD_SETTLEMENT,
                /**
                 * Card Revenue Payment: details will be under the `card_revenue_payment` object.
                 */
                CARD_REVENUE_PAYMENT,
                /**
                 * Check Deposit Acceptance: details will be under the `check_deposit_acceptance`
                 * object.
                 */
                CHECK_DEPOSIT_ACCEPTANCE,
                /**
                 * Check Deposit Return: details will be under the `check_deposit_return` object.
                 */
                CHECK_DEPOSIT_RETURN,
                /**
                 * Check Transfer Deposit: details will be under the `check_transfer_deposit`
                 * object.
                 */
                CHECK_TRANSFER_DEPOSIT,
                /** Fee Payment: details will be under the `fee_payment` object. */
                FEE_PAYMENT,
                /**
                 * Inbound ACH Transfer Intention: details will be under the `inbound_ach_transfer`
                 * object.
                 */
                INBOUND_ACH_TRANSFER,
                /**
                 * Inbound ACH Transfer Return Intention: details will be under the
                 * `inbound_ach_transfer_return_intention` object.
                 */
                INBOUND_ACH_TRANSFER_RETURN_INTENTION,
                /**
                 * Inbound Check Deposit Return Intention: details will be under the
                 * `inbound_check_deposit_return_intention` object.
                 */
                INBOUND_CHECK_DEPOSIT_RETURN_INTENTION,
                /**
                 * Inbound Check Adjustment: details will be under the `inbound_check_adjustment`
                 * object.
                 */
                INBOUND_CHECK_ADJUSTMENT,
                /**
                 * Inbound Real-Time Payments Transfer Confirmation: details will be under the
                 * `inbound_real_time_payments_transfer_confirmation` object.
                 */
                INBOUND_REAL_TIME_PAYMENTS_TRANSFER_CONFIRMATION,
                /**
                 * Inbound Wire Reversal: details will be under the `inbound_wire_reversal` object.
                 */
                INBOUND_WIRE_REVERSAL,
                /**
                 * Inbound Wire Transfer Intention: details will be under the
                 * `inbound_wire_transfer` object.
                 */
                INBOUND_WIRE_TRANSFER,
                /**
                 * Inbound Wire Transfer Reversal Intention: details will be under the
                 * `inbound_wire_transfer_reversal` object.
                 */
                INBOUND_WIRE_TRANSFER_REVERSAL,
                /** Interest Payment: details will be under the `interest_payment` object. */
                INTEREST_PAYMENT,
                /** Internal Source: details will be under the `internal_source` object. */
                INTERNAL_SOURCE,
                /**
                 * Real-Time Payments Transfer Acknowledgement: details will be under the
                 * `real_time_payments_transfer_acknowledgement` object.
                 */
                REAL_TIME_PAYMENTS_TRANSFER_ACKNOWLEDGEMENT,
                /** Sample Funds: details will be under the `sample_funds` object. */
                SAMPLE_FUNDS,
                /**
                 * Wire Transfer Intention: details will be under the `wire_transfer_intention`
                 * object.
                 */
                WIRE_TRANSFER_INTENTION,
                /**
                 * Swift Transfer Intention: details will be under the `swift_transfer_intention`
                 * object.
                 */
                SWIFT_TRANSFER_INTENTION,
                /**
                 * Swift Transfer Return: details will be under the `swift_transfer_return` object.
                 */
                SWIFT_TRANSFER_RETURN,
                /**
                 * Card Push Transfer Acceptance: details will be under the
                 * `card_push_transfer_acceptance` object.
                 */
                CARD_PUSH_TRANSFER_ACCEPTANCE,
                /**
                 * Account Revenue Payment: details will be under the `account_revenue_payment`
                 * object.
                 */
                ACCOUNT_REVENUE_PAYMENT,
                /** The Transaction was made for an undocumented or deprecated reason. */
                OTHER,
                /**
                 * An enum member indicating that [Category] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ACCOUNT_TRANSFER_INTENTION -> Value.ACCOUNT_TRANSFER_INTENTION
                    ACH_TRANSFER_INTENTION -> Value.ACH_TRANSFER_INTENTION
                    ACH_TRANSFER_REJECTION -> Value.ACH_TRANSFER_REJECTION
                    ACH_TRANSFER_RETURN -> Value.ACH_TRANSFER_RETURN
                    CASHBACK_PAYMENT -> Value.CASHBACK_PAYMENT
                    CARD_DISPUTE_ACCEPTANCE -> Value.CARD_DISPUTE_ACCEPTANCE
                    CARD_DISPUTE_FINANCIAL -> Value.CARD_DISPUTE_FINANCIAL
                    CARD_DISPUTE_LOSS -> Value.CARD_DISPUTE_LOSS
                    CARD_REFUND -> Value.CARD_REFUND
                    CARD_SETTLEMENT -> Value.CARD_SETTLEMENT
                    CARD_REVENUE_PAYMENT -> Value.CARD_REVENUE_PAYMENT
                    CHECK_DEPOSIT_ACCEPTANCE -> Value.CHECK_DEPOSIT_ACCEPTANCE
                    CHECK_DEPOSIT_RETURN -> Value.CHECK_DEPOSIT_RETURN
                    CHECK_TRANSFER_DEPOSIT -> Value.CHECK_TRANSFER_DEPOSIT
                    FEE_PAYMENT -> Value.FEE_PAYMENT
                    INBOUND_ACH_TRANSFER -> Value.INBOUND_ACH_TRANSFER
                    INBOUND_ACH_TRANSFER_RETURN_INTENTION ->
                        Value.INBOUND_ACH_TRANSFER_RETURN_INTENTION
                    INBOUND_CHECK_DEPOSIT_RETURN_INTENTION ->
                        Value.INBOUND_CHECK_DEPOSIT_RETURN_INTENTION
                    INBOUND_CHECK_ADJUSTMENT -> Value.INBOUND_CHECK_ADJUSTMENT
                    INBOUND_REAL_TIME_PAYMENTS_TRANSFER_CONFIRMATION ->
                        Value.INBOUND_REAL_TIME_PAYMENTS_TRANSFER_CONFIRMATION
                    INBOUND_WIRE_REVERSAL -> Value.INBOUND_WIRE_REVERSAL
                    INBOUND_WIRE_TRANSFER -> Value.INBOUND_WIRE_TRANSFER
                    INBOUND_WIRE_TRANSFER_REVERSAL -> Value.INBOUND_WIRE_TRANSFER_REVERSAL
                    INTEREST_PAYMENT -> Value.INTEREST_PAYMENT
                    INTERNAL_SOURCE -> Value.INTERNAL_SOURCE
                    REAL_TIME_PAYMENTS_TRANSFER_ACKNOWLEDGEMENT ->
                        Value.REAL_TIME_PAYMENTS_TRANSFER_ACKNOWLEDGEMENT
                    SAMPLE_FUNDS -> Value.SAMPLE_FUNDS
                    WIRE_TRANSFER_INTENTION -> Value.WIRE_TRANSFER_INTENTION
                    SWIFT_TRANSFER_INTENTION -> Value.SWIFT_TRANSFER_INTENTION
                    SWIFT_TRANSFER_RETURN -> Value.SWIFT_TRANSFER_RETURN
                    CARD_PUSH_TRANSFER_ACCEPTANCE -> Value.CARD_PUSH_TRANSFER_ACCEPTANCE
                    ACCOUNT_REVENUE_PAYMENT -> Value.ACCOUNT_REVENUE_PAYMENT
                    OTHER -> Value.OTHER
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws IncreaseInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ACCOUNT_TRANSFER_INTENTION -> Known.ACCOUNT_TRANSFER_INTENTION
                    ACH_TRANSFER_INTENTION -> Known.ACH_TRANSFER_INTENTION
                    ACH_TRANSFER_REJECTION -> Known.ACH_TRANSFER_REJECTION
                    ACH_TRANSFER_RETURN -> Known.ACH_TRANSFER_RETURN
                    CASHBACK_PAYMENT -> Known.CASHBACK_PAYMENT
                    CARD_DISPUTE_ACCEPTANCE -> Known.CARD_DISPUTE_ACCEPTANCE
                    CARD_DISPUTE_FINANCIAL -> Known.CARD_DISPUTE_FINANCIAL
                    CARD_DISPUTE_LOSS -> Known.CARD_DISPUTE_LOSS
                    CARD_REFUND -> Known.CARD_REFUND
                    CARD_SETTLEMENT -> Known.CARD_SETTLEMENT
                    CARD_REVENUE_PAYMENT -> Known.CARD_REVENUE_PAYMENT
                    CHECK_DEPOSIT_ACCEPTANCE -> Known.CHECK_DEPOSIT_ACCEPTANCE
                    CHECK_DEPOSIT_RETURN -> Known.CHECK_DEPOSIT_RETURN
                    CHECK_TRANSFER_DEPOSIT -> Known.CHECK_TRANSFER_DEPOSIT
                    FEE_PAYMENT -> Known.FEE_PAYMENT
                    INBOUND_ACH_TRANSFER -> Known.INBOUND_ACH_TRANSFER
                    INBOUND_ACH_TRANSFER_RETURN_INTENTION ->
                        Known.INBOUND_ACH_TRANSFER_RETURN_INTENTION
                    INBOUND_CHECK_DEPOSIT_RETURN_INTENTION ->
                        Known.INBOUND_CHECK_DEPOSIT_RETURN_INTENTION
                    INBOUND_CHECK_ADJUSTMENT -> Known.INBOUND_CHECK_ADJUSTMENT
                    INBOUND_REAL_TIME_PAYMENTS_TRANSFER_CONFIRMATION ->
                        Known.INBOUND_REAL_TIME_PAYMENTS_TRANSFER_CONFIRMATION
                    INBOUND_WIRE_REVERSAL -> Known.INBOUND_WIRE_REVERSAL
                    INBOUND_WIRE_TRANSFER -> Known.INBOUND_WIRE_TRANSFER
                    INBOUND_WIRE_TRANSFER_REVERSAL -> Known.INBOUND_WIRE_TRANSFER_REVERSAL
                    INTEREST_PAYMENT -> Known.INTEREST_PAYMENT
                    INTERNAL_SOURCE -> Known.INTERNAL_SOURCE
                    REAL_TIME_PAYMENTS_TRANSFER_ACKNOWLEDGEMENT ->
                        Known.REAL_TIME_PAYMENTS_TRANSFER_ACKNOWLEDGEMENT
                    SAMPLE_FUNDS -> Known.SAMPLE_FUNDS
                    WIRE_TRANSFER_INTENTION -> Known.WIRE_TRANSFER_INTENTION
                    SWIFT_TRANSFER_INTENTION -> Known.SWIFT_TRANSFER_INTENTION
                    SWIFT_TRANSFER_RETURN -> Known.SWIFT_TRANSFER_RETURN
                    CARD_PUSH_TRANSFER_ACCEPTANCE -> Known.CARD_PUSH_TRANSFER_ACCEPTANCE
                    ACCOUNT_REVENUE_PAYMENT -> Known.ACCOUNT_REVENUE_PAYMENT
                    OTHER -> Known.OTHER
                    else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws IncreaseInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Category = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Category && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * A Check Deposit Acceptance object. This field will be present in the JSON response if and
         * only if `category` is equal to `check_deposit_acceptance`. A Check Deposit Acceptance is
         * created when a Check Deposit is processed and its details confirmed. Check Deposits may
         * be returned by the receiving bank, which will appear as a Check Deposit Return.
         */
        class CheckDepositAcceptance
        private constructor(
            private val accountNumber: JsonField<String>,
            private val amount: JsonField<Long>,
            private val auxiliaryOnUs: JsonField<String>,
            private val checkDepositId: JsonField<String>,
            private val currency: JsonField<Currency>,
            private val routingNumber: JsonField<String>,
            private val serialNumber: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("account_number")
                @ExcludeMissing
                accountNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("auxiliary_on_us")
                @ExcludeMissing
                auxiliaryOnUs: JsonField<String> = JsonMissing.of(),
                @JsonProperty("check_deposit_id")
                @ExcludeMissing
                checkDepositId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("routing_number")
                @ExcludeMissing
                routingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("serial_number")
                @ExcludeMissing
                serialNumber: JsonField<String> = JsonMissing.of(),
            ) : this(
                accountNumber,
                amount,
                auxiliaryOnUs,
                checkDepositId,
                currency,
                routingNumber,
                serialNumber,
                mutableMapOf(),
            )

            /**
             * The account number printed on the check.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun accountNumber(): String = accountNumber.getRequired("account_number")

            /**
             * The amount to be deposited in the minor unit of the transaction's currency. For
             * dollars, for example, this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * An additional line of metadata printed on the check. This typically includes the
             * check number for business checks.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun auxiliaryOnUs(): String? = auxiliaryOnUs.getNullable("auxiliary_on_us")

            /**
             * The ID of the Check Deposit that was accepted.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun checkDepositId(): String = checkDepositId.getRequired("check_deposit_id")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * The routing number printed on the check.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun routingNumber(): String = routingNumber.getRequired("routing_number")

            /**
             * The check serial number, if present, for consumer checks. For business checks, the
             * serial number is usually in the `auxiliary_on_us` field.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun serialNumber(): String? = serialNumber.getNullable("serial_number")

            /**
             * Returns the raw JSON value of [accountNumber].
             *
             * Unlike [accountNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("account_number")
            @ExcludeMissing
            fun _accountNumber(): JsonField<String> = accountNumber

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [auxiliaryOnUs].
             *
             * Unlike [auxiliaryOnUs], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("auxiliary_on_us")
            @ExcludeMissing
            fun _auxiliaryOnUs(): JsonField<String> = auxiliaryOnUs

            /**
             * Returns the raw JSON value of [checkDepositId].
             *
             * Unlike [checkDepositId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("check_deposit_id")
            @ExcludeMissing
            fun _checkDepositId(): JsonField<String> = checkDepositId

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [routingNumber].
             *
             * Unlike [routingNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("routing_number")
            @ExcludeMissing
            fun _routingNumber(): JsonField<String> = routingNumber

            /**
             * Returns the raw JSON value of [serialNumber].
             *
             * Unlike [serialNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("serial_number")
            @ExcludeMissing
            fun _serialNumber(): JsonField<String> = serialNumber

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [CheckDepositAcceptance].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accountNumber()
                 * .amount()
                 * .auxiliaryOnUs()
                 * .checkDepositId()
                 * .currency()
                 * .routingNumber()
                 * .serialNumber()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CheckDepositAcceptance]. */
            class Builder internal constructor() {

                private var accountNumber: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var auxiliaryOnUs: JsonField<String>? = null
                private var checkDepositId: JsonField<String>? = null
                private var currency: JsonField<Currency>? = null
                private var routingNumber: JsonField<String>? = null
                private var serialNumber: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(checkDepositAcceptance: CheckDepositAcceptance) = apply {
                    accountNumber = checkDepositAcceptance.accountNumber
                    amount = checkDepositAcceptance.amount
                    auxiliaryOnUs = checkDepositAcceptance.auxiliaryOnUs
                    checkDepositId = checkDepositAcceptance.checkDepositId
                    currency = checkDepositAcceptance.currency
                    routingNumber = checkDepositAcceptance.routingNumber
                    serialNumber = checkDepositAcceptance.serialNumber
                    additionalProperties =
                        checkDepositAcceptance.additionalProperties.toMutableMap()
                }

                /** The account number printed on the check. */
                fun accountNumber(accountNumber: String) =
                    accountNumber(JsonField.of(accountNumber))

                /**
                 * Sets [Builder.accountNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.accountNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun accountNumber(accountNumber: JsonField<String>) = apply {
                    this.accountNumber = accountNumber
                }

                /**
                 * The amount to be deposited in the minor unit of the transaction's currency. For
                 * dollars, for example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * An additional line of metadata printed on the check. This typically includes the
                 * check number for business checks.
                 */
                fun auxiliaryOnUs(auxiliaryOnUs: String?) =
                    auxiliaryOnUs(JsonField.ofNullable(auxiliaryOnUs))

                /**
                 * Sets [Builder.auxiliaryOnUs] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.auxiliaryOnUs] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun auxiliaryOnUs(auxiliaryOnUs: JsonField<String>) = apply {
                    this.auxiliaryOnUs = auxiliaryOnUs
                }

                /** The ID of the Check Deposit that was accepted. */
                fun checkDepositId(checkDepositId: String) =
                    checkDepositId(JsonField.of(checkDepositId))

                /**
                 * Sets [Builder.checkDepositId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.checkDepositId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun checkDepositId(checkDepositId: JsonField<String>) = apply {
                    this.checkDepositId = checkDepositId
                }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
                 * currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** The routing number printed on the check. */
                fun routingNumber(routingNumber: String) =
                    routingNumber(JsonField.of(routingNumber))

                /**
                 * Sets [Builder.routingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.routingNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun routingNumber(routingNumber: JsonField<String>) = apply {
                    this.routingNumber = routingNumber
                }

                /**
                 * The check serial number, if present, for consumer checks. For business checks,
                 * the serial number is usually in the `auxiliary_on_us` field.
                 */
                fun serialNumber(serialNumber: String?) =
                    serialNumber(JsonField.ofNullable(serialNumber))

                /**
                 * Sets [Builder.serialNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.serialNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun serialNumber(serialNumber: JsonField<String>) = apply {
                    this.serialNumber = serialNumber
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CheckDepositAcceptance].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accountNumber()
                 * .amount()
                 * .auxiliaryOnUs()
                 * .checkDepositId()
                 * .currency()
                 * .routingNumber()
                 * .serialNumber()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CheckDepositAcceptance =
                    CheckDepositAcceptance(
                        checkRequired("accountNumber", accountNumber),
                        checkRequired("amount", amount),
                        checkRequired("auxiliaryOnUs", auxiliaryOnUs),
                        checkRequired("checkDepositId", checkDepositId),
                        checkRequired("currency", currency),
                        checkRequired("routingNumber", routingNumber),
                        checkRequired("serialNumber", serialNumber),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CheckDepositAcceptance = apply {
                if (validated) {
                    return@apply
                }

                accountNumber()
                amount()
                auxiliaryOnUs()
                checkDepositId()
                currency().validate()
                routingNumber()
                serialNumber()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (accountNumber.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (if (auxiliaryOnUs.asKnown() == null) 0 else 1) +
                    (if (checkDepositId.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (if (routingNumber.asKnown() == null) 0 else 1) +
                    (if (serialNumber.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CheckDepositAcceptance &&
                    accountNumber == other.accountNumber &&
                    amount == other.amount &&
                    auxiliaryOnUs == other.auxiliaryOnUs &&
                    checkDepositId == other.checkDepositId &&
                    currency == other.currency &&
                    routingNumber == other.routingNumber &&
                    serialNumber == other.serialNumber &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    accountNumber,
                    amount,
                    auxiliaryOnUs,
                    checkDepositId,
                    currency,
                    routingNumber,
                    serialNumber,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CheckDepositAcceptance{accountNumber=$accountNumber, amount=$amount, auxiliaryOnUs=$auxiliaryOnUs, checkDepositId=$checkDepositId, currency=$currency, routingNumber=$routingNumber, serialNumber=$serialNumber, additionalProperties=$additionalProperties}"
        }

        /**
         * A Check Deposit Return object. This field will be present in the JSON response if and
         * only if `category` is equal to `check_deposit_return`. A Check Deposit Return is created
         * when a Check Deposit is returned by the bank holding the account it was drawn against.
         * Check Deposits may be returned for a variety of reasons, including insufficient funds or
         * a mismatched account number. Usually, checks are returned within the first 7 days after
         * the deposit is made.
         */
        class CheckDepositReturn
        private constructor(
            private val amount: JsonField<Long>,
            private val checkDepositId: JsonField<String>,
            private val currency: JsonField<Currency>,
            private val returnReason: JsonField<ReturnReason>,
            private val returnedAt: JsonField<OffsetDateTime>,
            private val transactionId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("check_deposit_id")
                @ExcludeMissing
                checkDepositId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("return_reason")
                @ExcludeMissing
                returnReason: JsonField<ReturnReason> = JsonMissing.of(),
                @JsonProperty("returned_at")
                @ExcludeMissing
                returnedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
            ) : this(
                amount,
                checkDepositId,
                currency,
                returnReason,
                returnedAt,
                transactionId,
                mutableMapOf(),
            )

            /**
             * The returned amount in USD cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The identifier of the Check Deposit that was returned.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun checkDepositId(): String = checkDepositId.getRequired("check_deposit_id")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * Why this check was returned by the bank holding the account it was drawn against.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun returnReason(): ReturnReason = returnReason.getRequired("return_reason")

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * check deposit was returned.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun returnedAt(): OffsetDateTime = returnedAt.getRequired("returned_at")

            /**
             * The identifier of the transaction that reversed the original check deposit
             * transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [checkDepositId].
             *
             * Unlike [checkDepositId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("check_deposit_id")
            @ExcludeMissing
            fun _checkDepositId(): JsonField<String> = checkDepositId

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [returnReason].
             *
             * Unlike [returnReason], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("return_reason")
            @ExcludeMissing
            fun _returnReason(): JsonField<ReturnReason> = returnReason

            /**
             * Returns the raw JSON value of [returnedAt].
             *
             * Unlike [returnedAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("returned_at")
            @ExcludeMissing
            fun _returnedAt(): JsonField<OffsetDateTime> = returnedAt

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CheckDepositReturn].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .checkDepositId()
                 * .currency()
                 * .returnReason()
                 * .returnedAt()
                 * .transactionId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CheckDepositReturn]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var checkDepositId: JsonField<String>? = null
                private var currency: JsonField<Currency>? = null
                private var returnReason: JsonField<ReturnReason>? = null
                private var returnedAt: JsonField<OffsetDateTime>? = null
                private var transactionId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(checkDepositReturn: CheckDepositReturn) = apply {
                    amount = checkDepositReturn.amount
                    checkDepositId = checkDepositReturn.checkDepositId
                    currency = checkDepositReturn.currency
                    returnReason = checkDepositReturn.returnReason
                    returnedAt = checkDepositReturn.returnedAt
                    transactionId = checkDepositReturn.transactionId
                    additionalProperties = checkDepositReturn.additionalProperties.toMutableMap()
                }

                /** The returned amount in USD cents. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The identifier of the Check Deposit that was returned. */
                fun checkDepositId(checkDepositId: String) =
                    checkDepositId(JsonField.of(checkDepositId))

                /**
                 * Sets [Builder.checkDepositId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.checkDepositId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun checkDepositId(checkDepositId: JsonField<String>) = apply {
                    this.checkDepositId = checkDepositId
                }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
                 * currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /**
                 * Why this check was returned by the bank holding the account it was drawn against.
                 */
                fun returnReason(returnReason: ReturnReason) =
                    returnReason(JsonField.of(returnReason))

                /**
                 * Sets [Builder.returnReason] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.returnReason] with a well-typed [ReturnReason]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun returnReason(returnReason: JsonField<ReturnReason>) = apply {
                    this.returnReason = returnReason
                }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * check deposit was returned.
                 */
                fun returnedAt(returnedAt: OffsetDateTime) = returnedAt(JsonField.of(returnedAt))

                /**
                 * Sets [Builder.returnedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.returnedAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun returnedAt(returnedAt: JsonField<OffsetDateTime>) = apply {
                    this.returnedAt = returnedAt
                }

                /**
                 * The identifier of the transaction that reversed the original check deposit
                 * transaction.
                 */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CheckDepositReturn].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .checkDepositId()
                 * .currency()
                 * .returnReason()
                 * .returnedAt()
                 * .transactionId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CheckDepositReturn =
                    CheckDepositReturn(
                        checkRequired("amount", amount),
                        checkRequired("checkDepositId", checkDepositId),
                        checkRequired("currency", currency),
                        checkRequired("returnReason", returnReason),
                        checkRequired("returnedAt", returnedAt),
                        checkRequired("transactionId", transactionId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CheckDepositReturn = apply {
                if (validated) {
                    return@apply
                }

                amount()
                checkDepositId()
                currency().validate()
                returnReason().validate()
                returnedAt()
                transactionId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (if (checkDepositId.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (returnReason.asKnown()?.validity() ?: 0) +
                    (if (returnedAt.asKnown() == null) 0 else 1) +
                    (if (transactionId.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction's
             * currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /** Why this check was returned by the bank holding the account it was drawn against. */
            class ReturnReason
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** The check doesn't allow ACH conversion. */
                    val ACH_CONVERSION_NOT_SUPPORTED = of("ach_conversion_not_supported")

                    /** The account is closed. (Check21 return code `D`) */
                    val CLOSED_ACCOUNT = of("closed_account")

                    /** The check has already been deposited. (Check21 return code `Y`) */
                    val DUPLICATE_SUBMISSION = of("duplicate_submission")

                    /** Insufficient funds (Check21 return code `A`) */
                    val INSUFFICIENT_FUNDS = of("insufficient_funds")

                    /**
                     * No account was found matching the check details. (Check21 return code `E`)
                     */
                    val NO_ACCOUNT = of("no_account")

                    /** The check was not authorized. (Check21 return code `Q`) */
                    val NOT_AUTHORIZED = of("not_authorized")

                    /** The check is too old. (Check21 return code `G`) */
                    val STALE_DATED = of("stale_dated")

                    /**
                     * The payment has been stopped by the account holder. (Check21 return code `C`)
                     */
                    val STOP_PAYMENT = of("stop_payment")

                    /** The reason for the return is unknown. */
                    val UNKNOWN_REASON = of("unknown_reason")

                    /** The image doesn't match the details submitted. */
                    val UNMATCHED_DETAILS = of("unmatched_details")

                    /** The image could not be read. (Check21 return code `U`) */
                    val UNREADABLE_IMAGE = of("unreadable_image")

                    /** The check endorsement was irregular. (Check21 return code `J`) */
                    val ENDORSEMENT_IRREGULAR = of("endorsement_irregular")

                    /** The check present was either altered or fake. (Check21 return code `N`) */
                    val ALTERED_OR_FICTITIOUS_ITEM = of("altered_or_fictitious_item")

                    /** The account this check is drawn on is frozen. (Check21 return code `F`) */
                    val FROZEN_OR_BLOCKED_ACCOUNT = of("frozen_or_blocked_account")

                    /** The check is post dated. (Check21 return code `H`) */
                    val POST_DATED = of("post_dated")

                    /** The endorsement was missing. (Check21 return code `I`) */
                    val ENDORSEMENT_MISSING = of("endorsement_missing")

                    /** The check signature was missing. (Check21 return code `K`) */
                    val SIGNATURE_MISSING = of("signature_missing")

                    /**
                     * The bank suspects a stop payment will be placed. (Check21 return code `T`)
                     */
                    val STOP_PAYMENT_SUSPECT = of("stop_payment_suspect")

                    /** The bank cannot read the image. (Check21 return code `U`) */
                    val UNUSABLE_IMAGE = of("unusable_image")

                    /**
                     * The check image fails the bank's security check. (Check21 return code `V`)
                     */
                    val IMAGE_FAILS_SECURITY_CHECK = of("image_fails_security_check")

                    /** The bank cannot determine the amount. (Check21 return code `W`) */
                    val CANNOT_DETERMINE_AMOUNT = of("cannot_determine_amount")

                    /**
                     * The signature is inconsistent with prior signatures. (Check21 return code
                     * `L`)
                     */
                    val SIGNATURE_IRREGULAR = of("signature_irregular")

                    /**
                     * The check is a non-cash item and cannot be drawn against the account.
                     * (Check21 return code `M`)
                     */
                    val NON_CASH_ITEM = of("non_cash_item")

                    /** The bank is unable to process this check. (Check21 return code `O`) */
                    val UNABLE_TO_PROCESS = of("unable_to_process")

                    /** The check exceeds the bank or customer's limit. (Check21 return code `P`) */
                    val ITEM_EXCEEDS_DOLLAR_LIMIT = of("item_exceeds_dollar_limit")

                    /**
                     * The bank sold this account and no longer services this customer. (Check21
                     * return code `R`)
                     */
                    val BRANCH_OR_ACCOUNT_SOLD = of("branch_or_account_sold")

                    fun of(value: String) = ReturnReason(JsonField.of(value))
                }

                /** An enum containing [ReturnReason]'s known values. */
                enum class Known {
                    /** The check doesn't allow ACH conversion. */
                    ACH_CONVERSION_NOT_SUPPORTED,
                    /** The account is closed. (Check21 return code `D`) */
                    CLOSED_ACCOUNT,
                    /** The check has already been deposited. (Check21 return code `Y`) */
                    DUPLICATE_SUBMISSION,
                    /** Insufficient funds (Check21 return code `A`) */
                    INSUFFICIENT_FUNDS,
                    /**
                     * No account was found matching the check details. (Check21 return code `E`)
                     */
                    NO_ACCOUNT,
                    /** The check was not authorized. (Check21 return code `Q`) */
                    NOT_AUTHORIZED,
                    /** The check is too old. (Check21 return code `G`) */
                    STALE_DATED,
                    /**
                     * The payment has been stopped by the account holder. (Check21 return code `C`)
                     */
                    STOP_PAYMENT,
                    /** The reason for the return is unknown. */
                    UNKNOWN_REASON,
                    /** The image doesn't match the details submitted. */
                    UNMATCHED_DETAILS,
                    /** The image could not be read. (Check21 return code `U`) */
                    UNREADABLE_IMAGE,
                    /** The check endorsement was irregular. (Check21 return code `J`) */
                    ENDORSEMENT_IRREGULAR,
                    /** The check present was either altered or fake. (Check21 return code `N`) */
                    ALTERED_OR_FICTITIOUS_ITEM,
                    /** The account this check is drawn on is frozen. (Check21 return code `F`) */
                    FROZEN_OR_BLOCKED_ACCOUNT,
                    /** The check is post dated. (Check21 return code `H`) */
                    POST_DATED,
                    /** The endorsement was missing. (Check21 return code `I`) */
                    ENDORSEMENT_MISSING,
                    /** The check signature was missing. (Check21 return code `K`) */
                    SIGNATURE_MISSING,
                    /**
                     * The bank suspects a stop payment will be placed. (Check21 return code `T`)
                     */
                    STOP_PAYMENT_SUSPECT,
                    /** The bank cannot read the image. (Check21 return code `U`) */
                    UNUSABLE_IMAGE,
                    /**
                     * The check image fails the bank's security check. (Check21 return code `V`)
                     */
                    IMAGE_FAILS_SECURITY_CHECK,
                    /** The bank cannot determine the amount. (Check21 return code `W`) */
                    CANNOT_DETERMINE_AMOUNT,
                    /**
                     * The signature is inconsistent with prior signatures. (Check21 return code
                     * `L`)
                     */
                    SIGNATURE_IRREGULAR,
                    /**
                     * The check is a non-cash item and cannot be drawn against the account.
                     * (Check21 return code `M`)
                     */
                    NON_CASH_ITEM,
                    /** The bank is unable to process this check. (Check21 return code `O`) */
                    UNABLE_TO_PROCESS,
                    /** The check exceeds the bank or customer's limit. (Check21 return code `P`) */
                    ITEM_EXCEEDS_DOLLAR_LIMIT,
                    /**
                     * The bank sold this account and no longer services this customer. (Check21
                     * return code `R`)
                     */
                    BRANCH_OR_ACCOUNT_SOLD,
                }

                /**
                 * An enum containing [ReturnReason]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [ReturnReason] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** The check doesn't allow ACH conversion. */
                    ACH_CONVERSION_NOT_SUPPORTED,
                    /** The account is closed. (Check21 return code `D`) */
                    CLOSED_ACCOUNT,
                    /** The check has already been deposited. (Check21 return code `Y`) */
                    DUPLICATE_SUBMISSION,
                    /** Insufficient funds (Check21 return code `A`) */
                    INSUFFICIENT_FUNDS,
                    /**
                     * No account was found matching the check details. (Check21 return code `E`)
                     */
                    NO_ACCOUNT,
                    /** The check was not authorized. (Check21 return code `Q`) */
                    NOT_AUTHORIZED,
                    /** The check is too old. (Check21 return code `G`) */
                    STALE_DATED,
                    /**
                     * The payment has been stopped by the account holder. (Check21 return code `C`)
                     */
                    STOP_PAYMENT,
                    /** The reason for the return is unknown. */
                    UNKNOWN_REASON,
                    /** The image doesn't match the details submitted. */
                    UNMATCHED_DETAILS,
                    /** The image could not be read. (Check21 return code `U`) */
                    UNREADABLE_IMAGE,
                    /** The check endorsement was irregular. (Check21 return code `J`) */
                    ENDORSEMENT_IRREGULAR,
                    /** The check present was either altered or fake. (Check21 return code `N`) */
                    ALTERED_OR_FICTITIOUS_ITEM,
                    /** The account this check is drawn on is frozen. (Check21 return code `F`) */
                    FROZEN_OR_BLOCKED_ACCOUNT,
                    /** The check is post dated. (Check21 return code `H`) */
                    POST_DATED,
                    /** The endorsement was missing. (Check21 return code `I`) */
                    ENDORSEMENT_MISSING,
                    /** The check signature was missing. (Check21 return code `K`) */
                    SIGNATURE_MISSING,
                    /**
                     * The bank suspects a stop payment will be placed. (Check21 return code `T`)
                     */
                    STOP_PAYMENT_SUSPECT,
                    /** The bank cannot read the image. (Check21 return code `U`) */
                    UNUSABLE_IMAGE,
                    /**
                     * The check image fails the bank's security check. (Check21 return code `V`)
                     */
                    IMAGE_FAILS_SECURITY_CHECK,
                    /** The bank cannot determine the amount. (Check21 return code `W`) */
                    CANNOT_DETERMINE_AMOUNT,
                    /**
                     * The signature is inconsistent with prior signatures. (Check21 return code
                     * `L`)
                     */
                    SIGNATURE_IRREGULAR,
                    /**
                     * The check is a non-cash item and cannot be drawn against the account.
                     * (Check21 return code `M`)
                     */
                    NON_CASH_ITEM,
                    /** The bank is unable to process this check. (Check21 return code `O`) */
                    UNABLE_TO_PROCESS,
                    /** The check exceeds the bank or customer's limit. (Check21 return code `P`) */
                    ITEM_EXCEEDS_DOLLAR_LIMIT,
                    /**
                     * The bank sold this account and no longer services this customer. (Check21
                     * return code `R`)
                     */
                    BRANCH_OR_ACCOUNT_SOLD,
                    /**
                     * An enum member indicating that [ReturnReason] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        ACH_CONVERSION_NOT_SUPPORTED -> Value.ACH_CONVERSION_NOT_SUPPORTED
                        CLOSED_ACCOUNT -> Value.CLOSED_ACCOUNT
                        DUPLICATE_SUBMISSION -> Value.DUPLICATE_SUBMISSION
                        INSUFFICIENT_FUNDS -> Value.INSUFFICIENT_FUNDS
                        NO_ACCOUNT -> Value.NO_ACCOUNT
                        NOT_AUTHORIZED -> Value.NOT_AUTHORIZED
                        STALE_DATED -> Value.STALE_DATED
                        STOP_PAYMENT -> Value.STOP_PAYMENT
                        UNKNOWN_REASON -> Value.UNKNOWN_REASON
                        UNMATCHED_DETAILS -> Value.UNMATCHED_DETAILS
                        UNREADABLE_IMAGE -> Value.UNREADABLE_IMAGE
                        ENDORSEMENT_IRREGULAR -> Value.ENDORSEMENT_IRREGULAR
                        ALTERED_OR_FICTITIOUS_ITEM -> Value.ALTERED_OR_FICTITIOUS_ITEM
                        FROZEN_OR_BLOCKED_ACCOUNT -> Value.FROZEN_OR_BLOCKED_ACCOUNT
                        POST_DATED -> Value.POST_DATED
                        ENDORSEMENT_MISSING -> Value.ENDORSEMENT_MISSING
                        SIGNATURE_MISSING -> Value.SIGNATURE_MISSING
                        STOP_PAYMENT_SUSPECT -> Value.STOP_PAYMENT_SUSPECT
                        UNUSABLE_IMAGE -> Value.UNUSABLE_IMAGE
                        IMAGE_FAILS_SECURITY_CHECK -> Value.IMAGE_FAILS_SECURITY_CHECK
                        CANNOT_DETERMINE_AMOUNT -> Value.CANNOT_DETERMINE_AMOUNT
                        SIGNATURE_IRREGULAR -> Value.SIGNATURE_IRREGULAR
                        NON_CASH_ITEM -> Value.NON_CASH_ITEM
                        UNABLE_TO_PROCESS -> Value.UNABLE_TO_PROCESS
                        ITEM_EXCEEDS_DOLLAR_LIMIT -> Value.ITEM_EXCEEDS_DOLLAR_LIMIT
                        BRANCH_OR_ACCOUNT_SOLD -> Value.BRANCH_OR_ACCOUNT_SOLD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        ACH_CONVERSION_NOT_SUPPORTED -> Known.ACH_CONVERSION_NOT_SUPPORTED
                        CLOSED_ACCOUNT -> Known.CLOSED_ACCOUNT
                        DUPLICATE_SUBMISSION -> Known.DUPLICATE_SUBMISSION
                        INSUFFICIENT_FUNDS -> Known.INSUFFICIENT_FUNDS
                        NO_ACCOUNT -> Known.NO_ACCOUNT
                        NOT_AUTHORIZED -> Known.NOT_AUTHORIZED
                        STALE_DATED -> Known.STALE_DATED
                        STOP_PAYMENT -> Known.STOP_PAYMENT
                        UNKNOWN_REASON -> Known.UNKNOWN_REASON
                        UNMATCHED_DETAILS -> Known.UNMATCHED_DETAILS
                        UNREADABLE_IMAGE -> Known.UNREADABLE_IMAGE
                        ENDORSEMENT_IRREGULAR -> Known.ENDORSEMENT_IRREGULAR
                        ALTERED_OR_FICTITIOUS_ITEM -> Known.ALTERED_OR_FICTITIOUS_ITEM
                        FROZEN_OR_BLOCKED_ACCOUNT -> Known.FROZEN_OR_BLOCKED_ACCOUNT
                        POST_DATED -> Known.POST_DATED
                        ENDORSEMENT_MISSING -> Known.ENDORSEMENT_MISSING
                        SIGNATURE_MISSING -> Known.SIGNATURE_MISSING
                        STOP_PAYMENT_SUSPECT -> Known.STOP_PAYMENT_SUSPECT
                        UNUSABLE_IMAGE -> Known.UNUSABLE_IMAGE
                        IMAGE_FAILS_SECURITY_CHECK -> Known.IMAGE_FAILS_SECURITY_CHECK
                        CANNOT_DETERMINE_AMOUNT -> Known.CANNOT_DETERMINE_AMOUNT
                        SIGNATURE_IRREGULAR -> Known.SIGNATURE_IRREGULAR
                        NON_CASH_ITEM -> Known.NON_CASH_ITEM
                        UNABLE_TO_PROCESS -> Known.UNABLE_TO_PROCESS
                        ITEM_EXCEEDS_DOLLAR_LIMIT -> Known.ITEM_EXCEEDS_DOLLAR_LIMIT
                        BRANCH_OR_ACCOUNT_SOLD -> Known.BRANCH_OR_ACCOUNT_SOLD
                        else -> throw IncreaseInvalidDataException("Unknown ReturnReason: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): ReturnReason = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is ReturnReason && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CheckDepositReturn &&
                    amount == other.amount &&
                    checkDepositId == other.checkDepositId &&
                    currency == other.currency &&
                    returnReason == other.returnReason &&
                    returnedAt == other.returnedAt &&
                    transactionId == other.transactionId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    checkDepositId,
                    currency,
                    returnReason,
                    returnedAt,
                    transactionId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CheckDepositReturn{amount=$amount, checkDepositId=$checkDepositId, currency=$currency, returnReason=$returnReason, returnedAt=$returnedAt, transactionId=$transactionId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Check Transfer Deposit object. This field will be present in the JSON response if and
         * only if `category` is equal to `check_transfer_deposit`. An Inbound Check is a check
         * drawn on an Increase account that has been deposited by an external bank account. These
         * types of checks are not pre-registered.
         */
        class CheckTransferDeposit
        private constructor(
            private val backImageFileId: JsonField<String>,
            private val bankOfFirstDepositRoutingNumber: JsonField<String>,
            private val depositedAt: JsonField<OffsetDateTime>,
            private val frontImageFileId: JsonField<String>,
            private val inboundCheckDepositId: JsonField<String>,
            private val transactionId: JsonField<String>,
            private val transferId: JsonField<String>,
            private val type: JsonField<Type>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("back_image_file_id")
                @ExcludeMissing
                backImageFileId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("bank_of_first_deposit_routing_number")
                @ExcludeMissing
                bankOfFirstDepositRoutingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("deposited_at")
                @ExcludeMissing
                depositedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("front_image_file_id")
                @ExcludeMissing
                frontImageFileId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("inbound_check_deposit_id")
                @ExcludeMissing
                inboundCheckDepositId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("type") @ExcludeMissing type: JsonField<Type> = JsonMissing.of(),
            ) : this(
                backImageFileId,
                bankOfFirstDepositRoutingNumber,
                depositedAt,
                frontImageFileId,
                inboundCheckDepositId,
                transactionId,
                transferId,
                type,
                mutableMapOf(),
            )

            /**
             * The identifier of the API File object containing an image of the back of the
             * deposited check.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun backImageFileId(): String? = backImageFileId.getNullable("back_image_file_id")

            /**
             * The American Bankers' Association (ABA) Routing Transit Number (RTN) for the bank
             * depositing this check. In some rare cases, this is not transmitted via Check21 and
             * the value will be null.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun bankOfFirstDepositRoutingNumber(): String? =
                bankOfFirstDepositRoutingNumber.getNullable("bank_of_first_deposit_routing_number")

            /**
             * When the check was deposited.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun depositedAt(): OffsetDateTime = depositedAt.getRequired("deposited_at")

            /**
             * The identifier of the API File object containing an image of the front of the
             * deposited check.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun frontImageFileId(): String? = frontImageFileId.getNullable("front_image_file_id")

            /**
             * The identifier of the Inbound Check Deposit object associated with this transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun inboundCheckDepositId(): String? =
                inboundCheckDepositId.getNullable("inbound_check_deposit_id")

            /**
             * The identifier of the Transaction object created when the check was deposited.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun transactionId(): String? = transactionId.getNullable("transaction_id")

            /**
             * The identifier of the Check Transfer object that was deposited.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun transferId(): String? = transferId.getNullable("transfer_id")

            /**
             * A constant representing the object's type. For this resource it will always be
             * `check_transfer_deposit`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun type(): Type = type.getRequired("type")

            /**
             * Returns the raw JSON value of [backImageFileId].
             *
             * Unlike [backImageFileId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("back_image_file_id")
            @ExcludeMissing
            fun _backImageFileId(): JsonField<String> = backImageFileId

            /**
             * Returns the raw JSON value of [bankOfFirstDepositRoutingNumber].
             *
             * Unlike [bankOfFirstDepositRoutingNumber], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("bank_of_first_deposit_routing_number")
            @ExcludeMissing
            fun _bankOfFirstDepositRoutingNumber(): JsonField<String> =
                bankOfFirstDepositRoutingNumber

            /**
             * Returns the raw JSON value of [depositedAt].
             *
             * Unlike [depositedAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("deposited_at")
            @ExcludeMissing
            fun _depositedAt(): JsonField<OffsetDateTime> = depositedAt

            /**
             * Returns the raw JSON value of [frontImageFileId].
             *
             * Unlike [frontImageFileId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("front_image_file_id")
            @ExcludeMissing
            fun _frontImageFileId(): JsonField<String> = frontImageFileId

            /**
             * Returns the raw JSON value of [inboundCheckDepositId].
             *
             * Unlike [inboundCheckDepositId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("inbound_check_deposit_id")
            @ExcludeMissing
            fun _inboundCheckDepositId(): JsonField<String> = inboundCheckDepositId

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            /**
             * Returns the raw JSON value of [type].
             *
             * Unlike [type], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("type") @ExcludeMissing fun _type(): JsonField<Type> = type

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CheckTransferDeposit].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .backImageFileId()
                 * .bankOfFirstDepositRoutingNumber()
                 * .depositedAt()
                 * .frontImageFileId()
                 * .inboundCheckDepositId()
                 * .transactionId()
                 * .transferId()
                 * .type()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [CheckTransferDeposit]. */
            class Builder internal constructor() {

                private var backImageFileId: JsonField<String>? = null
                private var bankOfFirstDepositRoutingNumber: JsonField<String>? = null
                private var depositedAt: JsonField<OffsetDateTime>? = null
                private var frontImageFileId: JsonField<String>? = null
                private var inboundCheckDepositId: JsonField<String>? = null
                private var transactionId: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var type: JsonField<Type>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(checkTransferDeposit: CheckTransferDeposit) = apply {
                    backImageFileId = checkTransferDeposit.backImageFileId
                    bankOfFirstDepositRoutingNumber =
                        checkTransferDeposit.bankOfFirstDepositRoutingNumber
                    depositedAt = checkTransferDeposit.depositedAt
                    frontImageFileId = checkTransferDeposit.frontImageFileId
                    inboundCheckDepositId = checkTransferDeposit.inboundCheckDepositId
                    transactionId = checkTransferDeposit.transactionId
                    transferId = checkTransferDeposit.transferId
                    type = checkTransferDeposit.type
                    additionalProperties = checkTransferDeposit.additionalProperties.toMutableMap()
                }

                /**
                 * The identifier of the API File object containing an image of the back of the
                 * deposited check.
                 */
                fun backImageFileId(backImageFileId: String?) =
                    backImageFileId(JsonField.ofNullable(backImageFileId))

                /**
                 * Sets [Builder.backImageFileId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.backImageFileId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun backImageFileId(backImageFileId: JsonField<String>) = apply {
                    this.backImageFileId = backImageFileId
                }

                /**
                 * The American Bankers' Association (ABA) Routing Transit Number (RTN) for the bank
                 * depositing this check. In some rare cases, this is not transmitted via Check21
                 * and the value will be null.
                 */
                fun bankOfFirstDepositRoutingNumber(bankOfFirstDepositRoutingNumber: String?) =
                    bankOfFirstDepositRoutingNumber(
                        JsonField.ofNullable(bankOfFirstDepositRoutingNumber)
                    )

                /**
                 * Sets [Builder.bankOfFirstDepositRoutingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.bankOfFirstDepositRoutingNumber] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun bankOfFirstDepositRoutingNumber(
                    bankOfFirstDepositRoutingNumber: JsonField<String>
                ) = apply { this.bankOfFirstDepositRoutingNumber = bankOfFirstDepositRoutingNumber }

                /** When the check was deposited. */
                fun depositedAt(depositedAt: OffsetDateTime) =
                    depositedAt(JsonField.of(depositedAt))

                /**
                 * Sets [Builder.depositedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.depositedAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun depositedAt(depositedAt: JsonField<OffsetDateTime>) = apply {
                    this.depositedAt = depositedAt
                }

                /**
                 * The identifier of the API File object containing an image of the front of the
                 * deposited check.
                 */
                fun frontImageFileId(frontImageFileId: String?) =
                    frontImageFileId(JsonField.ofNullable(frontImageFileId))

                /**
                 * Sets [Builder.frontImageFileId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.frontImageFileId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun frontImageFileId(frontImageFileId: JsonField<String>) = apply {
                    this.frontImageFileId = frontImageFileId
                }

                /**
                 * The identifier of the Inbound Check Deposit object associated with this
                 * transaction.
                 */
                fun inboundCheckDepositId(inboundCheckDepositId: String?) =
                    inboundCheckDepositId(JsonField.ofNullable(inboundCheckDepositId))

                /**
                 * Sets [Builder.inboundCheckDepositId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inboundCheckDepositId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun inboundCheckDepositId(inboundCheckDepositId: JsonField<String>) = apply {
                    this.inboundCheckDepositId = inboundCheckDepositId
                }

                /**
                 * The identifier of the Transaction object created when the check was deposited.
                 */
                fun transactionId(transactionId: String?) =
                    transactionId(JsonField.ofNullable(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                /** The identifier of the Check Transfer object that was deposited. */
                fun transferId(transferId: String?) = transferId(JsonField.ofNullable(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                /**
                 * A constant representing the object's type. For this resource it will always be
                 * `check_transfer_deposit`.
                 */
                fun type(type: Type) = type(JsonField.of(type))

                /**
                 * Sets [Builder.type] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.type] with a well-typed [Type] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun type(type: JsonField<Type>) = apply { this.type = type }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CheckTransferDeposit].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .backImageFileId()
                 * .bankOfFirstDepositRoutingNumber()
                 * .depositedAt()
                 * .frontImageFileId()
                 * .inboundCheckDepositId()
                 * .transactionId()
                 * .transferId()
                 * .type()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): CheckTransferDeposit =
                    CheckTransferDeposit(
                        checkRequired("backImageFileId", backImageFileId),
                        checkRequired(
                            "bankOfFirstDepositRoutingNumber",
                            bankOfFirstDepositRoutingNumber,
                        ),
                        checkRequired("depositedAt", depositedAt),
                        checkRequired("frontImageFileId", frontImageFileId),
                        checkRequired("inboundCheckDepositId", inboundCheckDepositId),
                        checkRequired("transactionId", transactionId),
                        checkRequired("transferId", transferId),
                        checkRequired("type", type),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): CheckTransferDeposit = apply {
                if (validated) {
                    return@apply
                }

                backImageFileId()
                bankOfFirstDepositRoutingNumber()
                depositedAt()
                frontImageFileId()
                inboundCheckDepositId()
                transactionId()
                transferId()
                type().validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (backImageFileId.asKnown() == null) 0 else 1) +
                    (if (bankOfFirstDepositRoutingNumber.asKnown() == null) 0 else 1) +
                    (if (depositedAt.asKnown() == null) 0 else 1) +
                    (if (frontImageFileId.asKnown() == null) 0 else 1) +
                    (if (inboundCheckDepositId.asKnown() == null) 0 else 1) +
                    (if (transactionId.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1) +
                    (type.asKnown()?.validity() ?: 0)

            /**
             * A constant representing the object's type. For this resource it will always be
             * `check_transfer_deposit`.
             */
            class Type @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    val CHECK_TRANSFER_DEPOSIT = of("check_transfer_deposit")

                    fun of(value: String) = Type(JsonField.of(value))
                }

                /** An enum containing [Type]'s known values. */
                enum class Known {
                    CHECK_TRANSFER_DEPOSIT
                }

                /**
                 * An enum containing [Type]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Type] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    CHECK_TRANSFER_DEPOSIT,
                    /**
                     * An enum member indicating that [Type] was instantiated with an unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CHECK_TRANSFER_DEPOSIT -> Value.CHECK_TRANSFER_DEPOSIT
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CHECK_TRANSFER_DEPOSIT -> Known.CHECK_TRANSFER_DEPOSIT
                        else -> throw IncreaseInvalidDataException("Unknown Type: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Type = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Type && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is CheckTransferDeposit &&
                    backImageFileId == other.backImageFileId &&
                    bankOfFirstDepositRoutingNumber == other.bankOfFirstDepositRoutingNumber &&
                    depositedAt == other.depositedAt &&
                    frontImageFileId == other.frontImageFileId &&
                    inboundCheckDepositId == other.inboundCheckDepositId &&
                    transactionId == other.transactionId &&
                    transferId == other.transferId &&
                    type == other.type &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    backImageFileId,
                    bankOfFirstDepositRoutingNumber,
                    depositedAt,
                    frontImageFileId,
                    inboundCheckDepositId,
                    transactionId,
                    transferId,
                    type,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CheckTransferDeposit{backImageFileId=$backImageFileId, bankOfFirstDepositRoutingNumber=$bankOfFirstDepositRoutingNumber, depositedAt=$depositedAt, frontImageFileId=$frontImageFileId, inboundCheckDepositId=$inboundCheckDepositId, transactionId=$transactionId, transferId=$transferId, type=$type, additionalProperties=$additionalProperties}"
        }

        /**
         * A Fee Payment object. This field will be present in the JSON response if and only if
         * `category` is equal to `fee_payment`. A Fee Payment represents a payment made to
         * Increase.
         */
        class FeePayment
        private constructor(
            private val amount: JsonField<Long>,
            private val currency: JsonField<Currency>,
            private val feePeriodStart: JsonField<LocalDate>,
            private val programId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("fee_period_start")
                @ExcludeMissing
                feePeriodStart: JsonField<LocalDate> = JsonMissing.of(),
                @JsonProperty("program_id")
                @ExcludeMissing
                programId: JsonField<String> = JsonMissing.of(),
            ) : this(amount, currency, feePeriodStart, programId, mutableMapOf())

            /**
             * The amount in the minor unit of the transaction's currency. For dollars, for example,
             * this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * The start of this payment's fee period, usually the first day of a month.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun feePeriodStart(): LocalDate = feePeriodStart.getRequired("fee_period_start")

            /**
             * The Program for which this fee was incurred.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun programId(): String? = programId.getNullable("program_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [feePeriodStart].
             *
             * Unlike [feePeriodStart], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("fee_period_start")
            @ExcludeMissing
            fun _feePeriodStart(): JsonField<LocalDate> = feePeriodStart

            /**
             * Returns the raw JSON value of [programId].
             *
             * Unlike [programId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("program_id")
            @ExcludeMissing
            fun _programId(): JsonField<String> = programId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [FeePayment].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .feePeriodStart()
                 * .programId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [FeePayment]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var currency: JsonField<Currency>? = null
                private var feePeriodStart: JsonField<LocalDate>? = null
                private var programId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(feePayment: FeePayment) = apply {
                    amount = feePayment.amount
                    currency = feePayment.currency
                    feePeriodStart = feePayment.feePeriodStart
                    programId = feePayment.programId
                    additionalProperties = feePayment.additionalProperties.toMutableMap()
                }

                /**
                 * The amount in the minor unit of the transaction's currency. For dollars, for
                 * example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
                 * currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** The start of this payment's fee period, usually the first day of a month. */
                fun feePeriodStart(feePeriodStart: LocalDate) =
                    feePeriodStart(JsonField.of(feePeriodStart))

                /**
                 * Sets [Builder.feePeriodStart] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.feePeriodStart] with a well-typed [LocalDate]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun feePeriodStart(feePeriodStart: JsonField<LocalDate>) = apply {
                    this.feePeriodStart = feePeriodStart
                }

                /** The Program for which this fee was incurred. */
                fun programId(programId: String?) = programId(JsonField.ofNullable(programId))

                /**
                 * Sets [Builder.programId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.programId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun programId(programId: JsonField<String>) = apply { this.programId = programId }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [FeePayment].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .feePeriodStart()
                 * .programId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): FeePayment =
                    FeePayment(
                        checkRequired("amount", amount),
                        checkRequired("currency", currency),
                        checkRequired("feePeriodStart", feePeriodStart),
                        checkRequired("programId", programId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): FeePayment = apply {
                if (validated) {
                    return@apply
                }

                amount()
                currency().validate()
                feePeriodStart()
                programId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (if (feePeriodStart.asKnown() == null) 0 else 1) +
                    (if (programId.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is FeePayment &&
                    amount == other.amount &&
                    currency == other.currency &&
                    feePeriodStart == other.feePeriodStart &&
                    programId == other.programId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(amount, currency, feePeriodStart, programId, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "FeePayment{amount=$amount, currency=$currency, feePeriodStart=$feePeriodStart, programId=$programId, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound ACH Transfer Intention object. This field will be present in the JSON response
         * if and only if `category` is equal to `inbound_ach_transfer`. An Inbound ACH Transfer
         * Intention is created when an ACH transfer is initiated at another bank and received by
         * Increase.
         */
        class InboundAchTransfer
        private constructor(
            private val addenda: JsonField<Addenda>,
            private val amount: JsonField<Long>,
            private val originatorCompanyDescriptiveDate: JsonField<String>,
            private val originatorCompanyDiscretionaryData: JsonField<String>,
            private val originatorCompanyEntryDescription: JsonField<String>,
            private val originatorCompanyId: JsonField<String>,
            private val originatorCompanyName: JsonField<String>,
            private val receiverIdNumber: JsonField<String>,
            private val receiverName: JsonField<String>,
            private val traceNumber: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("addenda")
                @ExcludeMissing
                addenda: JsonField<Addenda> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("originator_company_descriptive_date")
                @ExcludeMissing
                originatorCompanyDescriptiveDate: JsonField<String> = JsonMissing.of(),
                @JsonProperty("originator_company_discretionary_data")
                @ExcludeMissing
                originatorCompanyDiscretionaryData: JsonField<String> = JsonMissing.of(),
                @JsonProperty("originator_company_entry_description")
                @ExcludeMissing
                originatorCompanyEntryDescription: JsonField<String> = JsonMissing.of(),
                @JsonProperty("originator_company_id")
                @ExcludeMissing
                originatorCompanyId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("originator_company_name")
                @ExcludeMissing
                originatorCompanyName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("receiver_id_number")
                @ExcludeMissing
                receiverIdNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("receiver_name")
                @ExcludeMissing
                receiverName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("trace_number")
                @ExcludeMissing
                traceNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                addenda,
                amount,
                originatorCompanyDescriptiveDate,
                originatorCompanyDiscretionaryData,
                originatorCompanyEntryDescription,
                originatorCompanyId,
                originatorCompanyName,
                receiverIdNumber,
                receiverName,
                traceNumber,
                transferId,
                mutableMapOf(),
            )

            /**
             * Additional information sent from the originator.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun addenda(): Addenda? = addenda.getNullable("addenda")

            /**
             * The transfer amount in USD cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The description of the date of the transfer, usually in the format `YYMMDD`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun originatorCompanyDescriptiveDate(): String? =
                originatorCompanyDescriptiveDate.getNullable("originator_company_descriptive_date")

            /**
             * Data set by the originator.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun originatorCompanyDiscretionaryData(): String? =
                originatorCompanyDiscretionaryData.getNullable(
                    "originator_company_discretionary_data"
                )

            /**
             * An informational description of the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun originatorCompanyEntryDescription(): String =
                originatorCompanyEntryDescription.getRequired(
                    "originator_company_entry_description"
                )

            /**
             * An identifier for the originating company. This is generally, but not always, a
             * stable identifier across multiple transfers.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun originatorCompanyId(): String =
                originatorCompanyId.getRequired("originator_company_id")

            /**
             * A name set by the originator to identify themselves.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun originatorCompanyName(): String =
                originatorCompanyName.getRequired("originator_company_name")

            /**
             * The originator's identifier for the transfer recipient.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun receiverIdNumber(): String? = receiverIdNumber.getNullable("receiver_id_number")

            /**
             * The name of the transfer recipient. This value is informational and not verified by
             * Increase.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun receiverName(): String? = receiverName.getNullable("receiver_name")

            /**
             * A 15 digit number recorded in the Nacha file and available to both the originating
             * and receiving bank. Along with the amount, date, and originating routing number, this
             * can be used to identify the ACH transfer at either bank. ACH trace numbers are not
             * unique, but are
             * [used to correlate returns](https://increase.com/documentation/ach-returns#ach-returns).
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun traceNumber(): String = traceNumber.getRequired("trace_number")

            /**
             * The Inbound ACH Transfer's identifier.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [addenda].
             *
             * Unlike [addenda], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("addenda") @ExcludeMissing fun _addenda(): JsonField<Addenda> = addenda

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [originatorCompanyDescriptiveDate].
             *
             * Unlike [originatorCompanyDescriptiveDate], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("originator_company_descriptive_date")
            @ExcludeMissing
            fun _originatorCompanyDescriptiveDate(): JsonField<String> =
                originatorCompanyDescriptiveDate

            /**
             * Returns the raw JSON value of [originatorCompanyDiscretionaryData].
             *
             * Unlike [originatorCompanyDiscretionaryData], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("originator_company_discretionary_data")
            @ExcludeMissing
            fun _originatorCompanyDiscretionaryData(): JsonField<String> =
                originatorCompanyDiscretionaryData

            /**
             * Returns the raw JSON value of [originatorCompanyEntryDescription].
             *
             * Unlike [originatorCompanyEntryDescription], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("originator_company_entry_description")
            @ExcludeMissing
            fun _originatorCompanyEntryDescription(): JsonField<String> =
                originatorCompanyEntryDescription

            /**
             * Returns the raw JSON value of [originatorCompanyId].
             *
             * Unlike [originatorCompanyId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("originator_company_id")
            @ExcludeMissing
            fun _originatorCompanyId(): JsonField<String> = originatorCompanyId

            /**
             * Returns the raw JSON value of [originatorCompanyName].
             *
             * Unlike [originatorCompanyName], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("originator_company_name")
            @ExcludeMissing
            fun _originatorCompanyName(): JsonField<String> = originatorCompanyName

            /**
             * Returns the raw JSON value of [receiverIdNumber].
             *
             * Unlike [receiverIdNumber], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("receiver_id_number")
            @ExcludeMissing
            fun _receiverIdNumber(): JsonField<String> = receiverIdNumber

            /**
             * Returns the raw JSON value of [receiverName].
             *
             * Unlike [receiverName], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("receiver_name")
            @ExcludeMissing
            fun _receiverName(): JsonField<String> = receiverName

            /**
             * Returns the raw JSON value of [traceNumber].
             *
             * Unlike [traceNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("trace_number")
            @ExcludeMissing
            fun _traceNumber(): JsonField<String> = traceNumber

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [InboundAchTransfer].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .addenda()
                 * .amount()
                 * .originatorCompanyDescriptiveDate()
                 * .originatorCompanyDiscretionaryData()
                 * .originatorCompanyEntryDescription()
                 * .originatorCompanyId()
                 * .originatorCompanyName()
                 * .receiverIdNumber()
                 * .receiverName()
                 * .traceNumber()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundAchTransfer]. */
            class Builder internal constructor() {

                private var addenda: JsonField<Addenda>? = null
                private var amount: JsonField<Long>? = null
                private var originatorCompanyDescriptiveDate: JsonField<String>? = null
                private var originatorCompanyDiscretionaryData: JsonField<String>? = null
                private var originatorCompanyEntryDescription: JsonField<String>? = null
                private var originatorCompanyId: JsonField<String>? = null
                private var originatorCompanyName: JsonField<String>? = null
                private var receiverIdNumber: JsonField<String>? = null
                private var receiverName: JsonField<String>? = null
                private var traceNumber: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(inboundAchTransfer: InboundAchTransfer) = apply {
                    addenda = inboundAchTransfer.addenda
                    amount = inboundAchTransfer.amount
                    originatorCompanyDescriptiveDate =
                        inboundAchTransfer.originatorCompanyDescriptiveDate
                    originatorCompanyDiscretionaryData =
                        inboundAchTransfer.originatorCompanyDiscretionaryData
                    originatorCompanyEntryDescription =
                        inboundAchTransfer.originatorCompanyEntryDescription
                    originatorCompanyId = inboundAchTransfer.originatorCompanyId
                    originatorCompanyName = inboundAchTransfer.originatorCompanyName
                    receiverIdNumber = inboundAchTransfer.receiverIdNumber
                    receiverName = inboundAchTransfer.receiverName
                    traceNumber = inboundAchTransfer.traceNumber
                    transferId = inboundAchTransfer.transferId
                    additionalProperties = inboundAchTransfer.additionalProperties.toMutableMap()
                }

                /** Additional information sent from the originator. */
                fun addenda(addenda: Addenda?) = addenda(JsonField.ofNullable(addenda))

                /**
                 * Sets [Builder.addenda] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.addenda] with a well-typed [Addenda] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun addenda(addenda: JsonField<Addenda>) = apply { this.addenda = addenda }

                /** The transfer amount in USD cents. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The description of the date of the transfer, usually in the format `YYMMDD`. */
                fun originatorCompanyDescriptiveDate(originatorCompanyDescriptiveDate: String?) =
                    originatorCompanyDescriptiveDate(
                        JsonField.ofNullable(originatorCompanyDescriptiveDate)
                    )

                /**
                 * Sets [Builder.originatorCompanyDescriptiveDate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.originatorCompanyDescriptiveDate] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun originatorCompanyDescriptiveDate(
                    originatorCompanyDescriptiveDate: JsonField<String>
                ) = apply {
                    this.originatorCompanyDescriptiveDate = originatorCompanyDescriptiveDate
                }

                /** Data set by the originator. */
                fun originatorCompanyDiscretionaryData(
                    originatorCompanyDiscretionaryData: String?
                ) =
                    originatorCompanyDiscretionaryData(
                        JsonField.ofNullable(originatorCompanyDiscretionaryData)
                    )

                /**
                 * Sets [Builder.originatorCompanyDiscretionaryData] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.originatorCompanyDiscretionaryData] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun originatorCompanyDiscretionaryData(
                    originatorCompanyDiscretionaryData: JsonField<String>
                ) = apply {
                    this.originatorCompanyDiscretionaryData = originatorCompanyDiscretionaryData
                }

                /** An informational description of the transfer. */
                fun originatorCompanyEntryDescription(originatorCompanyEntryDescription: String) =
                    originatorCompanyEntryDescription(
                        JsonField.of(originatorCompanyEntryDescription)
                    )

                /**
                 * Sets [Builder.originatorCompanyEntryDescription] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.originatorCompanyEntryDescription] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun originatorCompanyEntryDescription(
                    originatorCompanyEntryDescription: JsonField<String>
                ) = apply {
                    this.originatorCompanyEntryDescription = originatorCompanyEntryDescription
                }

                /**
                 * An identifier for the originating company. This is generally, but not always, a
                 * stable identifier across multiple transfers.
                 */
                fun originatorCompanyId(originatorCompanyId: String) =
                    originatorCompanyId(JsonField.of(originatorCompanyId))

                /**
                 * Sets [Builder.originatorCompanyId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.originatorCompanyId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun originatorCompanyId(originatorCompanyId: JsonField<String>) = apply {
                    this.originatorCompanyId = originatorCompanyId
                }

                /** A name set by the originator to identify themselves. */
                fun originatorCompanyName(originatorCompanyName: String) =
                    originatorCompanyName(JsonField.of(originatorCompanyName))

                /**
                 * Sets [Builder.originatorCompanyName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.originatorCompanyName] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun originatorCompanyName(originatorCompanyName: JsonField<String>) = apply {
                    this.originatorCompanyName = originatorCompanyName
                }

                /** The originator's identifier for the transfer recipient. */
                fun receiverIdNumber(receiverIdNumber: String?) =
                    receiverIdNumber(JsonField.ofNullable(receiverIdNumber))

                /**
                 * Sets [Builder.receiverIdNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.receiverIdNumber] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun receiverIdNumber(receiverIdNumber: JsonField<String>) = apply {
                    this.receiverIdNumber = receiverIdNumber
                }

                /**
                 * The name of the transfer recipient. This value is informational and not verified
                 * by Increase.
                 */
                fun receiverName(receiverName: String?) =
                    receiverName(JsonField.ofNullable(receiverName))

                /**
                 * Sets [Builder.receiverName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.receiverName] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun receiverName(receiverName: JsonField<String>) = apply {
                    this.receiverName = receiverName
                }

                /**
                 * A 15 digit number recorded in the Nacha file and available to both the
                 * originating and receiving bank. Along with the amount, date, and originating
                 * routing number, this can be used to identify the ACH transfer at either bank. ACH
                 * trace numbers are not unique, but are
                 * [used to correlate returns](https://increase.com/documentation/ach-returns#ach-returns).
                 */
                fun traceNumber(traceNumber: String) = traceNumber(JsonField.of(traceNumber))

                /**
                 * Sets [Builder.traceNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.traceNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun traceNumber(traceNumber: JsonField<String>) = apply {
                    this.traceNumber = traceNumber
                }

                /** The Inbound ACH Transfer's identifier. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundAchTransfer].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .addenda()
                 * .amount()
                 * .originatorCompanyDescriptiveDate()
                 * .originatorCompanyDiscretionaryData()
                 * .originatorCompanyEntryDescription()
                 * .originatorCompanyId()
                 * .originatorCompanyName()
                 * .receiverIdNumber()
                 * .receiverName()
                 * .traceNumber()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundAchTransfer =
                    InboundAchTransfer(
                        checkRequired("addenda", addenda),
                        checkRequired("amount", amount),
                        checkRequired(
                            "originatorCompanyDescriptiveDate",
                            originatorCompanyDescriptiveDate,
                        ),
                        checkRequired(
                            "originatorCompanyDiscretionaryData",
                            originatorCompanyDiscretionaryData,
                        ),
                        checkRequired(
                            "originatorCompanyEntryDescription",
                            originatorCompanyEntryDescription,
                        ),
                        checkRequired("originatorCompanyId", originatorCompanyId),
                        checkRequired("originatorCompanyName", originatorCompanyName),
                        checkRequired("receiverIdNumber", receiverIdNumber),
                        checkRequired("receiverName", receiverName),
                        checkRequired("traceNumber", traceNumber),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundAchTransfer = apply {
                if (validated) {
                    return@apply
                }

                addenda()?.validate()
                amount()
                originatorCompanyDescriptiveDate()
                originatorCompanyDiscretionaryData()
                originatorCompanyEntryDescription()
                originatorCompanyId()
                originatorCompanyName()
                receiverIdNumber()
                receiverName()
                traceNumber()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (addenda.asKnown()?.validity() ?: 0) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (if (originatorCompanyDescriptiveDate.asKnown() == null) 0 else 1) +
                    (if (originatorCompanyDiscretionaryData.asKnown() == null) 0 else 1) +
                    (if (originatorCompanyEntryDescription.asKnown() == null) 0 else 1) +
                    (if (originatorCompanyId.asKnown() == null) 0 else 1) +
                    (if (originatorCompanyName.asKnown() == null) 0 else 1) +
                    (if (receiverIdNumber.asKnown() == null) 0 else 1) +
                    (if (receiverName.asKnown() == null) 0 else 1) +
                    (if (traceNumber.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            /** Additional information sent from the originator. */
            class Addenda
            private constructor(
                private val category: JsonField<Category>,
                private val freeform: JsonField<Freeform>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("category")
                    @ExcludeMissing
                    category: JsonField<Category> = JsonMissing.of(),
                    @JsonProperty("freeform")
                    @ExcludeMissing
                    freeform: JsonField<Freeform> = JsonMissing.of(),
                ) : this(category, freeform, mutableMapOf())

                /**
                 * The type of addendum.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun category(): Category = category.getRequired("category")

                /**
                 * Unstructured `payment_related_information` passed through by the originator.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun freeform(): Freeform? = freeform.getNullable("freeform")

                /**
                 * Returns the raw JSON value of [category].
                 *
                 * Unlike [category], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("category")
                @ExcludeMissing
                fun _category(): JsonField<Category> = category

                /**
                 * Returns the raw JSON value of [freeform].
                 *
                 * Unlike [freeform], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("freeform")
                @ExcludeMissing
                fun _freeform(): JsonField<Freeform> = freeform

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Addenda].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .category()
                     * .freeform()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Addenda]. */
                class Builder internal constructor() {

                    private var category: JsonField<Category>? = null
                    private var freeform: JsonField<Freeform>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(addenda: Addenda) = apply {
                        category = addenda.category
                        freeform = addenda.freeform
                        additionalProperties = addenda.additionalProperties.toMutableMap()
                    }

                    /** The type of addendum. */
                    fun category(category: Category) = category(JsonField.of(category))

                    /**
                     * Sets [Builder.category] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.category] with a well-typed [Category] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun category(category: JsonField<Category>) = apply { this.category = category }

                    /**
                     * Unstructured `payment_related_information` passed through by the originator.
                     */
                    fun freeform(freeform: Freeform?) = freeform(JsonField.ofNullable(freeform))

                    /**
                     * Sets [Builder.freeform] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.freeform] with a well-typed [Freeform] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun freeform(freeform: JsonField<Freeform>) = apply { this.freeform = freeform }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Addenda].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .category()
                     * .freeform()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Addenda =
                        Addenda(
                            checkRequired("category", category),
                            checkRequired("freeform", freeform),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Addenda = apply {
                    if (validated) {
                        return@apply
                    }

                    category().validate()
                    freeform()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (category.asKnown()?.validity() ?: 0) + (freeform.asKnown()?.validity() ?: 0)

                /** The type of addendum. */
                class Category
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Unstructured addendum. */
                        val FREEFORM = of("freeform")

                        fun of(value: String) = Category(JsonField.of(value))
                    }

                    /** An enum containing [Category]'s known values. */
                    enum class Known {
                        /** Unstructured addendum. */
                        FREEFORM
                    }

                    /**
                     * An enum containing [Category]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [Category] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Unstructured addendum. */
                        FREEFORM,
                        /**
                         * An enum member indicating that [Category] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            FREEFORM -> Value.FREEFORM
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            FREEFORM -> Known.FREEFORM
                            else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Category = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Category && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /** Unstructured `payment_related_information` passed through by the originator. */
                class Freeform
                private constructor(
                    private val entries: JsonField<List<Entry>>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("entries")
                        @ExcludeMissing
                        entries: JsonField<List<Entry>> = JsonMissing.of()
                    ) : this(entries, mutableMapOf())

                    /**
                     * Each entry represents an addendum received from the originator.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun entries(): List<Entry> = entries.getRequired("entries")

                    /**
                     * Returns the raw JSON value of [entries].
                     *
                     * Unlike [entries], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("entries")
                    @ExcludeMissing
                    fun _entries(): JsonField<List<Entry>> = entries

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Freeform].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .entries()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Freeform]. */
                    class Builder internal constructor() {

                        private var entries: JsonField<MutableList<Entry>>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(freeform: Freeform) = apply {
                            entries = freeform.entries.map { it.toMutableList() }
                            additionalProperties = freeform.additionalProperties.toMutableMap()
                        }

                        /** Each entry represents an addendum received from the originator. */
                        fun entries(entries: List<Entry>) = entries(JsonField.of(entries))

                        /**
                         * Sets [Builder.entries] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.entries] with a well-typed `List<Entry>`
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun entries(entries: JsonField<List<Entry>>) = apply {
                            this.entries = entries.map { it.toMutableList() }
                        }

                        /**
                         * Adds a single [Entry] to [entries].
                         *
                         * @throws IllegalStateException if the field was previously set to a
                         *   non-list.
                         */
                        fun addEntry(entry: Entry) = apply {
                            entries =
                                (entries ?: JsonField.of(mutableListOf())).also {
                                    checkKnown("entries", it).add(entry)
                                }
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Freeform].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .entries()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Freeform =
                            Freeform(
                                checkRequired("entries", entries).map { it.toImmutable() },
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Freeform = apply {
                        if (validated) {
                            return@apply
                        }

                        entries().forEach { it.validate() }
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (entries.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

                    class Entry
                    private constructor(
                        private val paymentRelatedInformation: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("payment_related_information")
                            @ExcludeMissing
                            paymentRelatedInformation: JsonField<String> = JsonMissing.of()
                        ) : this(paymentRelatedInformation, mutableMapOf())

                        /**
                         * The payment related information passed in the addendum.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun paymentRelatedInformation(): String =
                            paymentRelatedInformation.getRequired("payment_related_information")

                        /**
                         * Returns the raw JSON value of [paymentRelatedInformation].
                         *
                         * Unlike [paymentRelatedInformation], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("payment_related_information")
                        @ExcludeMissing
                        fun _paymentRelatedInformation(): JsonField<String> =
                            paymentRelatedInformation

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Entry].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .paymentRelatedInformation()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Entry]. */
                        class Builder internal constructor() {

                            private var paymentRelatedInformation: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(entry: Entry) = apply {
                                paymentRelatedInformation = entry.paymentRelatedInformation
                                additionalProperties = entry.additionalProperties.toMutableMap()
                            }

                            /** The payment related information passed in the addendum. */
                            fun paymentRelatedInformation(paymentRelatedInformation: String) =
                                paymentRelatedInformation(JsonField.of(paymentRelatedInformation))

                            /**
                             * Sets [Builder.paymentRelatedInformation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.paymentRelatedInformation] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun paymentRelatedInformation(
                                paymentRelatedInformation: JsonField<String>
                            ) = apply { this.paymentRelatedInformation = paymentRelatedInformation }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Entry].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .paymentRelatedInformation()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Entry =
                                Entry(
                                    checkRequired(
                                        "paymentRelatedInformation",
                                        paymentRelatedInformation,
                                    ),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Entry = apply {
                            if (validated) {
                                return@apply
                            }

                            paymentRelatedInformation()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (paymentRelatedInformation.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Entry &&
                                paymentRelatedInformation == other.paymentRelatedInformation &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(paymentRelatedInformation, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Entry{paymentRelatedInformation=$paymentRelatedInformation, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Freeform &&
                            entries == other.entries &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(entries, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Freeform{entries=$entries, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Addenda &&
                        category == other.category &&
                        freeform == other.freeform &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(category, freeform, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Addenda{category=$category, freeform=$freeform, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundAchTransfer &&
                    addenda == other.addenda &&
                    amount == other.amount &&
                    originatorCompanyDescriptiveDate == other.originatorCompanyDescriptiveDate &&
                    originatorCompanyDiscretionaryData ==
                        other.originatorCompanyDiscretionaryData &&
                    originatorCompanyEntryDescription == other.originatorCompanyEntryDescription &&
                    originatorCompanyId == other.originatorCompanyId &&
                    originatorCompanyName == other.originatorCompanyName &&
                    receiverIdNumber == other.receiverIdNumber &&
                    receiverName == other.receiverName &&
                    traceNumber == other.traceNumber &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    addenda,
                    amount,
                    originatorCompanyDescriptiveDate,
                    originatorCompanyDiscretionaryData,
                    originatorCompanyEntryDescription,
                    originatorCompanyId,
                    originatorCompanyName,
                    receiverIdNumber,
                    receiverName,
                    traceNumber,
                    transferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundAchTransfer{addenda=$addenda, amount=$amount, originatorCompanyDescriptiveDate=$originatorCompanyDescriptiveDate, originatorCompanyDiscretionaryData=$originatorCompanyDiscretionaryData, originatorCompanyEntryDescription=$originatorCompanyEntryDescription, originatorCompanyId=$originatorCompanyId, originatorCompanyName=$originatorCompanyName, receiverIdNumber=$receiverIdNumber, receiverName=$receiverName, traceNumber=$traceNumber, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound ACH Transfer Return Intention object. This field will be present in the JSON
         * response if and only if `category` is equal to `inbound_ach_transfer_return_intention`.
         * An Inbound ACH Transfer Return Intention is created when an ACH transfer is initiated at
         * another bank and returned by Increase.
         */
        class InboundAchTransferReturnIntention
        private constructor(
            private val inboundAchTransferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("inbound_ach_transfer_id")
                @ExcludeMissing
                inboundAchTransferId: JsonField<String> = JsonMissing.of()
            ) : this(inboundAchTransferId, mutableMapOf())

            /**
             * The ID of the Inbound ACH Transfer that is being returned.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun inboundAchTransferId(): String =
                inboundAchTransferId.getRequired("inbound_ach_transfer_id")

            /**
             * Returns the raw JSON value of [inboundAchTransferId].
             *
             * Unlike [inboundAchTransferId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("inbound_ach_transfer_id")
            @ExcludeMissing
            fun _inboundAchTransferId(): JsonField<String> = inboundAchTransferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InboundAchTransferReturnIntention].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .inboundAchTransferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundAchTransferReturnIntention]. */
            class Builder internal constructor() {

                private var inboundAchTransferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    inboundAchTransferReturnIntention: InboundAchTransferReturnIntention
                ) = apply {
                    inboundAchTransferId = inboundAchTransferReturnIntention.inboundAchTransferId
                    additionalProperties =
                        inboundAchTransferReturnIntention.additionalProperties.toMutableMap()
                }

                /** The ID of the Inbound ACH Transfer that is being returned. */
                fun inboundAchTransferId(inboundAchTransferId: String) =
                    inboundAchTransferId(JsonField.of(inboundAchTransferId))

                /**
                 * Sets [Builder.inboundAchTransferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inboundAchTransferId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun inboundAchTransferId(inboundAchTransferId: JsonField<String>) = apply {
                    this.inboundAchTransferId = inboundAchTransferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundAchTransferReturnIntention].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .inboundAchTransferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundAchTransferReturnIntention =
                    InboundAchTransferReturnIntention(
                        checkRequired("inboundAchTransferId", inboundAchTransferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundAchTransferReturnIntention = apply {
                if (validated) {
                    return@apply
                }

                inboundAchTransferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (inboundAchTransferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundAchTransferReturnIntention &&
                    inboundAchTransferId == other.inboundAchTransferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(inboundAchTransferId, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundAchTransferReturnIntention{inboundAchTransferId=$inboundAchTransferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound Check Adjustment object. This field will be present in the JSON response if
         * and only if `category` is equal to `inbound_check_adjustment`. An Inbound Check
         * Adjustment is created when Increase receives an adjustment for a check or return
         * deposited through Check21.
         */
        class InboundCheckAdjustment
        private constructor(
            private val adjustedTransactionId: JsonField<String>,
            private val amount: JsonField<Long>,
            private val reason: JsonField<Reason>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("adjusted_transaction_id")
                @ExcludeMissing
                adjustedTransactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("reason") @ExcludeMissing reason: JsonField<Reason> = JsonMissing.of(),
            ) : this(adjustedTransactionId, amount, reason, mutableMapOf())

            /**
             * The ID of the transaction that was adjusted.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun adjustedTransactionId(): String =
                adjustedTransactionId.getRequired("adjusted_transaction_id")

            /**
             * The amount of the check adjustment.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The reason for the adjustment.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun reason(): Reason = reason.getRequired("reason")

            /**
             * Returns the raw JSON value of [adjustedTransactionId].
             *
             * Unlike [adjustedTransactionId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("adjusted_transaction_id")
            @ExcludeMissing
            fun _adjustedTransactionId(): JsonField<String> = adjustedTransactionId

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [reason].
             *
             * Unlike [reason], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<Reason> = reason

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InboundCheckAdjustment].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .adjustedTransactionId()
                 * .amount()
                 * .reason()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundCheckAdjustment]. */
            class Builder internal constructor() {

                private var adjustedTransactionId: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var reason: JsonField<Reason>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(inboundCheckAdjustment: InboundCheckAdjustment) = apply {
                    adjustedTransactionId = inboundCheckAdjustment.adjustedTransactionId
                    amount = inboundCheckAdjustment.amount
                    reason = inboundCheckAdjustment.reason
                    additionalProperties =
                        inboundCheckAdjustment.additionalProperties.toMutableMap()
                }

                /** The ID of the transaction that was adjusted. */
                fun adjustedTransactionId(adjustedTransactionId: String) =
                    adjustedTransactionId(JsonField.of(adjustedTransactionId))

                /**
                 * Sets [Builder.adjustedTransactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.adjustedTransactionId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun adjustedTransactionId(adjustedTransactionId: JsonField<String>) = apply {
                    this.adjustedTransactionId = adjustedTransactionId
                }

                /** The amount of the check adjustment. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The reason for the adjustment. */
                fun reason(reason: Reason) = reason(JsonField.of(reason))

                /**
                 * Sets [Builder.reason] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.reason] with a well-typed [Reason] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundCheckAdjustment].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .adjustedTransactionId()
                 * .amount()
                 * .reason()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundCheckAdjustment =
                    InboundCheckAdjustment(
                        checkRequired("adjustedTransactionId", adjustedTransactionId),
                        checkRequired("amount", amount),
                        checkRequired("reason", reason),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundCheckAdjustment = apply {
                if (validated) {
                    return@apply
                }

                adjustedTransactionId()
                amount()
                reason().validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (adjustedTransactionId.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (reason.asKnown()?.validity() ?: 0)

            /** The reason for the adjustment. */
            class Reason @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /**
                     * The return was initiated too late and the receiving institution has responded
                     * with a Late Return Claim.
                     */
                    val LATE_RETURN = of("late_return")

                    /**
                     * The check was deposited to the wrong payee and the depositing institution has
                     * reimbursed the funds with a Wrong Payee Credit.
                     */
                    val WRONG_PAYEE_CREDIT = of("wrong_payee_credit")

                    /**
                     * The check was deposited with a different amount than what was written on the
                     * check.
                     */
                    val ADJUSTED_AMOUNT = of("adjusted_amount")

                    /**
                     * The recipient was not able to process the check. This usually happens for
                     * e.g., low quality images.
                     */
                    val NON_CONFORMING_ITEM = of("non_conforming_item")

                    fun of(value: String) = Reason(JsonField.of(value))
                }

                /** An enum containing [Reason]'s known values. */
                enum class Known {
                    /**
                     * The return was initiated too late and the receiving institution has responded
                     * with a Late Return Claim.
                     */
                    LATE_RETURN,
                    /**
                     * The check was deposited to the wrong payee and the depositing institution has
                     * reimbursed the funds with a Wrong Payee Credit.
                     */
                    WRONG_PAYEE_CREDIT,
                    /**
                     * The check was deposited with a different amount than what was written on the
                     * check.
                     */
                    ADJUSTED_AMOUNT,
                    /**
                     * The recipient was not able to process the check. This usually happens for
                     * e.g., low quality images.
                     */
                    NON_CONFORMING_ITEM,
                }

                /**
                 * An enum containing [Reason]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Reason] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /**
                     * The return was initiated too late and the receiving institution has responded
                     * with a Late Return Claim.
                     */
                    LATE_RETURN,
                    /**
                     * The check was deposited to the wrong payee and the depositing institution has
                     * reimbursed the funds with a Wrong Payee Credit.
                     */
                    WRONG_PAYEE_CREDIT,
                    /**
                     * The check was deposited with a different amount than what was written on the
                     * check.
                     */
                    ADJUSTED_AMOUNT,
                    /**
                     * The recipient was not able to process the check. This usually happens for
                     * e.g., low quality images.
                     */
                    NON_CONFORMING_ITEM,
                    /**
                     * An enum member indicating that [Reason] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        LATE_RETURN -> Value.LATE_RETURN
                        WRONG_PAYEE_CREDIT -> Value.WRONG_PAYEE_CREDIT
                        ADJUSTED_AMOUNT -> Value.ADJUSTED_AMOUNT
                        NON_CONFORMING_ITEM -> Value.NON_CONFORMING_ITEM
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        LATE_RETURN -> Known.LATE_RETURN
                        WRONG_PAYEE_CREDIT -> Known.WRONG_PAYEE_CREDIT
                        ADJUSTED_AMOUNT -> Known.ADJUSTED_AMOUNT
                        NON_CONFORMING_ITEM -> Known.NON_CONFORMING_ITEM
                        else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Reason = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Reason && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundCheckAdjustment &&
                    adjustedTransactionId == other.adjustedTransactionId &&
                    amount == other.amount &&
                    reason == other.reason &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(adjustedTransactionId, amount, reason, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundCheckAdjustment{adjustedTransactionId=$adjustedTransactionId, amount=$amount, reason=$reason, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound Check Deposit Return Intention object. This field will be present in the JSON
         * response if and only if `category` is equal to `inbound_check_deposit_return_intention`.
         * An Inbound Check Deposit Return Intention is created when Increase receives an Inbound
         * Check and the User requests that it be returned.
         */
        class InboundCheckDepositReturnIntention
        private constructor(
            private val inboundCheckDepositId: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("inbound_check_deposit_id")
                @ExcludeMissing
                inboundCheckDepositId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(inboundCheckDepositId, transferId, mutableMapOf())

            /**
             * The ID of the Inbound Check Deposit that is being returned.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun inboundCheckDepositId(): String =
                inboundCheckDepositId.getRequired("inbound_check_deposit_id")

            /**
             * The identifier of the Check Transfer object that was deposited.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun transferId(): String? = transferId.getNullable("transfer_id")

            /**
             * Returns the raw JSON value of [inboundCheckDepositId].
             *
             * Unlike [inboundCheckDepositId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("inbound_check_deposit_id")
            @ExcludeMissing
            fun _inboundCheckDepositId(): JsonField<String> = inboundCheckDepositId

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InboundCheckDepositReturnIntention].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .inboundCheckDepositId()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundCheckDepositReturnIntention]. */
            class Builder internal constructor() {

                private var inboundCheckDepositId: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    inboundCheckDepositReturnIntention: InboundCheckDepositReturnIntention
                ) = apply {
                    inboundCheckDepositId = inboundCheckDepositReturnIntention.inboundCheckDepositId
                    transferId = inboundCheckDepositReturnIntention.transferId
                    additionalProperties =
                        inboundCheckDepositReturnIntention.additionalProperties.toMutableMap()
                }

                /** The ID of the Inbound Check Deposit that is being returned. */
                fun inboundCheckDepositId(inboundCheckDepositId: String) =
                    inboundCheckDepositId(JsonField.of(inboundCheckDepositId))

                /**
                 * Sets [Builder.inboundCheckDepositId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inboundCheckDepositId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun inboundCheckDepositId(inboundCheckDepositId: JsonField<String>) = apply {
                    this.inboundCheckDepositId = inboundCheckDepositId
                }

                /** The identifier of the Check Transfer object that was deposited. */
                fun transferId(transferId: String?) = transferId(JsonField.ofNullable(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundCheckDepositReturnIntention].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .inboundCheckDepositId()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundCheckDepositReturnIntention =
                    InboundCheckDepositReturnIntention(
                        checkRequired("inboundCheckDepositId", inboundCheckDepositId),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundCheckDepositReturnIntention = apply {
                if (validated) {
                    return@apply
                }

                inboundCheckDepositId()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (inboundCheckDepositId.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundCheckDepositReturnIntention &&
                    inboundCheckDepositId == other.inboundCheckDepositId &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(inboundCheckDepositId, transferId, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundCheckDepositReturnIntention{inboundCheckDepositId=$inboundCheckDepositId, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound Real-Time Payments Transfer Confirmation object. This field will be present in
         * the JSON response if and only if `category` is equal to
         * `inbound_real_time_payments_transfer_confirmation`. An Inbound Real-Time Payments
         * Transfer Confirmation is created when a Real-Time Payments transfer is initiated at
         * another bank and received by Increase.
         */
        class InboundRealTimePaymentsTransferConfirmation
        private constructor(
            private val amount: JsonField<Long>,
            private val creditorName: JsonField<String>,
            private val currency: JsonField<Currency>,
            private val debtorAccountNumber: JsonField<String>,
            private val debtorName: JsonField<String>,
            private val debtorRoutingNumber: JsonField<String>,
            private val remittanceInformation: JsonField<String>,
            private val transactionIdentification: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("creditor_name")
                @ExcludeMissing
                creditorName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("debtor_account_number")
                @ExcludeMissing
                debtorAccountNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("debtor_name")
                @ExcludeMissing
                debtorName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("debtor_routing_number")
                @ExcludeMissing
                debtorRoutingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("remittance_information")
                @ExcludeMissing
                remittanceInformation: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transaction_identification")
                @ExcludeMissing
                transactionIdentification: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                amount,
                creditorName,
                currency,
                debtorAccountNumber,
                debtorName,
                debtorRoutingNumber,
                remittanceInformation,
                transactionIdentification,
                transferId,
                mutableMapOf(),
            )

            /**
             * The amount in the minor unit of the transfer's currency. For dollars, for example,
             * this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The name the sender of the transfer specified as the recipient of the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun creditorName(): String = creditorName.getRequired("creditor_name")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code of the transfer's
             * currency. This will always be "USD" for a Real-Time Payments transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * The account number of the account that sent the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun debtorAccountNumber(): String =
                debtorAccountNumber.getRequired("debtor_account_number")

            /**
             * The name provided by the sender of the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun debtorName(): String = debtorName.getRequired("debtor_name")

            /**
             * The routing number of the account that sent the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun debtorRoutingNumber(): String =
                debtorRoutingNumber.getRequired("debtor_routing_number")

            /**
             * Additional information included with the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun remittanceInformation(): String? =
                remittanceInformation.getNullable("remittance_information")

            /**
             * The Real-Time Payments network identification of the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionIdentification(): String =
                transactionIdentification.getRequired("transaction_identification")

            /**
             * The identifier of the Real-Time Payments Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [creditorName].
             *
             * Unlike [creditorName], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("creditor_name")
            @ExcludeMissing
            fun _creditorName(): JsonField<String> = creditorName

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [debtorAccountNumber].
             *
             * Unlike [debtorAccountNumber], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("debtor_account_number")
            @ExcludeMissing
            fun _debtorAccountNumber(): JsonField<String> = debtorAccountNumber

            /**
             * Returns the raw JSON value of [debtorName].
             *
             * Unlike [debtorName], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("debtor_name")
            @ExcludeMissing
            fun _debtorName(): JsonField<String> = debtorName

            /**
             * Returns the raw JSON value of [debtorRoutingNumber].
             *
             * Unlike [debtorRoutingNumber], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("debtor_routing_number")
            @ExcludeMissing
            fun _debtorRoutingNumber(): JsonField<String> = debtorRoutingNumber

            /**
             * Returns the raw JSON value of [remittanceInformation].
             *
             * Unlike [remittanceInformation], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("remittance_information")
            @ExcludeMissing
            fun _remittanceInformation(): JsonField<String> = remittanceInformation

            /**
             * Returns the raw JSON value of [transactionIdentification].
             *
             * Unlike [transactionIdentification], this method doesn't throw if the JSON field has
             * an unexpected type.
             */
            @JsonProperty("transaction_identification")
            @ExcludeMissing
            fun _transactionIdentification(): JsonField<String> = transactionIdentification

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InboundRealTimePaymentsTransferConfirmation].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .creditorName()
                 * .currency()
                 * .debtorAccountNumber()
                 * .debtorName()
                 * .debtorRoutingNumber()
                 * .remittanceInformation()
                 * .transactionIdentification()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundRealTimePaymentsTransferConfirmation]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var creditorName: JsonField<String>? = null
                private var currency: JsonField<Currency>? = null
                private var debtorAccountNumber: JsonField<String>? = null
                private var debtorName: JsonField<String>? = null
                private var debtorRoutingNumber: JsonField<String>? = null
                private var remittanceInformation: JsonField<String>? = null
                private var transactionIdentification: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    inboundRealTimePaymentsTransferConfirmation:
                        InboundRealTimePaymentsTransferConfirmation
                ) = apply {
                    amount = inboundRealTimePaymentsTransferConfirmation.amount
                    creditorName = inboundRealTimePaymentsTransferConfirmation.creditorName
                    currency = inboundRealTimePaymentsTransferConfirmation.currency
                    debtorAccountNumber =
                        inboundRealTimePaymentsTransferConfirmation.debtorAccountNumber
                    debtorName = inboundRealTimePaymentsTransferConfirmation.debtorName
                    debtorRoutingNumber =
                        inboundRealTimePaymentsTransferConfirmation.debtorRoutingNumber
                    remittanceInformation =
                        inboundRealTimePaymentsTransferConfirmation.remittanceInformation
                    transactionIdentification =
                        inboundRealTimePaymentsTransferConfirmation.transactionIdentification
                    transferId = inboundRealTimePaymentsTransferConfirmation.transferId
                    additionalProperties =
                        inboundRealTimePaymentsTransferConfirmation.additionalProperties
                            .toMutableMap()
                }

                /**
                 * The amount in the minor unit of the transfer's currency. For dollars, for
                 * example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The name the sender of the transfer specified as the recipient of the transfer.
                 */
                fun creditorName(creditorName: String) = creditorName(JsonField.of(creditorName))

                /**
                 * Sets [Builder.creditorName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.creditorName] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun creditorName(creditorName: JsonField<String>) = apply {
                    this.creditorName = creditorName
                }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code of the transfer's
                 * currency. This will always be "USD" for a Real-Time Payments transfer.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** The account number of the account that sent the transfer. */
                fun debtorAccountNumber(debtorAccountNumber: String) =
                    debtorAccountNumber(JsonField.of(debtorAccountNumber))

                /**
                 * Sets [Builder.debtorAccountNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorAccountNumber] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun debtorAccountNumber(debtorAccountNumber: JsonField<String>) = apply {
                    this.debtorAccountNumber = debtorAccountNumber
                }

                /** The name provided by the sender of the transfer. */
                fun debtorName(debtorName: String) = debtorName(JsonField.of(debtorName))

                /**
                 * Sets [Builder.debtorName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorName] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun debtorName(debtorName: JsonField<String>) = apply {
                    this.debtorName = debtorName
                }

                /** The routing number of the account that sent the transfer. */
                fun debtorRoutingNumber(debtorRoutingNumber: String) =
                    debtorRoutingNumber(JsonField.of(debtorRoutingNumber))

                /**
                 * Sets [Builder.debtorRoutingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorRoutingNumber] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun debtorRoutingNumber(debtorRoutingNumber: JsonField<String>) = apply {
                    this.debtorRoutingNumber = debtorRoutingNumber
                }

                /** Additional information included with the transfer. */
                fun remittanceInformation(remittanceInformation: String?) =
                    remittanceInformation(JsonField.ofNullable(remittanceInformation))

                /**
                 * Sets [Builder.remittanceInformation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.remittanceInformation] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun remittanceInformation(remittanceInformation: JsonField<String>) = apply {
                    this.remittanceInformation = remittanceInformation
                }

                /** The Real-Time Payments network identification of the transfer. */
                fun transactionIdentification(transactionIdentification: String) =
                    transactionIdentification(JsonField.of(transactionIdentification))

                /**
                 * Sets [Builder.transactionIdentification] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionIdentification] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun transactionIdentification(transactionIdentification: JsonField<String>) =
                    apply {
                        this.transactionIdentification = transactionIdentification
                    }

                /**
                 * The identifier of the Real-Time Payments Transfer that led to this Transaction.
                 */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundRealTimePaymentsTransferConfirmation].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .creditorName()
                 * .currency()
                 * .debtorAccountNumber()
                 * .debtorName()
                 * .debtorRoutingNumber()
                 * .remittanceInformation()
                 * .transactionIdentification()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundRealTimePaymentsTransferConfirmation =
                    InboundRealTimePaymentsTransferConfirmation(
                        checkRequired("amount", amount),
                        checkRequired("creditorName", creditorName),
                        checkRequired("currency", currency),
                        checkRequired("debtorAccountNumber", debtorAccountNumber),
                        checkRequired("debtorName", debtorName),
                        checkRequired("debtorRoutingNumber", debtorRoutingNumber),
                        checkRequired("remittanceInformation", remittanceInformation),
                        checkRequired("transactionIdentification", transactionIdentification),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundRealTimePaymentsTransferConfirmation = apply {
                if (validated) {
                    return@apply
                }

                amount()
                creditorName()
                currency().validate()
                debtorAccountNumber()
                debtorName()
                debtorRoutingNumber()
                remittanceInformation()
                transactionIdentification()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (if (creditorName.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (if (debtorAccountNumber.asKnown() == null) 0 else 1) +
                    (if (debtorName.asKnown() == null) 0 else 1) +
                    (if (debtorRoutingNumber.asKnown() == null) 0 else 1) +
                    (if (remittanceInformation.asKnown() == null) 0 else 1) +
                    (if (transactionIdentification.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code of the transfer's
             * currency. This will always be "USD" for a Real-Time Payments transfer.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundRealTimePaymentsTransferConfirmation &&
                    amount == other.amount &&
                    creditorName == other.creditorName &&
                    currency == other.currency &&
                    debtorAccountNumber == other.debtorAccountNumber &&
                    debtorName == other.debtorName &&
                    debtorRoutingNumber == other.debtorRoutingNumber &&
                    remittanceInformation == other.remittanceInformation &&
                    transactionIdentification == other.transactionIdentification &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    creditorName,
                    currency,
                    debtorAccountNumber,
                    debtorName,
                    debtorRoutingNumber,
                    remittanceInformation,
                    transactionIdentification,
                    transferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundRealTimePaymentsTransferConfirmation{amount=$amount, creditorName=$creditorName, currency=$currency, debtorAccountNumber=$debtorAccountNumber, debtorName=$debtorName, debtorRoutingNumber=$debtorRoutingNumber, remittanceInformation=$remittanceInformation, transactionIdentification=$transactionIdentification, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound Wire Reversal object. This field will be present in the JSON response if and
         * only if `category` is equal to `inbound_wire_reversal`. An Inbound Wire Reversal
         * represents a reversal of a wire transfer that was initiated via Increase. The other bank
         * is sending the money back. This most often happens when the original destination account
         * details were incorrect.
         */
        class InboundWireReversal
        private constructor(
            private val amount: JsonField<Long>,
            private val createdAt: JsonField<OffsetDateTime>,
            private val debtorRoutingNumber: JsonField<String>,
            private val description: JsonField<String>,
            private val inputCycleDate: JsonField<LocalDate>,
            private val inputMessageAccountabilityData: JsonField<String>,
            private val inputSequenceNumber: JsonField<String>,
            private val inputSource: JsonField<String>,
            private val instructionIdentification: JsonField<String>,
            private val returnReasonAdditionalInformation: JsonField<String>,
            private val transactionId: JsonField<String>,
            private val wireTransferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("created_at")
                @ExcludeMissing
                createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("debtor_routing_number")
                @ExcludeMissing
                debtorRoutingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("description")
                @ExcludeMissing
                description: JsonField<String> = JsonMissing.of(),
                @JsonProperty("input_cycle_date")
                @ExcludeMissing
                inputCycleDate: JsonField<LocalDate> = JsonMissing.of(),
                @JsonProperty("input_message_accountability_data")
                @ExcludeMissing
                inputMessageAccountabilityData: JsonField<String> = JsonMissing.of(),
                @JsonProperty("input_sequence_number")
                @ExcludeMissing
                inputSequenceNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("input_source")
                @ExcludeMissing
                inputSource: JsonField<String> = JsonMissing.of(),
                @JsonProperty("instruction_identification")
                @ExcludeMissing
                instructionIdentification: JsonField<String> = JsonMissing.of(),
                @JsonProperty("return_reason_additional_information")
                @ExcludeMissing
                returnReasonAdditionalInformation: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transaction_id")
                @ExcludeMissing
                transactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("wire_transfer_id")
                @ExcludeMissing
                wireTransferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                amount,
                createdAt,
                debtorRoutingNumber,
                description,
                inputCycleDate,
                inputMessageAccountabilityData,
                inputSequenceNumber,
                inputSource,
                instructionIdentification,
                returnReasonAdditionalInformation,
                transactionId,
                wireTransferId,
                mutableMapOf(),
            )

            /**
             * The amount that was reversed in USD cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * reversal was created.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

            /**
             * The debtor's routing number.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun debtorRoutingNumber(): String? =
                debtorRoutingNumber.getNullable("debtor_routing_number")

            /**
             * The description on the reversal message from Fedwire, set by the reversing bank.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun description(): String = description.getRequired("description")

            /**
             * The Fedwire cycle date for the wire reversal. The "Fedwire day" begins at 9:00 PM
             * Eastern Time on the evening before the `cycle date`.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun inputCycleDate(): LocalDate = inputCycleDate.getRequired("input_cycle_date")

            /**
             * The Fedwire transaction identifier.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun inputMessageAccountabilityData(): String =
                inputMessageAccountabilityData.getRequired("input_message_accountability_data")

            /**
             * The Fedwire sequence number.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun inputSequenceNumber(): String =
                inputSequenceNumber.getRequired("input_sequence_number")

            /**
             * The Fedwire input source identifier.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun inputSource(): String = inputSource.getRequired("input_source")

            /**
             * The sending bank's identifier for the reversal.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun instructionIdentification(): String? =
                instructionIdentification.getNullable("instruction_identification")

            /**
             * Additional information about the reason for the reversal.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun returnReasonAdditionalInformation(): String? =
                returnReasonAdditionalInformation.getNullable(
                    "return_reason_additional_information"
                )

            /**
             * The ID for the Transaction associated with the transfer reversal.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transactionId(): String = transactionId.getRequired("transaction_id")

            /**
             * The ID for the Wire Transfer that is being reversed.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun wireTransferId(): String = wireTransferId.getRequired("wire_transfer_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [createdAt].
             *
             * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("created_at")
            @ExcludeMissing
            fun _createdAt(): JsonField<OffsetDateTime> = createdAt

            /**
             * Returns the raw JSON value of [debtorRoutingNumber].
             *
             * Unlike [debtorRoutingNumber], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("debtor_routing_number")
            @ExcludeMissing
            fun _debtorRoutingNumber(): JsonField<String> = debtorRoutingNumber

            /**
             * Returns the raw JSON value of [description].
             *
             * Unlike [description], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("description")
            @ExcludeMissing
            fun _description(): JsonField<String> = description

            /**
             * Returns the raw JSON value of [inputCycleDate].
             *
             * Unlike [inputCycleDate], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("input_cycle_date")
            @ExcludeMissing
            fun _inputCycleDate(): JsonField<LocalDate> = inputCycleDate

            /**
             * Returns the raw JSON value of [inputMessageAccountabilityData].
             *
             * Unlike [inputMessageAccountabilityData], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("input_message_accountability_data")
            @ExcludeMissing
            fun _inputMessageAccountabilityData(): JsonField<String> =
                inputMessageAccountabilityData

            /**
             * Returns the raw JSON value of [inputSequenceNumber].
             *
             * Unlike [inputSequenceNumber], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("input_sequence_number")
            @ExcludeMissing
            fun _inputSequenceNumber(): JsonField<String> = inputSequenceNumber

            /**
             * Returns the raw JSON value of [inputSource].
             *
             * Unlike [inputSource], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("input_source")
            @ExcludeMissing
            fun _inputSource(): JsonField<String> = inputSource

            /**
             * Returns the raw JSON value of [instructionIdentification].
             *
             * Unlike [instructionIdentification], this method doesn't throw if the JSON field has
             * an unexpected type.
             */
            @JsonProperty("instruction_identification")
            @ExcludeMissing
            fun _instructionIdentification(): JsonField<String> = instructionIdentification

            /**
             * Returns the raw JSON value of [returnReasonAdditionalInformation].
             *
             * Unlike [returnReasonAdditionalInformation], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("return_reason_additional_information")
            @ExcludeMissing
            fun _returnReasonAdditionalInformation(): JsonField<String> =
                returnReasonAdditionalInformation

            /**
             * Returns the raw JSON value of [transactionId].
             *
             * Unlike [transactionId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transaction_id")
            @ExcludeMissing
            fun _transactionId(): JsonField<String> = transactionId

            /**
             * Returns the raw JSON value of [wireTransferId].
             *
             * Unlike [wireTransferId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("wire_transfer_id")
            @ExcludeMissing
            fun _wireTransferId(): JsonField<String> = wireTransferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [InboundWireReversal].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .createdAt()
                 * .debtorRoutingNumber()
                 * .description()
                 * .inputCycleDate()
                 * .inputMessageAccountabilityData()
                 * .inputSequenceNumber()
                 * .inputSource()
                 * .instructionIdentification()
                 * .returnReasonAdditionalInformation()
                 * .transactionId()
                 * .wireTransferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundWireReversal]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var createdAt: JsonField<OffsetDateTime>? = null
                private var debtorRoutingNumber: JsonField<String>? = null
                private var description: JsonField<String>? = null
                private var inputCycleDate: JsonField<LocalDate>? = null
                private var inputMessageAccountabilityData: JsonField<String>? = null
                private var inputSequenceNumber: JsonField<String>? = null
                private var inputSource: JsonField<String>? = null
                private var instructionIdentification: JsonField<String>? = null
                private var returnReasonAdditionalInformation: JsonField<String>? = null
                private var transactionId: JsonField<String>? = null
                private var wireTransferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(inboundWireReversal: InboundWireReversal) = apply {
                    amount = inboundWireReversal.amount
                    createdAt = inboundWireReversal.createdAt
                    debtorRoutingNumber = inboundWireReversal.debtorRoutingNumber
                    description = inboundWireReversal.description
                    inputCycleDate = inboundWireReversal.inputCycleDate
                    inputMessageAccountabilityData =
                        inboundWireReversal.inputMessageAccountabilityData
                    inputSequenceNumber = inboundWireReversal.inputSequenceNumber
                    inputSource = inboundWireReversal.inputSource
                    instructionIdentification = inboundWireReversal.instructionIdentification
                    returnReasonAdditionalInformation =
                        inboundWireReversal.returnReasonAdditionalInformation
                    transactionId = inboundWireReversal.transactionId
                    wireTransferId = inboundWireReversal.wireTransferId
                    additionalProperties = inboundWireReversal.additionalProperties.toMutableMap()
                }

                /** The amount that was reversed in USD cents. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * reversal was created.
                 */
                fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

                /**
                 * Sets [Builder.createdAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                    this.createdAt = createdAt
                }

                /** The debtor's routing number. */
                fun debtorRoutingNumber(debtorRoutingNumber: String?) =
                    debtorRoutingNumber(JsonField.ofNullable(debtorRoutingNumber))

                /**
                 * Sets [Builder.debtorRoutingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorRoutingNumber] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun debtorRoutingNumber(debtorRoutingNumber: JsonField<String>) = apply {
                    this.debtorRoutingNumber = debtorRoutingNumber
                }

                /**
                 * The description on the reversal message from Fedwire, set by the reversing bank.
                 */
                fun description(description: String) = description(JsonField.of(description))

                /**
                 * Sets [Builder.description] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.description] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun description(description: JsonField<String>) = apply {
                    this.description = description
                }

                /**
                 * The Fedwire cycle date for the wire reversal. The "Fedwire day" begins at 9:00 PM
                 * Eastern Time on the evening before the `cycle date`.
                 */
                fun inputCycleDate(inputCycleDate: LocalDate) =
                    inputCycleDate(JsonField.of(inputCycleDate))

                /**
                 * Sets [Builder.inputCycleDate] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inputCycleDate] with a well-typed [LocalDate]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun inputCycleDate(inputCycleDate: JsonField<LocalDate>) = apply {
                    this.inputCycleDate = inputCycleDate
                }

                /** The Fedwire transaction identifier. */
                fun inputMessageAccountabilityData(inputMessageAccountabilityData: String) =
                    inputMessageAccountabilityData(JsonField.of(inputMessageAccountabilityData))

                /**
                 * Sets [Builder.inputMessageAccountabilityData] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inputMessageAccountabilityData] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun inputMessageAccountabilityData(
                    inputMessageAccountabilityData: JsonField<String>
                ) = apply { this.inputMessageAccountabilityData = inputMessageAccountabilityData }

                /** The Fedwire sequence number. */
                fun inputSequenceNumber(inputSequenceNumber: String) =
                    inputSequenceNumber(JsonField.of(inputSequenceNumber))

                /**
                 * Sets [Builder.inputSequenceNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inputSequenceNumber] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun inputSequenceNumber(inputSequenceNumber: JsonField<String>) = apply {
                    this.inputSequenceNumber = inputSequenceNumber
                }

                /** The Fedwire input source identifier. */
                fun inputSource(inputSource: String) = inputSource(JsonField.of(inputSource))

                /**
                 * Sets [Builder.inputSource] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inputSource] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun inputSource(inputSource: JsonField<String>) = apply {
                    this.inputSource = inputSource
                }

                /** The sending bank's identifier for the reversal. */
                fun instructionIdentification(instructionIdentification: String?) =
                    instructionIdentification(JsonField.ofNullable(instructionIdentification))

                /**
                 * Sets [Builder.instructionIdentification] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.instructionIdentification] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun instructionIdentification(instructionIdentification: JsonField<String>) =
                    apply {
                        this.instructionIdentification = instructionIdentification
                    }

                /** Additional information about the reason for the reversal. */
                fun returnReasonAdditionalInformation(returnReasonAdditionalInformation: String?) =
                    returnReasonAdditionalInformation(
                        JsonField.ofNullable(returnReasonAdditionalInformation)
                    )

                /**
                 * Sets [Builder.returnReasonAdditionalInformation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.returnReasonAdditionalInformation] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun returnReasonAdditionalInformation(
                    returnReasonAdditionalInformation: JsonField<String>
                ) = apply {
                    this.returnReasonAdditionalInformation = returnReasonAdditionalInformation
                }

                /** The ID for the Transaction associated with the transfer reversal. */
                fun transactionId(transactionId: String) =
                    transactionId(JsonField.of(transactionId))

                /**
                 * Sets [Builder.transactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transactionId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transactionId(transactionId: JsonField<String>) = apply {
                    this.transactionId = transactionId
                }

                /** The ID for the Wire Transfer that is being reversed. */
                fun wireTransferId(wireTransferId: String) =
                    wireTransferId(JsonField.of(wireTransferId))

                /**
                 * Sets [Builder.wireTransferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.wireTransferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun wireTransferId(wireTransferId: JsonField<String>) = apply {
                    this.wireTransferId = wireTransferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundWireReversal].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .createdAt()
                 * .debtorRoutingNumber()
                 * .description()
                 * .inputCycleDate()
                 * .inputMessageAccountabilityData()
                 * .inputSequenceNumber()
                 * .inputSource()
                 * .instructionIdentification()
                 * .returnReasonAdditionalInformation()
                 * .transactionId()
                 * .wireTransferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundWireReversal =
                    InboundWireReversal(
                        checkRequired("amount", amount),
                        checkRequired("createdAt", createdAt),
                        checkRequired("debtorRoutingNumber", debtorRoutingNumber),
                        checkRequired("description", description),
                        checkRequired("inputCycleDate", inputCycleDate),
                        checkRequired(
                            "inputMessageAccountabilityData",
                            inputMessageAccountabilityData,
                        ),
                        checkRequired("inputSequenceNumber", inputSequenceNumber),
                        checkRequired("inputSource", inputSource),
                        checkRequired("instructionIdentification", instructionIdentification),
                        checkRequired(
                            "returnReasonAdditionalInformation",
                            returnReasonAdditionalInformation,
                        ),
                        checkRequired("transactionId", transactionId),
                        checkRequired("wireTransferId", wireTransferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundWireReversal = apply {
                if (validated) {
                    return@apply
                }

                amount()
                createdAt()
                debtorRoutingNumber()
                description()
                inputCycleDate()
                inputMessageAccountabilityData()
                inputSequenceNumber()
                inputSource()
                instructionIdentification()
                returnReasonAdditionalInformation()
                transactionId()
                wireTransferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (if (createdAt.asKnown() == null) 0 else 1) +
                    (if (debtorRoutingNumber.asKnown() == null) 0 else 1) +
                    (if (description.asKnown() == null) 0 else 1) +
                    (if (inputCycleDate.asKnown() == null) 0 else 1) +
                    (if (inputMessageAccountabilityData.asKnown() == null) 0 else 1) +
                    (if (inputSequenceNumber.asKnown() == null) 0 else 1) +
                    (if (inputSource.asKnown() == null) 0 else 1) +
                    (if (instructionIdentification.asKnown() == null) 0 else 1) +
                    (if (returnReasonAdditionalInformation.asKnown() == null) 0 else 1) +
                    (if (transactionId.asKnown() == null) 0 else 1) +
                    (if (wireTransferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundWireReversal &&
                    amount == other.amount &&
                    createdAt == other.createdAt &&
                    debtorRoutingNumber == other.debtorRoutingNumber &&
                    description == other.description &&
                    inputCycleDate == other.inputCycleDate &&
                    inputMessageAccountabilityData == other.inputMessageAccountabilityData &&
                    inputSequenceNumber == other.inputSequenceNumber &&
                    inputSource == other.inputSource &&
                    instructionIdentification == other.instructionIdentification &&
                    returnReasonAdditionalInformation == other.returnReasonAdditionalInformation &&
                    transactionId == other.transactionId &&
                    wireTransferId == other.wireTransferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    createdAt,
                    debtorRoutingNumber,
                    description,
                    inputCycleDate,
                    inputMessageAccountabilityData,
                    inputSequenceNumber,
                    inputSource,
                    instructionIdentification,
                    returnReasonAdditionalInformation,
                    transactionId,
                    wireTransferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundWireReversal{amount=$amount, createdAt=$createdAt, debtorRoutingNumber=$debtorRoutingNumber, description=$description, inputCycleDate=$inputCycleDate, inputMessageAccountabilityData=$inputMessageAccountabilityData, inputSequenceNumber=$inputSequenceNumber, inputSource=$inputSource, instructionIdentification=$instructionIdentification, returnReasonAdditionalInformation=$returnReasonAdditionalInformation, transactionId=$transactionId, wireTransferId=$wireTransferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound Wire Transfer Intention object. This field will be present in the JSON
         * response if and only if `category` is equal to `inbound_wire_transfer`. An Inbound Wire
         * Transfer Intention is created when a wire transfer is initiated at another bank and
         * received by Increase.
         */
        class InboundWireTransfer
        private constructor(
            private val amount: JsonField<Long>,
            private val creditorAddressLine1: JsonField<String>,
            private val creditorAddressLine2: JsonField<String>,
            private val creditorAddressLine3: JsonField<String>,
            private val creditorName: JsonField<String>,
            private val debtorAddressLine1: JsonField<String>,
            private val debtorAddressLine2: JsonField<String>,
            private val debtorAddressLine3: JsonField<String>,
            private val debtorName: JsonField<String>,
            private val description: JsonField<String>,
            private val endToEndIdentification: JsonField<String>,
            private val inputMessageAccountabilityData: JsonField<String>,
            private val instructingAgentRoutingNumber: JsonField<String>,
            private val instructionIdentification: JsonField<String>,
            private val transferId: JsonField<String>,
            private val uniqueEndToEndTransactionReference: JsonField<String>,
            private val unstructuredRemittanceInformation: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("creditor_address_line1")
                @ExcludeMissing
                creditorAddressLine1: JsonField<String> = JsonMissing.of(),
                @JsonProperty("creditor_address_line2")
                @ExcludeMissing
                creditorAddressLine2: JsonField<String> = JsonMissing.of(),
                @JsonProperty("creditor_address_line3")
                @ExcludeMissing
                creditorAddressLine3: JsonField<String> = JsonMissing.of(),
                @JsonProperty("creditor_name")
                @ExcludeMissing
                creditorName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("debtor_address_line1")
                @ExcludeMissing
                debtorAddressLine1: JsonField<String> = JsonMissing.of(),
                @JsonProperty("debtor_address_line2")
                @ExcludeMissing
                debtorAddressLine2: JsonField<String> = JsonMissing.of(),
                @JsonProperty("debtor_address_line3")
                @ExcludeMissing
                debtorAddressLine3: JsonField<String> = JsonMissing.of(),
                @JsonProperty("debtor_name")
                @ExcludeMissing
                debtorName: JsonField<String> = JsonMissing.of(),
                @JsonProperty("description")
                @ExcludeMissing
                description: JsonField<String> = JsonMissing.of(),
                @JsonProperty("end_to_end_identification")
                @ExcludeMissing
                endToEndIdentification: JsonField<String> = JsonMissing.of(),
                @JsonProperty("input_message_accountability_data")
                @ExcludeMissing
                inputMessageAccountabilityData: JsonField<String> = JsonMissing.of(),
                @JsonProperty("instructing_agent_routing_number")
                @ExcludeMissing
                instructingAgentRoutingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("instruction_identification")
                @ExcludeMissing
                instructionIdentification: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("unique_end_to_end_transaction_reference")
                @ExcludeMissing
                uniqueEndToEndTransactionReference: JsonField<String> = JsonMissing.of(),
                @JsonProperty("unstructured_remittance_information")
                @ExcludeMissing
                unstructuredRemittanceInformation: JsonField<String> = JsonMissing.of(),
            ) : this(
                amount,
                creditorAddressLine1,
                creditorAddressLine2,
                creditorAddressLine3,
                creditorName,
                debtorAddressLine1,
                debtorAddressLine2,
                debtorAddressLine3,
                debtorName,
                description,
                endToEndIdentification,
                inputMessageAccountabilityData,
                instructingAgentRoutingNumber,
                instructionIdentification,
                transferId,
                uniqueEndToEndTransactionReference,
                unstructuredRemittanceInformation,
                mutableMapOf(),
            )

            /**
             * The amount in USD cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * A free-form address field set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun creditorAddressLine1(): String? =
                creditorAddressLine1.getNullable("creditor_address_line1")

            /**
             * A free-form address field set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun creditorAddressLine2(): String? =
                creditorAddressLine2.getNullable("creditor_address_line2")

            /**
             * A free-form address field set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun creditorAddressLine3(): String? =
                creditorAddressLine3.getNullable("creditor_address_line3")

            /**
             * A name set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun creditorName(): String? = creditorName.getNullable("creditor_name")

            /**
             * A free-form address field set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun debtorAddressLine1(): String? =
                debtorAddressLine1.getNullable("debtor_address_line1")

            /**
             * A free-form address field set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun debtorAddressLine2(): String? =
                debtorAddressLine2.getNullable("debtor_address_line2")

            /**
             * A free-form address field set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun debtorAddressLine3(): String? =
                debtorAddressLine3.getNullable("debtor_address_line3")

            /**
             * A name set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun debtorName(): String? = debtorName.getNullable("debtor_name")

            /**
             * An Increase-constructed description of the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun description(): String = description.getRequired("description")

            /**
             * A free-form reference string set by the sender, to help identify the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun endToEndIdentification(): String? =
                endToEndIdentification.getNullable("end_to_end_identification")

            /**
             * A unique identifier available to the originating and receiving banks, commonly
             * abbreviated as IMAD. It is created when the wire is submitted to the Fedwire service
             * and is helpful when debugging wires with the originating bank.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun inputMessageAccountabilityData(): String? =
                inputMessageAccountabilityData.getNullable("input_message_accountability_data")

            /**
             * The American Banking Association (ABA) routing number of the bank that sent the wire.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun instructingAgentRoutingNumber(): String? =
                instructingAgentRoutingNumber.getNullable("instructing_agent_routing_number")

            /**
             * The sending bank's identifier for the wire transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun instructionIdentification(): String? =
                instructionIdentification.getNullable("instruction_identification")

            /**
             * The ID of the Inbound Wire Transfer object that resulted in this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * The Unique End-to-end Transaction Reference
             * ([UETR](https://www.swift.com/payments/what-unique-end-end-transaction-reference-uetr))
             * of the transfer.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun uniqueEndToEndTransactionReference(): String? =
                uniqueEndToEndTransactionReference.getNullable(
                    "unique_end_to_end_transaction_reference"
                )

            /**
             * A free-form message set by the sender.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun unstructuredRemittanceInformation(): String? =
                unstructuredRemittanceInformation.getNullable("unstructured_remittance_information")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [creditorAddressLine1].
             *
             * Unlike [creditorAddressLine1], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("creditor_address_line1")
            @ExcludeMissing
            fun _creditorAddressLine1(): JsonField<String> = creditorAddressLine1

            /**
             * Returns the raw JSON value of [creditorAddressLine2].
             *
             * Unlike [creditorAddressLine2], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("creditor_address_line2")
            @ExcludeMissing
            fun _creditorAddressLine2(): JsonField<String> = creditorAddressLine2

            /**
             * Returns the raw JSON value of [creditorAddressLine3].
             *
             * Unlike [creditorAddressLine3], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("creditor_address_line3")
            @ExcludeMissing
            fun _creditorAddressLine3(): JsonField<String> = creditorAddressLine3

            /**
             * Returns the raw JSON value of [creditorName].
             *
             * Unlike [creditorName], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("creditor_name")
            @ExcludeMissing
            fun _creditorName(): JsonField<String> = creditorName

            /**
             * Returns the raw JSON value of [debtorAddressLine1].
             *
             * Unlike [debtorAddressLine1], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("debtor_address_line1")
            @ExcludeMissing
            fun _debtorAddressLine1(): JsonField<String> = debtorAddressLine1

            /**
             * Returns the raw JSON value of [debtorAddressLine2].
             *
             * Unlike [debtorAddressLine2], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("debtor_address_line2")
            @ExcludeMissing
            fun _debtorAddressLine2(): JsonField<String> = debtorAddressLine2

            /**
             * Returns the raw JSON value of [debtorAddressLine3].
             *
             * Unlike [debtorAddressLine3], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("debtor_address_line3")
            @ExcludeMissing
            fun _debtorAddressLine3(): JsonField<String> = debtorAddressLine3

            /**
             * Returns the raw JSON value of [debtorName].
             *
             * Unlike [debtorName], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("debtor_name")
            @ExcludeMissing
            fun _debtorName(): JsonField<String> = debtorName

            /**
             * Returns the raw JSON value of [description].
             *
             * Unlike [description], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("description")
            @ExcludeMissing
            fun _description(): JsonField<String> = description

            /**
             * Returns the raw JSON value of [endToEndIdentification].
             *
             * Unlike [endToEndIdentification], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("end_to_end_identification")
            @ExcludeMissing
            fun _endToEndIdentification(): JsonField<String> = endToEndIdentification

            /**
             * Returns the raw JSON value of [inputMessageAccountabilityData].
             *
             * Unlike [inputMessageAccountabilityData], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("input_message_accountability_data")
            @ExcludeMissing
            fun _inputMessageAccountabilityData(): JsonField<String> =
                inputMessageAccountabilityData

            /**
             * Returns the raw JSON value of [instructingAgentRoutingNumber].
             *
             * Unlike [instructingAgentRoutingNumber], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("instructing_agent_routing_number")
            @ExcludeMissing
            fun _instructingAgentRoutingNumber(): JsonField<String> = instructingAgentRoutingNumber

            /**
             * Returns the raw JSON value of [instructionIdentification].
             *
             * Unlike [instructionIdentification], this method doesn't throw if the JSON field has
             * an unexpected type.
             */
            @JsonProperty("instruction_identification")
            @ExcludeMissing
            fun _instructionIdentification(): JsonField<String> = instructionIdentification

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            /**
             * Returns the raw JSON value of [uniqueEndToEndTransactionReference].
             *
             * Unlike [uniqueEndToEndTransactionReference], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("unique_end_to_end_transaction_reference")
            @ExcludeMissing
            fun _uniqueEndToEndTransactionReference(): JsonField<String> =
                uniqueEndToEndTransactionReference

            /**
             * Returns the raw JSON value of [unstructuredRemittanceInformation].
             *
             * Unlike [unstructuredRemittanceInformation], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("unstructured_remittance_information")
            @ExcludeMissing
            fun _unstructuredRemittanceInformation(): JsonField<String> =
                unstructuredRemittanceInformation

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [InboundWireTransfer].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .creditorAddressLine1()
                 * .creditorAddressLine2()
                 * .creditorAddressLine3()
                 * .creditorName()
                 * .debtorAddressLine1()
                 * .debtorAddressLine2()
                 * .debtorAddressLine3()
                 * .debtorName()
                 * .description()
                 * .endToEndIdentification()
                 * .inputMessageAccountabilityData()
                 * .instructingAgentRoutingNumber()
                 * .instructionIdentification()
                 * .transferId()
                 * .uniqueEndToEndTransactionReference()
                 * .unstructuredRemittanceInformation()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundWireTransfer]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var creditorAddressLine1: JsonField<String>? = null
                private var creditorAddressLine2: JsonField<String>? = null
                private var creditorAddressLine3: JsonField<String>? = null
                private var creditorName: JsonField<String>? = null
                private var debtorAddressLine1: JsonField<String>? = null
                private var debtorAddressLine2: JsonField<String>? = null
                private var debtorAddressLine3: JsonField<String>? = null
                private var debtorName: JsonField<String>? = null
                private var description: JsonField<String>? = null
                private var endToEndIdentification: JsonField<String>? = null
                private var inputMessageAccountabilityData: JsonField<String>? = null
                private var instructingAgentRoutingNumber: JsonField<String>? = null
                private var instructionIdentification: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var uniqueEndToEndTransactionReference: JsonField<String>? = null
                private var unstructuredRemittanceInformation: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(inboundWireTransfer: InboundWireTransfer) = apply {
                    amount = inboundWireTransfer.amount
                    creditorAddressLine1 = inboundWireTransfer.creditorAddressLine1
                    creditorAddressLine2 = inboundWireTransfer.creditorAddressLine2
                    creditorAddressLine3 = inboundWireTransfer.creditorAddressLine3
                    creditorName = inboundWireTransfer.creditorName
                    debtorAddressLine1 = inboundWireTransfer.debtorAddressLine1
                    debtorAddressLine2 = inboundWireTransfer.debtorAddressLine2
                    debtorAddressLine3 = inboundWireTransfer.debtorAddressLine3
                    debtorName = inboundWireTransfer.debtorName
                    description = inboundWireTransfer.description
                    endToEndIdentification = inboundWireTransfer.endToEndIdentification
                    inputMessageAccountabilityData =
                        inboundWireTransfer.inputMessageAccountabilityData
                    instructingAgentRoutingNumber =
                        inboundWireTransfer.instructingAgentRoutingNumber
                    instructionIdentification = inboundWireTransfer.instructionIdentification
                    transferId = inboundWireTransfer.transferId
                    uniqueEndToEndTransactionReference =
                        inboundWireTransfer.uniqueEndToEndTransactionReference
                    unstructuredRemittanceInformation =
                        inboundWireTransfer.unstructuredRemittanceInformation
                    additionalProperties = inboundWireTransfer.additionalProperties.toMutableMap()
                }

                /** The amount in USD cents. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** A free-form address field set by the sender. */
                fun creditorAddressLine1(creditorAddressLine1: String?) =
                    creditorAddressLine1(JsonField.ofNullable(creditorAddressLine1))

                /**
                 * Sets [Builder.creditorAddressLine1] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.creditorAddressLine1] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun creditorAddressLine1(creditorAddressLine1: JsonField<String>) = apply {
                    this.creditorAddressLine1 = creditorAddressLine1
                }

                /** A free-form address field set by the sender. */
                fun creditorAddressLine2(creditorAddressLine2: String?) =
                    creditorAddressLine2(JsonField.ofNullable(creditorAddressLine2))

                /**
                 * Sets [Builder.creditorAddressLine2] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.creditorAddressLine2] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun creditorAddressLine2(creditorAddressLine2: JsonField<String>) = apply {
                    this.creditorAddressLine2 = creditorAddressLine2
                }

                /** A free-form address field set by the sender. */
                fun creditorAddressLine3(creditorAddressLine3: String?) =
                    creditorAddressLine3(JsonField.ofNullable(creditorAddressLine3))

                /**
                 * Sets [Builder.creditorAddressLine3] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.creditorAddressLine3] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun creditorAddressLine3(creditorAddressLine3: JsonField<String>) = apply {
                    this.creditorAddressLine3 = creditorAddressLine3
                }

                /** A name set by the sender. */
                fun creditorName(creditorName: String?) =
                    creditorName(JsonField.ofNullable(creditorName))

                /**
                 * Sets [Builder.creditorName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.creditorName] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun creditorName(creditorName: JsonField<String>) = apply {
                    this.creditorName = creditorName
                }

                /** A free-form address field set by the sender. */
                fun debtorAddressLine1(debtorAddressLine1: String?) =
                    debtorAddressLine1(JsonField.ofNullable(debtorAddressLine1))

                /**
                 * Sets [Builder.debtorAddressLine1] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorAddressLine1] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun debtorAddressLine1(debtorAddressLine1: JsonField<String>) = apply {
                    this.debtorAddressLine1 = debtorAddressLine1
                }

                /** A free-form address field set by the sender. */
                fun debtorAddressLine2(debtorAddressLine2: String?) =
                    debtorAddressLine2(JsonField.ofNullable(debtorAddressLine2))

                /**
                 * Sets [Builder.debtorAddressLine2] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorAddressLine2] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun debtorAddressLine2(debtorAddressLine2: JsonField<String>) = apply {
                    this.debtorAddressLine2 = debtorAddressLine2
                }

                /** A free-form address field set by the sender. */
                fun debtorAddressLine3(debtorAddressLine3: String?) =
                    debtorAddressLine3(JsonField.ofNullable(debtorAddressLine3))

                /**
                 * Sets [Builder.debtorAddressLine3] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorAddressLine3] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun debtorAddressLine3(debtorAddressLine3: JsonField<String>) = apply {
                    this.debtorAddressLine3 = debtorAddressLine3
                }

                /** A name set by the sender. */
                fun debtorName(debtorName: String?) = debtorName(JsonField.ofNullable(debtorName))

                /**
                 * Sets [Builder.debtorName] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.debtorName] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun debtorName(debtorName: JsonField<String>) = apply {
                    this.debtorName = debtorName
                }

                /** An Increase-constructed description of the transfer. */
                fun description(description: String) = description(JsonField.of(description))

                /**
                 * Sets [Builder.description] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.description] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun description(description: JsonField<String>) = apply {
                    this.description = description
                }

                /**
                 * A free-form reference string set by the sender, to help identify the transfer.
                 */
                fun endToEndIdentification(endToEndIdentification: String?) =
                    endToEndIdentification(JsonField.ofNullable(endToEndIdentification))

                /**
                 * Sets [Builder.endToEndIdentification] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.endToEndIdentification] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun endToEndIdentification(endToEndIdentification: JsonField<String>) = apply {
                    this.endToEndIdentification = endToEndIdentification
                }

                /**
                 * A unique identifier available to the originating and receiving banks, commonly
                 * abbreviated as IMAD. It is created when the wire is submitted to the Fedwire
                 * service and is helpful when debugging wires with the originating bank.
                 */
                fun inputMessageAccountabilityData(inputMessageAccountabilityData: String?) =
                    inputMessageAccountabilityData(
                        JsonField.ofNullable(inputMessageAccountabilityData)
                    )

                /**
                 * Sets [Builder.inputMessageAccountabilityData] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inputMessageAccountabilityData] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun inputMessageAccountabilityData(
                    inputMessageAccountabilityData: JsonField<String>
                ) = apply { this.inputMessageAccountabilityData = inputMessageAccountabilityData }

                /**
                 * The American Banking Association (ABA) routing number of the bank that sent the
                 * wire.
                 */
                fun instructingAgentRoutingNumber(instructingAgentRoutingNumber: String?) =
                    instructingAgentRoutingNumber(
                        JsonField.ofNullable(instructingAgentRoutingNumber)
                    )

                /**
                 * Sets [Builder.instructingAgentRoutingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.instructingAgentRoutingNumber] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun instructingAgentRoutingNumber(
                    instructingAgentRoutingNumber: JsonField<String>
                ) = apply { this.instructingAgentRoutingNumber = instructingAgentRoutingNumber }

                /** The sending bank's identifier for the wire transfer. */
                fun instructionIdentification(instructionIdentification: String?) =
                    instructionIdentification(JsonField.ofNullable(instructionIdentification))

                /**
                 * Sets [Builder.instructionIdentification] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.instructionIdentification] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun instructionIdentification(instructionIdentification: JsonField<String>) =
                    apply {
                        this.instructionIdentification = instructionIdentification
                    }

                /** The ID of the Inbound Wire Transfer object that resulted in this Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                /**
                 * The Unique End-to-end Transaction Reference
                 * ([UETR](https://www.swift.com/payments/what-unique-end-end-transaction-reference-uetr))
                 * of the transfer.
                 */
                fun uniqueEndToEndTransactionReference(
                    uniqueEndToEndTransactionReference: String?
                ) =
                    uniqueEndToEndTransactionReference(
                        JsonField.ofNullable(uniqueEndToEndTransactionReference)
                    )

                /**
                 * Sets [Builder.uniqueEndToEndTransactionReference] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.uniqueEndToEndTransactionReference] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun uniqueEndToEndTransactionReference(
                    uniqueEndToEndTransactionReference: JsonField<String>
                ) = apply {
                    this.uniqueEndToEndTransactionReference = uniqueEndToEndTransactionReference
                }

                /** A free-form message set by the sender. */
                fun unstructuredRemittanceInformation(unstructuredRemittanceInformation: String?) =
                    unstructuredRemittanceInformation(
                        JsonField.ofNullable(unstructuredRemittanceInformation)
                    )

                /**
                 * Sets [Builder.unstructuredRemittanceInformation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unstructuredRemittanceInformation] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun unstructuredRemittanceInformation(
                    unstructuredRemittanceInformation: JsonField<String>
                ) = apply {
                    this.unstructuredRemittanceInformation = unstructuredRemittanceInformation
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundWireTransfer].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .creditorAddressLine1()
                 * .creditorAddressLine2()
                 * .creditorAddressLine3()
                 * .creditorName()
                 * .debtorAddressLine1()
                 * .debtorAddressLine2()
                 * .debtorAddressLine3()
                 * .debtorName()
                 * .description()
                 * .endToEndIdentification()
                 * .inputMessageAccountabilityData()
                 * .instructingAgentRoutingNumber()
                 * .instructionIdentification()
                 * .transferId()
                 * .uniqueEndToEndTransactionReference()
                 * .unstructuredRemittanceInformation()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundWireTransfer =
                    InboundWireTransfer(
                        checkRequired("amount", amount),
                        checkRequired("creditorAddressLine1", creditorAddressLine1),
                        checkRequired("creditorAddressLine2", creditorAddressLine2),
                        checkRequired("creditorAddressLine3", creditorAddressLine3),
                        checkRequired("creditorName", creditorName),
                        checkRequired("debtorAddressLine1", debtorAddressLine1),
                        checkRequired("debtorAddressLine2", debtorAddressLine2),
                        checkRequired("debtorAddressLine3", debtorAddressLine3),
                        checkRequired("debtorName", debtorName),
                        checkRequired("description", description),
                        checkRequired("endToEndIdentification", endToEndIdentification),
                        checkRequired(
                            "inputMessageAccountabilityData",
                            inputMessageAccountabilityData,
                        ),
                        checkRequired(
                            "instructingAgentRoutingNumber",
                            instructingAgentRoutingNumber,
                        ),
                        checkRequired("instructionIdentification", instructionIdentification),
                        checkRequired("transferId", transferId),
                        checkRequired(
                            "uniqueEndToEndTransactionReference",
                            uniqueEndToEndTransactionReference,
                        ),
                        checkRequired(
                            "unstructuredRemittanceInformation",
                            unstructuredRemittanceInformation,
                        ),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundWireTransfer = apply {
                if (validated) {
                    return@apply
                }

                amount()
                creditorAddressLine1()
                creditorAddressLine2()
                creditorAddressLine3()
                creditorName()
                debtorAddressLine1()
                debtorAddressLine2()
                debtorAddressLine3()
                debtorName()
                description()
                endToEndIdentification()
                inputMessageAccountabilityData()
                instructingAgentRoutingNumber()
                instructionIdentification()
                transferId()
                uniqueEndToEndTransactionReference()
                unstructuredRemittanceInformation()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (if (creditorAddressLine1.asKnown() == null) 0 else 1) +
                    (if (creditorAddressLine2.asKnown() == null) 0 else 1) +
                    (if (creditorAddressLine3.asKnown() == null) 0 else 1) +
                    (if (creditorName.asKnown() == null) 0 else 1) +
                    (if (debtorAddressLine1.asKnown() == null) 0 else 1) +
                    (if (debtorAddressLine2.asKnown() == null) 0 else 1) +
                    (if (debtorAddressLine3.asKnown() == null) 0 else 1) +
                    (if (debtorName.asKnown() == null) 0 else 1) +
                    (if (description.asKnown() == null) 0 else 1) +
                    (if (endToEndIdentification.asKnown() == null) 0 else 1) +
                    (if (inputMessageAccountabilityData.asKnown() == null) 0 else 1) +
                    (if (instructingAgentRoutingNumber.asKnown() == null) 0 else 1) +
                    (if (instructionIdentification.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1) +
                    (if (uniqueEndToEndTransactionReference.asKnown() == null) 0 else 1) +
                    (if (unstructuredRemittanceInformation.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundWireTransfer &&
                    amount == other.amount &&
                    creditorAddressLine1 == other.creditorAddressLine1 &&
                    creditorAddressLine2 == other.creditorAddressLine2 &&
                    creditorAddressLine3 == other.creditorAddressLine3 &&
                    creditorName == other.creditorName &&
                    debtorAddressLine1 == other.debtorAddressLine1 &&
                    debtorAddressLine2 == other.debtorAddressLine2 &&
                    debtorAddressLine3 == other.debtorAddressLine3 &&
                    debtorName == other.debtorName &&
                    description == other.description &&
                    endToEndIdentification == other.endToEndIdentification &&
                    inputMessageAccountabilityData == other.inputMessageAccountabilityData &&
                    instructingAgentRoutingNumber == other.instructingAgentRoutingNumber &&
                    instructionIdentification == other.instructionIdentification &&
                    transferId == other.transferId &&
                    uniqueEndToEndTransactionReference ==
                        other.uniqueEndToEndTransactionReference &&
                    unstructuredRemittanceInformation == other.unstructuredRemittanceInformation &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    creditorAddressLine1,
                    creditorAddressLine2,
                    creditorAddressLine3,
                    creditorName,
                    debtorAddressLine1,
                    debtorAddressLine2,
                    debtorAddressLine3,
                    debtorName,
                    description,
                    endToEndIdentification,
                    inputMessageAccountabilityData,
                    instructingAgentRoutingNumber,
                    instructionIdentification,
                    transferId,
                    uniqueEndToEndTransactionReference,
                    unstructuredRemittanceInformation,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundWireTransfer{amount=$amount, creditorAddressLine1=$creditorAddressLine1, creditorAddressLine2=$creditorAddressLine2, creditorAddressLine3=$creditorAddressLine3, creditorName=$creditorName, debtorAddressLine1=$debtorAddressLine1, debtorAddressLine2=$debtorAddressLine2, debtorAddressLine3=$debtorAddressLine3, debtorName=$debtorName, description=$description, endToEndIdentification=$endToEndIdentification, inputMessageAccountabilityData=$inputMessageAccountabilityData, instructingAgentRoutingNumber=$instructingAgentRoutingNumber, instructionIdentification=$instructionIdentification, transferId=$transferId, uniqueEndToEndTransactionReference=$uniqueEndToEndTransactionReference, unstructuredRemittanceInformation=$unstructuredRemittanceInformation, additionalProperties=$additionalProperties}"
        }

        /**
         * An Inbound Wire Transfer Reversal Intention object. This field will be present in the
         * JSON response if and only if `category` is equal to `inbound_wire_transfer_reversal`. An
         * Inbound Wire Transfer Reversal Intention is created when Increase has received a wire and
         * the User requests that it be reversed.
         */
        class InboundWireTransferReversal
        private constructor(
            private val inboundWireTransferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("inbound_wire_transfer_id")
                @ExcludeMissing
                inboundWireTransferId: JsonField<String> = JsonMissing.of()
            ) : this(inboundWireTransferId, mutableMapOf())

            /**
             * The ID of the Inbound Wire Transfer that is being reversed.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun inboundWireTransferId(): String =
                inboundWireTransferId.getRequired("inbound_wire_transfer_id")

            /**
             * Returns the raw JSON value of [inboundWireTransferId].
             *
             * Unlike [inboundWireTransferId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("inbound_wire_transfer_id")
            @ExcludeMissing
            fun _inboundWireTransferId(): JsonField<String> = inboundWireTransferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InboundWireTransferReversal].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .inboundWireTransferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InboundWireTransferReversal]. */
            class Builder internal constructor() {

                private var inboundWireTransferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(inboundWireTransferReversal: InboundWireTransferReversal) =
                    apply {
                        inboundWireTransferId = inboundWireTransferReversal.inboundWireTransferId
                        additionalProperties =
                            inboundWireTransferReversal.additionalProperties.toMutableMap()
                    }

                /** The ID of the Inbound Wire Transfer that is being reversed. */
                fun inboundWireTransferId(inboundWireTransferId: String) =
                    inboundWireTransferId(JsonField.of(inboundWireTransferId))

                /**
                 * Sets [Builder.inboundWireTransferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.inboundWireTransferId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun inboundWireTransferId(inboundWireTransferId: JsonField<String>) = apply {
                    this.inboundWireTransferId = inboundWireTransferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InboundWireTransferReversal].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .inboundWireTransferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InboundWireTransferReversal =
                    InboundWireTransferReversal(
                        checkRequired("inboundWireTransferId", inboundWireTransferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InboundWireTransferReversal = apply {
                if (validated) {
                    return@apply
                }

                inboundWireTransferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (inboundWireTransferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InboundWireTransferReversal &&
                    inboundWireTransferId == other.inboundWireTransferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(inboundWireTransferId, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InboundWireTransferReversal{inboundWireTransferId=$inboundWireTransferId, additionalProperties=$additionalProperties}"
        }

        /**
         * An Interest Payment object. This field will be present in the JSON response if and only
         * if `category` is equal to `interest_payment`. An Interest Payment represents a payment of
         * interest on an account. Interest is usually paid monthly.
         */
        class InterestPayment
        private constructor(
            private val accruedOnAccountId: JsonField<String>,
            private val amount: JsonField<Long>,
            private val currency: JsonField<Currency>,
            private val periodEnd: JsonField<OffsetDateTime>,
            private val periodStart: JsonField<OffsetDateTime>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("accrued_on_account_id")
                @ExcludeMissing
                accruedOnAccountId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("period_end")
                @ExcludeMissing
                periodEnd: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("period_start")
                @ExcludeMissing
                periodStart: JsonField<OffsetDateTime> = JsonMissing.of(),
            ) : this(accruedOnAccountId, amount, currency, periodEnd, periodStart, mutableMapOf())

            /**
             * The account on which the interest was accrued.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun accruedOnAccountId(): String =
                accruedOnAccountId.getRequired("accrued_on_account_id")

            /**
             * The amount in the minor unit of the transaction's currency. For dollars, for example,
             * this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * The end of the period for which this transaction paid interest.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodEnd(): OffsetDateTime = periodEnd.getRequired("period_end")

            /**
             * The start of the period for which this transaction paid interest.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun periodStart(): OffsetDateTime = periodStart.getRequired("period_start")

            /**
             * Returns the raw JSON value of [accruedOnAccountId].
             *
             * Unlike [accruedOnAccountId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("accrued_on_account_id")
            @ExcludeMissing
            fun _accruedOnAccountId(): JsonField<String> = accruedOnAccountId

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [periodEnd].
             *
             * Unlike [periodEnd], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_end")
            @ExcludeMissing
            fun _periodEnd(): JsonField<OffsetDateTime> = periodEnd

            /**
             * Returns the raw JSON value of [periodStart].
             *
             * Unlike [periodStart], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("period_start")
            @ExcludeMissing
            fun _periodStart(): JsonField<OffsetDateTime> = periodStart

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [InterestPayment].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accruedOnAccountId()
                 * .amount()
                 * .currency()
                 * .periodEnd()
                 * .periodStart()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InterestPayment]. */
            class Builder internal constructor() {

                private var accruedOnAccountId: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var currency: JsonField<Currency>? = null
                private var periodEnd: JsonField<OffsetDateTime>? = null
                private var periodStart: JsonField<OffsetDateTime>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(interestPayment: InterestPayment) = apply {
                    accruedOnAccountId = interestPayment.accruedOnAccountId
                    amount = interestPayment.amount
                    currency = interestPayment.currency
                    periodEnd = interestPayment.periodEnd
                    periodStart = interestPayment.periodStart
                    additionalProperties = interestPayment.additionalProperties.toMutableMap()
                }

                /** The account on which the interest was accrued. */
                fun accruedOnAccountId(accruedOnAccountId: String) =
                    accruedOnAccountId(JsonField.of(accruedOnAccountId))

                /**
                 * Sets [Builder.accruedOnAccountId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.accruedOnAccountId] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun accruedOnAccountId(accruedOnAccountId: JsonField<String>) = apply {
                    this.accruedOnAccountId = accruedOnAccountId
                }

                /**
                 * The amount in the minor unit of the transaction's currency. For dollars, for
                 * example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
                 * currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /** The end of the period for which this transaction paid interest. */
                fun periodEnd(periodEnd: OffsetDateTime) = periodEnd(JsonField.of(periodEnd))

                /**
                 * Sets [Builder.periodEnd] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodEnd] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodEnd(periodEnd: JsonField<OffsetDateTime>) = apply {
                    this.periodEnd = periodEnd
                }

                /** The start of the period for which this transaction paid interest. */
                fun periodStart(periodStart: OffsetDateTime) =
                    periodStart(JsonField.of(periodStart))

                /**
                 * Sets [Builder.periodStart] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.periodStart] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun periodStart(periodStart: JsonField<OffsetDateTime>) = apply {
                    this.periodStart = periodStart
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InterestPayment].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accruedOnAccountId()
                 * .amount()
                 * .currency()
                 * .periodEnd()
                 * .periodStart()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InterestPayment =
                    InterestPayment(
                        checkRequired("accruedOnAccountId", accruedOnAccountId),
                        checkRequired("amount", amount),
                        checkRequired("currency", currency),
                        checkRequired("periodEnd", periodEnd),
                        checkRequired("periodStart", periodStart),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InterestPayment = apply {
                if (validated) {
                    return@apply
                }

                accruedOnAccountId()
                amount()
                currency().validate()
                periodEnd()
                periodStart()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (accruedOnAccountId.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (if (periodEnd.asKnown() == null) 0 else 1) +
                    (if (periodStart.asKnown() == null) 0 else 1)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InterestPayment &&
                    accruedOnAccountId == other.accruedOnAccountId &&
                    amount == other.amount &&
                    currency == other.currency &&
                    periodEnd == other.periodEnd &&
                    periodStart == other.periodStart &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    accruedOnAccountId,
                    amount,
                    currency,
                    periodEnd,
                    periodStart,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InterestPayment{accruedOnAccountId=$accruedOnAccountId, amount=$amount, currency=$currency, periodEnd=$periodEnd, periodStart=$periodStart, additionalProperties=$additionalProperties}"
        }

        /**
         * An Internal Source object. This field will be present in the JSON response if and only if
         * `category` is equal to `internal_source`. A transaction between the user and Increase.
         * See the `reason` attribute for more information.
         */
        class InternalSource
        private constructor(
            private val amount: JsonField<Long>,
            private val currency: JsonField<Currency>,
            private val reason: JsonField<Reason>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("currency")
                @ExcludeMissing
                currency: JsonField<Currency> = JsonMissing.of(),
                @JsonProperty("reason") @ExcludeMissing reason: JsonField<Reason> = JsonMissing.of(),
            ) : this(amount, currency, reason, mutableMapOf())

            /**
             * The amount in the minor unit of the transaction's currency. For dollars, for example,
             * this is cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): Currency = currency.getRequired("currency")

            /**
             * An Internal Source is a transaction between you and Increase. This describes the
             * reason for the transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun reason(): Reason = reason.getRequired("reason")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency")
            @ExcludeMissing
            fun _currency(): JsonField<Currency> = currency

            /**
             * Returns the raw JSON value of [reason].
             *
             * Unlike [reason], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<Reason> = reason

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [InternalSource].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .reason()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [InternalSource]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var currency: JsonField<Currency>? = null
                private var reason: JsonField<Reason>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(internalSource: InternalSource) = apply {
                    amount = internalSource.amount
                    currency = internalSource.currency
                    reason = internalSource.reason
                    additionalProperties = internalSource.additionalProperties.toMutableMap()
                }

                /**
                 * The amount in the minor unit of the transaction's currency. For dollars, for
                 * example, this is cents.
                 */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /**
                 * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
                 * currency.
                 */
                fun currency(currency: Currency) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [Currency] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<Currency>) = apply { this.currency = currency }

                /**
                 * An Internal Source is a transaction between you and Increase. This describes the
                 * reason for the transaction.
                 */
                fun reason(reason: Reason) = reason(JsonField.of(reason))

                /**
                 * Sets [Builder.reason] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.reason] with a well-typed [Reason] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [InternalSource].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .currency()
                 * .reason()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): InternalSource =
                    InternalSource(
                        checkRequired("amount", amount),
                        checkRequired("currency", currency),
                        checkRequired("reason", reason),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): InternalSource = apply {
                if (validated) {
                    return@apply
                }

                amount()
                currency().validate()
                reason().validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (currency.asKnown()?.validity() ?: 0) +
                    (reason.asKnown()?.validity() ?: 0)

            /**
             * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the transaction
             * currency.
             */
            class Currency @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Canadian Dollar (CAD) */
                    val CAD = of("CAD")

                    /** Swiss Franc (CHF) */
                    val CHF = of("CHF")

                    /** Euro (EUR) */
                    val EUR = of("EUR")

                    /** British Pound (GBP) */
                    val GBP = of("GBP")

                    /** Japanese Yen (JPY) */
                    val JPY = of("JPY")

                    /** US Dollar (USD) */
                    val USD = of("USD")

                    fun of(value: String) = Currency(JsonField.of(value))
                }

                /** An enum containing [Currency]'s known values. */
                enum class Known {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                }

                /**
                 * An enum containing [Currency]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Currency] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Canadian Dollar (CAD) */
                    CAD,
                    /** Swiss Franc (CHF) */
                    CHF,
                    /** Euro (EUR) */
                    EUR,
                    /** British Pound (GBP) */
                    GBP,
                    /** Japanese Yen (JPY) */
                    JPY,
                    /** US Dollar (USD) */
                    USD,
                    /**
                     * An enum member indicating that [Currency] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CAD -> Value.CAD
                        CHF -> Value.CHF
                        EUR -> Value.EUR
                        GBP -> Value.GBP
                        JPY -> Value.JPY
                        USD -> Value.USD
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CAD -> Known.CAD
                        CHF -> Known.CHF
                        EUR -> Known.EUR
                        GBP -> Known.GBP
                        JPY -> Known.JPY
                        USD -> Known.USD
                        else -> throw IncreaseInvalidDataException("Unknown Currency: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Currency = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Currency && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * An Internal Source is a transaction between you and Increase. This describes the
             * reason for the transaction.
             */
            class Reason @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** Account closure */
                    val ACCOUNT_CLOSURE = of("account_closure")

                    /** Bank-drawn check */
                    val BANK_DRAWN_CHECK = of("bank_drawn_check")

                    /** Bank-drawn check credit */
                    val BANK_DRAWN_CHECK_CREDIT = of("bank_drawn_check_credit")

                    /** Bank migration */
                    val BANK_MIGRATION = of("bank_migration")

                    /** Check adjustment */
                    val CHECK_ADJUSTMENT = of("check_adjustment")

                    /** Collection payment */
                    val COLLECTION_PAYMENT = of("collection_payment")

                    /** Collection receivable */
                    val COLLECTION_RECEIVABLE = of("collection_receivable")

                    /** Empyreal adjustment */
                    val EMPYREAL_ADJUSTMENT = of("empyreal_adjustment")

                    /** Error */
                    val ERROR = of("error")

                    /** Error correction */
                    val ERROR_CORRECTION = of("error_correction")

                    /** Fees */
                    val FEES = of("fees")

                    /** Interest */
                    val INTEREST = of("interest")

                    /** Negative balance forgiveness */
                    val NEGATIVE_BALANCE_FORGIVENESS = of("negative_balance_forgiveness")

                    /** Sample funds */
                    val SAMPLE_FUNDS = of("sample_funds")

                    /** Sample funds return */
                    val SAMPLE_FUNDS_RETURN = of("sample_funds_return")

                    /** Account revenue payment distribution */
                    val ACCOUNT_REVENUE_PAYMENT_DISTRIBUTION =
                        of("account_revenue_payment_distribution")

                    fun of(value: String) = Reason(JsonField.of(value))
                }

                /** An enum containing [Reason]'s known values. */
                enum class Known {
                    /** Account closure */
                    ACCOUNT_CLOSURE,
                    /** Bank-drawn check */
                    BANK_DRAWN_CHECK,
                    /** Bank-drawn check credit */
                    BANK_DRAWN_CHECK_CREDIT,
                    /** Bank migration */
                    BANK_MIGRATION,
                    /** Check adjustment */
                    CHECK_ADJUSTMENT,
                    /** Collection payment */
                    COLLECTION_PAYMENT,
                    /** Collection receivable */
                    COLLECTION_RECEIVABLE,
                    /** Empyreal adjustment */
                    EMPYREAL_ADJUSTMENT,
                    /** Error */
                    ERROR,
                    /** Error correction */
                    ERROR_CORRECTION,
                    /** Fees */
                    FEES,
                    /** Interest */
                    INTEREST,
                    /** Negative balance forgiveness */
                    NEGATIVE_BALANCE_FORGIVENESS,
                    /** Sample funds */
                    SAMPLE_FUNDS,
                    /** Sample funds return */
                    SAMPLE_FUNDS_RETURN,
                    /** Account revenue payment distribution */
                    ACCOUNT_REVENUE_PAYMENT_DISTRIBUTION,
                }

                /**
                 * An enum containing [Reason]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Reason] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** Account closure */
                    ACCOUNT_CLOSURE,
                    /** Bank-drawn check */
                    BANK_DRAWN_CHECK,
                    /** Bank-drawn check credit */
                    BANK_DRAWN_CHECK_CREDIT,
                    /** Bank migration */
                    BANK_MIGRATION,
                    /** Check adjustment */
                    CHECK_ADJUSTMENT,
                    /** Collection payment */
                    COLLECTION_PAYMENT,
                    /** Collection receivable */
                    COLLECTION_RECEIVABLE,
                    /** Empyreal adjustment */
                    EMPYREAL_ADJUSTMENT,
                    /** Error */
                    ERROR,
                    /** Error correction */
                    ERROR_CORRECTION,
                    /** Fees */
                    FEES,
                    /** Interest */
                    INTEREST,
                    /** Negative balance forgiveness */
                    NEGATIVE_BALANCE_FORGIVENESS,
                    /** Sample funds */
                    SAMPLE_FUNDS,
                    /** Sample funds return */
                    SAMPLE_FUNDS_RETURN,
                    /** Account revenue payment distribution */
                    ACCOUNT_REVENUE_PAYMENT_DISTRIBUTION,
                    /**
                     * An enum member indicating that [Reason] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        ACCOUNT_CLOSURE -> Value.ACCOUNT_CLOSURE
                        BANK_DRAWN_CHECK -> Value.BANK_DRAWN_CHECK
                        BANK_DRAWN_CHECK_CREDIT -> Value.BANK_DRAWN_CHECK_CREDIT
                        BANK_MIGRATION -> Value.BANK_MIGRATION
                        CHECK_ADJUSTMENT -> Value.CHECK_ADJUSTMENT
                        COLLECTION_PAYMENT -> Value.COLLECTION_PAYMENT
                        COLLECTION_RECEIVABLE -> Value.COLLECTION_RECEIVABLE
                        EMPYREAL_ADJUSTMENT -> Value.EMPYREAL_ADJUSTMENT
                        ERROR -> Value.ERROR
                        ERROR_CORRECTION -> Value.ERROR_CORRECTION
                        FEES -> Value.FEES
                        INTEREST -> Value.INTEREST
                        NEGATIVE_BALANCE_FORGIVENESS -> Value.NEGATIVE_BALANCE_FORGIVENESS
                        SAMPLE_FUNDS -> Value.SAMPLE_FUNDS
                        SAMPLE_FUNDS_RETURN -> Value.SAMPLE_FUNDS_RETURN
                        ACCOUNT_REVENUE_PAYMENT_DISTRIBUTION ->
                            Value.ACCOUNT_REVENUE_PAYMENT_DISTRIBUTION
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        ACCOUNT_CLOSURE -> Known.ACCOUNT_CLOSURE
                        BANK_DRAWN_CHECK -> Known.BANK_DRAWN_CHECK
                        BANK_DRAWN_CHECK_CREDIT -> Known.BANK_DRAWN_CHECK_CREDIT
                        BANK_MIGRATION -> Known.BANK_MIGRATION
                        CHECK_ADJUSTMENT -> Known.CHECK_ADJUSTMENT
                        COLLECTION_PAYMENT -> Known.COLLECTION_PAYMENT
                        COLLECTION_RECEIVABLE -> Known.COLLECTION_RECEIVABLE
                        EMPYREAL_ADJUSTMENT -> Known.EMPYREAL_ADJUSTMENT
                        ERROR -> Known.ERROR
                        ERROR_CORRECTION -> Known.ERROR_CORRECTION
                        FEES -> Known.FEES
                        INTEREST -> Known.INTEREST
                        NEGATIVE_BALANCE_FORGIVENESS -> Known.NEGATIVE_BALANCE_FORGIVENESS
                        SAMPLE_FUNDS -> Known.SAMPLE_FUNDS
                        SAMPLE_FUNDS_RETURN -> Known.SAMPLE_FUNDS_RETURN
                        ACCOUNT_REVENUE_PAYMENT_DISTRIBUTION ->
                            Known.ACCOUNT_REVENUE_PAYMENT_DISTRIBUTION
                        else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Reason = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Reason && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is InternalSource &&
                    amount == other.amount &&
                    currency == other.currency &&
                    reason == other.reason &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(amount, currency, reason, additionalProperties)
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InternalSource{amount=$amount, currency=$currency, reason=$reason, additionalProperties=$additionalProperties}"
        }

        /**
         * A Real-Time Payments Transfer Acknowledgement object. This field will be present in the
         * JSON response if and only if `category` is equal to
         * `real_time_payments_transfer_acknowledgement`. A Real-Time Payments Transfer
         * Acknowledgement is created when a Real-Time Payments Transfer sent from Increase is
         * acknowledged by the receiving bank.
         */
        class RealTimePaymentsTransferAcknowledgement
        private constructor(
            private val amount: JsonField<Long>,
            private val destinationAccountNumber: JsonField<String>,
            private val destinationRoutingNumber: JsonField<String>,
            private val remittanceInformation: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("destination_account_number")
                @ExcludeMissing
                destinationAccountNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("destination_routing_number")
                @ExcludeMissing
                destinationRoutingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("remittance_information")
                @ExcludeMissing
                remittanceInformation: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                amount,
                destinationAccountNumber,
                destinationRoutingNumber,
                remittanceInformation,
                transferId,
                mutableMapOf(),
            )

            /**
             * The transfer amount in USD cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The destination account number.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun destinationAccountNumber(): String =
                destinationAccountNumber.getRequired("destination_account_number")

            /**
             * The American Bankers' Association (ABA) Routing Transit Number (RTN).
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun destinationRoutingNumber(): String =
                destinationRoutingNumber.getRequired("destination_routing_number")

            /**
             * Unstructured information that will show on the recipient's bank statement.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun remittanceInformation(): String =
                remittanceInformation.getRequired("remittance_information")

            /**
             * The identifier of the Real-Time Payments Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [destinationAccountNumber].
             *
             * Unlike [destinationAccountNumber], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("destination_account_number")
            @ExcludeMissing
            fun _destinationAccountNumber(): JsonField<String> = destinationAccountNumber

            /**
             * Returns the raw JSON value of [destinationRoutingNumber].
             *
             * Unlike [destinationRoutingNumber], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("destination_routing_number")
            @ExcludeMissing
            fun _destinationRoutingNumber(): JsonField<String> = destinationRoutingNumber

            /**
             * Returns the raw JSON value of [remittanceInformation].
             *
             * Unlike [remittanceInformation], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("remittance_information")
            @ExcludeMissing
            fun _remittanceInformation(): JsonField<String> = remittanceInformation

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [RealTimePaymentsTransferAcknowledgement].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .destinationAccountNumber()
                 * .destinationRoutingNumber()
                 * .remittanceInformation()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [RealTimePaymentsTransferAcknowledgement]. */
            class Builder internal constructor() {

                private var amount: JsonField<Long>? = null
                private var destinationAccountNumber: JsonField<String>? = null
                private var destinationRoutingNumber: JsonField<String>? = null
                private var remittanceInformation: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(
                    realTimePaymentsTransferAcknowledgement: RealTimePaymentsTransferAcknowledgement
                ) = apply {
                    amount = realTimePaymentsTransferAcknowledgement.amount
                    destinationAccountNumber =
                        realTimePaymentsTransferAcknowledgement.destinationAccountNumber
                    destinationRoutingNumber =
                        realTimePaymentsTransferAcknowledgement.destinationRoutingNumber
                    remittanceInformation =
                        realTimePaymentsTransferAcknowledgement.remittanceInformation
                    transferId = realTimePaymentsTransferAcknowledgement.transferId
                    additionalProperties =
                        realTimePaymentsTransferAcknowledgement.additionalProperties.toMutableMap()
                }

                /** The transfer amount in USD cents. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The destination account number. */
                fun destinationAccountNumber(destinationAccountNumber: String) =
                    destinationAccountNumber(JsonField.of(destinationAccountNumber))

                /**
                 * Sets [Builder.destinationAccountNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.destinationAccountNumber] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun destinationAccountNumber(destinationAccountNumber: JsonField<String>) = apply {
                    this.destinationAccountNumber = destinationAccountNumber
                }

                /** The American Bankers' Association (ABA) Routing Transit Number (RTN). */
                fun destinationRoutingNumber(destinationRoutingNumber: String) =
                    destinationRoutingNumber(JsonField.of(destinationRoutingNumber))

                /**
                 * Sets [Builder.destinationRoutingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.destinationRoutingNumber] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun destinationRoutingNumber(destinationRoutingNumber: JsonField<String>) = apply {
                    this.destinationRoutingNumber = destinationRoutingNumber
                }

                /** Unstructured information that will show on the recipient's bank statement. */
                fun remittanceInformation(remittanceInformation: String) =
                    remittanceInformation(JsonField.of(remittanceInformation))

                /**
                 * Sets [Builder.remittanceInformation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.remittanceInformation] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun remittanceInformation(remittanceInformation: JsonField<String>) = apply {
                    this.remittanceInformation = remittanceInformation
                }

                /**
                 * The identifier of the Real-Time Payments Transfer that led to this Transaction.
                 */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [RealTimePaymentsTransferAcknowledgement].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .amount()
                 * .destinationAccountNumber()
                 * .destinationRoutingNumber()
                 * .remittanceInformation()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): RealTimePaymentsTransferAcknowledgement =
                    RealTimePaymentsTransferAcknowledgement(
                        checkRequired("amount", amount),
                        checkRequired("destinationAccountNumber", destinationAccountNumber),
                        checkRequired("destinationRoutingNumber", destinationRoutingNumber),
                        checkRequired("remittanceInformation", remittanceInformation),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): RealTimePaymentsTransferAcknowledgement = apply {
                if (validated) {
                    return@apply
                }

                amount()
                destinationAccountNumber()
                destinationRoutingNumber()
                remittanceInformation()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (amount.asKnown() == null) 0 else 1) +
                    (if (destinationAccountNumber.asKnown() == null) 0 else 1) +
                    (if (destinationRoutingNumber.asKnown() == null) 0 else 1) +
                    (if (remittanceInformation.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is RealTimePaymentsTransferAcknowledgement &&
                    amount == other.amount &&
                    destinationAccountNumber == other.destinationAccountNumber &&
                    destinationRoutingNumber == other.destinationRoutingNumber &&
                    remittanceInformation == other.remittanceInformation &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    amount,
                    destinationAccountNumber,
                    destinationRoutingNumber,
                    remittanceInformation,
                    transferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "RealTimePaymentsTransferAcknowledgement{amount=$amount, destinationAccountNumber=$destinationAccountNumber, destinationRoutingNumber=$destinationRoutingNumber, remittanceInformation=$remittanceInformation, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Sample Funds object. This field will be present in the JSON response if and only if
         * `category` is equal to `sample_funds`. Sample funds for testing purposes.
         */
        class SampleFunds
        private constructor(
            private val originator: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("originator")
                @ExcludeMissing
                originator: JsonField<String> = JsonMissing.of()
            ) : this(originator, mutableMapOf())

            /**
             * Where the sample funds came from.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun originator(): String = originator.getRequired("originator")

            /**
             * Returns the raw JSON value of [originator].
             *
             * Unlike [originator], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("originator")
            @ExcludeMissing
            fun _originator(): JsonField<String> = originator

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [SampleFunds].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .originator()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [SampleFunds]. */
            class Builder internal constructor() {

                private var originator: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(sampleFunds: SampleFunds) = apply {
                    originator = sampleFunds.originator
                    additionalProperties = sampleFunds.additionalProperties.toMutableMap()
                }

                /** Where the sample funds came from. */
                fun originator(originator: String) = originator(JsonField.of(originator))

                /**
                 * Sets [Builder.originator] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.originator] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun originator(originator: JsonField<String>) = apply {
                    this.originator = originator
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [SampleFunds].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .originator()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): SampleFunds =
                    SampleFunds(
                        checkRequired("originator", originator),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): SampleFunds = apply {
                if (validated) {
                    return@apply
                }

                originator()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (originator.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is SampleFunds &&
                    originator == other.originator &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(originator, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "SampleFunds{originator=$originator, additionalProperties=$additionalProperties}"
        }

        /**
         * A Swift Transfer Intention object. This field will be present in the JSON response if and
         * only if `category` is equal to `swift_transfer_intention`. A Swift Transfer initiated via
         * Increase.
         */
        class SwiftTransferIntention
        private constructor(
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of()
            ) : this(transferId, mutableMapOf())

            /**
             * The identifier of the Swift Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [SwiftTransferIntention].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [SwiftTransferIntention]. */
            class Builder internal constructor() {

                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(swiftTransferIntention: SwiftTransferIntention) = apply {
                    transferId = swiftTransferIntention.transferId
                    additionalProperties =
                        swiftTransferIntention.additionalProperties.toMutableMap()
                }

                /** The identifier of the Swift Transfer that led to this Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [SwiftTransferIntention].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): SwiftTransferIntention =
                    SwiftTransferIntention(
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): SwiftTransferIntention = apply {
                if (validated) {
                    return@apply
                }

                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is SwiftTransferIntention &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(transferId, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "SwiftTransferIntention{transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Swift Transfer Return object. This field will be present in the JSON response if and
         * only if `category` is equal to `swift_transfer_return`. A Swift Transfer Return is
         * created when a Swift Transfer is returned by the receiving bank.
         */
        class SwiftTransferReturn
        private constructor(
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of()
            ) : this(transferId, mutableMapOf())

            /**
             * The identifier of the Swift Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [SwiftTransferReturn].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [SwiftTransferReturn]. */
            class Builder internal constructor() {

                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(swiftTransferReturn: SwiftTransferReturn) = apply {
                    transferId = swiftTransferReturn.transferId
                    additionalProperties = swiftTransferReturn.additionalProperties.toMutableMap()
                }

                /** The identifier of the Swift Transfer that led to this Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [SwiftTransferReturn].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): SwiftTransferReturn =
                    SwiftTransferReturn(
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): SwiftTransferReturn = apply {
                if (validated) {
                    return@apply
                }

                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is SwiftTransferReturn &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy { Objects.hash(transferId, additionalProperties) }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "SwiftTransferReturn{transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        /**
         * A Wire Transfer Intention object. This field will be present in the JSON response if and
         * only if `category` is equal to `wire_transfer_intention`. A Wire Transfer initiated via
         * Increase and sent to a different bank.
         */
        class WireTransferIntention
        private constructor(
            private val accountNumber: JsonField<String>,
            private val amount: JsonField<Long>,
            private val messageToRecipient: JsonField<String>,
            private val routingNumber: JsonField<String>,
            private val transferId: JsonField<String>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("account_number")
                @ExcludeMissing
                accountNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("message_to_recipient")
                @ExcludeMissing
                messageToRecipient: JsonField<String> = JsonMissing.of(),
                @JsonProperty("routing_number")
                @ExcludeMissing
                routingNumber: JsonField<String> = JsonMissing.of(),
                @JsonProperty("transfer_id")
                @ExcludeMissing
                transferId: JsonField<String> = JsonMissing.of(),
            ) : this(
                accountNumber,
                amount,
                messageToRecipient,
                routingNumber,
                transferId,
                mutableMapOf(),
            )

            /**
             * The destination account number.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun accountNumber(): String = accountNumber.getRequired("account_number")

            /**
             * The transfer amount in USD cents.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun amount(): Long = amount.getRequired("amount")

            /**
             * The message that will show on the recipient's bank statement.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun messageToRecipient(): String =
                messageToRecipient.getRequired("message_to_recipient")

            /**
             * The American Bankers' Association (ABA) Routing Transit Number (RTN).
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun routingNumber(): String = routingNumber.getRequired("routing_number")

            /**
             * The identifier of the Wire Transfer that led to this Transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun transferId(): String = transferId.getRequired("transfer_id")

            /**
             * Returns the raw JSON value of [accountNumber].
             *
             * Unlike [accountNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("account_number")
            @ExcludeMissing
            fun _accountNumber(): JsonField<String> = accountNumber

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [messageToRecipient].
             *
             * Unlike [messageToRecipient], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("message_to_recipient")
            @ExcludeMissing
            fun _messageToRecipient(): JsonField<String> = messageToRecipient

            /**
             * Returns the raw JSON value of [routingNumber].
             *
             * Unlike [routingNumber], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("routing_number")
            @ExcludeMissing
            fun _routingNumber(): JsonField<String> = routingNumber

            /**
             * Returns the raw JSON value of [transferId].
             *
             * Unlike [transferId], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("transfer_id")
            @ExcludeMissing
            fun _transferId(): JsonField<String> = transferId

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [WireTransferIntention].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accountNumber()
                 * .amount()
                 * .messageToRecipient()
                 * .routingNumber()
                 * .transferId()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [WireTransferIntention]. */
            class Builder internal constructor() {

                private var accountNumber: JsonField<String>? = null
                private var amount: JsonField<Long>? = null
                private var messageToRecipient: JsonField<String>? = null
                private var routingNumber: JsonField<String>? = null
                private var transferId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(wireTransferIntention: WireTransferIntention) = apply {
                    accountNumber = wireTransferIntention.accountNumber
                    amount = wireTransferIntention.amount
                    messageToRecipient = wireTransferIntention.messageToRecipient
                    routingNumber = wireTransferIntention.routingNumber
                    transferId = wireTransferIntention.transferId
                    additionalProperties = wireTransferIntention.additionalProperties.toMutableMap()
                }

                /** The destination account number. */
                fun accountNumber(accountNumber: String) =
                    accountNumber(JsonField.of(accountNumber))

                /**
                 * Sets [Builder.accountNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.accountNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun accountNumber(accountNumber: JsonField<String>) = apply {
                    this.accountNumber = accountNumber
                }

                /** The transfer amount in USD cents. */
                fun amount(amount: Long) = amount(JsonField.of(amount))

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The message that will show on the recipient's bank statement. */
                fun messageToRecipient(messageToRecipient: String) =
                    messageToRecipient(JsonField.of(messageToRecipient))

                /**
                 * Sets [Builder.messageToRecipient] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.messageToRecipient] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun messageToRecipient(messageToRecipient: JsonField<String>) = apply {
                    this.messageToRecipient = messageToRecipient
                }

                /** The American Bankers' Association (ABA) Routing Transit Number (RTN). */
                fun routingNumber(routingNumber: String) =
                    routingNumber(JsonField.of(routingNumber))

                /**
                 * Sets [Builder.routingNumber] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.routingNumber] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun routingNumber(routingNumber: JsonField<String>) = apply {
                    this.routingNumber = routingNumber
                }

                /** The identifier of the Wire Transfer that led to this Transaction. */
                fun transferId(transferId: String) = transferId(JsonField.of(transferId))

                /**
                 * Sets [Builder.transferId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.transferId] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun transferId(transferId: JsonField<String>) = apply {
                    this.transferId = transferId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [WireTransferIntention].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .accountNumber()
                 * .amount()
                 * .messageToRecipient()
                 * .routingNumber()
                 * .transferId()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): WireTransferIntention =
                    WireTransferIntention(
                        checkRequired("accountNumber", accountNumber),
                        checkRequired("amount", amount),
                        checkRequired("messageToRecipient", messageToRecipient),
                        checkRequired("routingNumber", routingNumber),
                        checkRequired("transferId", transferId),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): WireTransferIntention = apply {
                if (validated) {
                    return@apply
                }

                accountNumber()
                amount()
                messageToRecipient()
                routingNumber()
                transferId()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (accountNumber.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (if (messageToRecipient.asKnown() == null) 0 else 1) +
                    (if (routingNumber.asKnown() == null) 0 else 1) +
                    (if (transferId.asKnown() == null) 0 else 1)

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is WireTransferIntention &&
                    accountNumber == other.accountNumber &&
                    amount == other.amount &&
                    messageToRecipient == other.messageToRecipient &&
                    routingNumber == other.routingNumber &&
                    transferId == other.transferId &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    accountNumber,
                    amount,
                    messageToRecipient,
                    routingNumber,
                    transferId,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "WireTransferIntention{accountNumber=$accountNumber, amount=$amount, messageToRecipient=$messageToRecipient, routingNumber=$routingNumber, transferId=$transferId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Source &&
                accountRevenuePayment == other.accountRevenuePayment &&
                accountTransferIntention == other.accountTransferIntention &&
                achTransferIntention == other.achTransferIntention &&
                achTransferRejection == other.achTransferRejection &&
                achTransferReturn == other.achTransferReturn &&
                cardDisputeAcceptance == other.cardDisputeAcceptance &&
                cardDisputeFinancial == other.cardDisputeFinancial &&
                cardDisputeLoss == other.cardDisputeLoss &&
                cardPushTransferAcceptance == other.cardPushTransferAcceptance &&
                cardRefund == other.cardRefund &&
                cardRevenuePayment == other.cardRevenuePayment &&
                cardSettlement == other.cardSettlement &&
                cashbackPayment == other.cashbackPayment &&
                category == other.category &&
                checkDepositAcceptance == other.checkDepositAcceptance &&
                checkDepositReturn == other.checkDepositReturn &&
                checkTransferDeposit == other.checkTransferDeposit &&
                feePayment == other.feePayment &&
                inboundAchTransfer == other.inboundAchTransfer &&
                inboundAchTransferReturnIntention == other.inboundAchTransferReturnIntention &&
                inboundCheckAdjustment == other.inboundCheckAdjustment &&
                inboundCheckDepositReturnIntention == other.inboundCheckDepositReturnIntention &&
                inboundRealTimePaymentsTransferConfirmation ==
                    other.inboundRealTimePaymentsTransferConfirmation &&
                inboundWireReversal == other.inboundWireReversal &&
                inboundWireTransfer == other.inboundWireTransfer &&
                inboundWireTransferReversal == other.inboundWireTransferReversal &&
                interestPayment == other.interestPayment &&
                internalSource == other.internalSource &&
                this.other == other.other &&
                realTimePaymentsTransferAcknowledgement ==
                    other.realTimePaymentsTransferAcknowledgement &&
                sampleFunds == other.sampleFunds &&
                swiftTransferIntention == other.swiftTransferIntention &&
                swiftTransferReturn == other.swiftTransferReturn &&
                wireTransferIntention == other.wireTransferIntention &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                accountRevenuePayment,
                accountTransferIntention,
                achTransferIntention,
                achTransferRejection,
                achTransferReturn,
                cardDisputeAcceptance,
                cardDisputeFinancial,
                cardDisputeLoss,
                cardPushTransferAcceptance,
                cardRefund,
                cardRevenuePayment,
                cardSettlement,
                cashbackPayment,
                category,
                checkDepositAcceptance,
                checkDepositReturn,
                checkTransferDeposit,
                feePayment,
                inboundAchTransfer,
                inboundAchTransferReturnIntention,
                inboundCheckAdjustment,
                inboundCheckDepositReturnIntention,
                inboundRealTimePaymentsTransferConfirmation,
                inboundWireReversal,
                inboundWireTransfer,
                inboundWireTransferReversal,
                interestPayment,
                internalSource,
                other,
                realTimePaymentsTransferAcknowledgement,
                sampleFunds,
                swiftTransferIntention,
                swiftTransferReturn,
                wireTransferIntention,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Source{accountRevenuePayment=$accountRevenuePayment, accountTransferIntention=$accountTransferIntention, achTransferIntention=$achTransferIntention, achTransferRejection=$achTransferRejection, achTransferReturn=$achTransferReturn, cardDisputeAcceptance=$cardDisputeAcceptance, cardDisputeFinancial=$cardDisputeFinancial, cardDisputeLoss=$cardDisputeLoss, cardPushTransferAcceptance=$cardPushTransferAcceptance, cardRefund=$cardRefund, cardRevenuePayment=$cardRevenuePayment, cardSettlement=$cardSettlement, cashbackPayment=$cashbackPayment, category=$category, checkDepositAcceptance=$checkDepositAcceptance, checkDepositReturn=$checkDepositReturn, checkTransferDeposit=$checkTransferDeposit, feePayment=$feePayment, inboundAchTransfer=$inboundAchTransfer, inboundAchTransferReturnIntention=$inboundAchTransferReturnIntention, inboundCheckAdjustment=$inboundCheckAdjustment, inboundCheckDepositReturnIntention=$inboundCheckDepositReturnIntention, inboundRealTimePaymentsTransferConfirmation=$inboundRealTimePaymentsTransferConfirmation, inboundWireReversal=$inboundWireReversal, inboundWireTransfer=$inboundWireTransfer, inboundWireTransferReversal=$inboundWireTransferReversal, interestPayment=$interestPayment, internalSource=$internalSource, other=$other, realTimePaymentsTransferAcknowledgement=$realTimePaymentsTransferAcknowledgement, sampleFunds=$sampleFunds, swiftTransferIntention=$swiftTransferIntention, swiftTransferReturn=$swiftTransferReturn, wireTransferIntention=$wireTransferIntention, additionalProperties=$additionalProperties}"
    }

    /**
     * A constant representing the object's type. For this resource it will always be `transaction`.
     */
    class Type @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val TRANSACTION = of("transaction")

            fun of(value: String) = Type(JsonField.of(value))
        }

        /** An enum containing [Type]'s known values. */
        enum class Known {
            TRANSACTION
        }

        /**
         * An enum containing [Type]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Type] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            TRANSACTION,
            /** An enum member indicating that [Type] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                TRANSACTION -> Value.TRANSACTION
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws IncreaseInvalidDataException if this class instance's value is a not a known
         *   member.
         */
        fun known(): Known =
            when (this) {
                TRANSACTION -> Known.TRANSACTION
                else -> throw IncreaseInvalidDataException("Unknown Type: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws IncreaseInvalidDataException if this class instance's value does not have the
         *   expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): Type = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Type && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is Transaction &&
            id == other.id &&
            accountId == other.accountId &&
            amount == other.amount &&
            createdAt == other.createdAt &&
            currency == other.currency &&
            description == other.description &&
            routeId == other.routeId &&
            routeType == other.routeType &&
            source == other.source &&
            type == other.type &&
            additionalProperties == other.additionalProperties
    }

    private val hashCode: Int by lazy {
        Objects.hash(
            id,
            accountId,
            amount,
            createdAt,
            currency,
            description,
            routeId,
            routeType,
            source,
            type,
            additionalProperties,
        )
    }

    override fun hashCode(): Int = hashCode

    override fun toString() =
        "Transaction{id=$id, accountId=$accountId, amount=$amount, createdAt=$createdAt, currency=$currency, description=$description, routeId=$routeId, routeType=$routeType, source=$source, type=$type, additionalProperties=$additionalProperties}"
}
