// File generated from our OpenAPI spec by Stainless.

package com.increase.api.models.carddisputes

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.increase.api.core.Enum
import com.increase.api.core.ExcludeMissing
import com.increase.api.core.JsonField
import com.increase.api.core.JsonMissing
import com.increase.api.core.JsonValue
import com.increase.api.core.checkKnown
import com.increase.api.core.checkRequired
import com.increase.api.core.toImmutable
import com.increase.api.errors.IncreaseInvalidDataException
import java.time.LocalDate
import java.time.OffsetDateTime
import java.util.Collections
import java.util.Objects

/**
 * If unauthorized activity occurs on a card, you can create a Card Dispute and we'll work with the
 * card networks to return the funds if appropriate.
 */
class CardDispute
@JsonCreator(mode = JsonCreator.Mode.DISABLED)
private constructor(
    private val id: JsonField<String>,
    private val amount: JsonField<Long>,
    private val cardId: JsonField<String>,
    private val createdAt: JsonField<OffsetDateTime>,
    private val disputedTransactionId: JsonField<String>,
    private val idempotencyKey: JsonField<String>,
    private val loss: JsonField<Loss>,
    private val network: JsonField<Network>,
    private val status: JsonField<Status>,
    private val type: JsonField<Type>,
    private val userSubmissionRequiredBy: JsonField<OffsetDateTime>,
    private val visa: JsonField<Visa>,
    private val win: JsonField<Win>,
    private val additionalProperties: MutableMap<String, JsonValue>,
) {

    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("card_id") @ExcludeMissing cardId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("disputed_transaction_id")
        @ExcludeMissing
        disputedTransactionId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("idempotency_key")
        @ExcludeMissing
        idempotencyKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("loss") @ExcludeMissing loss: JsonField<Loss> = JsonMissing.of(),
        @JsonProperty("network") @ExcludeMissing network: JsonField<Network> = JsonMissing.of(),
        @JsonProperty("status") @ExcludeMissing status: JsonField<Status> = JsonMissing.of(),
        @JsonProperty("type") @ExcludeMissing type: JsonField<Type> = JsonMissing.of(),
        @JsonProperty("user_submission_required_by")
        @ExcludeMissing
        userSubmissionRequiredBy: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("visa") @ExcludeMissing visa: JsonField<Visa> = JsonMissing.of(),
        @JsonProperty("win") @ExcludeMissing win: JsonField<Win> = JsonMissing.of(),
    ) : this(
        id,
        amount,
        cardId,
        createdAt,
        disputedTransactionId,
        idempotencyKey,
        loss,
        network,
        status,
        type,
        userSubmissionRequiredBy,
        visa,
        win,
        mutableMapOf(),
    )

    /**
     * The Card Dispute identifier.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun id(): String = id.getRequired("id")

    /**
     * The amount of the dispute.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun amount(): Long = amount.getRequired("amount")

    /**
     * The Card that the Card Dispute is associated with.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun cardId(): String = cardId.getRequired("card_id")

    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the Card
     * Dispute was created.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

    /**
     * The identifier of the Transaction that was disputed.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun disputedTransactionId(): String =
        disputedTransactionId.getRequired("disputed_transaction_id")

    /**
     * The idempotency key you chose for this object. This value is unique across Increase and is
     * used to ensure that a request is only processed once. Learn more about
     * [idempotency](https://increase.com/documentation/idempotency-keys).
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun idempotencyKey(): String? = idempotencyKey.getNullable("idempotency_key")

    /**
     * If the Card Dispute's status is `lost`, this will contain details of the lost dispute.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun loss(): Loss? = loss.getNullable("loss")

    /**
     * The network that the Card Dispute is associated with.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun network(): Network = network.getRequired("network")

    /**
     * The status of the Card Dispute.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun status(): Status = status.getRequired("status")

    /**
     * A constant representing the object's type. For this resource it will always be
     * `card_dispute`.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun type(): Type = type.getRequired("type")

    /**
     * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the user
     * submission is required by. Present only if status is `user_submission_required` and a user
     * submission is required by a certain time. Otherwise, this will be `nil`.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun userSubmissionRequiredBy(): OffsetDateTime? =
        userSubmissionRequiredBy.getNullable("user_submission_required_by")

    /**
     * Card Dispute information for card payments processed over Visa's network. This field will be
     * present in the JSON response if and only if `network` is equal to `visa`.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun visa(): Visa? = visa.getNullable("visa")

    /**
     * If the Card Dispute's status is `won`, this will contain details of the won dispute.
     *
     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if the
     *   server responded with an unexpected value).
     */
    fun win(): Win? = win.getNullable("win")

    /**
     * Returns the raw JSON value of [id].
     *
     * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

    /**
     * Returns the raw JSON value of [amount].
     *
     * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

    /**
     * Returns the raw JSON value of [cardId].
     *
     * Unlike [cardId], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("card_id") @ExcludeMissing fun _cardId(): JsonField<String> = cardId

    /**
     * Returns the raw JSON value of [createdAt].
     *
     * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("created_at")
    @ExcludeMissing
    fun _createdAt(): JsonField<OffsetDateTime> = createdAt

    /**
     * Returns the raw JSON value of [disputedTransactionId].
     *
     * Unlike [disputedTransactionId], this method doesn't throw if the JSON field has an unexpected
     * type.
     */
    @JsonProperty("disputed_transaction_id")
    @ExcludeMissing
    fun _disputedTransactionId(): JsonField<String> = disputedTransactionId

    /**
     * Returns the raw JSON value of [idempotencyKey].
     *
     * Unlike [idempotencyKey], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("idempotency_key")
    @ExcludeMissing
    fun _idempotencyKey(): JsonField<String> = idempotencyKey

    /**
     * Returns the raw JSON value of [loss].
     *
     * Unlike [loss], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("loss") @ExcludeMissing fun _loss(): JsonField<Loss> = loss

    /**
     * Returns the raw JSON value of [network].
     *
     * Unlike [network], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("network") @ExcludeMissing fun _network(): JsonField<Network> = network

    /**
     * Returns the raw JSON value of [status].
     *
     * Unlike [status], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("status") @ExcludeMissing fun _status(): JsonField<Status> = status

    /**
     * Returns the raw JSON value of [type].
     *
     * Unlike [type], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("type") @ExcludeMissing fun _type(): JsonField<Type> = type

    /**
     * Returns the raw JSON value of [userSubmissionRequiredBy].
     *
     * Unlike [userSubmissionRequiredBy], this method doesn't throw if the JSON field has an
     * unexpected type.
     */
    @JsonProperty("user_submission_required_by")
    @ExcludeMissing
    fun _userSubmissionRequiredBy(): JsonField<OffsetDateTime> = userSubmissionRequiredBy

    /**
     * Returns the raw JSON value of [visa].
     *
     * Unlike [visa], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("visa") @ExcludeMissing fun _visa(): JsonField<Visa> = visa

    /**
     * Returns the raw JSON value of [win].
     *
     * Unlike [win], this method doesn't throw if the JSON field has an unexpected type.
     */
    @JsonProperty("win") @ExcludeMissing fun _win(): JsonField<Win> = win

    @JsonAnySetter
    private fun putAdditionalProperty(key: String, value: JsonValue) {
        additionalProperties.put(key, value)
    }

    @JsonAnyGetter
    @ExcludeMissing
    fun _additionalProperties(): Map<String, JsonValue> =
        Collections.unmodifiableMap(additionalProperties)

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of [CardDispute].
         *
         * The following fields are required:
         * ```kotlin
         * .id()
         * .amount()
         * .cardId()
         * .createdAt()
         * .disputedTransactionId()
         * .idempotencyKey()
         * .loss()
         * .network()
         * .status()
         * .type()
         * .userSubmissionRequiredBy()
         * .visa()
         * .win()
         * ```
         */
        fun builder() = Builder()
    }

    /** A builder for [CardDispute]. */
    class Builder internal constructor() {

        private var id: JsonField<String>? = null
        private var amount: JsonField<Long>? = null
        private var cardId: JsonField<String>? = null
        private var createdAt: JsonField<OffsetDateTime>? = null
        private var disputedTransactionId: JsonField<String>? = null
        private var idempotencyKey: JsonField<String>? = null
        private var loss: JsonField<Loss>? = null
        private var network: JsonField<Network>? = null
        private var status: JsonField<Status>? = null
        private var type: JsonField<Type>? = null
        private var userSubmissionRequiredBy: JsonField<OffsetDateTime>? = null
        private var visa: JsonField<Visa>? = null
        private var win: JsonField<Win>? = null
        private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

        internal fun from(cardDispute: CardDispute) = apply {
            id = cardDispute.id
            amount = cardDispute.amount
            cardId = cardDispute.cardId
            createdAt = cardDispute.createdAt
            disputedTransactionId = cardDispute.disputedTransactionId
            idempotencyKey = cardDispute.idempotencyKey
            loss = cardDispute.loss
            network = cardDispute.network
            status = cardDispute.status
            type = cardDispute.type
            userSubmissionRequiredBy = cardDispute.userSubmissionRequiredBy
            visa = cardDispute.visa
            win = cardDispute.win
            additionalProperties = cardDispute.additionalProperties.toMutableMap()
        }

        /** The Card Dispute identifier. */
        fun id(id: String) = id(JsonField.of(id))

        /**
         * Sets [Builder.id] to an arbitrary JSON value.
         *
         * You should usually call [Builder.id] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun id(id: JsonField<String>) = apply { this.id = id }

        /** The amount of the dispute. */
        fun amount(amount: Long) = amount(JsonField.of(amount))

        /**
         * Sets [Builder.amount] to an arbitrary JSON value.
         *
         * You should usually call [Builder.amount] with a well-typed [Long] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

        /** The Card that the Card Dispute is associated with. */
        fun cardId(cardId: String) = cardId(JsonField.of(cardId))

        /**
         * Sets [Builder.cardId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.cardId] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun cardId(cardId: JsonField<String>) = apply { this.cardId = cardId }

        /**
         * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the Card
         * Dispute was created.
         */
        fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

        /**
         * Sets [Builder.createdAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply { this.createdAt = createdAt }

        /** The identifier of the Transaction that was disputed. */
        fun disputedTransactionId(disputedTransactionId: String) =
            disputedTransactionId(JsonField.of(disputedTransactionId))

        /**
         * Sets [Builder.disputedTransactionId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.disputedTransactionId] with a well-typed [String] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun disputedTransactionId(disputedTransactionId: JsonField<String>) = apply {
            this.disputedTransactionId = disputedTransactionId
        }

        /**
         * The idempotency key you chose for this object. This value is unique across Increase and
         * is used to ensure that a request is only processed once. Learn more about
         * [idempotency](https://increase.com/documentation/idempotency-keys).
         */
        fun idempotencyKey(idempotencyKey: String?) =
            idempotencyKey(JsonField.ofNullable(idempotencyKey))

        /**
         * Sets [Builder.idempotencyKey] to an arbitrary JSON value.
         *
         * You should usually call [Builder.idempotencyKey] with a well-typed [String] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun idempotencyKey(idempotencyKey: JsonField<String>) = apply {
            this.idempotencyKey = idempotencyKey
        }

        /**
         * If the Card Dispute's status is `lost`, this will contain details of the lost dispute.
         */
        fun loss(loss: Loss?) = loss(JsonField.ofNullable(loss))

        /**
         * Sets [Builder.loss] to an arbitrary JSON value.
         *
         * You should usually call [Builder.loss] with a well-typed [Loss] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun loss(loss: JsonField<Loss>) = apply { this.loss = loss }

        /** The network that the Card Dispute is associated with. */
        fun network(network: Network) = network(JsonField.of(network))

        /**
         * Sets [Builder.network] to an arbitrary JSON value.
         *
         * You should usually call [Builder.network] with a well-typed [Network] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun network(network: JsonField<Network>) = apply { this.network = network }

        /** The status of the Card Dispute. */
        fun status(status: Status) = status(JsonField.of(status))

        /**
         * Sets [Builder.status] to an arbitrary JSON value.
         *
         * You should usually call [Builder.status] with a well-typed [Status] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun status(status: JsonField<Status>) = apply { this.status = status }

        /**
         * A constant representing the object's type. For this resource it will always be
         * `card_dispute`.
         */
        fun type(type: Type) = type(JsonField.of(type))

        /**
         * Sets [Builder.type] to an arbitrary JSON value.
         *
         * You should usually call [Builder.type] with a well-typed [Type] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun type(type: JsonField<Type>) = apply { this.type = type }

        /**
         * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the user
         * submission is required by. Present only if status is `user_submission_required` and a
         * user submission is required by a certain time. Otherwise, this will be `nil`.
         */
        fun userSubmissionRequiredBy(userSubmissionRequiredBy: OffsetDateTime?) =
            userSubmissionRequiredBy(JsonField.ofNullable(userSubmissionRequiredBy))

        /**
         * Sets [Builder.userSubmissionRequiredBy] to an arbitrary JSON value.
         *
         * You should usually call [Builder.userSubmissionRequiredBy] with a well-typed
         * [OffsetDateTime] value instead. This method is primarily for setting the field to an
         * undocumented or not yet supported value.
         */
        fun userSubmissionRequiredBy(userSubmissionRequiredBy: JsonField<OffsetDateTime>) = apply {
            this.userSubmissionRequiredBy = userSubmissionRequiredBy
        }

        /**
         * Card Dispute information for card payments processed over Visa's network. This field will
         * be present in the JSON response if and only if `network` is equal to `visa`.
         */
        fun visa(visa: Visa?) = visa(JsonField.ofNullable(visa))

        /**
         * Sets [Builder.visa] to an arbitrary JSON value.
         *
         * You should usually call [Builder.visa] with a well-typed [Visa] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun visa(visa: JsonField<Visa>) = apply { this.visa = visa }

        /** If the Card Dispute's status is `won`, this will contain details of the won dispute. */
        fun win(win: Win?) = win(JsonField.ofNullable(win))

        /**
         * Sets [Builder.win] to an arbitrary JSON value.
         *
         * You should usually call [Builder.win] with a well-typed [Win] value instead. This method
         * is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun win(win: JsonField<Win>) = apply { this.win = win }

        fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.clear()
            putAllAdditionalProperties(additionalProperties)
        }

        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
            additionalProperties.put(key, value)
        }

        fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
            this.additionalProperties.putAll(additionalProperties)
        }

        fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
            keys.forEach(::removeAdditionalProperty)
        }

        /**
         * Returns an immutable instance of [CardDispute].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```kotlin
         * .id()
         * .amount()
         * .cardId()
         * .createdAt()
         * .disputedTransactionId()
         * .idempotencyKey()
         * .loss()
         * .network()
         * .status()
         * .type()
         * .userSubmissionRequiredBy()
         * .visa()
         * .win()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): CardDispute =
            CardDispute(
                checkRequired("id", id),
                checkRequired("amount", amount),
                checkRequired("cardId", cardId),
                checkRequired("createdAt", createdAt),
                checkRequired("disputedTransactionId", disputedTransactionId),
                checkRequired("idempotencyKey", idempotencyKey),
                checkRequired("loss", loss),
                checkRequired("network", network),
                checkRequired("status", status),
                checkRequired("type", type),
                checkRequired("userSubmissionRequiredBy", userSubmissionRequiredBy),
                checkRequired("visa", visa),
                checkRequired("win", win),
                additionalProperties.toMutableMap(),
            )
    }

    private var validated: Boolean = false

    fun validate(): CardDispute = apply {
        if (validated) {
            return@apply
        }

        id()
        amount()
        cardId()
        createdAt()
        disputedTransactionId()
        idempotencyKey()
        loss()?.validate()
        network().validate()
        status().validate()
        type().validate()
        userSubmissionRequiredBy()
        visa()?.validate()
        win()?.validate()
        validated = true
    }

    fun isValid(): Boolean =
        try {
            validate()
            true
        } catch (e: IncreaseInvalidDataException) {
            false
        }

    /**
     * Returns a score indicating how many valid values are contained in this object recursively.
     *
     * Used for best match union deserialization.
     */
    internal fun validity(): Int =
        (if (id.asKnown() == null) 0 else 1) +
            (if (amount.asKnown() == null) 0 else 1) +
            (if (cardId.asKnown() == null) 0 else 1) +
            (if (createdAt.asKnown() == null) 0 else 1) +
            (if (disputedTransactionId.asKnown() == null) 0 else 1) +
            (if (idempotencyKey.asKnown() == null) 0 else 1) +
            (loss.asKnown()?.validity() ?: 0) +
            (network.asKnown()?.validity() ?: 0) +
            (status.asKnown()?.validity() ?: 0) +
            (type.asKnown()?.validity() ?: 0) +
            (if (userSubmissionRequiredBy.asKnown() == null) 0 else 1) +
            (visa.asKnown()?.validity() ?: 0) +
            (win.asKnown()?.validity() ?: 0)

    /** If the Card Dispute's status is `lost`, this will contain details of the lost dispute. */
    class Loss
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val lostAt: JsonField<OffsetDateTime>,
        private val reason: JsonField<Reason>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("lost_at")
            @ExcludeMissing
            lostAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("reason") @ExcludeMissing reason: JsonField<Reason> = JsonMissing.of(),
        ) : this(lostAt, reason, mutableMapOf())

        /**
         * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the Card
         * Dispute was lost.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun lostAt(): OffsetDateTime = lostAt.getRequired("lost_at")

        /**
         * The reason the Card Dispute was lost.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun reason(): Reason = reason.getRequired("reason")

        /**
         * Returns the raw JSON value of [lostAt].
         *
         * Unlike [lostAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("lost_at") @ExcludeMissing fun _lostAt(): JsonField<OffsetDateTime> = lostAt

        /**
         * Returns the raw JSON value of [reason].
         *
         * Unlike [reason], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<Reason> = reason

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Loss].
             *
             * The following fields are required:
             * ```kotlin
             * .lostAt()
             * .reason()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Loss]. */
        class Builder internal constructor() {

            private var lostAt: JsonField<OffsetDateTime>? = null
            private var reason: JsonField<Reason>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(loss: Loss) = apply {
                lostAt = loss.lostAt
                reason = loss.reason
                additionalProperties = loss.additionalProperties.toMutableMap()
            }

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * Card Dispute was lost.
             */
            fun lostAt(lostAt: OffsetDateTime) = lostAt(JsonField.of(lostAt))

            /**
             * Sets [Builder.lostAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.lostAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun lostAt(lostAt: JsonField<OffsetDateTime>) = apply { this.lostAt = lostAt }

            /** The reason the Card Dispute was lost. */
            fun reason(reason: Reason) = reason(JsonField.of(reason))

            /**
             * Sets [Builder.reason] to an arbitrary JSON value.
             *
             * You should usually call [Builder.reason] with a well-typed [Reason] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Loss].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .lostAt()
             * .reason()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Loss =
                Loss(
                    checkRequired("lostAt", lostAt),
                    checkRequired("reason", reason),
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Loss = apply {
            if (validated) {
                return@apply
            }

            lostAt()
            reason().validate()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (if (lostAt.asKnown() == null) 0 else 1) + (reason.asKnown()?.validity() ?: 0)

        /** The reason the Card Dispute was lost. */
        class Reason @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                /** The user withdrew the Card Dispute. */
                val USER_WITHDRAWN = of("user_withdrawn")

                /** The Card Dispute was lost according to network rules. */
                val LOSS = of("loss")

                fun of(value: String) = Reason(JsonField.of(value))
            }

            /** An enum containing [Reason]'s known values. */
            enum class Known {
                /** The user withdrew the Card Dispute. */
                USER_WITHDRAWN,
                /** The Card Dispute was lost according to network rules. */
                LOSS,
            }

            /**
             * An enum containing [Reason]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Reason] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                /** The user withdrew the Card Dispute. */
                USER_WITHDRAWN,
                /** The Card Dispute was lost according to network rules. */
                LOSS,
                /**
                 * An enum member indicating that [Reason] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USER_WITHDRAWN -> Value.USER_WITHDRAWN
                    LOSS -> Value.LOSS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws IncreaseInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USER_WITHDRAWN -> Known.USER_WITHDRAWN
                    LOSS -> Known.LOSS
                    else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws IncreaseInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): Reason = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Reason && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Loss &&
                lostAt == other.lostAt &&
                reason == other.reason &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy { Objects.hash(lostAt, reason, additionalProperties) }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Loss{lostAt=$lostAt, reason=$reason, additionalProperties=$additionalProperties}"
    }

    /** The network that the Card Dispute is associated with. */
    class Network @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            /** Visa: details will be under the `visa` object. */
            val VISA = of("visa")

            /** Pulse: details will be under the `pulse` object. */
            val PULSE = of("pulse")

            fun of(value: String) = Network(JsonField.of(value))
        }

        /** An enum containing [Network]'s known values. */
        enum class Known {
            /** Visa: details will be under the `visa` object. */
            VISA,
            /** Pulse: details will be under the `pulse` object. */
            PULSE,
        }

        /**
         * An enum containing [Network]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Network] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            /** Visa: details will be under the `visa` object. */
            VISA,
            /** Pulse: details will be under the `pulse` object. */
            PULSE,
            /** An enum member indicating that [Network] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                VISA -> Value.VISA
                PULSE -> Value.PULSE
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws IncreaseInvalidDataException if this class instance's value is a not a known
         *   member.
         */
        fun known(): Known =
            when (this) {
                VISA -> Known.VISA
                PULSE -> Known.PULSE
                else -> throw IncreaseInvalidDataException("Unknown Network: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws IncreaseInvalidDataException if this class instance's value does not have the
         *   expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): Network = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Network && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /** The status of the Card Dispute. */
    class Status @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            /** A User Submission is required to continue with the Card Dispute. */
            val USER_SUBMISSION_REQUIRED = of("user_submission_required")

            /** The most recent User Submission is being reviewed. */
            val PENDING_USER_SUBMISSION_REVIEWING = of("pending_user_submission_reviewing")

            /** The most recent User Submission is being submitted to the network. */
            val PENDING_USER_SUBMISSION_SUBMITTING = of("pending_user_submission_submitting")

            /** The user's withdrawal of the Card Dispute is being submitted to the network. */
            val PENDING_USER_WITHDRAWAL_SUBMITTING = of("pending_user_withdrawal_submitting")

            /** The Card Dispute is pending a response from the network. */
            val PENDING_RESPONSE = of("pending_response")

            /**
             * The Card Dispute has been lost and funds previously credited from the acceptance have
             * been debited.
             */
            val LOST = of("lost")

            /** The Card Dispute has been won and no further action can be taken. */
            val WON = of("won")

            fun of(value: String) = Status(JsonField.of(value))
        }

        /** An enum containing [Status]'s known values. */
        enum class Known {
            /** A User Submission is required to continue with the Card Dispute. */
            USER_SUBMISSION_REQUIRED,
            /** The most recent User Submission is being reviewed. */
            PENDING_USER_SUBMISSION_REVIEWING,
            /** The most recent User Submission is being submitted to the network. */
            PENDING_USER_SUBMISSION_SUBMITTING,
            /** The user's withdrawal of the Card Dispute is being submitted to the network. */
            PENDING_USER_WITHDRAWAL_SUBMITTING,
            /** The Card Dispute is pending a response from the network. */
            PENDING_RESPONSE,
            /**
             * The Card Dispute has been lost and funds previously credited from the acceptance have
             * been debited.
             */
            LOST,
            /** The Card Dispute has been won and no further action can be taken. */
            WON,
        }

        /**
         * An enum containing [Status]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Status] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            /** A User Submission is required to continue with the Card Dispute. */
            USER_SUBMISSION_REQUIRED,
            /** The most recent User Submission is being reviewed. */
            PENDING_USER_SUBMISSION_REVIEWING,
            /** The most recent User Submission is being submitted to the network. */
            PENDING_USER_SUBMISSION_SUBMITTING,
            /** The user's withdrawal of the Card Dispute is being submitted to the network. */
            PENDING_USER_WITHDRAWAL_SUBMITTING,
            /** The Card Dispute is pending a response from the network. */
            PENDING_RESPONSE,
            /**
             * The Card Dispute has been lost and funds previously credited from the acceptance have
             * been debited.
             */
            LOST,
            /** The Card Dispute has been won and no further action can be taken. */
            WON,
            /** An enum member indicating that [Status] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                USER_SUBMISSION_REQUIRED -> Value.USER_SUBMISSION_REQUIRED
                PENDING_USER_SUBMISSION_REVIEWING -> Value.PENDING_USER_SUBMISSION_REVIEWING
                PENDING_USER_SUBMISSION_SUBMITTING -> Value.PENDING_USER_SUBMISSION_SUBMITTING
                PENDING_USER_WITHDRAWAL_SUBMITTING -> Value.PENDING_USER_WITHDRAWAL_SUBMITTING
                PENDING_RESPONSE -> Value.PENDING_RESPONSE
                LOST -> Value.LOST
                WON -> Value.WON
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws IncreaseInvalidDataException if this class instance's value is a not a known
         *   member.
         */
        fun known(): Known =
            when (this) {
                USER_SUBMISSION_REQUIRED -> Known.USER_SUBMISSION_REQUIRED
                PENDING_USER_SUBMISSION_REVIEWING -> Known.PENDING_USER_SUBMISSION_REVIEWING
                PENDING_USER_SUBMISSION_SUBMITTING -> Known.PENDING_USER_SUBMISSION_SUBMITTING
                PENDING_USER_WITHDRAWAL_SUBMITTING -> Known.PENDING_USER_WITHDRAWAL_SUBMITTING
                PENDING_RESPONSE -> Known.PENDING_RESPONSE
                LOST -> Known.LOST
                WON -> Known.WON
                else -> throw IncreaseInvalidDataException("Unknown Status: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws IncreaseInvalidDataException if this class instance's value does not have the
         *   expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): Status = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Status && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /**
     * A constant representing the object's type. For this resource it will always be
     * `card_dispute`.
     */
    class Type @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            val CARD_DISPUTE = of("card_dispute")

            fun of(value: String) = Type(JsonField.of(value))
        }

        /** An enum containing [Type]'s known values. */
        enum class Known {
            CARD_DISPUTE
        }

        /**
         * An enum containing [Type]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [Type] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            CARD_DISPUTE,
            /** An enum member indicating that [Type] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                CARD_DISPUTE -> Value.CARD_DISPUTE
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws IncreaseInvalidDataException if this class instance's value is a not a known
         *   member.
         */
        fun known(): Known =
            when (this) {
                CARD_DISPUTE -> Known.CARD_DISPUTE
                else -> throw IncreaseInvalidDataException("Unknown Type: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws IncreaseInvalidDataException if this class instance's value does not have the
         *   expected primitive type.
         */
        fun asString(): String =
            _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

        private var validated: Boolean = false

        fun validate(): Type = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Type && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    /**
     * Card Dispute information for card payments processed over Visa's network. This field will be
     * present in the JSON response if and only if `network` is equal to `visa`.
     */
    class Visa
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val networkEvents: JsonField<List<NetworkEvent>>,
        private val requiredUserSubmissionCategory: JsonField<RequiredUserSubmissionCategory>,
        private val userSubmissions: JsonField<List<UserSubmission>>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("network_events")
            @ExcludeMissing
            networkEvents: JsonField<List<NetworkEvent>> = JsonMissing.of(),
            @JsonProperty("required_user_submission_category")
            @ExcludeMissing
            requiredUserSubmissionCategory: JsonField<RequiredUserSubmissionCategory> =
                JsonMissing.of(),
            @JsonProperty("user_submissions")
            @ExcludeMissing
            userSubmissions: JsonField<List<UserSubmission>> = JsonMissing.of(),
        ) : this(networkEvents, requiredUserSubmissionCategory, userSubmissions, mutableMapOf())

        /**
         * The network events for the Card Dispute.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun networkEvents(): List<NetworkEvent> = networkEvents.getRequired("network_events")

        /**
         * The category of the currently required user submission if the user wishes to proceed with
         * the dispute. Present if and only if status is `user_submission_required`. Otherwise, this
         * will be `nil`.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g. if
         *   the server responded with an unexpected value).
         */
        fun requiredUserSubmissionCategory(): RequiredUserSubmissionCategory? =
            requiredUserSubmissionCategory.getNullable("required_user_submission_category")

        /**
         * The user submissions for the Card Dispute.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun userSubmissions(): List<UserSubmission> =
            userSubmissions.getRequired("user_submissions")

        /**
         * Returns the raw JSON value of [networkEvents].
         *
         * Unlike [networkEvents], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("network_events")
        @ExcludeMissing
        fun _networkEvents(): JsonField<List<NetworkEvent>> = networkEvents

        /**
         * Returns the raw JSON value of [requiredUserSubmissionCategory].
         *
         * Unlike [requiredUserSubmissionCategory], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("required_user_submission_category")
        @ExcludeMissing
        fun _requiredUserSubmissionCategory(): JsonField<RequiredUserSubmissionCategory> =
            requiredUserSubmissionCategory

        /**
         * Returns the raw JSON value of [userSubmissions].
         *
         * Unlike [userSubmissions], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("user_submissions")
        @ExcludeMissing
        fun _userSubmissions(): JsonField<List<UserSubmission>> = userSubmissions

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Visa].
             *
             * The following fields are required:
             * ```kotlin
             * .networkEvents()
             * .requiredUserSubmissionCategory()
             * .userSubmissions()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Visa]. */
        class Builder internal constructor() {

            private var networkEvents: JsonField<MutableList<NetworkEvent>>? = null
            private var requiredUserSubmissionCategory: JsonField<RequiredUserSubmissionCategory>? =
                null
            private var userSubmissions: JsonField<MutableList<UserSubmission>>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(visa: Visa) = apply {
                networkEvents = visa.networkEvents.map { it.toMutableList() }
                requiredUserSubmissionCategory = visa.requiredUserSubmissionCategory
                userSubmissions = visa.userSubmissions.map { it.toMutableList() }
                additionalProperties = visa.additionalProperties.toMutableMap()
            }

            /** The network events for the Card Dispute. */
            fun networkEvents(networkEvents: List<NetworkEvent>) =
                networkEvents(JsonField.of(networkEvents))

            /**
             * Sets [Builder.networkEvents] to an arbitrary JSON value.
             *
             * You should usually call [Builder.networkEvents] with a well-typed
             * `List<NetworkEvent>` value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun networkEvents(networkEvents: JsonField<List<NetworkEvent>>) = apply {
                this.networkEvents = networkEvents.map { it.toMutableList() }
            }

            /**
             * Adds a single [NetworkEvent] to [networkEvents].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addNetworkEvent(networkEvent: NetworkEvent) = apply {
                networkEvents =
                    (networkEvents ?: JsonField.of(mutableListOf())).also {
                        checkKnown("networkEvents", it).add(networkEvent)
                    }
            }

            /**
             * The category of the currently required user submission if the user wishes to proceed
             * with the dispute. Present if and only if status is `user_submission_required`.
             * Otherwise, this will be `nil`.
             */
            fun requiredUserSubmissionCategory(
                requiredUserSubmissionCategory: RequiredUserSubmissionCategory?
            ) = requiredUserSubmissionCategory(JsonField.ofNullable(requiredUserSubmissionCategory))

            /**
             * Sets [Builder.requiredUserSubmissionCategory] to an arbitrary JSON value.
             *
             * You should usually call [Builder.requiredUserSubmissionCategory] with a well-typed
             * [RequiredUserSubmissionCategory] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun requiredUserSubmissionCategory(
                requiredUserSubmissionCategory: JsonField<RequiredUserSubmissionCategory>
            ) = apply { this.requiredUserSubmissionCategory = requiredUserSubmissionCategory }

            /** The user submissions for the Card Dispute. */
            fun userSubmissions(userSubmissions: List<UserSubmission>) =
                userSubmissions(JsonField.of(userSubmissions))

            /**
             * Sets [Builder.userSubmissions] to an arbitrary JSON value.
             *
             * You should usually call [Builder.userSubmissions] with a well-typed
             * `List<UserSubmission>` value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun userSubmissions(userSubmissions: JsonField<List<UserSubmission>>) = apply {
                this.userSubmissions = userSubmissions.map { it.toMutableList() }
            }

            /**
             * Adds a single [UserSubmission] to [userSubmissions].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addUserSubmission(userSubmission: UserSubmission) = apply {
                userSubmissions =
                    (userSubmissions ?: JsonField.of(mutableListOf())).also {
                        checkKnown("userSubmissions", it).add(userSubmission)
                    }
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Visa].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .networkEvents()
             * .requiredUserSubmissionCategory()
             * .userSubmissions()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Visa =
                Visa(
                    checkRequired("networkEvents", networkEvents).map { it.toImmutable() },
                    checkRequired("requiredUserSubmissionCategory", requiredUserSubmissionCategory),
                    checkRequired("userSubmissions", userSubmissions).map { it.toImmutable() },
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Visa = apply {
            if (validated) {
                return@apply
            }

            networkEvents().forEach { it.validate() }
            requiredUserSubmissionCategory()?.validate()
            userSubmissions().forEach { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int =
            (networkEvents.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                (requiredUserSubmissionCategory.asKnown()?.validity() ?: 0) +
                (userSubmissions.asKnown()?.sumOf { it.validity().toInt() } ?: 0)

        class NetworkEvent
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val attachmentFiles: JsonField<List<AttachmentFile>>,
            private val category: JsonField<Category>,
            private val chargebackAccepted: JsonValue,
            private val chargebackSubmitted: JsonValue,
            private val chargebackTimedOut: JsonValue,
            private val createdAt: JsonField<OffsetDateTime>,
            private val disputeFinancialTransactionId: JsonField<String>,
            private val merchantPrearbitrationDeclineSubmitted: JsonValue,
            private val merchantPrearbitrationReceived: JsonField<MerchantPrearbitrationReceived>,
            private val merchantPrearbitrationTimedOut: JsonValue,
            private val represented: JsonField<Represented>,
            private val representmentTimedOut: JsonValue,
            private val userPrearbitrationAccepted: JsonValue,
            private val userPrearbitrationDeclined: JsonValue,
            private val userPrearbitrationSubmitted: JsonValue,
            private val userPrearbitrationTimedOut: JsonValue,
            private val userWithdrawalSubmitted: JsonValue,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("attachment_files")
                @ExcludeMissing
                attachmentFiles: JsonField<List<AttachmentFile>> = JsonMissing.of(),
                @JsonProperty("category")
                @ExcludeMissing
                category: JsonField<Category> = JsonMissing.of(),
                @JsonProperty("chargeback_accepted")
                @ExcludeMissing
                chargebackAccepted: JsonValue = JsonMissing.of(),
                @JsonProperty("chargeback_submitted")
                @ExcludeMissing
                chargebackSubmitted: JsonValue = JsonMissing.of(),
                @JsonProperty("chargeback_timed_out")
                @ExcludeMissing
                chargebackTimedOut: JsonValue = JsonMissing.of(),
                @JsonProperty("created_at")
                @ExcludeMissing
                createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("dispute_financial_transaction_id")
                @ExcludeMissing
                disputeFinancialTransactionId: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_prearbitration_decline_submitted")
                @ExcludeMissing
                merchantPrearbitrationDeclineSubmitted: JsonValue = JsonMissing.of(),
                @JsonProperty("merchant_prearbitration_received")
                @ExcludeMissing
                merchantPrearbitrationReceived: JsonField<MerchantPrearbitrationReceived> =
                    JsonMissing.of(),
                @JsonProperty("merchant_prearbitration_timed_out")
                @ExcludeMissing
                merchantPrearbitrationTimedOut: JsonValue = JsonMissing.of(),
                @JsonProperty("represented")
                @ExcludeMissing
                represented: JsonField<Represented> = JsonMissing.of(),
                @JsonProperty("representment_timed_out")
                @ExcludeMissing
                representmentTimedOut: JsonValue = JsonMissing.of(),
                @JsonProperty("user_prearbitration_accepted")
                @ExcludeMissing
                userPrearbitrationAccepted: JsonValue = JsonMissing.of(),
                @JsonProperty("user_prearbitration_declined")
                @ExcludeMissing
                userPrearbitrationDeclined: JsonValue = JsonMissing.of(),
                @JsonProperty("user_prearbitration_submitted")
                @ExcludeMissing
                userPrearbitrationSubmitted: JsonValue = JsonMissing.of(),
                @JsonProperty("user_prearbitration_timed_out")
                @ExcludeMissing
                userPrearbitrationTimedOut: JsonValue = JsonMissing.of(),
                @JsonProperty("user_withdrawal_submitted")
                @ExcludeMissing
                userWithdrawalSubmitted: JsonValue = JsonMissing.of(),
            ) : this(
                attachmentFiles,
                category,
                chargebackAccepted,
                chargebackSubmitted,
                chargebackTimedOut,
                createdAt,
                disputeFinancialTransactionId,
                merchantPrearbitrationDeclineSubmitted,
                merchantPrearbitrationReceived,
                merchantPrearbitrationTimedOut,
                represented,
                representmentTimedOut,
                userPrearbitrationAccepted,
                userPrearbitrationDeclined,
                userPrearbitrationSubmitted,
                userPrearbitrationTimedOut,
                userWithdrawalSubmitted,
                mutableMapOf(),
            )

            /**
             * The files attached to the Visa Card Dispute User Submission.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun attachmentFiles(): List<AttachmentFile> =
                attachmentFiles.getRequired("attachment_files")

            /**
             * The category of the user submission. We may add additional possible values for this
             * enum over time; your application should be able to handle such additions gracefully.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun category(): Category = category.getRequired("category")

            /**
             * A Card Dispute Chargeback Accepted Visa Network Event object. This field will be
             * present in the JSON response if and only if `category` is equal to
             * `chargeback_accepted`. Contains the details specific to a chargeback accepted Visa
             * Card Dispute Network Event, which represents that a chargeback has been accepted by
             * the merchant.
             */
            @JsonProperty("chargeback_accepted")
            @ExcludeMissing
            fun _chargebackAccepted(): JsonValue = chargebackAccepted

            /**
             * A Card Dispute Chargeback Submitted Visa Network Event object. This field will be
             * present in the JSON response if and only if `category` is equal to
             * `chargeback_submitted`. Contains the details specific to a chargeback submitted Visa
             * Card Dispute Network Event, which represents that a chargeback has been submitted to
             * the network.
             */
            @JsonProperty("chargeback_submitted")
            @ExcludeMissing
            fun _chargebackSubmitted(): JsonValue = chargebackSubmitted

            /**
             * A Card Dispute Chargeback Timed Out Visa Network Event object. This field will be
             * present in the JSON response if and only if `category` is equal to
             * `chargeback_timed_out`. Contains the details specific to a chargeback timed out Visa
             * Card Dispute Network Event, which represents that the chargeback has timed out in the
             * user's favor.
             */
            @JsonProperty("chargeback_timed_out")
            @ExcludeMissing
            fun _chargebackTimedOut(): JsonValue = chargebackTimedOut

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * Visa Card Dispute Network Event was created.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

            /**
             * The dispute financial transaction that resulted from the network event, if any.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun disputeFinancialTransactionId(): String? =
                disputeFinancialTransactionId.getNullable("dispute_financial_transaction_id")

            /**
             * A Card Dispute Merchant Pre-Arbitration Decline Submitted Visa Network Event object.
             * This field will be present in the JSON response if and only if `category` is equal to
             * `merchant_prearbitration_decline_submitted`. Contains the details specific to a
             * merchant prearbitration decline submitted Visa Card Dispute Network Event, which
             * represents that the user has declined the merchant's request for a prearbitration
             * request decision in their favor.
             */
            @JsonProperty("merchant_prearbitration_decline_submitted")
            @ExcludeMissing
            fun _merchantPrearbitrationDeclineSubmitted(): JsonValue =
                merchantPrearbitrationDeclineSubmitted

            /**
             * A Card Dispute Merchant Pre-Arbitration Received Visa Network Event object. This
             * field will be present in the JSON response if and only if `category` is equal to
             * `merchant_prearbitration_received`. Contains the details specific to a merchant
             * prearbitration received Visa Card Dispute Network Event, which represents that the
             * merchant has issued a prearbitration request in the user's favor.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun merchantPrearbitrationReceived(): MerchantPrearbitrationReceived? =
                merchantPrearbitrationReceived.getNullable("merchant_prearbitration_received")

            /**
             * A Card Dispute Merchant Pre-Arbitration Timed Out Visa Network Event object. This
             * field will be present in the JSON response if and only if `category` is equal to
             * `merchant_prearbitration_timed_out`. Contains the details specific to a merchant
             * prearbitration timed out Visa Card Dispute Network Event, which represents that the
             * user has timed out responding to the merchant's prearbitration request.
             */
            @JsonProperty("merchant_prearbitration_timed_out")
            @ExcludeMissing
            fun _merchantPrearbitrationTimedOut(): JsonValue = merchantPrearbitrationTimedOut

            /**
             * A Card Dispute Re-presented Visa Network Event object. This field will be present in
             * the JSON response if and only if `category` is equal to `represented`. Contains the
             * details specific to a re-presented Visa Card Dispute Network Event, which represents
             * that the merchant has declined the user's chargeback and has re-presented the
             * payment.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun represented(): Represented? = represented.getNullable("represented")

            /**
             * A Card Dispute Re-presentment Timed Out Visa Network Event object. This field will be
             * present in the JSON response if and only if `category` is equal to
             * `representment_timed_out`. Contains the details specific to a re-presentment time-out
             * Visa Card Dispute Network Event, which represents that the user did not respond to
             * the re-presentment by the merchant within the time limit.
             */
            @JsonProperty("representment_timed_out")
            @ExcludeMissing
            fun _representmentTimedOut(): JsonValue = representmentTimedOut

            /**
             * A Card Dispute User Pre-Arbitration Accepted Visa Network Event object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `user_prearbitration_accepted`. Contains the details specific to a user
             * prearbitration accepted Visa Card Dispute Network Event, which represents that the
             * merchant has accepted the user's prearbitration request in the user's favor.
             */
            @JsonProperty("user_prearbitration_accepted")
            @ExcludeMissing
            fun _userPrearbitrationAccepted(): JsonValue = userPrearbitrationAccepted

            /**
             * A Card Dispute User Pre-Arbitration Declined Visa Network Event object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `user_prearbitration_declined`. Contains the details specific to a user
             * prearbitration declined Visa Card Dispute Network Event, which represents that the
             * merchant has declined the user's prearbitration request.
             */
            @JsonProperty("user_prearbitration_declined")
            @ExcludeMissing
            fun _userPrearbitrationDeclined(): JsonValue = userPrearbitrationDeclined

            /**
             * A Card Dispute User Pre-Arbitration Submitted Visa Network Event object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `user_prearbitration_submitted`. Contains the details specific to a user
             * prearbitration submitted Visa Card Dispute Network Event, which represents that the
             * user's request for prearbitration has been submitted to the network.
             */
            @JsonProperty("user_prearbitration_submitted")
            @ExcludeMissing
            fun _userPrearbitrationSubmitted(): JsonValue = userPrearbitrationSubmitted

            /**
             * A Card Dispute User Pre-Arbitration Timed Out Visa Network Event object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `user_prearbitration_timed_out`. Contains the details specific to a user
             * prearbitration timed out Visa Card Dispute Network Event, which represents that the
             * merchant has timed out responding to the user's prearbitration request.
             */
            @JsonProperty("user_prearbitration_timed_out")
            @ExcludeMissing
            fun _userPrearbitrationTimedOut(): JsonValue = userPrearbitrationTimedOut

            /**
             * A Card Dispute User Withdrawal Submitted Visa Network Event object. This field will
             * be present in the JSON response if and only if `category` is equal to
             * `user_withdrawal_submitted`. Contains the details specific to a user withdrawal
             * submitted Visa Card Dispute Network Event, which represents that the user's request
             * to withdraw the dispute has been submitted to the network.
             */
            @JsonProperty("user_withdrawal_submitted")
            @ExcludeMissing
            fun _userWithdrawalSubmitted(): JsonValue = userWithdrawalSubmitted

            /**
             * Returns the raw JSON value of [attachmentFiles].
             *
             * Unlike [attachmentFiles], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("attachment_files")
            @ExcludeMissing
            fun _attachmentFiles(): JsonField<List<AttachmentFile>> = attachmentFiles

            /**
             * Returns the raw JSON value of [category].
             *
             * Unlike [category], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("category")
            @ExcludeMissing
            fun _category(): JsonField<Category> = category

            /**
             * Returns the raw JSON value of [createdAt].
             *
             * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("created_at")
            @ExcludeMissing
            fun _createdAt(): JsonField<OffsetDateTime> = createdAt

            /**
             * Returns the raw JSON value of [disputeFinancialTransactionId].
             *
             * Unlike [disputeFinancialTransactionId], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("dispute_financial_transaction_id")
            @ExcludeMissing
            fun _disputeFinancialTransactionId(): JsonField<String> = disputeFinancialTransactionId

            /**
             * Returns the raw JSON value of [merchantPrearbitrationReceived].
             *
             * Unlike [merchantPrearbitrationReceived], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("merchant_prearbitration_received")
            @ExcludeMissing
            fun _merchantPrearbitrationReceived(): JsonField<MerchantPrearbitrationReceived> =
                merchantPrearbitrationReceived

            /**
             * Returns the raw JSON value of [represented].
             *
             * Unlike [represented], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("represented")
            @ExcludeMissing
            fun _represented(): JsonField<Represented> = represented

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [NetworkEvent].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .attachmentFiles()
                 * .category()
                 * .chargebackAccepted()
                 * .chargebackSubmitted()
                 * .chargebackTimedOut()
                 * .createdAt()
                 * .disputeFinancialTransactionId()
                 * .merchantPrearbitrationDeclineSubmitted()
                 * .merchantPrearbitrationReceived()
                 * .merchantPrearbitrationTimedOut()
                 * .represented()
                 * .representmentTimedOut()
                 * .userPrearbitrationAccepted()
                 * .userPrearbitrationDeclined()
                 * .userPrearbitrationSubmitted()
                 * .userPrearbitrationTimedOut()
                 * .userWithdrawalSubmitted()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [NetworkEvent]. */
            class Builder internal constructor() {

                private var attachmentFiles: JsonField<MutableList<AttachmentFile>>? = null
                private var category: JsonField<Category>? = null
                private var chargebackAccepted: JsonValue? = null
                private var chargebackSubmitted: JsonValue? = null
                private var chargebackTimedOut: JsonValue? = null
                private var createdAt: JsonField<OffsetDateTime>? = null
                private var disputeFinancialTransactionId: JsonField<String>? = null
                private var merchantPrearbitrationDeclineSubmitted: JsonValue? = null
                private var merchantPrearbitrationReceived:
                    JsonField<MerchantPrearbitrationReceived>? =
                    null
                private var merchantPrearbitrationTimedOut: JsonValue? = null
                private var represented: JsonField<Represented>? = null
                private var representmentTimedOut: JsonValue? = null
                private var userPrearbitrationAccepted: JsonValue? = null
                private var userPrearbitrationDeclined: JsonValue? = null
                private var userPrearbitrationSubmitted: JsonValue? = null
                private var userPrearbitrationTimedOut: JsonValue? = null
                private var userWithdrawalSubmitted: JsonValue? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(networkEvent: NetworkEvent) = apply {
                    attachmentFiles = networkEvent.attachmentFiles.map { it.toMutableList() }
                    category = networkEvent.category
                    chargebackAccepted = networkEvent.chargebackAccepted
                    chargebackSubmitted = networkEvent.chargebackSubmitted
                    chargebackTimedOut = networkEvent.chargebackTimedOut
                    createdAt = networkEvent.createdAt
                    disputeFinancialTransactionId = networkEvent.disputeFinancialTransactionId
                    merchantPrearbitrationDeclineSubmitted =
                        networkEvent.merchantPrearbitrationDeclineSubmitted
                    merchantPrearbitrationReceived = networkEvent.merchantPrearbitrationReceived
                    merchantPrearbitrationTimedOut = networkEvent.merchantPrearbitrationTimedOut
                    represented = networkEvent.represented
                    representmentTimedOut = networkEvent.representmentTimedOut
                    userPrearbitrationAccepted = networkEvent.userPrearbitrationAccepted
                    userPrearbitrationDeclined = networkEvent.userPrearbitrationDeclined
                    userPrearbitrationSubmitted = networkEvent.userPrearbitrationSubmitted
                    userPrearbitrationTimedOut = networkEvent.userPrearbitrationTimedOut
                    userWithdrawalSubmitted = networkEvent.userWithdrawalSubmitted
                    additionalProperties = networkEvent.additionalProperties.toMutableMap()
                }

                /** The files attached to the Visa Card Dispute User Submission. */
                fun attachmentFiles(attachmentFiles: List<AttachmentFile>) =
                    attachmentFiles(JsonField.of(attachmentFiles))

                /**
                 * Sets [Builder.attachmentFiles] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.attachmentFiles] with a well-typed
                 * `List<AttachmentFile>` value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun attachmentFiles(attachmentFiles: JsonField<List<AttachmentFile>>) = apply {
                    this.attachmentFiles = attachmentFiles.map { it.toMutableList() }
                }

                /**
                 * Adds a single [AttachmentFile] to [attachmentFiles].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAttachmentFile(attachmentFile: AttachmentFile) = apply {
                    attachmentFiles =
                        (attachmentFiles ?: JsonField.of(mutableListOf())).also {
                            checkKnown("attachmentFiles", it).add(attachmentFile)
                        }
                }

                /**
                 * The category of the user submission. We may add additional possible values for
                 * this enum over time; your application should be able to handle such additions
                 * gracefully.
                 */
                fun category(category: Category) = category(JsonField.of(category))

                /**
                 * Sets [Builder.category] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.category] with a well-typed [Category] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun category(category: JsonField<Category>) = apply { this.category = category }

                /**
                 * A Card Dispute Chargeback Accepted Visa Network Event object. This field will be
                 * present in the JSON response if and only if `category` is equal to
                 * `chargeback_accepted`. Contains the details specific to a chargeback accepted
                 * Visa Card Dispute Network Event, which represents that a chargeback has been
                 * accepted by the merchant.
                 */
                fun chargebackAccepted(chargebackAccepted: JsonValue) = apply {
                    this.chargebackAccepted = chargebackAccepted
                }

                /**
                 * A Card Dispute Chargeback Submitted Visa Network Event object. This field will be
                 * present in the JSON response if and only if `category` is equal to
                 * `chargeback_submitted`. Contains the details specific to a chargeback submitted
                 * Visa Card Dispute Network Event, which represents that a chargeback has been
                 * submitted to the network.
                 */
                fun chargebackSubmitted(chargebackSubmitted: JsonValue) = apply {
                    this.chargebackSubmitted = chargebackSubmitted
                }

                /**
                 * A Card Dispute Chargeback Timed Out Visa Network Event object. This field will be
                 * present in the JSON response if and only if `category` is equal to
                 * `chargeback_timed_out`. Contains the details specific to a chargeback timed out
                 * Visa Card Dispute Network Event, which represents that the chargeback has timed
                 * out in the user's favor.
                 */
                fun chargebackTimedOut(chargebackTimedOut: JsonValue) = apply {
                    this.chargebackTimedOut = chargebackTimedOut
                }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * Visa Card Dispute Network Event was created.
                 */
                fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

                /**
                 * Sets [Builder.createdAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                    this.createdAt = createdAt
                }

                /**
                 * The dispute financial transaction that resulted from the network event, if any.
                 */
                fun disputeFinancialTransactionId(disputeFinancialTransactionId: String?) =
                    disputeFinancialTransactionId(
                        JsonField.ofNullable(disputeFinancialTransactionId)
                    )

                /**
                 * Sets [Builder.disputeFinancialTransactionId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.disputeFinancialTransactionId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun disputeFinancialTransactionId(
                    disputeFinancialTransactionId: JsonField<String>
                ) = apply { this.disputeFinancialTransactionId = disputeFinancialTransactionId }

                /**
                 * A Card Dispute Merchant Pre-Arbitration Decline Submitted Visa Network Event
                 * object. This field will be present in the JSON response if and only if `category`
                 * is equal to `merchant_prearbitration_decline_submitted`. Contains the details
                 * specific to a merchant prearbitration decline submitted Visa Card Dispute Network
                 * Event, which represents that the user has declined the merchant's request for a
                 * prearbitration request decision in their favor.
                 */
                fun merchantPrearbitrationDeclineSubmitted(
                    merchantPrearbitrationDeclineSubmitted: JsonValue
                ) = apply {
                    this.merchantPrearbitrationDeclineSubmitted =
                        merchantPrearbitrationDeclineSubmitted
                }

                /**
                 * A Card Dispute Merchant Pre-Arbitration Received Visa Network Event object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `merchant_prearbitration_received`. Contains the details specific to a merchant
                 * prearbitration received Visa Card Dispute Network Event, which represents that
                 * the merchant has issued a prearbitration request in the user's favor.
                 */
                fun merchantPrearbitrationReceived(
                    merchantPrearbitrationReceived: MerchantPrearbitrationReceived?
                ) =
                    merchantPrearbitrationReceived(
                        JsonField.ofNullable(merchantPrearbitrationReceived)
                    )

                /**
                 * Sets [Builder.merchantPrearbitrationReceived] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantPrearbitrationReceived] with a
                 * well-typed [MerchantPrearbitrationReceived] value instead. This method is
                 * primarily for setting the field to an undocumented or not yet supported value.
                 */
                fun merchantPrearbitrationReceived(
                    merchantPrearbitrationReceived: JsonField<MerchantPrearbitrationReceived>
                ) = apply { this.merchantPrearbitrationReceived = merchantPrearbitrationReceived }

                /**
                 * A Card Dispute Merchant Pre-Arbitration Timed Out Visa Network Event object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `merchant_prearbitration_timed_out`. Contains the details specific to a merchant
                 * prearbitration timed out Visa Card Dispute Network Event, which represents that
                 * the user has timed out responding to the merchant's prearbitration request.
                 */
                fun merchantPrearbitrationTimedOut(merchantPrearbitrationTimedOut: JsonValue) =
                    apply {
                        this.merchantPrearbitrationTimedOut = merchantPrearbitrationTimedOut
                    }

                /**
                 * A Card Dispute Re-presented Visa Network Event object. This field will be present
                 * in the JSON response if and only if `category` is equal to `represented`.
                 * Contains the details specific to a re-presented Visa Card Dispute Network Event,
                 * which represents that the merchant has declined the user's chargeback and has
                 * re-presented the payment.
                 */
                fun represented(represented: Represented?) =
                    represented(JsonField.ofNullable(represented))

                /**
                 * Sets [Builder.represented] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.represented] with a well-typed [Represented]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun represented(represented: JsonField<Represented>) = apply {
                    this.represented = represented
                }

                /**
                 * A Card Dispute Re-presentment Timed Out Visa Network Event object. This field
                 * will be present in the JSON response if and only if `category` is equal to
                 * `representment_timed_out`. Contains the details specific to a re-presentment
                 * time-out Visa Card Dispute Network Event, which represents that the user did not
                 * respond to the re-presentment by the merchant within the time limit.
                 */
                fun representmentTimedOut(representmentTimedOut: JsonValue) = apply {
                    this.representmentTimedOut = representmentTimedOut
                }

                /**
                 * A Card Dispute User Pre-Arbitration Accepted Visa Network Event object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `user_prearbitration_accepted`. Contains the details specific to a user
                 * prearbitration accepted Visa Card Dispute Network Event, which represents that
                 * the merchant has accepted the user's prearbitration request in the user's favor.
                 */
                fun userPrearbitrationAccepted(userPrearbitrationAccepted: JsonValue) = apply {
                    this.userPrearbitrationAccepted = userPrearbitrationAccepted
                }

                /**
                 * A Card Dispute User Pre-Arbitration Declined Visa Network Event object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `user_prearbitration_declined`. Contains the details specific to a user
                 * prearbitration declined Visa Card Dispute Network Event, which represents that
                 * the merchant has declined the user's prearbitration request.
                 */
                fun userPrearbitrationDeclined(userPrearbitrationDeclined: JsonValue) = apply {
                    this.userPrearbitrationDeclined = userPrearbitrationDeclined
                }

                /**
                 * A Card Dispute User Pre-Arbitration Submitted Visa Network Event object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `user_prearbitration_submitted`. Contains the details specific to a user
                 * prearbitration submitted Visa Card Dispute Network Event, which represents that
                 * the user's request for prearbitration has been submitted to the network.
                 */
                fun userPrearbitrationSubmitted(userPrearbitrationSubmitted: JsonValue) = apply {
                    this.userPrearbitrationSubmitted = userPrearbitrationSubmitted
                }

                /**
                 * A Card Dispute User Pre-Arbitration Timed Out Visa Network Event object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `user_prearbitration_timed_out`. Contains the details specific to a user
                 * prearbitration timed out Visa Card Dispute Network Event, which represents that
                 * the merchant has timed out responding to the user's prearbitration request.
                 */
                fun userPrearbitrationTimedOut(userPrearbitrationTimedOut: JsonValue) = apply {
                    this.userPrearbitrationTimedOut = userPrearbitrationTimedOut
                }

                /**
                 * A Card Dispute User Withdrawal Submitted Visa Network Event object. This field
                 * will be present in the JSON response if and only if `category` is equal to
                 * `user_withdrawal_submitted`. Contains the details specific to a user withdrawal
                 * submitted Visa Card Dispute Network Event, which represents that the user's
                 * request to withdraw the dispute has been submitted to the network.
                 */
                fun userWithdrawalSubmitted(userWithdrawalSubmitted: JsonValue) = apply {
                    this.userWithdrawalSubmitted = userWithdrawalSubmitted
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [NetworkEvent].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .attachmentFiles()
                 * .category()
                 * .chargebackAccepted()
                 * .chargebackSubmitted()
                 * .chargebackTimedOut()
                 * .createdAt()
                 * .disputeFinancialTransactionId()
                 * .merchantPrearbitrationDeclineSubmitted()
                 * .merchantPrearbitrationReceived()
                 * .merchantPrearbitrationTimedOut()
                 * .represented()
                 * .representmentTimedOut()
                 * .userPrearbitrationAccepted()
                 * .userPrearbitrationDeclined()
                 * .userPrearbitrationSubmitted()
                 * .userPrearbitrationTimedOut()
                 * .userWithdrawalSubmitted()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): NetworkEvent =
                    NetworkEvent(
                        checkRequired("attachmentFiles", attachmentFiles).map { it.toImmutable() },
                        checkRequired("category", category),
                        checkRequired("chargebackAccepted", chargebackAccepted),
                        checkRequired("chargebackSubmitted", chargebackSubmitted),
                        checkRequired("chargebackTimedOut", chargebackTimedOut),
                        checkRequired("createdAt", createdAt),
                        checkRequired(
                            "disputeFinancialTransactionId",
                            disputeFinancialTransactionId,
                        ),
                        checkRequired(
                            "merchantPrearbitrationDeclineSubmitted",
                            merchantPrearbitrationDeclineSubmitted,
                        ),
                        checkRequired(
                            "merchantPrearbitrationReceived",
                            merchantPrearbitrationReceived,
                        ),
                        checkRequired(
                            "merchantPrearbitrationTimedOut",
                            merchantPrearbitrationTimedOut,
                        ),
                        checkRequired("represented", represented),
                        checkRequired("representmentTimedOut", representmentTimedOut),
                        checkRequired("userPrearbitrationAccepted", userPrearbitrationAccepted),
                        checkRequired("userPrearbitrationDeclined", userPrearbitrationDeclined),
                        checkRequired("userPrearbitrationSubmitted", userPrearbitrationSubmitted),
                        checkRequired("userPrearbitrationTimedOut", userPrearbitrationTimedOut),
                        checkRequired("userWithdrawalSubmitted", userWithdrawalSubmitted),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): NetworkEvent = apply {
                if (validated) {
                    return@apply
                }

                attachmentFiles().forEach { it.validate() }
                category().validate()
                createdAt()
                disputeFinancialTransactionId()
                merchantPrearbitrationReceived()?.validate()
                represented()?.validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (attachmentFiles.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (category.asKnown()?.validity() ?: 0) +
                    (if (createdAt.asKnown() == null) 0 else 1) +
                    (if (disputeFinancialTransactionId.asKnown() == null) 0 else 1) +
                    (merchantPrearbitrationReceived.asKnown()?.validity() ?: 0) +
                    (represented.asKnown()?.validity() ?: 0)

            class AttachmentFile
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val fileId: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("file_id")
                    @ExcludeMissing
                    fileId: JsonField<String> = JsonMissing.of()
                ) : this(fileId, mutableMapOf())

                /**
                 * The ID of the file attached to the Card Dispute.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun fileId(): String = fileId.getRequired("file_id")

                /**
                 * Returns the raw JSON value of [fileId].
                 *
                 * Unlike [fileId], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("file_id") @ExcludeMissing fun _fileId(): JsonField<String> = fileId

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [AttachmentFile].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .fileId()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [AttachmentFile]. */
                class Builder internal constructor() {

                    private var fileId: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(attachmentFile: AttachmentFile) = apply {
                        fileId = attachmentFile.fileId
                        additionalProperties = attachmentFile.additionalProperties.toMutableMap()
                    }

                    /** The ID of the file attached to the Card Dispute. */
                    fun fileId(fileId: String) = fileId(JsonField.of(fileId))

                    /**
                     * Sets [Builder.fileId] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.fileId] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun fileId(fileId: JsonField<String>) = apply { this.fileId = fileId }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [AttachmentFile].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .fileId()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): AttachmentFile =
                        AttachmentFile(
                            checkRequired("fileId", fileId),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): AttachmentFile = apply {
                    if (validated) {
                        return@apply
                    }

                    fileId()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = (if (fileId.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is AttachmentFile &&
                        fileId == other.fileId &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy { Objects.hash(fileId, additionalProperties) }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "AttachmentFile{fileId=$fileId, additionalProperties=$additionalProperties}"
            }

            /**
             * The category of the user submission. We may add additional possible values for this
             * enum over time; your application should be able to handle such additions gracefully.
             */
            class Category @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /**
                     * Card Dispute Chargeback Accepted Visa Network Event: details will be under
                     * the `chargeback_accepted` object.
                     */
                    val CHARGEBACK_ACCEPTED = of("chargeback_accepted")

                    /**
                     * Card Dispute Chargeback Submitted Visa Network Event: details will be under
                     * the `chargeback_submitted` object.
                     */
                    val CHARGEBACK_SUBMITTED = of("chargeback_submitted")

                    /**
                     * Card Dispute Chargeback Timed Out Visa Network Event: details will be under
                     * the `chargeback_timed_out` object.
                     */
                    val CHARGEBACK_TIMED_OUT = of("chargeback_timed_out")

                    /**
                     * Card Dispute Merchant Pre-Arbitration Decline Submitted Visa Network Event:
                     * details will be under the `merchant_prearbitration_decline_submitted` object.
                     */
                    val MERCHANT_PREARBITRATION_DECLINE_SUBMITTED =
                        of("merchant_prearbitration_decline_submitted")

                    /**
                     * Card Dispute Merchant Pre-Arbitration Received Visa Network Event: details
                     * will be under the `merchant_prearbitration_received` object.
                     */
                    val MERCHANT_PREARBITRATION_RECEIVED = of("merchant_prearbitration_received")

                    /**
                     * Card Dispute Merchant Pre-Arbitration Timed Out Visa Network Event: details
                     * will be under the `merchant_prearbitration_timed_out` object.
                     */
                    val MERCHANT_PREARBITRATION_TIMED_OUT = of("merchant_prearbitration_timed_out")

                    /**
                     * Card Dispute Re-presented Visa Network Event: details will be under the
                     * `represented` object.
                     */
                    val REPRESENTED = of("represented")

                    /**
                     * Card Dispute Re-presentment Timed Out Visa Network Event: details will be
                     * under the `representment_timed_out` object.
                     */
                    val REPRESENTMENT_TIMED_OUT = of("representment_timed_out")

                    /**
                     * Card Dispute User Pre-Arbitration Accepted Visa Network Event: details will
                     * be under the `user_prearbitration_accepted` object.
                     */
                    val USER_PREARBITRATION_ACCEPTED = of("user_prearbitration_accepted")

                    /**
                     * Card Dispute User Pre-Arbitration Declined Visa Network Event: details will
                     * be under the `user_prearbitration_declined` object.
                     */
                    val USER_PREARBITRATION_DECLINED = of("user_prearbitration_declined")

                    /**
                     * Card Dispute User Pre-Arbitration Submitted Visa Network Event: details will
                     * be under the `user_prearbitration_submitted` object.
                     */
                    val USER_PREARBITRATION_SUBMITTED = of("user_prearbitration_submitted")

                    /**
                     * Card Dispute User Pre-Arbitration Timed Out Visa Network Event: details will
                     * be under the `user_prearbitration_timed_out` object.
                     */
                    val USER_PREARBITRATION_TIMED_OUT = of("user_prearbitration_timed_out")

                    /**
                     * Card Dispute User Withdrawal Submitted Visa Network Event: details will be
                     * under the `user_withdrawal_submitted` object.
                     */
                    val USER_WITHDRAWAL_SUBMITTED = of("user_withdrawal_submitted")

                    fun of(value: String) = Category(JsonField.of(value))
                }

                /** An enum containing [Category]'s known values. */
                enum class Known {
                    /**
                     * Card Dispute Chargeback Accepted Visa Network Event: details will be under
                     * the `chargeback_accepted` object.
                     */
                    CHARGEBACK_ACCEPTED,
                    /**
                     * Card Dispute Chargeback Submitted Visa Network Event: details will be under
                     * the `chargeback_submitted` object.
                     */
                    CHARGEBACK_SUBMITTED,
                    /**
                     * Card Dispute Chargeback Timed Out Visa Network Event: details will be under
                     * the `chargeback_timed_out` object.
                     */
                    CHARGEBACK_TIMED_OUT,
                    /**
                     * Card Dispute Merchant Pre-Arbitration Decline Submitted Visa Network Event:
                     * details will be under the `merchant_prearbitration_decline_submitted` object.
                     */
                    MERCHANT_PREARBITRATION_DECLINE_SUBMITTED,
                    /**
                     * Card Dispute Merchant Pre-Arbitration Received Visa Network Event: details
                     * will be under the `merchant_prearbitration_received` object.
                     */
                    MERCHANT_PREARBITRATION_RECEIVED,
                    /**
                     * Card Dispute Merchant Pre-Arbitration Timed Out Visa Network Event: details
                     * will be under the `merchant_prearbitration_timed_out` object.
                     */
                    MERCHANT_PREARBITRATION_TIMED_OUT,
                    /**
                     * Card Dispute Re-presented Visa Network Event: details will be under the
                     * `represented` object.
                     */
                    REPRESENTED,
                    /**
                     * Card Dispute Re-presentment Timed Out Visa Network Event: details will be
                     * under the `representment_timed_out` object.
                     */
                    REPRESENTMENT_TIMED_OUT,
                    /**
                     * Card Dispute User Pre-Arbitration Accepted Visa Network Event: details will
                     * be under the `user_prearbitration_accepted` object.
                     */
                    USER_PREARBITRATION_ACCEPTED,
                    /**
                     * Card Dispute User Pre-Arbitration Declined Visa Network Event: details will
                     * be under the `user_prearbitration_declined` object.
                     */
                    USER_PREARBITRATION_DECLINED,
                    /**
                     * Card Dispute User Pre-Arbitration Submitted Visa Network Event: details will
                     * be under the `user_prearbitration_submitted` object.
                     */
                    USER_PREARBITRATION_SUBMITTED,
                    /**
                     * Card Dispute User Pre-Arbitration Timed Out Visa Network Event: details will
                     * be under the `user_prearbitration_timed_out` object.
                     */
                    USER_PREARBITRATION_TIMED_OUT,
                    /**
                     * Card Dispute User Withdrawal Submitted Visa Network Event: details will be
                     * under the `user_withdrawal_submitted` object.
                     */
                    USER_WITHDRAWAL_SUBMITTED,
                }

                /**
                 * An enum containing [Category]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Category] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /**
                     * Card Dispute Chargeback Accepted Visa Network Event: details will be under
                     * the `chargeback_accepted` object.
                     */
                    CHARGEBACK_ACCEPTED,
                    /**
                     * Card Dispute Chargeback Submitted Visa Network Event: details will be under
                     * the `chargeback_submitted` object.
                     */
                    CHARGEBACK_SUBMITTED,
                    /**
                     * Card Dispute Chargeback Timed Out Visa Network Event: details will be under
                     * the `chargeback_timed_out` object.
                     */
                    CHARGEBACK_TIMED_OUT,
                    /**
                     * Card Dispute Merchant Pre-Arbitration Decline Submitted Visa Network Event:
                     * details will be under the `merchant_prearbitration_decline_submitted` object.
                     */
                    MERCHANT_PREARBITRATION_DECLINE_SUBMITTED,
                    /**
                     * Card Dispute Merchant Pre-Arbitration Received Visa Network Event: details
                     * will be under the `merchant_prearbitration_received` object.
                     */
                    MERCHANT_PREARBITRATION_RECEIVED,
                    /**
                     * Card Dispute Merchant Pre-Arbitration Timed Out Visa Network Event: details
                     * will be under the `merchant_prearbitration_timed_out` object.
                     */
                    MERCHANT_PREARBITRATION_TIMED_OUT,
                    /**
                     * Card Dispute Re-presented Visa Network Event: details will be under the
                     * `represented` object.
                     */
                    REPRESENTED,
                    /**
                     * Card Dispute Re-presentment Timed Out Visa Network Event: details will be
                     * under the `representment_timed_out` object.
                     */
                    REPRESENTMENT_TIMED_OUT,
                    /**
                     * Card Dispute User Pre-Arbitration Accepted Visa Network Event: details will
                     * be under the `user_prearbitration_accepted` object.
                     */
                    USER_PREARBITRATION_ACCEPTED,
                    /**
                     * Card Dispute User Pre-Arbitration Declined Visa Network Event: details will
                     * be under the `user_prearbitration_declined` object.
                     */
                    USER_PREARBITRATION_DECLINED,
                    /**
                     * Card Dispute User Pre-Arbitration Submitted Visa Network Event: details will
                     * be under the `user_prearbitration_submitted` object.
                     */
                    USER_PREARBITRATION_SUBMITTED,
                    /**
                     * Card Dispute User Pre-Arbitration Timed Out Visa Network Event: details will
                     * be under the `user_prearbitration_timed_out` object.
                     */
                    USER_PREARBITRATION_TIMED_OUT,
                    /**
                     * Card Dispute User Withdrawal Submitted Visa Network Event: details will be
                     * under the `user_withdrawal_submitted` object.
                     */
                    USER_WITHDRAWAL_SUBMITTED,
                    /**
                     * An enum member indicating that [Category] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CHARGEBACK_ACCEPTED -> Value.CHARGEBACK_ACCEPTED
                        CHARGEBACK_SUBMITTED -> Value.CHARGEBACK_SUBMITTED
                        CHARGEBACK_TIMED_OUT -> Value.CHARGEBACK_TIMED_OUT
                        MERCHANT_PREARBITRATION_DECLINE_SUBMITTED ->
                            Value.MERCHANT_PREARBITRATION_DECLINE_SUBMITTED
                        MERCHANT_PREARBITRATION_RECEIVED -> Value.MERCHANT_PREARBITRATION_RECEIVED
                        MERCHANT_PREARBITRATION_TIMED_OUT -> Value.MERCHANT_PREARBITRATION_TIMED_OUT
                        REPRESENTED -> Value.REPRESENTED
                        REPRESENTMENT_TIMED_OUT -> Value.REPRESENTMENT_TIMED_OUT
                        USER_PREARBITRATION_ACCEPTED -> Value.USER_PREARBITRATION_ACCEPTED
                        USER_PREARBITRATION_DECLINED -> Value.USER_PREARBITRATION_DECLINED
                        USER_PREARBITRATION_SUBMITTED -> Value.USER_PREARBITRATION_SUBMITTED
                        USER_PREARBITRATION_TIMED_OUT -> Value.USER_PREARBITRATION_TIMED_OUT
                        USER_WITHDRAWAL_SUBMITTED -> Value.USER_WITHDRAWAL_SUBMITTED
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CHARGEBACK_ACCEPTED -> Known.CHARGEBACK_ACCEPTED
                        CHARGEBACK_SUBMITTED -> Known.CHARGEBACK_SUBMITTED
                        CHARGEBACK_TIMED_OUT -> Known.CHARGEBACK_TIMED_OUT
                        MERCHANT_PREARBITRATION_DECLINE_SUBMITTED ->
                            Known.MERCHANT_PREARBITRATION_DECLINE_SUBMITTED
                        MERCHANT_PREARBITRATION_RECEIVED -> Known.MERCHANT_PREARBITRATION_RECEIVED
                        MERCHANT_PREARBITRATION_TIMED_OUT -> Known.MERCHANT_PREARBITRATION_TIMED_OUT
                        REPRESENTED -> Known.REPRESENTED
                        REPRESENTMENT_TIMED_OUT -> Known.REPRESENTMENT_TIMED_OUT
                        USER_PREARBITRATION_ACCEPTED -> Known.USER_PREARBITRATION_ACCEPTED
                        USER_PREARBITRATION_DECLINED -> Known.USER_PREARBITRATION_DECLINED
                        USER_PREARBITRATION_SUBMITTED -> Known.USER_PREARBITRATION_SUBMITTED
                        USER_PREARBITRATION_TIMED_OUT -> Known.USER_PREARBITRATION_TIMED_OUT
                        USER_WITHDRAWAL_SUBMITTED -> Known.USER_WITHDRAWAL_SUBMITTED
                        else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Category = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Category && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * A Card Dispute Merchant Pre-Arbitration Received Visa Network Event object. This
             * field will be present in the JSON response if and only if `category` is equal to
             * `merchant_prearbitration_received`. Contains the details specific to a merchant
             * prearbitration received Visa Card Dispute Network Event, which represents that the
             * merchant has issued a prearbitration request in the user's favor.
             */
            class MerchantPrearbitrationReceived
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes>,
                private val compellingEvidence: JsonField<CompellingEvidence>,
                private val creditOrReversalProcessed: JsonField<CreditOrReversalProcessed>,
                private val delayedChargeTransaction: JsonField<DelayedChargeTransaction>,
                private val evidenceOfImprint: JsonField<EvidenceOfImprint>,
                private val invalidDispute: JsonField<InvalidDispute>,
                private val nonFiatCurrencyOrNonFungibleTokenReceived:
                    JsonField<NonFiatCurrencyOrNonFungibleTokenReceived>,
                private val priorUndisputedNonFraudTransactions:
                    JsonField<PriorUndisputedNonFraudTransactions>,
                private val reason: JsonField<Reason>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cardholder_no_longer_disputes")
                    @ExcludeMissing
                    cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes> =
                        JsonMissing.of(),
                    @JsonProperty("compelling_evidence")
                    @ExcludeMissing
                    compellingEvidence: JsonField<CompellingEvidence> = JsonMissing.of(),
                    @JsonProperty("credit_or_reversal_processed")
                    @ExcludeMissing
                    creditOrReversalProcessed: JsonField<CreditOrReversalProcessed> =
                        JsonMissing.of(),
                    @JsonProperty("delayed_charge_transaction")
                    @ExcludeMissing
                    delayedChargeTransaction: JsonField<DelayedChargeTransaction> =
                        JsonMissing.of(),
                    @JsonProperty("evidence_of_imprint")
                    @ExcludeMissing
                    evidenceOfImprint: JsonField<EvidenceOfImprint> = JsonMissing.of(),
                    @JsonProperty("invalid_dispute")
                    @ExcludeMissing
                    invalidDispute: JsonField<InvalidDispute> = JsonMissing.of(),
                    @JsonProperty("non_fiat_currency_or_non_fungible_token_received")
                    @ExcludeMissing
                    nonFiatCurrencyOrNonFungibleTokenReceived:
                        JsonField<NonFiatCurrencyOrNonFungibleTokenReceived> =
                        JsonMissing.of(),
                    @JsonProperty("prior_undisputed_non_fraud_transactions")
                    @ExcludeMissing
                    priorUndisputedNonFraudTransactions:
                        JsonField<PriorUndisputedNonFraudTransactions> =
                        JsonMissing.of(),
                    @JsonProperty("reason")
                    @ExcludeMissing
                    reason: JsonField<Reason> = JsonMissing.of(),
                ) : this(
                    cardholderNoLongerDisputes,
                    compellingEvidence,
                    creditOrReversalProcessed,
                    delayedChargeTransaction,
                    evidenceOfImprint,
                    invalidDispute,
                    nonFiatCurrencyOrNonFungibleTokenReceived,
                    priorUndisputedNonFraudTransactions,
                    reason,
                    mutableMapOf(),
                )

                /**
                 * Cardholder no longer disputes details. Present if and only if `reason` is
                 * `cardholder_no_longer_disputes`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun cardholderNoLongerDisputes(): CardholderNoLongerDisputes? =
                    cardholderNoLongerDisputes.getNullable("cardholder_no_longer_disputes")

                /**
                 * Compelling evidence details. Present if and only if `reason` is
                 * `compelling_evidence`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun compellingEvidence(): CompellingEvidence? =
                    compellingEvidence.getNullable("compelling_evidence")

                /**
                 * Credit or reversal processed details. Present if and only if `reason` is
                 * `credit_or_reversal_processed`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun creditOrReversalProcessed(): CreditOrReversalProcessed? =
                    creditOrReversalProcessed.getNullable("credit_or_reversal_processed")

                /**
                 * Delayed charge transaction details. Present if and only if `reason` is
                 * `delayed_charge_transaction`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun delayedChargeTransaction(): DelayedChargeTransaction? =
                    delayedChargeTransaction.getNullable("delayed_charge_transaction")

                /**
                 * Evidence of imprint details. Present if and only if `reason` is
                 * `evidence_of_imprint`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun evidenceOfImprint(): EvidenceOfImprint? =
                    evidenceOfImprint.getNullable("evidence_of_imprint")

                /**
                 * Invalid dispute details. Present if and only if `reason` is `invalid_dispute`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun invalidDispute(): InvalidDispute? =
                    invalidDispute.getNullable("invalid_dispute")

                /**
                 * Non-fiat currency or non-fungible token received details. Present if and only if
                 * `reason` is `non_fiat_currency_or_non_fungible_token_received`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun nonFiatCurrencyOrNonFungibleTokenReceived():
                    NonFiatCurrencyOrNonFungibleTokenReceived? =
                    nonFiatCurrencyOrNonFungibleTokenReceived.getNullable(
                        "non_fiat_currency_or_non_fungible_token_received"
                    )

                /**
                 * Prior undisputed non-fraud transactions details. Present if and only if `reason`
                 * is `prior_undisputed_non_fraud_transactions`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun priorUndisputedNonFraudTransactions(): PriorUndisputedNonFraudTransactions? =
                    priorUndisputedNonFraudTransactions.getNullable(
                        "prior_undisputed_non_fraud_transactions"
                    )

                /**
                 * The reason the merchant re-presented the dispute.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun reason(): Reason = reason.getRequired("reason")

                /**
                 * Returns the raw JSON value of [cardholderNoLongerDisputes].
                 *
                 * Unlike [cardholderNoLongerDisputes], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("cardholder_no_longer_disputes")
                @ExcludeMissing
                fun _cardholderNoLongerDisputes(): JsonField<CardholderNoLongerDisputes> =
                    cardholderNoLongerDisputes

                /**
                 * Returns the raw JSON value of [compellingEvidence].
                 *
                 * Unlike [compellingEvidence], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("compelling_evidence")
                @ExcludeMissing
                fun _compellingEvidence(): JsonField<CompellingEvidence> = compellingEvidence

                /**
                 * Returns the raw JSON value of [creditOrReversalProcessed].
                 *
                 * Unlike [creditOrReversalProcessed], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("credit_or_reversal_processed")
                @ExcludeMissing
                fun _creditOrReversalProcessed(): JsonField<CreditOrReversalProcessed> =
                    creditOrReversalProcessed

                /**
                 * Returns the raw JSON value of [delayedChargeTransaction].
                 *
                 * Unlike [delayedChargeTransaction], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("delayed_charge_transaction")
                @ExcludeMissing
                fun _delayedChargeTransaction(): JsonField<DelayedChargeTransaction> =
                    delayedChargeTransaction

                /**
                 * Returns the raw JSON value of [evidenceOfImprint].
                 *
                 * Unlike [evidenceOfImprint], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("evidence_of_imprint")
                @ExcludeMissing
                fun _evidenceOfImprint(): JsonField<EvidenceOfImprint> = evidenceOfImprint

                /**
                 * Returns the raw JSON value of [invalidDispute].
                 *
                 * Unlike [invalidDispute], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("invalid_dispute")
                @ExcludeMissing
                fun _invalidDispute(): JsonField<InvalidDispute> = invalidDispute

                /**
                 * Returns the raw JSON value of [nonFiatCurrencyOrNonFungibleTokenReceived].
                 *
                 * Unlike [nonFiatCurrencyOrNonFungibleTokenReceived], this method doesn't throw if
                 * the JSON field has an unexpected type.
                 */
                @JsonProperty("non_fiat_currency_or_non_fungible_token_received")
                @ExcludeMissing
                fun _nonFiatCurrencyOrNonFungibleTokenReceived():
                    JsonField<NonFiatCurrencyOrNonFungibleTokenReceived> =
                    nonFiatCurrencyOrNonFungibleTokenReceived

                /**
                 * Returns the raw JSON value of [priorUndisputedNonFraudTransactions].
                 *
                 * Unlike [priorUndisputedNonFraudTransactions], this method doesn't throw if the
                 * JSON field has an unexpected type.
                 */
                @JsonProperty("prior_undisputed_non_fraud_transactions")
                @ExcludeMissing
                fun _priorUndisputedNonFraudTransactions():
                    JsonField<PriorUndisputedNonFraudTransactions> =
                    priorUndisputedNonFraudTransactions

                /**
                 * Returns the raw JSON value of [reason].
                 *
                 * Unlike [reason], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<Reason> = reason

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [MerchantPrearbitrationReceived].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderNoLongerDisputes()
                     * .compellingEvidence()
                     * .creditOrReversalProcessed()
                     * .delayedChargeTransaction()
                     * .evidenceOfImprint()
                     * .invalidDispute()
                     * .nonFiatCurrencyOrNonFungibleTokenReceived()
                     * .priorUndisputedNonFraudTransactions()
                     * .reason()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [MerchantPrearbitrationReceived]. */
                class Builder internal constructor() {

                    private var cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes>? =
                        null
                    private var compellingEvidence: JsonField<CompellingEvidence>? = null
                    private var creditOrReversalProcessed: JsonField<CreditOrReversalProcessed>? =
                        null
                    private var delayedChargeTransaction: JsonField<DelayedChargeTransaction>? =
                        null
                    private var evidenceOfImprint: JsonField<EvidenceOfImprint>? = null
                    private var invalidDispute: JsonField<InvalidDispute>? = null
                    private var nonFiatCurrencyOrNonFungibleTokenReceived:
                        JsonField<NonFiatCurrencyOrNonFungibleTokenReceived>? =
                        null
                    private var priorUndisputedNonFraudTransactions:
                        JsonField<PriorUndisputedNonFraudTransactions>? =
                        null
                    private var reason: JsonField<Reason>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        merchantPrearbitrationReceived: MerchantPrearbitrationReceived
                    ) = apply {
                        cardholderNoLongerDisputes =
                            merchantPrearbitrationReceived.cardholderNoLongerDisputes
                        compellingEvidence = merchantPrearbitrationReceived.compellingEvidence
                        creditOrReversalProcessed =
                            merchantPrearbitrationReceived.creditOrReversalProcessed
                        delayedChargeTransaction =
                            merchantPrearbitrationReceived.delayedChargeTransaction
                        evidenceOfImprint = merchantPrearbitrationReceived.evidenceOfImprint
                        invalidDispute = merchantPrearbitrationReceived.invalidDispute
                        nonFiatCurrencyOrNonFungibleTokenReceived =
                            merchantPrearbitrationReceived.nonFiatCurrencyOrNonFungibleTokenReceived
                        priorUndisputedNonFraudTransactions =
                            merchantPrearbitrationReceived.priorUndisputedNonFraudTransactions
                        reason = merchantPrearbitrationReceived.reason
                        additionalProperties =
                            merchantPrearbitrationReceived.additionalProperties.toMutableMap()
                    }

                    /**
                     * Cardholder no longer disputes details. Present if and only if `reason` is
                     * `cardholder_no_longer_disputes`.
                     */
                    fun cardholderNoLongerDisputes(
                        cardholderNoLongerDisputes: CardholderNoLongerDisputes?
                    ) = cardholderNoLongerDisputes(JsonField.ofNullable(cardholderNoLongerDisputes))

                    /**
                     * Sets [Builder.cardholderNoLongerDisputes] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderNoLongerDisputes] with a
                     * well-typed [CardholderNoLongerDisputes] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun cardholderNoLongerDisputes(
                        cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes>
                    ) = apply { this.cardholderNoLongerDisputes = cardholderNoLongerDisputes }

                    /**
                     * Compelling evidence details. Present if and only if `reason` is
                     * `compelling_evidence`.
                     */
                    fun compellingEvidence(compellingEvidence: CompellingEvidence?) =
                        compellingEvidence(JsonField.ofNullable(compellingEvidence))

                    /**
                     * Sets [Builder.compellingEvidence] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.compellingEvidence] with a well-typed
                     * [CompellingEvidence] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun compellingEvidence(compellingEvidence: JsonField<CompellingEvidence>) =
                        apply {
                            this.compellingEvidence = compellingEvidence
                        }

                    /**
                     * Credit or reversal processed details. Present if and only if `reason` is
                     * `credit_or_reversal_processed`.
                     */
                    fun creditOrReversalProcessed(
                        creditOrReversalProcessed: CreditOrReversalProcessed?
                    ) = creditOrReversalProcessed(JsonField.ofNullable(creditOrReversalProcessed))

                    /**
                     * Sets [Builder.creditOrReversalProcessed] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.creditOrReversalProcessed] with a well-typed
                     * [CreditOrReversalProcessed] value instead. This method is primarily for
                     * setting the field to an undocumented or not yet supported value.
                     */
                    fun creditOrReversalProcessed(
                        creditOrReversalProcessed: JsonField<CreditOrReversalProcessed>
                    ) = apply { this.creditOrReversalProcessed = creditOrReversalProcessed }

                    /**
                     * Delayed charge transaction details. Present if and only if `reason` is
                     * `delayed_charge_transaction`.
                     */
                    fun delayedChargeTransaction(
                        delayedChargeTransaction: DelayedChargeTransaction?
                    ) = delayedChargeTransaction(JsonField.ofNullable(delayedChargeTransaction))

                    /**
                     * Sets [Builder.delayedChargeTransaction] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.delayedChargeTransaction] with a well-typed
                     * [DelayedChargeTransaction] value instead. This method is primarily for
                     * setting the field to an undocumented or not yet supported value.
                     */
                    fun delayedChargeTransaction(
                        delayedChargeTransaction: JsonField<DelayedChargeTransaction>
                    ) = apply { this.delayedChargeTransaction = delayedChargeTransaction }

                    /**
                     * Evidence of imprint details. Present if and only if `reason` is
                     * `evidence_of_imprint`.
                     */
                    fun evidenceOfImprint(evidenceOfImprint: EvidenceOfImprint?) =
                        evidenceOfImprint(JsonField.ofNullable(evidenceOfImprint))

                    /**
                     * Sets [Builder.evidenceOfImprint] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.evidenceOfImprint] with a well-typed
                     * [EvidenceOfImprint] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun evidenceOfImprint(evidenceOfImprint: JsonField<EvidenceOfImprint>) = apply {
                        this.evidenceOfImprint = evidenceOfImprint
                    }

                    /**
                     * Invalid dispute details. Present if and only if `reason` is
                     * `invalid_dispute`.
                     */
                    fun invalidDispute(invalidDispute: InvalidDispute?) =
                        invalidDispute(JsonField.ofNullable(invalidDispute))

                    /**
                     * Sets [Builder.invalidDispute] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.invalidDispute] with a well-typed
                     * [InvalidDispute] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun invalidDispute(invalidDispute: JsonField<InvalidDispute>) = apply {
                        this.invalidDispute = invalidDispute
                    }

                    /**
                     * Non-fiat currency or non-fungible token received details. Present if and only
                     * if `reason` is `non_fiat_currency_or_non_fungible_token_received`.
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenReceived(
                        nonFiatCurrencyOrNonFungibleTokenReceived:
                            NonFiatCurrencyOrNonFungibleTokenReceived?
                    ) =
                        nonFiatCurrencyOrNonFungibleTokenReceived(
                            JsonField.ofNullable(nonFiatCurrencyOrNonFungibleTokenReceived)
                        )

                    /**
                     * Sets [Builder.nonFiatCurrencyOrNonFungibleTokenReceived] to an arbitrary JSON
                     * value.
                     *
                     * You should usually call [Builder.nonFiatCurrencyOrNonFungibleTokenReceived]
                     * with a well-typed [NonFiatCurrencyOrNonFungibleTokenReceived] value instead.
                     * This method is primarily for setting the field to an undocumented or not yet
                     * supported value.
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenReceived(
                        nonFiatCurrencyOrNonFungibleTokenReceived:
                            JsonField<NonFiatCurrencyOrNonFungibleTokenReceived>
                    ) = apply {
                        this.nonFiatCurrencyOrNonFungibleTokenReceived =
                            nonFiatCurrencyOrNonFungibleTokenReceived
                    }

                    /**
                     * Prior undisputed non-fraud transactions details. Present if and only if
                     * `reason` is `prior_undisputed_non_fraud_transactions`.
                     */
                    fun priorUndisputedNonFraudTransactions(
                        priorUndisputedNonFraudTransactions: PriorUndisputedNonFraudTransactions?
                    ) =
                        priorUndisputedNonFraudTransactions(
                            JsonField.ofNullable(priorUndisputedNonFraudTransactions)
                        )

                    /**
                     * Sets [Builder.priorUndisputedNonFraudTransactions] to an arbitrary JSON
                     * value.
                     *
                     * You should usually call [Builder.priorUndisputedNonFraudTransactions] with a
                     * well-typed [PriorUndisputedNonFraudTransactions] value instead. This method
                     * is primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun priorUndisputedNonFraudTransactions(
                        priorUndisputedNonFraudTransactions:
                            JsonField<PriorUndisputedNonFraudTransactions>
                    ) = apply {
                        this.priorUndisputedNonFraudTransactions =
                            priorUndisputedNonFraudTransactions
                    }

                    /** The reason the merchant re-presented the dispute. */
                    fun reason(reason: Reason) = reason(JsonField.of(reason))

                    /**
                     * Sets [Builder.reason] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.reason] with a well-typed [Reason] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [MerchantPrearbitrationReceived].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderNoLongerDisputes()
                     * .compellingEvidence()
                     * .creditOrReversalProcessed()
                     * .delayedChargeTransaction()
                     * .evidenceOfImprint()
                     * .invalidDispute()
                     * .nonFiatCurrencyOrNonFungibleTokenReceived()
                     * .priorUndisputedNonFraudTransactions()
                     * .reason()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): MerchantPrearbitrationReceived =
                        MerchantPrearbitrationReceived(
                            checkRequired("cardholderNoLongerDisputes", cardholderNoLongerDisputes),
                            checkRequired("compellingEvidence", compellingEvidence),
                            checkRequired("creditOrReversalProcessed", creditOrReversalProcessed),
                            checkRequired("delayedChargeTransaction", delayedChargeTransaction),
                            checkRequired("evidenceOfImprint", evidenceOfImprint),
                            checkRequired("invalidDispute", invalidDispute),
                            checkRequired(
                                "nonFiatCurrencyOrNonFungibleTokenReceived",
                                nonFiatCurrencyOrNonFungibleTokenReceived,
                            ),
                            checkRequired(
                                "priorUndisputedNonFraudTransactions",
                                priorUndisputedNonFraudTransactions,
                            ),
                            checkRequired("reason", reason),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): MerchantPrearbitrationReceived = apply {
                    if (validated) {
                        return@apply
                    }

                    cardholderNoLongerDisputes()?.validate()
                    compellingEvidence()?.validate()
                    creditOrReversalProcessed()?.validate()
                    delayedChargeTransaction()?.validate()
                    evidenceOfImprint()?.validate()
                    invalidDispute()?.validate()
                    nonFiatCurrencyOrNonFungibleTokenReceived()?.validate()
                    priorUndisputedNonFraudTransactions()?.validate()
                    reason().validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cardholderNoLongerDisputes.asKnown()?.validity() ?: 0) +
                        (compellingEvidence.asKnown()?.validity() ?: 0) +
                        (creditOrReversalProcessed.asKnown()?.validity() ?: 0) +
                        (delayedChargeTransaction.asKnown()?.validity() ?: 0) +
                        (evidenceOfImprint.asKnown()?.validity() ?: 0) +
                        (invalidDispute.asKnown()?.validity() ?: 0) +
                        (nonFiatCurrencyOrNonFungibleTokenReceived.asKnown()?.validity() ?: 0) +
                        (priorUndisputedNonFraudTransactions.asKnown()?.validity() ?: 0) +
                        (reason.asKnown()?.validity() ?: 0)

                /**
                 * Cardholder no longer disputes details. Present if and only if `reason` is
                 * `cardholder_no_longer_disputes`.
                 */
                class CardholderNoLongerDisputes
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Explanation for why the merchant believes the cardholder no longer disputes
                     * the transaction.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderNoLongerDisputes].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderNoLongerDisputes]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(cardholderNoLongerDisputes: CardholderNoLongerDisputes) =
                            apply {
                                explanation = cardholderNoLongerDisputes.explanation
                                additionalProperties =
                                    cardholderNoLongerDisputes.additionalProperties.toMutableMap()
                            }

                        /**
                         * Explanation for why the merchant believes the cardholder no longer
                         * disputes the transaction.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CardholderNoLongerDisputes].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderNoLongerDisputes =
                            CardholderNoLongerDisputes(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderNoLongerDisputes = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (explanation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderNoLongerDisputes &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderNoLongerDisputes{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                /**
                 * Compelling evidence details. Present if and only if `reason` is
                 * `compelling_evidence`.
                 */
                class CompellingEvidence
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val category: JsonField<Category>,
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("category")
                        @ExcludeMissing
                        category: JsonField<Category> = JsonMissing.of(),
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                    ) : this(category, explanation, mutableMapOf())

                    /**
                     * The category of compelling evidence provided by the merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun category(): Category = category.getRequired("category")

                    /**
                     * Explanation of the compelling evidence provided by the merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [category].
                     *
                     * Unlike [category], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("category")
                    @ExcludeMissing
                    fun _category(): JsonField<Category> = category

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CompellingEvidence].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .category()
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CompellingEvidence]. */
                    class Builder internal constructor() {

                        private var category: JsonField<Category>? = null
                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(compellingEvidence: CompellingEvidence) = apply {
                            category = compellingEvidence.category
                            explanation = compellingEvidence.explanation
                            additionalProperties =
                                compellingEvidence.additionalProperties.toMutableMap()
                        }

                        /** The category of compelling evidence provided by the merchant. */
                        fun category(category: Category) = category(JsonField.of(category))

                        /**
                         * Sets [Builder.category] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.category] with a well-typed [Category]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun category(category: JsonField<Category>) = apply {
                            this.category = category
                        }

                        /** Explanation of the compelling evidence provided by the merchant. */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CompellingEvidence].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .category()
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CompellingEvidence =
                            CompellingEvidence(
                                checkRequired("category", category),
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CompellingEvidence = apply {
                        if (validated) {
                            return@apply
                        }

                        category().validate()
                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (category.asKnown()?.validity() ?: 0) +
                            (if (explanation.asKnown() == null) 0 else 1)

                    /** The category of compelling evidence provided by the merchant. */
                    class Category
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Authorized signer known by the cardholder. */
                            val AUTHORIZED_SIGNER = of("authorized_signer")

                            /** Proof of delivery. */
                            val DELIVERY = of("delivery")

                            /** Proof of delivery to cardholder at place of employment. */
                            val DELIVERY_AT_PLACE_OF_EMPLOYMENT =
                                of("delivery_at_place_of_employment")

                            /** Proof of digital goods download. */
                            val DIGITAL_GOODS_DOWNLOAD = of("digital_goods_download")

                            /** Dynamic Currency Conversion actively chosen by cardholder. */
                            val DYNAMIC_CURRENCY_CONVERSION_ACTIVELY_CHOSEN =
                                of("dynamic_currency_conversion_actively_chosen")

                            /** Flight manifest with corresponding purchase itinerary record. */
                            val FLIGHT_MANIFEST_AND_PURCHASE_ITINERARY =
                                of("flight_manifest_and_purchase_itinerary")

                            /** Signer is member of cardholder's household. */
                            val HOUSEHOLD_MEMBER_SIGNER = of("household_member_signer")

                            /**
                             * Legitimate spend across multiple payment types for same merchandise.
                             */
                            val LEGITIMATE_SPEND_ACROSS_PAYMENT_TYPES_FOR_SAME_MERCHANDISE =
                                of("legitimate_spend_across_payment_types_for_same_merchandise")

                            /**
                             * Documentation to prove the cardholder is in possession of and/or
                             * using the merchandise.
                             */
                            val MERCHANDISE_USE = of("merchandise_use")

                            /**
                             * Passenger transport: proof ticket was received, scanned at gate or
                             * other transaction related to original (for example, frequent flyer
                             * miles.)
                             */
                            val PASSENGER_TRANSPORT_TICKET_USE =
                                of("passenger_transport_ticket_use")

                            /**
                             * Recurring transaction with binding contract or previous undisputed
                             * recurring transactions and proof the cardholder is using the
                             * merchandise or service.
                             */
                            val RECURRING_TRANSACTION_WITH_BINDING_CONTRACT_OR_PREVIOUS_UNDISPUTED_TRANSACTION =
                                of(
                                    "recurring_transaction_with_binding_contract_or_previous_undisputed_transaction"
                                )

                            /**
                             * Signed delivery form, or copy of/details of identification from
                             * cardholder as proof goods were picked up at merchant location.
                             */
                            val SIGNED_DELIVERY_OR_PICKUP_FORM =
                                of("signed_delivery_or_pickup_form")

                            /** Signed Mail Order/Phone Order form. */
                            val SIGNED_MAIL_ORDER_PHONE_ORDER_FORM =
                                of("signed_mail_order_phone_order_form")

                            /** Travel & Expense: loyalty transactions related to purchase. */
                            val TRAVEL_AND_EXPENSE_LOYALTY_TRANSACTION =
                                of("travel_and_expense_loyalty_transaction")

                            /**
                             * Travel & Expense: subsequent purchases made throughout service
                             * period.
                             */
                            val TRAVEL_AND_EXPENSE_SUBSEQUENT_PURCHASE =
                                of("travel_and_expense_subsequent_purchase")

                            fun of(value: String) = Category(JsonField.of(value))
                        }

                        /** An enum containing [Category]'s known values. */
                        enum class Known {
                            /** Authorized signer known by the cardholder. */
                            AUTHORIZED_SIGNER,
                            /** Proof of delivery. */
                            DELIVERY,
                            /** Proof of delivery to cardholder at place of employment. */
                            DELIVERY_AT_PLACE_OF_EMPLOYMENT,
                            /** Proof of digital goods download. */
                            DIGITAL_GOODS_DOWNLOAD,
                            /** Dynamic Currency Conversion actively chosen by cardholder. */
                            DYNAMIC_CURRENCY_CONVERSION_ACTIVELY_CHOSEN,
                            /** Flight manifest with corresponding purchase itinerary record. */
                            FLIGHT_MANIFEST_AND_PURCHASE_ITINERARY,
                            /** Signer is member of cardholder's household. */
                            HOUSEHOLD_MEMBER_SIGNER,
                            /**
                             * Legitimate spend across multiple payment types for same merchandise.
                             */
                            LEGITIMATE_SPEND_ACROSS_PAYMENT_TYPES_FOR_SAME_MERCHANDISE,
                            /**
                             * Documentation to prove the cardholder is in possession of and/or
                             * using the merchandise.
                             */
                            MERCHANDISE_USE,
                            /**
                             * Passenger transport: proof ticket was received, scanned at gate or
                             * other transaction related to original (for example, frequent flyer
                             * miles.)
                             */
                            PASSENGER_TRANSPORT_TICKET_USE,
                            /**
                             * Recurring transaction with binding contract or previous undisputed
                             * recurring transactions and proof the cardholder is using the
                             * merchandise or service.
                             */
                            RECURRING_TRANSACTION_WITH_BINDING_CONTRACT_OR_PREVIOUS_UNDISPUTED_TRANSACTION,
                            /**
                             * Signed delivery form, or copy of/details of identification from
                             * cardholder as proof goods were picked up at merchant location.
                             */
                            SIGNED_DELIVERY_OR_PICKUP_FORM,
                            /** Signed Mail Order/Phone Order form. */
                            SIGNED_MAIL_ORDER_PHONE_ORDER_FORM,
                            /** Travel & Expense: loyalty transactions related to purchase. */
                            TRAVEL_AND_EXPENSE_LOYALTY_TRANSACTION,
                            /**
                             * Travel & Expense: subsequent purchases made throughout service
                             * period.
                             */
                            TRAVEL_AND_EXPENSE_SUBSEQUENT_PURCHASE,
                        }

                        /**
                         * An enum containing [Category]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [Category] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Authorized signer known by the cardholder. */
                            AUTHORIZED_SIGNER,
                            /** Proof of delivery. */
                            DELIVERY,
                            /** Proof of delivery to cardholder at place of employment. */
                            DELIVERY_AT_PLACE_OF_EMPLOYMENT,
                            /** Proof of digital goods download. */
                            DIGITAL_GOODS_DOWNLOAD,
                            /** Dynamic Currency Conversion actively chosen by cardholder. */
                            DYNAMIC_CURRENCY_CONVERSION_ACTIVELY_CHOSEN,
                            /** Flight manifest with corresponding purchase itinerary record. */
                            FLIGHT_MANIFEST_AND_PURCHASE_ITINERARY,
                            /** Signer is member of cardholder's household. */
                            HOUSEHOLD_MEMBER_SIGNER,
                            /**
                             * Legitimate spend across multiple payment types for same merchandise.
                             */
                            LEGITIMATE_SPEND_ACROSS_PAYMENT_TYPES_FOR_SAME_MERCHANDISE,
                            /**
                             * Documentation to prove the cardholder is in possession of and/or
                             * using the merchandise.
                             */
                            MERCHANDISE_USE,
                            /**
                             * Passenger transport: proof ticket was received, scanned at gate or
                             * other transaction related to original (for example, frequent flyer
                             * miles.)
                             */
                            PASSENGER_TRANSPORT_TICKET_USE,
                            /**
                             * Recurring transaction with binding contract or previous undisputed
                             * recurring transactions and proof the cardholder is using the
                             * merchandise or service.
                             */
                            RECURRING_TRANSACTION_WITH_BINDING_CONTRACT_OR_PREVIOUS_UNDISPUTED_TRANSACTION,
                            /**
                             * Signed delivery form, or copy of/details of identification from
                             * cardholder as proof goods were picked up at merchant location.
                             */
                            SIGNED_DELIVERY_OR_PICKUP_FORM,
                            /** Signed Mail Order/Phone Order form. */
                            SIGNED_MAIL_ORDER_PHONE_ORDER_FORM,
                            /** Travel & Expense: loyalty transactions related to purchase. */
                            TRAVEL_AND_EXPENSE_LOYALTY_TRANSACTION,
                            /**
                             * Travel & Expense: subsequent purchases made throughout service
                             * period.
                             */
                            TRAVEL_AND_EXPENSE_SUBSEQUENT_PURCHASE,
                            /**
                             * An enum member indicating that [Category] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                AUTHORIZED_SIGNER -> Value.AUTHORIZED_SIGNER
                                DELIVERY -> Value.DELIVERY
                                DELIVERY_AT_PLACE_OF_EMPLOYMENT ->
                                    Value.DELIVERY_AT_PLACE_OF_EMPLOYMENT
                                DIGITAL_GOODS_DOWNLOAD -> Value.DIGITAL_GOODS_DOWNLOAD
                                DYNAMIC_CURRENCY_CONVERSION_ACTIVELY_CHOSEN ->
                                    Value.DYNAMIC_CURRENCY_CONVERSION_ACTIVELY_CHOSEN
                                FLIGHT_MANIFEST_AND_PURCHASE_ITINERARY ->
                                    Value.FLIGHT_MANIFEST_AND_PURCHASE_ITINERARY
                                HOUSEHOLD_MEMBER_SIGNER -> Value.HOUSEHOLD_MEMBER_SIGNER
                                LEGITIMATE_SPEND_ACROSS_PAYMENT_TYPES_FOR_SAME_MERCHANDISE ->
                                    Value.LEGITIMATE_SPEND_ACROSS_PAYMENT_TYPES_FOR_SAME_MERCHANDISE
                                MERCHANDISE_USE -> Value.MERCHANDISE_USE
                                PASSENGER_TRANSPORT_TICKET_USE ->
                                    Value.PASSENGER_TRANSPORT_TICKET_USE
                                RECURRING_TRANSACTION_WITH_BINDING_CONTRACT_OR_PREVIOUS_UNDISPUTED_TRANSACTION ->
                                    Value
                                        .RECURRING_TRANSACTION_WITH_BINDING_CONTRACT_OR_PREVIOUS_UNDISPUTED_TRANSACTION
                                SIGNED_DELIVERY_OR_PICKUP_FORM ->
                                    Value.SIGNED_DELIVERY_OR_PICKUP_FORM
                                SIGNED_MAIL_ORDER_PHONE_ORDER_FORM ->
                                    Value.SIGNED_MAIL_ORDER_PHONE_ORDER_FORM
                                TRAVEL_AND_EXPENSE_LOYALTY_TRANSACTION ->
                                    Value.TRAVEL_AND_EXPENSE_LOYALTY_TRANSACTION
                                TRAVEL_AND_EXPENSE_SUBSEQUENT_PURCHASE ->
                                    Value.TRAVEL_AND_EXPENSE_SUBSEQUENT_PURCHASE
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                AUTHORIZED_SIGNER -> Known.AUTHORIZED_SIGNER
                                DELIVERY -> Known.DELIVERY
                                DELIVERY_AT_PLACE_OF_EMPLOYMENT ->
                                    Known.DELIVERY_AT_PLACE_OF_EMPLOYMENT
                                DIGITAL_GOODS_DOWNLOAD -> Known.DIGITAL_GOODS_DOWNLOAD
                                DYNAMIC_CURRENCY_CONVERSION_ACTIVELY_CHOSEN ->
                                    Known.DYNAMIC_CURRENCY_CONVERSION_ACTIVELY_CHOSEN
                                FLIGHT_MANIFEST_AND_PURCHASE_ITINERARY ->
                                    Known.FLIGHT_MANIFEST_AND_PURCHASE_ITINERARY
                                HOUSEHOLD_MEMBER_SIGNER -> Known.HOUSEHOLD_MEMBER_SIGNER
                                LEGITIMATE_SPEND_ACROSS_PAYMENT_TYPES_FOR_SAME_MERCHANDISE ->
                                    Known.LEGITIMATE_SPEND_ACROSS_PAYMENT_TYPES_FOR_SAME_MERCHANDISE
                                MERCHANDISE_USE -> Known.MERCHANDISE_USE
                                PASSENGER_TRANSPORT_TICKET_USE ->
                                    Known.PASSENGER_TRANSPORT_TICKET_USE
                                RECURRING_TRANSACTION_WITH_BINDING_CONTRACT_OR_PREVIOUS_UNDISPUTED_TRANSACTION ->
                                    Known
                                        .RECURRING_TRANSACTION_WITH_BINDING_CONTRACT_OR_PREVIOUS_UNDISPUTED_TRANSACTION
                                SIGNED_DELIVERY_OR_PICKUP_FORM ->
                                    Known.SIGNED_DELIVERY_OR_PICKUP_FORM
                                SIGNED_MAIL_ORDER_PHONE_ORDER_FORM ->
                                    Known.SIGNED_MAIL_ORDER_PHONE_ORDER_FORM
                                TRAVEL_AND_EXPENSE_LOYALTY_TRANSACTION ->
                                    Known.TRAVEL_AND_EXPENSE_LOYALTY_TRANSACTION
                                TRAVEL_AND_EXPENSE_SUBSEQUENT_PURCHASE ->
                                    Known.TRAVEL_AND_EXPENSE_SUBSEQUENT_PURCHASE
                                else ->
                                    throw IncreaseInvalidDataException("Unknown Category: $value")
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): Category = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Category && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CompellingEvidence &&
                            category == other.category &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(category, explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CompellingEvidence{category=$category, explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                /**
                 * Credit or reversal processed details. Present if and only if `reason` is
                 * `credit_or_reversal_processed`.
                 */
                class CreditOrReversalProcessed
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val amount: JsonField<Long>,
                    private val currency: JsonField<String>,
                    private val explanation: JsonField<String>,
                    private val processedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("amount")
                        @ExcludeMissing
                        amount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("currency")
                        @ExcludeMissing
                        currency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("processed_at")
                        @ExcludeMissing
                        processedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(amount, currency, explanation, processedAt, mutableMapOf())

                    /**
                     * The amount of the credit or reversal in the minor unit of its currency. For
                     * dollars, for example, this is cents.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun amount(): Long = amount.getRequired("amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the credit or
                     * reversal's currency.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun currency(): String = currency.getRequired("currency")

                    /**
                     * Explanation for why the merchant believes the credit or reversal was
                     * processed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * The date the credit or reversal was processed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun processedAt(): LocalDate = processedAt.getRequired("processed_at")

                    /**
                     * Returns the raw JSON value of [amount].
                     *
                     * Unlike [amount], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

                    /**
                     * Returns the raw JSON value of [currency].
                     *
                     * Unlike [currency], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun _currency(): JsonField<String> = currency

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [processedAt].
                     *
                     * Unlike [processedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("processed_at")
                    @ExcludeMissing
                    fun _processedAt(): JsonField<LocalDate> = processedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CreditOrReversalProcessed].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .amount()
                         * .currency()
                         * .explanation()
                         * .processedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CreditOrReversalProcessed]. */
                    class Builder internal constructor() {

                        private var amount: JsonField<Long>? = null
                        private var currency: JsonField<String>? = null
                        private var explanation: JsonField<String>? = null
                        private var processedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(creditOrReversalProcessed: CreditOrReversalProcessed) =
                            apply {
                                amount = creditOrReversalProcessed.amount
                                currency = creditOrReversalProcessed.currency
                                explanation = creditOrReversalProcessed.explanation
                                processedAt = creditOrReversalProcessed.processedAt
                                additionalProperties =
                                    creditOrReversalProcessed.additionalProperties.toMutableMap()
                            }

                        /**
                         * The amount of the credit or reversal in the minor unit of its currency.
                         * For dollars, for example, this is cents.
                         */
                        fun amount(amount: Long) = amount(JsonField.of(amount))

                        /**
                         * Sets [Builder.amount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.amount] with a well-typed [Long] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * credit or reversal's currency.
                         */
                        fun currency(currency: String) = currency(JsonField.of(currency))

                        /**
                         * Sets [Builder.currency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.currency] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun currency(currency: JsonField<String>) = apply {
                            this.currency = currency
                        }

                        /**
                         * Explanation for why the merchant believes the credit or reversal was
                         * processed.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** The date the credit or reversal was processed. */
                        fun processedAt(processedAt: LocalDate) =
                            processedAt(JsonField.of(processedAt))

                        /**
                         * Sets [Builder.processedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.processedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun processedAt(processedAt: JsonField<LocalDate>) = apply {
                            this.processedAt = processedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CreditOrReversalProcessed].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .amount()
                         * .currency()
                         * .explanation()
                         * .processedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CreditOrReversalProcessed =
                            CreditOrReversalProcessed(
                                checkRequired("amount", amount),
                                checkRequired("currency", currency),
                                checkRequired("explanation", explanation),
                                checkRequired("processedAt", processedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CreditOrReversalProcessed = apply {
                        if (validated) {
                            return@apply
                        }

                        amount()
                        currency()
                        explanation()
                        processedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (amount.asKnown() == null) 0 else 1) +
                            (if (currency.asKnown() == null) 0 else 1) +
                            (if (explanation.asKnown() == null) 0 else 1) +
                            (if (processedAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CreditOrReversalProcessed &&
                            amount == other.amount &&
                            currency == other.currency &&
                            explanation == other.explanation &&
                            processedAt == other.processedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            amount,
                            currency,
                            explanation,
                            processedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CreditOrReversalProcessed{amount=$amount, currency=$currency, explanation=$explanation, processedAt=$processedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Delayed charge transaction details. Present if and only if `reason` is
                 * `delayed_charge_transaction`.
                 */
                class DelayedChargeTransaction
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Additional details about the delayed charge transaction.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [DelayedChargeTransaction].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [DelayedChargeTransaction]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(delayedChargeTransaction: DelayedChargeTransaction) =
                            apply {
                                explanation = delayedChargeTransaction.explanation
                                additionalProperties =
                                    delayedChargeTransaction.additionalProperties.toMutableMap()
                            }

                        /** Additional details about the delayed charge transaction. */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [DelayedChargeTransaction].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): DelayedChargeTransaction =
                            DelayedChargeTransaction(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): DelayedChargeTransaction = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (explanation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is DelayedChargeTransaction &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "DelayedChargeTransaction{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                /**
                 * Evidence of imprint details. Present if and only if `reason` is
                 * `evidence_of_imprint`.
                 */
                class EvidenceOfImprint
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Explanation of the evidence of imprint.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [EvidenceOfImprint].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [EvidenceOfImprint]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(evidenceOfImprint: EvidenceOfImprint) = apply {
                            explanation = evidenceOfImprint.explanation
                            additionalProperties =
                                evidenceOfImprint.additionalProperties.toMutableMap()
                        }

                        /** Explanation of the evidence of imprint. */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [EvidenceOfImprint].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): EvidenceOfImprint =
                            EvidenceOfImprint(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): EvidenceOfImprint = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (explanation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is EvidenceOfImprint &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "EvidenceOfImprint{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                /**
                 * Invalid dispute details. Present if and only if `reason` is `invalid_dispute`.
                 */
                class InvalidDispute
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val reason: JsonField<Reason>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<Reason> = JsonMissing.of(),
                    ) : this(explanation, reason, mutableMapOf())

                    /**
                     * Explanation for why the dispute is considered invalid by the merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * The reason a merchant considers the dispute invalid.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): Reason = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<Reason> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [InvalidDispute].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [InvalidDispute]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var reason: JsonField<Reason>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(invalidDispute: InvalidDispute) = apply {
                            explanation = invalidDispute.explanation
                            reason = invalidDispute.reason
                            additionalProperties =
                                invalidDispute.additionalProperties.toMutableMap()
                        }

                        /**
                         * Explanation for why the dispute is considered invalid by the merchant.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** The reason a merchant considers the dispute invalid. */
                        fun reason(reason: Reason) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [Reason] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [InvalidDispute].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): InvalidDispute =
                            InvalidDispute(
                                checkRequired("explanation", explanation),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): InvalidDispute = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        reason().validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (explanation.asKnown() == null) 0 else 1) +
                            (reason.asKnown()?.validity() ?: 0)

                    /** The reason a merchant considers the dispute invalid. */
                    class Reason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Other. */
                            val OTHER = of("other")

                            /** Special authorization procedures followed. */
                            val SPECIAL_AUTHORIZATION_PROCEDURES_FOLLOWED =
                                of("special_authorization_procedures_followed")

                            fun of(value: String) = Reason(JsonField.of(value))
                        }

                        /** An enum containing [Reason]'s known values. */
                        enum class Known {
                            /** Other. */
                            OTHER,
                            /** Special authorization procedures followed. */
                            SPECIAL_AUTHORIZATION_PROCEDURES_FOLLOWED,
                        }

                        /**
                         * An enum containing [Reason]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [Reason] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Other. */
                            OTHER,
                            /** Special authorization procedures followed. */
                            SPECIAL_AUTHORIZATION_PROCEDURES_FOLLOWED,
                            /**
                             * An enum member indicating that [Reason] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                OTHER -> Value.OTHER
                                SPECIAL_AUTHORIZATION_PROCEDURES_FOLLOWED ->
                                    Value.SPECIAL_AUTHORIZATION_PROCEDURES_FOLLOWED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                OTHER -> Known.OTHER
                                SPECIAL_AUTHORIZATION_PROCEDURES_FOLLOWED ->
                                    Known.SPECIAL_AUTHORIZATION_PROCEDURES_FOLLOWED
                                else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): Reason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Reason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvalidDispute &&
                            explanation == other.explanation &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "InvalidDispute{explanation=$explanation, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /**
                 * Non-fiat currency or non-fungible token received details. Present if and only if
                 * `reason` is `non_fiat_currency_or_non_fungible_token_received`.
                 */
                class NonFiatCurrencyOrNonFungibleTokenReceived
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val blockchainTransactionHash: JsonField<String>,
                    private val destinationWalletAddress: JsonField<String>,
                    private val priorApprovedTransactions: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("blockchain_transaction_hash")
                        @ExcludeMissing
                        blockchainTransactionHash: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("destination_wallet_address")
                        @ExcludeMissing
                        destinationWalletAddress: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("prior_approved_transactions")
                        @ExcludeMissing
                        priorApprovedTransactions: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        blockchainTransactionHash,
                        destinationWalletAddress,
                        priorApprovedTransactions,
                        mutableMapOf(),
                    )

                    /**
                     * Blockchain transaction hash.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun blockchainTransactionHash(): String =
                        blockchainTransactionHash.getRequired("blockchain_transaction_hash")

                    /**
                     * Destination wallet address.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun destinationWalletAddress(): String =
                        destinationWalletAddress.getRequired("destination_wallet_address")

                    /**
                     * Prior approved transactions.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun priorApprovedTransactions(): String? =
                        priorApprovedTransactions.getNullable("prior_approved_transactions")

                    /**
                     * Returns the raw JSON value of [blockchainTransactionHash].
                     *
                     * Unlike [blockchainTransactionHash], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("blockchain_transaction_hash")
                    @ExcludeMissing
                    fun _blockchainTransactionHash(): JsonField<String> = blockchainTransactionHash

                    /**
                     * Returns the raw JSON value of [destinationWalletAddress].
                     *
                     * Unlike [destinationWalletAddress], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("destination_wallet_address")
                    @ExcludeMissing
                    fun _destinationWalletAddress(): JsonField<String> = destinationWalletAddress

                    /**
                     * Returns the raw JSON value of [priorApprovedTransactions].
                     *
                     * Unlike [priorApprovedTransactions], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("prior_approved_transactions")
                    @ExcludeMissing
                    fun _priorApprovedTransactions(): JsonField<String> = priorApprovedTransactions

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [NonFiatCurrencyOrNonFungibleTokenReceived].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .blockchainTransactionHash()
                         * .destinationWalletAddress()
                         * .priorApprovedTransactions()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [NonFiatCurrencyOrNonFungibleTokenReceived]. */
                    class Builder internal constructor() {

                        private var blockchainTransactionHash: JsonField<String>? = null
                        private var destinationWalletAddress: JsonField<String>? = null
                        private var priorApprovedTransactions: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            nonFiatCurrencyOrNonFungibleTokenReceived:
                                NonFiatCurrencyOrNonFungibleTokenReceived
                        ) = apply {
                            blockchainTransactionHash =
                                nonFiatCurrencyOrNonFungibleTokenReceived.blockchainTransactionHash
                            destinationWalletAddress =
                                nonFiatCurrencyOrNonFungibleTokenReceived.destinationWalletAddress
                            priorApprovedTransactions =
                                nonFiatCurrencyOrNonFungibleTokenReceived.priorApprovedTransactions
                            additionalProperties =
                                nonFiatCurrencyOrNonFungibleTokenReceived.additionalProperties
                                    .toMutableMap()
                        }

                        /** Blockchain transaction hash. */
                        fun blockchainTransactionHash(blockchainTransactionHash: String) =
                            blockchainTransactionHash(JsonField.of(blockchainTransactionHash))

                        /**
                         * Sets [Builder.blockchainTransactionHash] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.blockchainTransactionHash] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun blockchainTransactionHash(
                            blockchainTransactionHash: JsonField<String>
                        ) = apply { this.blockchainTransactionHash = blockchainTransactionHash }

                        /** Destination wallet address. */
                        fun destinationWalletAddress(destinationWalletAddress: String) =
                            destinationWalletAddress(JsonField.of(destinationWalletAddress))

                        /**
                         * Sets [Builder.destinationWalletAddress] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.destinationWalletAddress] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun destinationWalletAddress(destinationWalletAddress: JsonField<String>) =
                            apply {
                                this.destinationWalletAddress = destinationWalletAddress
                            }

                        /** Prior approved transactions. */
                        fun priorApprovedTransactions(priorApprovedTransactions: String?) =
                            priorApprovedTransactions(
                                JsonField.ofNullable(priorApprovedTransactions)
                            )

                        /**
                         * Sets [Builder.priorApprovedTransactions] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.priorApprovedTransactions] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun priorApprovedTransactions(
                            priorApprovedTransactions: JsonField<String>
                        ) = apply { this.priorApprovedTransactions = priorApprovedTransactions }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of
                         * [NonFiatCurrencyOrNonFungibleTokenReceived].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .blockchainTransactionHash()
                         * .destinationWalletAddress()
                         * .priorApprovedTransactions()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): NonFiatCurrencyOrNonFungibleTokenReceived =
                            NonFiatCurrencyOrNonFungibleTokenReceived(
                                checkRequired(
                                    "blockchainTransactionHash",
                                    blockchainTransactionHash,
                                ),
                                checkRequired("destinationWalletAddress", destinationWalletAddress),
                                checkRequired(
                                    "priorApprovedTransactions",
                                    priorApprovedTransactions,
                                ),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): NonFiatCurrencyOrNonFungibleTokenReceived = apply {
                        if (validated) {
                            return@apply
                        }

                        blockchainTransactionHash()
                        destinationWalletAddress()
                        priorApprovedTransactions()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (blockchainTransactionHash.asKnown() == null) 0 else 1) +
                            (if (destinationWalletAddress.asKnown() == null) 0 else 1) +
                            (if (priorApprovedTransactions.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is NonFiatCurrencyOrNonFungibleTokenReceived &&
                            blockchainTransactionHash == other.blockchainTransactionHash &&
                            destinationWalletAddress == other.destinationWalletAddress &&
                            priorApprovedTransactions == other.priorApprovedTransactions &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            blockchainTransactionHash,
                            destinationWalletAddress,
                            priorApprovedTransactions,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "NonFiatCurrencyOrNonFungibleTokenReceived{blockchainTransactionHash=$blockchainTransactionHash, destinationWalletAddress=$destinationWalletAddress, priorApprovedTransactions=$priorApprovedTransactions, additionalProperties=$additionalProperties}"
                }

                /**
                 * Prior undisputed non-fraud transactions details. Present if and only if `reason`
                 * is `prior_undisputed_non_fraud_transactions`.
                 */
                class PriorUndisputedNonFraudTransactions
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Explanation of the prior undisputed non-fraud transactions provided by the
                     * merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [PriorUndisputedNonFraudTransactions].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [PriorUndisputedNonFraudTransactions]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            priorUndisputedNonFraudTransactions: PriorUndisputedNonFraudTransactions
                        ) = apply {
                            explanation = priorUndisputedNonFraudTransactions.explanation
                            additionalProperties =
                                priorUndisputedNonFraudTransactions.additionalProperties
                                    .toMutableMap()
                        }

                        /**
                         * Explanation of the prior undisputed non-fraud transactions provided by
                         * the merchant.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [PriorUndisputedNonFraudTransactions].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): PriorUndisputedNonFraudTransactions =
                            PriorUndisputedNonFraudTransactions(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): PriorUndisputedNonFraudTransactions = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (explanation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is PriorUndisputedNonFraudTransactions &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "PriorUndisputedNonFraudTransactions{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                /** The reason the merchant re-presented the dispute. */
                class Reason
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Cardholder no longer disputes the transaction. */
                        val CARDHOLDER_NO_LONGER_DISPUTES = of("cardholder_no_longer_disputes")

                        /** Compelling evidence. */
                        val COMPELLING_EVIDENCE = of("compelling_evidence")

                        /** Credit or reversal was processed. */
                        val CREDIT_OR_REVERSAL_PROCESSED = of("credit_or_reversal_processed")

                        /** Delayed charge transaction. */
                        val DELAYED_CHARGE_TRANSACTION = of("delayed_charge_transaction")

                        /** Evidence of imprint. */
                        val EVIDENCE_OF_IMPRINT = of("evidence_of_imprint")

                        /** Invalid dispute. */
                        val INVALID_DISPUTE = of("invalid_dispute")

                        /**
                         * Non-fiat currency or non-fungible token was received by the cardholder.
                         */
                        val NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED =
                            of("non_fiat_currency_or_non_fungible_token_received")

                        /** Prior undisputed non-fraud transactions. */
                        val PRIOR_UNDISPUTED_NON_FRAUD_TRANSACTIONS =
                            of("prior_undisputed_non_fraud_transactions")

                        fun of(value: String) = Reason(JsonField.of(value))
                    }

                    /** An enum containing [Reason]'s known values. */
                    enum class Known {
                        /** Cardholder no longer disputes the transaction. */
                        CARDHOLDER_NO_LONGER_DISPUTES,
                        /** Compelling evidence. */
                        COMPELLING_EVIDENCE,
                        /** Credit or reversal was processed. */
                        CREDIT_OR_REVERSAL_PROCESSED,
                        /** Delayed charge transaction. */
                        DELAYED_CHARGE_TRANSACTION,
                        /** Evidence of imprint. */
                        EVIDENCE_OF_IMPRINT,
                        /** Invalid dispute. */
                        INVALID_DISPUTE,
                        /**
                         * Non-fiat currency or non-fungible token was received by the cardholder.
                         */
                        NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED,
                        /** Prior undisputed non-fraud transactions. */
                        PRIOR_UNDISPUTED_NON_FRAUD_TRANSACTIONS,
                    }

                    /**
                     * An enum containing [Reason]'s known values, as well as an [_UNKNOWN] member.
                     *
                     * An instance of [Reason] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Cardholder no longer disputes the transaction. */
                        CARDHOLDER_NO_LONGER_DISPUTES,
                        /** Compelling evidence. */
                        COMPELLING_EVIDENCE,
                        /** Credit or reversal was processed. */
                        CREDIT_OR_REVERSAL_PROCESSED,
                        /** Delayed charge transaction. */
                        DELAYED_CHARGE_TRANSACTION,
                        /** Evidence of imprint. */
                        EVIDENCE_OF_IMPRINT,
                        /** Invalid dispute. */
                        INVALID_DISPUTE,
                        /**
                         * Non-fiat currency or non-fungible token was received by the cardholder.
                         */
                        NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED,
                        /** Prior undisputed non-fraud transactions. */
                        PRIOR_UNDISPUTED_NON_FRAUD_TRANSACTIONS,
                        /**
                         * An enum member indicating that [Reason] was instantiated with an unknown
                         * value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CARDHOLDER_NO_LONGER_DISPUTES -> Value.CARDHOLDER_NO_LONGER_DISPUTES
                            COMPELLING_EVIDENCE -> Value.COMPELLING_EVIDENCE
                            CREDIT_OR_REVERSAL_PROCESSED -> Value.CREDIT_OR_REVERSAL_PROCESSED
                            DELAYED_CHARGE_TRANSACTION -> Value.DELAYED_CHARGE_TRANSACTION
                            EVIDENCE_OF_IMPRINT -> Value.EVIDENCE_OF_IMPRINT
                            INVALID_DISPUTE -> Value.INVALID_DISPUTE
                            NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED ->
                                Value.NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED
                            PRIOR_UNDISPUTED_NON_FRAUD_TRANSACTIONS ->
                                Value.PRIOR_UNDISPUTED_NON_FRAUD_TRANSACTIONS
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CARDHOLDER_NO_LONGER_DISPUTES -> Known.CARDHOLDER_NO_LONGER_DISPUTES
                            COMPELLING_EVIDENCE -> Known.COMPELLING_EVIDENCE
                            CREDIT_OR_REVERSAL_PROCESSED -> Known.CREDIT_OR_REVERSAL_PROCESSED
                            DELAYED_CHARGE_TRANSACTION -> Known.DELAYED_CHARGE_TRANSACTION
                            EVIDENCE_OF_IMPRINT -> Known.EVIDENCE_OF_IMPRINT
                            INVALID_DISPUTE -> Known.INVALID_DISPUTE
                            NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED ->
                                Known.NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED
                            PRIOR_UNDISPUTED_NON_FRAUD_TRANSACTIONS ->
                                Known.PRIOR_UNDISPUTED_NON_FRAUD_TRANSACTIONS
                            else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Reason = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Reason && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is MerchantPrearbitrationReceived &&
                        cardholderNoLongerDisputes == other.cardholderNoLongerDisputes &&
                        compellingEvidence == other.compellingEvidence &&
                        creditOrReversalProcessed == other.creditOrReversalProcessed &&
                        delayedChargeTransaction == other.delayedChargeTransaction &&
                        evidenceOfImprint == other.evidenceOfImprint &&
                        invalidDispute == other.invalidDispute &&
                        nonFiatCurrencyOrNonFungibleTokenReceived ==
                            other.nonFiatCurrencyOrNonFungibleTokenReceived &&
                        priorUndisputedNonFraudTransactions ==
                            other.priorUndisputedNonFraudTransactions &&
                        reason == other.reason &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cardholderNoLongerDisputes,
                        compellingEvidence,
                        creditOrReversalProcessed,
                        delayedChargeTransaction,
                        evidenceOfImprint,
                        invalidDispute,
                        nonFiatCurrencyOrNonFungibleTokenReceived,
                        priorUndisputedNonFraudTransactions,
                        reason,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MerchantPrearbitrationReceived{cardholderNoLongerDisputes=$cardholderNoLongerDisputes, compellingEvidence=$compellingEvidence, creditOrReversalProcessed=$creditOrReversalProcessed, delayedChargeTransaction=$delayedChargeTransaction, evidenceOfImprint=$evidenceOfImprint, invalidDispute=$invalidDispute, nonFiatCurrencyOrNonFungibleTokenReceived=$nonFiatCurrencyOrNonFungibleTokenReceived, priorUndisputedNonFraudTransactions=$priorUndisputedNonFraudTransactions, reason=$reason, additionalProperties=$additionalProperties}"
            }

            /**
             * A Card Dispute Re-presented Visa Network Event object. This field will be present in
             * the JSON response if and only if `category` is equal to `represented`. Contains the
             * details specific to a re-presented Visa Card Dispute Network Event, which represents
             * that the merchant has declined the user's chargeback and has re-presented the
             * payment.
             */
            class Represented
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes>,
                private val creditOrReversalProcessed: JsonField<CreditOrReversalProcessed>,
                private val invalidDispute: JsonField<InvalidDispute>,
                private val nonFiatCurrencyOrNonFungibleTokenAsDescribed: JsonValue,
                private val nonFiatCurrencyOrNonFungibleTokenReceived:
                    JsonField<NonFiatCurrencyOrNonFungibleTokenReceived>,
                private val proofOfCashDisbursement: JsonField<ProofOfCashDisbursement>,
                private val reason: JsonField<Reason>,
                private val reversalIssued: JsonField<ReversalIssued>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("cardholder_no_longer_disputes")
                    @ExcludeMissing
                    cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes> =
                        JsonMissing.of(),
                    @JsonProperty("credit_or_reversal_processed")
                    @ExcludeMissing
                    creditOrReversalProcessed: JsonField<CreditOrReversalProcessed> =
                        JsonMissing.of(),
                    @JsonProperty("invalid_dispute")
                    @ExcludeMissing
                    invalidDispute: JsonField<InvalidDispute> = JsonMissing.of(),
                    @JsonProperty("non_fiat_currency_or_non_fungible_token_as_described")
                    @ExcludeMissing
                    nonFiatCurrencyOrNonFungibleTokenAsDescribed: JsonValue = JsonMissing.of(),
                    @JsonProperty("non_fiat_currency_or_non_fungible_token_received")
                    @ExcludeMissing
                    nonFiatCurrencyOrNonFungibleTokenReceived:
                        JsonField<NonFiatCurrencyOrNonFungibleTokenReceived> =
                        JsonMissing.of(),
                    @JsonProperty("proof_of_cash_disbursement")
                    @ExcludeMissing
                    proofOfCashDisbursement: JsonField<ProofOfCashDisbursement> = JsonMissing.of(),
                    @JsonProperty("reason")
                    @ExcludeMissing
                    reason: JsonField<Reason> = JsonMissing.of(),
                    @JsonProperty("reversal_issued")
                    @ExcludeMissing
                    reversalIssued: JsonField<ReversalIssued> = JsonMissing.of(),
                ) : this(
                    cardholderNoLongerDisputes,
                    creditOrReversalProcessed,
                    invalidDispute,
                    nonFiatCurrencyOrNonFungibleTokenAsDescribed,
                    nonFiatCurrencyOrNonFungibleTokenReceived,
                    proofOfCashDisbursement,
                    reason,
                    reversalIssued,
                    mutableMapOf(),
                )

                /**
                 * Cardholder no longer disputes details. Present if and only if `reason` is
                 * `cardholder_no_longer_disputes`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun cardholderNoLongerDisputes(): CardholderNoLongerDisputes? =
                    cardholderNoLongerDisputes.getNullable("cardholder_no_longer_disputes")

                /**
                 * Credit or reversal processed details. Present if and only if `reason` is
                 * `credit_or_reversal_processed`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun creditOrReversalProcessed(): CreditOrReversalProcessed? =
                    creditOrReversalProcessed.getNullable("credit_or_reversal_processed")

                /**
                 * Invalid dispute details. Present if and only if `reason` is `invalid_dispute`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun invalidDispute(): InvalidDispute? =
                    invalidDispute.getNullable("invalid_dispute")

                /**
                 * Non-fiat currency or non-fungible token as described details. Present if and only
                 * if `reason` is `non_fiat_currency_or_non_fungible_token_as_described`.
                 */
                @JsonProperty("non_fiat_currency_or_non_fungible_token_as_described")
                @ExcludeMissing
                fun _nonFiatCurrencyOrNonFungibleTokenAsDescribed(): JsonValue =
                    nonFiatCurrencyOrNonFungibleTokenAsDescribed

                /**
                 * Non-fiat currency or non-fungible token received details. Present if and only if
                 * `reason` is `non_fiat_currency_or_non_fungible_token_received`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun nonFiatCurrencyOrNonFungibleTokenReceived():
                    NonFiatCurrencyOrNonFungibleTokenReceived? =
                    nonFiatCurrencyOrNonFungibleTokenReceived.getNullable(
                        "non_fiat_currency_or_non_fungible_token_received"
                    )

                /**
                 * Proof of cash disbursement details. Present if and only if `reason` is
                 * `proof_of_cash_disbursement`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun proofOfCashDisbursement(): ProofOfCashDisbursement? =
                    proofOfCashDisbursement.getNullable("proof_of_cash_disbursement")

                /**
                 * The reason the merchant re-presented the dispute.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun reason(): Reason = reason.getRequired("reason")

                /**
                 * Reversal issued by merchant details. Present if and only if `reason` is
                 * `reversal_issued`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun reversalIssued(): ReversalIssued? =
                    reversalIssued.getNullable("reversal_issued")

                /**
                 * Returns the raw JSON value of [cardholderNoLongerDisputes].
                 *
                 * Unlike [cardholderNoLongerDisputes], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("cardholder_no_longer_disputes")
                @ExcludeMissing
                fun _cardholderNoLongerDisputes(): JsonField<CardholderNoLongerDisputes> =
                    cardholderNoLongerDisputes

                /**
                 * Returns the raw JSON value of [creditOrReversalProcessed].
                 *
                 * Unlike [creditOrReversalProcessed], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("credit_or_reversal_processed")
                @ExcludeMissing
                fun _creditOrReversalProcessed(): JsonField<CreditOrReversalProcessed> =
                    creditOrReversalProcessed

                /**
                 * Returns the raw JSON value of [invalidDispute].
                 *
                 * Unlike [invalidDispute], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("invalid_dispute")
                @ExcludeMissing
                fun _invalidDispute(): JsonField<InvalidDispute> = invalidDispute

                /**
                 * Returns the raw JSON value of [nonFiatCurrencyOrNonFungibleTokenReceived].
                 *
                 * Unlike [nonFiatCurrencyOrNonFungibleTokenReceived], this method doesn't throw if
                 * the JSON field has an unexpected type.
                 */
                @JsonProperty("non_fiat_currency_or_non_fungible_token_received")
                @ExcludeMissing
                fun _nonFiatCurrencyOrNonFungibleTokenReceived():
                    JsonField<NonFiatCurrencyOrNonFungibleTokenReceived> =
                    nonFiatCurrencyOrNonFungibleTokenReceived

                /**
                 * Returns the raw JSON value of [proofOfCashDisbursement].
                 *
                 * Unlike [proofOfCashDisbursement], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("proof_of_cash_disbursement")
                @ExcludeMissing
                fun _proofOfCashDisbursement(): JsonField<ProofOfCashDisbursement> =
                    proofOfCashDisbursement

                /**
                 * Returns the raw JSON value of [reason].
                 *
                 * Unlike [reason], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<Reason> = reason

                /**
                 * Returns the raw JSON value of [reversalIssued].
                 *
                 * Unlike [reversalIssued], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("reversal_issued")
                @ExcludeMissing
                fun _reversalIssued(): JsonField<ReversalIssued> = reversalIssued

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Represented].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderNoLongerDisputes()
                     * .creditOrReversalProcessed()
                     * .invalidDispute()
                     * .nonFiatCurrencyOrNonFungibleTokenAsDescribed()
                     * .nonFiatCurrencyOrNonFungibleTokenReceived()
                     * .proofOfCashDisbursement()
                     * .reason()
                     * .reversalIssued()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Represented]. */
                class Builder internal constructor() {

                    private var cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes>? =
                        null
                    private var creditOrReversalProcessed: JsonField<CreditOrReversalProcessed>? =
                        null
                    private var invalidDispute: JsonField<InvalidDispute>? = null
                    private var nonFiatCurrencyOrNonFungibleTokenAsDescribed: JsonValue? = null
                    private var nonFiatCurrencyOrNonFungibleTokenReceived:
                        JsonField<NonFiatCurrencyOrNonFungibleTokenReceived>? =
                        null
                    private var proofOfCashDisbursement: JsonField<ProofOfCashDisbursement>? = null
                    private var reason: JsonField<Reason>? = null
                    private var reversalIssued: JsonField<ReversalIssued>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(represented: Represented) = apply {
                        cardholderNoLongerDisputes = represented.cardholderNoLongerDisputes
                        creditOrReversalProcessed = represented.creditOrReversalProcessed
                        invalidDispute = represented.invalidDispute
                        nonFiatCurrencyOrNonFungibleTokenAsDescribed =
                            represented.nonFiatCurrencyOrNonFungibleTokenAsDescribed
                        nonFiatCurrencyOrNonFungibleTokenReceived =
                            represented.nonFiatCurrencyOrNonFungibleTokenReceived
                        proofOfCashDisbursement = represented.proofOfCashDisbursement
                        reason = represented.reason
                        reversalIssued = represented.reversalIssued
                        additionalProperties = represented.additionalProperties.toMutableMap()
                    }

                    /**
                     * Cardholder no longer disputes details. Present if and only if `reason` is
                     * `cardholder_no_longer_disputes`.
                     */
                    fun cardholderNoLongerDisputes(
                        cardholderNoLongerDisputes: CardholderNoLongerDisputes?
                    ) = cardholderNoLongerDisputes(JsonField.ofNullable(cardholderNoLongerDisputes))

                    /**
                     * Sets [Builder.cardholderNoLongerDisputes] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.cardholderNoLongerDisputes] with a
                     * well-typed [CardholderNoLongerDisputes] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun cardholderNoLongerDisputes(
                        cardholderNoLongerDisputes: JsonField<CardholderNoLongerDisputes>
                    ) = apply { this.cardholderNoLongerDisputes = cardholderNoLongerDisputes }

                    /**
                     * Credit or reversal processed details. Present if and only if `reason` is
                     * `credit_or_reversal_processed`.
                     */
                    fun creditOrReversalProcessed(
                        creditOrReversalProcessed: CreditOrReversalProcessed?
                    ) = creditOrReversalProcessed(JsonField.ofNullable(creditOrReversalProcessed))

                    /**
                     * Sets [Builder.creditOrReversalProcessed] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.creditOrReversalProcessed] with a well-typed
                     * [CreditOrReversalProcessed] value instead. This method is primarily for
                     * setting the field to an undocumented or not yet supported value.
                     */
                    fun creditOrReversalProcessed(
                        creditOrReversalProcessed: JsonField<CreditOrReversalProcessed>
                    ) = apply { this.creditOrReversalProcessed = creditOrReversalProcessed }

                    /**
                     * Invalid dispute details. Present if and only if `reason` is
                     * `invalid_dispute`.
                     */
                    fun invalidDispute(invalidDispute: InvalidDispute?) =
                        invalidDispute(JsonField.ofNullable(invalidDispute))

                    /**
                     * Sets [Builder.invalidDispute] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.invalidDispute] with a well-typed
                     * [InvalidDispute] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun invalidDispute(invalidDispute: JsonField<InvalidDispute>) = apply {
                        this.invalidDispute = invalidDispute
                    }

                    /**
                     * Non-fiat currency or non-fungible token as described details. Present if and
                     * only if `reason` is `non_fiat_currency_or_non_fungible_token_as_described`.
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenAsDescribed(
                        nonFiatCurrencyOrNonFungibleTokenAsDescribed: JsonValue
                    ) = apply {
                        this.nonFiatCurrencyOrNonFungibleTokenAsDescribed =
                            nonFiatCurrencyOrNonFungibleTokenAsDescribed
                    }

                    /**
                     * Non-fiat currency or non-fungible token received details. Present if and only
                     * if `reason` is `non_fiat_currency_or_non_fungible_token_received`.
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenReceived(
                        nonFiatCurrencyOrNonFungibleTokenReceived:
                            NonFiatCurrencyOrNonFungibleTokenReceived?
                    ) =
                        nonFiatCurrencyOrNonFungibleTokenReceived(
                            JsonField.ofNullable(nonFiatCurrencyOrNonFungibleTokenReceived)
                        )

                    /**
                     * Sets [Builder.nonFiatCurrencyOrNonFungibleTokenReceived] to an arbitrary JSON
                     * value.
                     *
                     * You should usually call [Builder.nonFiatCurrencyOrNonFungibleTokenReceived]
                     * with a well-typed [NonFiatCurrencyOrNonFungibleTokenReceived] value instead.
                     * This method is primarily for setting the field to an undocumented or not yet
                     * supported value.
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenReceived(
                        nonFiatCurrencyOrNonFungibleTokenReceived:
                            JsonField<NonFiatCurrencyOrNonFungibleTokenReceived>
                    ) = apply {
                        this.nonFiatCurrencyOrNonFungibleTokenReceived =
                            nonFiatCurrencyOrNonFungibleTokenReceived
                    }

                    /**
                     * Proof of cash disbursement details. Present if and only if `reason` is
                     * `proof_of_cash_disbursement`.
                     */
                    fun proofOfCashDisbursement(proofOfCashDisbursement: ProofOfCashDisbursement?) =
                        proofOfCashDisbursement(JsonField.ofNullable(proofOfCashDisbursement))

                    /**
                     * Sets [Builder.proofOfCashDisbursement] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.proofOfCashDisbursement] with a well-typed
                     * [ProofOfCashDisbursement] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun proofOfCashDisbursement(
                        proofOfCashDisbursement: JsonField<ProofOfCashDisbursement>
                    ) = apply { this.proofOfCashDisbursement = proofOfCashDisbursement }

                    /** The reason the merchant re-presented the dispute. */
                    fun reason(reason: Reason) = reason(JsonField.of(reason))

                    /**
                     * Sets [Builder.reason] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.reason] with a well-typed [Reason] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                    /**
                     * Reversal issued by merchant details. Present if and only if `reason` is
                     * `reversal_issued`.
                     */
                    fun reversalIssued(reversalIssued: ReversalIssued?) =
                        reversalIssued(JsonField.ofNullable(reversalIssued))

                    /**
                     * Sets [Builder.reversalIssued] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.reversalIssued] with a well-typed
                     * [ReversalIssued] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun reversalIssued(reversalIssued: JsonField<ReversalIssued>) = apply {
                        this.reversalIssued = reversalIssued
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Represented].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .cardholderNoLongerDisputes()
                     * .creditOrReversalProcessed()
                     * .invalidDispute()
                     * .nonFiatCurrencyOrNonFungibleTokenAsDescribed()
                     * .nonFiatCurrencyOrNonFungibleTokenReceived()
                     * .proofOfCashDisbursement()
                     * .reason()
                     * .reversalIssued()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Represented =
                        Represented(
                            checkRequired("cardholderNoLongerDisputes", cardholderNoLongerDisputes),
                            checkRequired("creditOrReversalProcessed", creditOrReversalProcessed),
                            checkRequired("invalidDispute", invalidDispute),
                            checkRequired(
                                "nonFiatCurrencyOrNonFungibleTokenAsDescribed",
                                nonFiatCurrencyOrNonFungibleTokenAsDescribed,
                            ),
                            checkRequired(
                                "nonFiatCurrencyOrNonFungibleTokenReceived",
                                nonFiatCurrencyOrNonFungibleTokenReceived,
                            ),
                            checkRequired("proofOfCashDisbursement", proofOfCashDisbursement),
                            checkRequired("reason", reason),
                            checkRequired("reversalIssued", reversalIssued),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Represented = apply {
                    if (validated) {
                        return@apply
                    }

                    cardholderNoLongerDisputes()?.validate()
                    creditOrReversalProcessed()?.validate()
                    invalidDispute()?.validate()
                    nonFiatCurrencyOrNonFungibleTokenReceived()?.validate()
                    proofOfCashDisbursement()?.validate()
                    reason().validate()
                    reversalIssued()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (cardholderNoLongerDisputes.asKnown()?.validity() ?: 0) +
                        (creditOrReversalProcessed.asKnown()?.validity() ?: 0) +
                        (invalidDispute.asKnown()?.validity() ?: 0) +
                        (nonFiatCurrencyOrNonFungibleTokenReceived.asKnown()?.validity() ?: 0) +
                        (proofOfCashDisbursement.asKnown()?.validity() ?: 0) +
                        (reason.asKnown()?.validity() ?: 0) +
                        (reversalIssued.asKnown()?.validity() ?: 0)

                /**
                 * Cardholder no longer disputes details. Present if and only if `reason` is
                 * `cardholder_no_longer_disputes`.
                 */
                class CardholderNoLongerDisputes
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Explanation for why the merchant believes the cardholder no longer disputes
                     * the transaction.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CardholderNoLongerDisputes].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CardholderNoLongerDisputes]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(cardholderNoLongerDisputes: CardholderNoLongerDisputes) =
                            apply {
                                explanation = cardholderNoLongerDisputes.explanation
                                additionalProperties =
                                    cardholderNoLongerDisputes.additionalProperties.toMutableMap()
                            }

                        /**
                         * Explanation for why the merchant believes the cardholder no longer
                         * disputes the transaction.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CardholderNoLongerDisputes].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CardholderNoLongerDisputes =
                            CardholderNoLongerDisputes(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CardholderNoLongerDisputes = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (explanation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CardholderNoLongerDisputes &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CardholderNoLongerDisputes{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                /**
                 * Credit or reversal processed details. Present if and only if `reason` is
                 * `credit_or_reversal_processed`.
                 */
                class CreditOrReversalProcessed
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val amount: JsonField<Long>,
                    private val currency: JsonField<String>,
                    private val explanation: JsonField<String>,
                    private val processedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("amount")
                        @ExcludeMissing
                        amount: JsonField<Long> = JsonMissing.of(),
                        @JsonProperty("currency")
                        @ExcludeMissing
                        currency: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("processed_at")
                        @ExcludeMissing
                        processedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(amount, currency, explanation, processedAt, mutableMapOf())

                    /**
                     * The amount of the credit or reversal in the minor unit of its currency. For
                     * dollars, for example, this is cents.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun amount(): Long = amount.getRequired("amount")

                    /**
                     * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the credit or
                     * reversal's currency.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun currency(): String = currency.getRequired("currency")

                    /**
                     * Explanation for why the merchant believes the credit or reversal was
                     * processed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * The date the credit or reversal was processed.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun processedAt(): LocalDate = processedAt.getRequired("processed_at")

                    /**
                     * Returns the raw JSON value of [amount].
                     *
                     * Unlike [amount], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

                    /**
                     * Returns the raw JSON value of [currency].
                     *
                     * Unlike [currency], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("currency")
                    @ExcludeMissing
                    fun _currency(): JsonField<String> = currency

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [processedAt].
                     *
                     * Unlike [processedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("processed_at")
                    @ExcludeMissing
                    fun _processedAt(): JsonField<LocalDate> = processedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CreditOrReversalProcessed].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .amount()
                         * .currency()
                         * .explanation()
                         * .processedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CreditOrReversalProcessed]. */
                    class Builder internal constructor() {

                        private var amount: JsonField<Long>? = null
                        private var currency: JsonField<String>? = null
                        private var explanation: JsonField<String>? = null
                        private var processedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(creditOrReversalProcessed: CreditOrReversalProcessed) =
                            apply {
                                amount = creditOrReversalProcessed.amount
                                currency = creditOrReversalProcessed.currency
                                explanation = creditOrReversalProcessed.explanation
                                processedAt = creditOrReversalProcessed.processedAt
                                additionalProperties =
                                    creditOrReversalProcessed.additionalProperties.toMutableMap()
                            }

                        /**
                         * The amount of the credit or reversal in the minor unit of its currency.
                         * For dollars, for example, this is cents.
                         */
                        fun amount(amount: Long) = amount(JsonField.of(amount))

                        /**
                         * Sets [Builder.amount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.amount] with a well-typed [Long] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                        /**
                         * The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) code for the
                         * credit or reversal's currency.
                         */
                        fun currency(currency: String) = currency(JsonField.of(currency))

                        /**
                         * Sets [Builder.currency] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.currency] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun currency(currency: JsonField<String>) = apply {
                            this.currency = currency
                        }

                        /**
                         * Explanation for why the merchant believes the credit or reversal was
                         * processed.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** The date the credit or reversal was processed. */
                        fun processedAt(processedAt: LocalDate) =
                            processedAt(JsonField.of(processedAt))

                        /**
                         * Sets [Builder.processedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.processedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun processedAt(processedAt: JsonField<LocalDate>) = apply {
                            this.processedAt = processedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CreditOrReversalProcessed].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .amount()
                         * .currency()
                         * .explanation()
                         * .processedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CreditOrReversalProcessed =
                            CreditOrReversalProcessed(
                                checkRequired("amount", amount),
                                checkRequired("currency", currency),
                                checkRequired("explanation", explanation),
                                checkRequired("processedAt", processedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CreditOrReversalProcessed = apply {
                        if (validated) {
                            return@apply
                        }

                        amount()
                        currency()
                        explanation()
                        processedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (amount.asKnown() == null) 0 else 1) +
                            (if (currency.asKnown() == null) 0 else 1) +
                            (if (explanation.asKnown() == null) 0 else 1) +
                            (if (processedAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CreditOrReversalProcessed &&
                            amount == other.amount &&
                            currency == other.currency &&
                            explanation == other.explanation &&
                            processedAt == other.processedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            amount,
                            currency,
                            explanation,
                            processedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CreditOrReversalProcessed{amount=$amount, currency=$currency, explanation=$explanation, processedAt=$processedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Invalid dispute details. Present if and only if `reason` is `invalid_dispute`.
                 */
                class InvalidDispute
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val reason: JsonField<Reason>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<Reason> = JsonMissing.of(),
                    ) : this(explanation, reason, mutableMapOf())

                    /**
                     * Explanation for why the dispute is considered invalid by the merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * The reason a merchant considers the dispute invalid.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): Reason = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<Reason> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [InvalidDispute].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [InvalidDispute]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var reason: JsonField<Reason>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(invalidDispute: InvalidDispute) = apply {
                            explanation = invalidDispute.explanation
                            reason = invalidDispute.reason
                            additionalProperties =
                                invalidDispute.additionalProperties.toMutableMap()
                        }

                        /**
                         * Explanation for why the dispute is considered invalid by the merchant.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** The reason a merchant considers the dispute invalid. */
                        fun reason(reason: Reason) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [Reason] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [InvalidDispute].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): InvalidDispute =
                            InvalidDispute(
                                checkRequired("explanation", explanation),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): InvalidDispute = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        reason().validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (explanation.asKnown() == null) 0 else 1) +
                            (reason.asKnown()?.validity() ?: 0)

                    /** The reason a merchant considers the dispute invalid. */
                    class Reason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Automatic Teller Machine (ATM) transaction proof provided. */
                            val AUTOMATIC_TELLER_MACHINE_TRANSACTION_PROOF_PROVIDED =
                                of("automatic_teller_machine_transaction_proof_provided")

                            /** Balance of partial prepayment not paid. */
                            val BALANCE_OF_PARTIAL_PREPAYMENT_NOT_PAID =
                                of("balance_of_partial_prepayment_not_paid")

                            /**
                             * Cardholder canceled before expected receipt date of the merchandise.
                             */
                            val CARDHOLDER_CANCELED_BEFORE_EXPECTED_MERCHANDISE_RECEIPT_DATE =
                                of("cardholder_canceled_before_expected_merchandise_receipt_date")

                            /** Cardholder canceled before expected receipt date of the services. */
                            val CARDHOLDER_CANCELED_BEFORE_EXPECTED_SERVICES_RECEIPT_DATE =
                                of("cardholder_canceled_before_expected_services_receipt_date")

                            /** Cardholder canceled on a different date than claimed. */
                            val CARDHOLDER_CANCELED_DIFFERENT_DATE =
                                of("cardholder_canceled_different_date")

                            /** Cardholder received did not cancel according to policy. */
                            val CARDHOLDER_DID_NOT_CANCEL_ACCORDING_TO_POLICY =
                                of("cardholder_did_not_cancel_according_to_policy")

                            /** Cardholder received the merchandise. */
                            val CARDHOLDER_RECEIVED_MERCHANDISE =
                                of("cardholder_received_merchandise")

                            /** Country code is correct. */
                            val COUNTRY_CODE_CORRECT = of("country_code_correct")

                            /** Credit was processed correctly. */
                            val CREDIT_PROCESSED_CORRECTLY = of("credit_processed_correctly")

                            /** Currency is correct. */
                            val CURRENCY_CORRECT = of("currency_correct")

                            /** Dispute is for quality. */
                            val DISPUTE_IS_FOR_QUALITY = of("dispute_is_for_quality")

                            /** Dispute is for Visa Cash Back transaction portion. */
                            val DISPUTE_IS_FOR_VISA_CASH_BACK_TRANSACTION_PORTION =
                                of("dispute_is_for_visa_cash_back_transaction_portion")

                            /** Disputed amount is Value Added Tax (VAT). */
                            val DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX =
                                of("disputed_amount_is_value_added_tax")

                            /**
                             * Disputed amount is Value Added Tax (VAT) but no credit receipt was
                             * provided by the cardholder.
                             */
                            val DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX_NO_CREDIT_RECEIPT_PROVIDED =
                                of("disputed_amount_is_value_added_tax_no_credit_receipt_provided")

                            /** Limited return or cancellation policy was properly disclosed. */
                            val LIMITED_RETURN_OR_CANCELLATION_POLICY_PROPERLY_DISCLOSED =
                                of("limited_return_or_cancellation_policy_properly_disclosed")

                            /** Merchandise held at cardholder customs agency. */
                            val MERCHANDISE_HELD_AT_CARDHOLDER_CUSTOMS_AGENCY =
                                of("merchandise_held_at_cardholder_customs_agency")

                            /** Merchandise matches the merchant's description. */
                            val MERCHANDISE_MATCHES_DESCRIPTION =
                                of("merchandise_matches_description")

                            /** Merchandise is not counterfeit. */
                            val MERCHANDISE_NOT_COUNTERFEIT = of("merchandise_not_counterfeit")

                            /** Merchandise is not damaged. */
                            val MERCHANDISE_NOT_DAMAGED = of("merchandise_not_damaged")

                            /** Merchandise is not defective. */
                            val MERCHANDISE_NOT_DEFECTIVE = of("merchandise_not_defective")

                            /** Merchandise was provided prior to the cancellation date. */
                            val MERCHANDISE_PROVIDED_PRIOR_TO_CANCELLATION_DATE =
                                of("merchandise_provided_prior_to_cancellation_date")

                            /** Merchandise quality matches the merchant's description. */
                            val MERCHANDISE_QUALITY_MATCHES_DESCRIPTION =
                                of("merchandise_quality_matches_description")

                            /** Merchandise was not attempted returned to the merchant. */
                            val MERCHANDISE_RETURN_NOT_ATTEMPTED =
                                of("merchandise_return_not_attempted")

                            /** Merchant was not notified of the closed account. */
                            val MERCHANT_NOT_NOTIFIED_OF_CLOSED_ACCOUNT =
                                of("merchant_not_notified_of_closed_account")

                            /**
                             * Name on manifest of departed flight matches name on purchased
                             * itinerary.
                             */
                            val NAME_ON_FLIGHT_MANIFEST_MATCHES_PURCHASE =
                                of("name_on_flight_manifest_matches_purchase")

                            /** No credit receipt was provided by the cardholder. */
                            val NO_CREDIT_RECEIPT_PROVIDED = of("no_credit_receipt_provided")

                            /** Other. */
                            val OTHER = of("other")

                            /** The claimed processing error did not occur. */
                            val PROCESSING_ERROR_INCORRECT = of("processing_error_incorrect")

                            /**
                             * Returned merchandise held at customs agency outside the merchant's
                             * country.
                             */
                            val RETURNED_MECHANDISE_HELD_AT_CUSTOMS_AGENCY_OUTSIDE_MERCHANT_COUNTRY =
                                of(
                                    "returned_mechandise_held_at_customs_agency_outside_merchant_country"
                                )

                            /** Services match the merchant's description. */
                            val SERVICES_MATCH_DESCRIPTION = of("services_match_description")

                            /** Services were provided prior to the cancellation date. */
                            val SERVICES_PROVIDED_PRIOR_TO_CANCELLATION_DATE =
                                of("services_provided_prior_to_cancellation_date")

                            /**
                             * Services were used after the cancellation date and prior to the
                             * dispute submission date.
                             */
                            val SERVICES_USED_AFTER_CANCELLATION_DATE =
                                of("services_used_after_cancellation_date")

                            /** Terms of service were not misrepresented. */
                            val TERMS_OF_SERVICE_NOT_MISREPRESENTED =
                                of("terms_of_service_not_misrepresented")

                            /** Transaction code is correct. */
                            val TRANSACTION_CODE_CORRECT = of("transaction_code_correct")

                            fun of(value: String) = Reason(JsonField.of(value))
                        }

                        /** An enum containing [Reason]'s known values. */
                        enum class Known {
                            /** Automatic Teller Machine (ATM) transaction proof provided. */
                            AUTOMATIC_TELLER_MACHINE_TRANSACTION_PROOF_PROVIDED,
                            /** Balance of partial prepayment not paid. */
                            BALANCE_OF_PARTIAL_PREPAYMENT_NOT_PAID,
                            /**
                             * Cardholder canceled before expected receipt date of the merchandise.
                             */
                            CARDHOLDER_CANCELED_BEFORE_EXPECTED_MERCHANDISE_RECEIPT_DATE,
                            /** Cardholder canceled before expected receipt date of the services. */
                            CARDHOLDER_CANCELED_BEFORE_EXPECTED_SERVICES_RECEIPT_DATE,
                            /** Cardholder canceled on a different date than claimed. */
                            CARDHOLDER_CANCELED_DIFFERENT_DATE,
                            /** Cardholder received did not cancel according to policy. */
                            CARDHOLDER_DID_NOT_CANCEL_ACCORDING_TO_POLICY,
                            /** Cardholder received the merchandise. */
                            CARDHOLDER_RECEIVED_MERCHANDISE,
                            /** Country code is correct. */
                            COUNTRY_CODE_CORRECT,
                            /** Credit was processed correctly. */
                            CREDIT_PROCESSED_CORRECTLY,
                            /** Currency is correct. */
                            CURRENCY_CORRECT,
                            /** Dispute is for quality. */
                            DISPUTE_IS_FOR_QUALITY,
                            /** Dispute is for Visa Cash Back transaction portion. */
                            DISPUTE_IS_FOR_VISA_CASH_BACK_TRANSACTION_PORTION,
                            /** Disputed amount is Value Added Tax (VAT). */
                            DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX,
                            /**
                             * Disputed amount is Value Added Tax (VAT) but no credit receipt was
                             * provided by the cardholder.
                             */
                            DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX_NO_CREDIT_RECEIPT_PROVIDED,
                            /** Limited return or cancellation policy was properly disclosed. */
                            LIMITED_RETURN_OR_CANCELLATION_POLICY_PROPERLY_DISCLOSED,
                            /** Merchandise held at cardholder customs agency. */
                            MERCHANDISE_HELD_AT_CARDHOLDER_CUSTOMS_AGENCY,
                            /** Merchandise matches the merchant's description. */
                            MERCHANDISE_MATCHES_DESCRIPTION,
                            /** Merchandise is not counterfeit. */
                            MERCHANDISE_NOT_COUNTERFEIT,
                            /** Merchandise is not damaged. */
                            MERCHANDISE_NOT_DAMAGED,
                            /** Merchandise is not defective. */
                            MERCHANDISE_NOT_DEFECTIVE,
                            /** Merchandise was provided prior to the cancellation date. */
                            MERCHANDISE_PROVIDED_PRIOR_TO_CANCELLATION_DATE,
                            /** Merchandise quality matches the merchant's description. */
                            MERCHANDISE_QUALITY_MATCHES_DESCRIPTION,
                            /** Merchandise was not attempted returned to the merchant. */
                            MERCHANDISE_RETURN_NOT_ATTEMPTED,
                            /** Merchant was not notified of the closed account. */
                            MERCHANT_NOT_NOTIFIED_OF_CLOSED_ACCOUNT,
                            /**
                             * Name on manifest of departed flight matches name on purchased
                             * itinerary.
                             */
                            NAME_ON_FLIGHT_MANIFEST_MATCHES_PURCHASE,
                            /** No credit receipt was provided by the cardholder. */
                            NO_CREDIT_RECEIPT_PROVIDED,
                            /** Other. */
                            OTHER,
                            /** The claimed processing error did not occur. */
                            PROCESSING_ERROR_INCORRECT,
                            /**
                             * Returned merchandise held at customs agency outside the merchant's
                             * country.
                             */
                            RETURNED_MECHANDISE_HELD_AT_CUSTOMS_AGENCY_OUTSIDE_MERCHANT_COUNTRY,
                            /** Services match the merchant's description. */
                            SERVICES_MATCH_DESCRIPTION,
                            /** Services were provided prior to the cancellation date. */
                            SERVICES_PROVIDED_PRIOR_TO_CANCELLATION_DATE,
                            /**
                             * Services were used after the cancellation date and prior to the
                             * dispute submission date.
                             */
                            SERVICES_USED_AFTER_CANCELLATION_DATE,
                            /** Terms of service were not misrepresented. */
                            TERMS_OF_SERVICE_NOT_MISREPRESENTED,
                            /** Transaction code is correct. */
                            TRANSACTION_CODE_CORRECT,
                        }

                        /**
                         * An enum containing [Reason]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [Reason] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Automatic Teller Machine (ATM) transaction proof provided. */
                            AUTOMATIC_TELLER_MACHINE_TRANSACTION_PROOF_PROVIDED,
                            /** Balance of partial prepayment not paid. */
                            BALANCE_OF_PARTIAL_PREPAYMENT_NOT_PAID,
                            /**
                             * Cardholder canceled before expected receipt date of the merchandise.
                             */
                            CARDHOLDER_CANCELED_BEFORE_EXPECTED_MERCHANDISE_RECEIPT_DATE,
                            /** Cardholder canceled before expected receipt date of the services. */
                            CARDHOLDER_CANCELED_BEFORE_EXPECTED_SERVICES_RECEIPT_DATE,
                            /** Cardholder canceled on a different date than claimed. */
                            CARDHOLDER_CANCELED_DIFFERENT_DATE,
                            /** Cardholder received did not cancel according to policy. */
                            CARDHOLDER_DID_NOT_CANCEL_ACCORDING_TO_POLICY,
                            /** Cardholder received the merchandise. */
                            CARDHOLDER_RECEIVED_MERCHANDISE,
                            /** Country code is correct. */
                            COUNTRY_CODE_CORRECT,
                            /** Credit was processed correctly. */
                            CREDIT_PROCESSED_CORRECTLY,
                            /** Currency is correct. */
                            CURRENCY_CORRECT,
                            /** Dispute is for quality. */
                            DISPUTE_IS_FOR_QUALITY,
                            /** Dispute is for Visa Cash Back transaction portion. */
                            DISPUTE_IS_FOR_VISA_CASH_BACK_TRANSACTION_PORTION,
                            /** Disputed amount is Value Added Tax (VAT). */
                            DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX,
                            /**
                             * Disputed amount is Value Added Tax (VAT) but no credit receipt was
                             * provided by the cardholder.
                             */
                            DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX_NO_CREDIT_RECEIPT_PROVIDED,
                            /** Limited return or cancellation policy was properly disclosed. */
                            LIMITED_RETURN_OR_CANCELLATION_POLICY_PROPERLY_DISCLOSED,
                            /** Merchandise held at cardholder customs agency. */
                            MERCHANDISE_HELD_AT_CARDHOLDER_CUSTOMS_AGENCY,
                            /** Merchandise matches the merchant's description. */
                            MERCHANDISE_MATCHES_DESCRIPTION,
                            /** Merchandise is not counterfeit. */
                            MERCHANDISE_NOT_COUNTERFEIT,
                            /** Merchandise is not damaged. */
                            MERCHANDISE_NOT_DAMAGED,
                            /** Merchandise is not defective. */
                            MERCHANDISE_NOT_DEFECTIVE,
                            /** Merchandise was provided prior to the cancellation date. */
                            MERCHANDISE_PROVIDED_PRIOR_TO_CANCELLATION_DATE,
                            /** Merchandise quality matches the merchant's description. */
                            MERCHANDISE_QUALITY_MATCHES_DESCRIPTION,
                            /** Merchandise was not attempted returned to the merchant. */
                            MERCHANDISE_RETURN_NOT_ATTEMPTED,
                            /** Merchant was not notified of the closed account. */
                            MERCHANT_NOT_NOTIFIED_OF_CLOSED_ACCOUNT,
                            /**
                             * Name on manifest of departed flight matches name on purchased
                             * itinerary.
                             */
                            NAME_ON_FLIGHT_MANIFEST_MATCHES_PURCHASE,
                            /** No credit receipt was provided by the cardholder. */
                            NO_CREDIT_RECEIPT_PROVIDED,
                            /** Other. */
                            OTHER,
                            /** The claimed processing error did not occur. */
                            PROCESSING_ERROR_INCORRECT,
                            /**
                             * Returned merchandise held at customs agency outside the merchant's
                             * country.
                             */
                            RETURNED_MECHANDISE_HELD_AT_CUSTOMS_AGENCY_OUTSIDE_MERCHANT_COUNTRY,
                            /** Services match the merchant's description. */
                            SERVICES_MATCH_DESCRIPTION,
                            /** Services were provided prior to the cancellation date. */
                            SERVICES_PROVIDED_PRIOR_TO_CANCELLATION_DATE,
                            /**
                             * Services were used after the cancellation date and prior to the
                             * dispute submission date.
                             */
                            SERVICES_USED_AFTER_CANCELLATION_DATE,
                            /** Terms of service were not misrepresented. */
                            TERMS_OF_SERVICE_NOT_MISREPRESENTED,
                            /** Transaction code is correct. */
                            TRANSACTION_CODE_CORRECT,
                            /**
                             * An enum member indicating that [Reason] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                AUTOMATIC_TELLER_MACHINE_TRANSACTION_PROOF_PROVIDED ->
                                    Value.AUTOMATIC_TELLER_MACHINE_TRANSACTION_PROOF_PROVIDED
                                BALANCE_OF_PARTIAL_PREPAYMENT_NOT_PAID ->
                                    Value.BALANCE_OF_PARTIAL_PREPAYMENT_NOT_PAID
                                CARDHOLDER_CANCELED_BEFORE_EXPECTED_MERCHANDISE_RECEIPT_DATE ->
                                    Value
                                        .CARDHOLDER_CANCELED_BEFORE_EXPECTED_MERCHANDISE_RECEIPT_DATE
                                CARDHOLDER_CANCELED_BEFORE_EXPECTED_SERVICES_RECEIPT_DATE ->
                                    Value.CARDHOLDER_CANCELED_BEFORE_EXPECTED_SERVICES_RECEIPT_DATE
                                CARDHOLDER_CANCELED_DIFFERENT_DATE ->
                                    Value.CARDHOLDER_CANCELED_DIFFERENT_DATE
                                CARDHOLDER_DID_NOT_CANCEL_ACCORDING_TO_POLICY ->
                                    Value.CARDHOLDER_DID_NOT_CANCEL_ACCORDING_TO_POLICY
                                CARDHOLDER_RECEIVED_MERCHANDISE ->
                                    Value.CARDHOLDER_RECEIVED_MERCHANDISE
                                COUNTRY_CODE_CORRECT -> Value.COUNTRY_CODE_CORRECT
                                CREDIT_PROCESSED_CORRECTLY -> Value.CREDIT_PROCESSED_CORRECTLY
                                CURRENCY_CORRECT -> Value.CURRENCY_CORRECT
                                DISPUTE_IS_FOR_QUALITY -> Value.DISPUTE_IS_FOR_QUALITY
                                DISPUTE_IS_FOR_VISA_CASH_BACK_TRANSACTION_PORTION ->
                                    Value.DISPUTE_IS_FOR_VISA_CASH_BACK_TRANSACTION_PORTION
                                DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX ->
                                    Value.DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX
                                DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX_NO_CREDIT_RECEIPT_PROVIDED ->
                                    Value
                                        .DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX_NO_CREDIT_RECEIPT_PROVIDED
                                LIMITED_RETURN_OR_CANCELLATION_POLICY_PROPERLY_DISCLOSED ->
                                    Value.LIMITED_RETURN_OR_CANCELLATION_POLICY_PROPERLY_DISCLOSED
                                MERCHANDISE_HELD_AT_CARDHOLDER_CUSTOMS_AGENCY ->
                                    Value.MERCHANDISE_HELD_AT_CARDHOLDER_CUSTOMS_AGENCY
                                MERCHANDISE_MATCHES_DESCRIPTION ->
                                    Value.MERCHANDISE_MATCHES_DESCRIPTION
                                MERCHANDISE_NOT_COUNTERFEIT -> Value.MERCHANDISE_NOT_COUNTERFEIT
                                MERCHANDISE_NOT_DAMAGED -> Value.MERCHANDISE_NOT_DAMAGED
                                MERCHANDISE_NOT_DEFECTIVE -> Value.MERCHANDISE_NOT_DEFECTIVE
                                MERCHANDISE_PROVIDED_PRIOR_TO_CANCELLATION_DATE ->
                                    Value.MERCHANDISE_PROVIDED_PRIOR_TO_CANCELLATION_DATE
                                MERCHANDISE_QUALITY_MATCHES_DESCRIPTION ->
                                    Value.MERCHANDISE_QUALITY_MATCHES_DESCRIPTION
                                MERCHANDISE_RETURN_NOT_ATTEMPTED ->
                                    Value.MERCHANDISE_RETURN_NOT_ATTEMPTED
                                MERCHANT_NOT_NOTIFIED_OF_CLOSED_ACCOUNT ->
                                    Value.MERCHANT_NOT_NOTIFIED_OF_CLOSED_ACCOUNT
                                NAME_ON_FLIGHT_MANIFEST_MATCHES_PURCHASE ->
                                    Value.NAME_ON_FLIGHT_MANIFEST_MATCHES_PURCHASE
                                NO_CREDIT_RECEIPT_PROVIDED -> Value.NO_CREDIT_RECEIPT_PROVIDED
                                OTHER -> Value.OTHER
                                PROCESSING_ERROR_INCORRECT -> Value.PROCESSING_ERROR_INCORRECT
                                RETURNED_MECHANDISE_HELD_AT_CUSTOMS_AGENCY_OUTSIDE_MERCHANT_COUNTRY ->
                                    Value
                                        .RETURNED_MECHANDISE_HELD_AT_CUSTOMS_AGENCY_OUTSIDE_MERCHANT_COUNTRY
                                SERVICES_MATCH_DESCRIPTION -> Value.SERVICES_MATCH_DESCRIPTION
                                SERVICES_PROVIDED_PRIOR_TO_CANCELLATION_DATE ->
                                    Value.SERVICES_PROVIDED_PRIOR_TO_CANCELLATION_DATE
                                SERVICES_USED_AFTER_CANCELLATION_DATE ->
                                    Value.SERVICES_USED_AFTER_CANCELLATION_DATE
                                TERMS_OF_SERVICE_NOT_MISREPRESENTED ->
                                    Value.TERMS_OF_SERVICE_NOT_MISREPRESENTED
                                TRANSACTION_CODE_CORRECT -> Value.TRANSACTION_CODE_CORRECT
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                AUTOMATIC_TELLER_MACHINE_TRANSACTION_PROOF_PROVIDED ->
                                    Known.AUTOMATIC_TELLER_MACHINE_TRANSACTION_PROOF_PROVIDED
                                BALANCE_OF_PARTIAL_PREPAYMENT_NOT_PAID ->
                                    Known.BALANCE_OF_PARTIAL_PREPAYMENT_NOT_PAID
                                CARDHOLDER_CANCELED_BEFORE_EXPECTED_MERCHANDISE_RECEIPT_DATE ->
                                    Known
                                        .CARDHOLDER_CANCELED_BEFORE_EXPECTED_MERCHANDISE_RECEIPT_DATE
                                CARDHOLDER_CANCELED_BEFORE_EXPECTED_SERVICES_RECEIPT_DATE ->
                                    Known.CARDHOLDER_CANCELED_BEFORE_EXPECTED_SERVICES_RECEIPT_DATE
                                CARDHOLDER_CANCELED_DIFFERENT_DATE ->
                                    Known.CARDHOLDER_CANCELED_DIFFERENT_DATE
                                CARDHOLDER_DID_NOT_CANCEL_ACCORDING_TO_POLICY ->
                                    Known.CARDHOLDER_DID_NOT_CANCEL_ACCORDING_TO_POLICY
                                CARDHOLDER_RECEIVED_MERCHANDISE ->
                                    Known.CARDHOLDER_RECEIVED_MERCHANDISE
                                COUNTRY_CODE_CORRECT -> Known.COUNTRY_CODE_CORRECT
                                CREDIT_PROCESSED_CORRECTLY -> Known.CREDIT_PROCESSED_CORRECTLY
                                CURRENCY_CORRECT -> Known.CURRENCY_CORRECT
                                DISPUTE_IS_FOR_QUALITY -> Known.DISPUTE_IS_FOR_QUALITY
                                DISPUTE_IS_FOR_VISA_CASH_BACK_TRANSACTION_PORTION ->
                                    Known.DISPUTE_IS_FOR_VISA_CASH_BACK_TRANSACTION_PORTION
                                DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX ->
                                    Known.DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX
                                DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX_NO_CREDIT_RECEIPT_PROVIDED ->
                                    Known
                                        .DISPUTED_AMOUNT_IS_VALUE_ADDED_TAX_NO_CREDIT_RECEIPT_PROVIDED
                                LIMITED_RETURN_OR_CANCELLATION_POLICY_PROPERLY_DISCLOSED ->
                                    Known.LIMITED_RETURN_OR_CANCELLATION_POLICY_PROPERLY_DISCLOSED
                                MERCHANDISE_HELD_AT_CARDHOLDER_CUSTOMS_AGENCY ->
                                    Known.MERCHANDISE_HELD_AT_CARDHOLDER_CUSTOMS_AGENCY
                                MERCHANDISE_MATCHES_DESCRIPTION ->
                                    Known.MERCHANDISE_MATCHES_DESCRIPTION
                                MERCHANDISE_NOT_COUNTERFEIT -> Known.MERCHANDISE_NOT_COUNTERFEIT
                                MERCHANDISE_NOT_DAMAGED -> Known.MERCHANDISE_NOT_DAMAGED
                                MERCHANDISE_NOT_DEFECTIVE -> Known.MERCHANDISE_NOT_DEFECTIVE
                                MERCHANDISE_PROVIDED_PRIOR_TO_CANCELLATION_DATE ->
                                    Known.MERCHANDISE_PROVIDED_PRIOR_TO_CANCELLATION_DATE
                                MERCHANDISE_QUALITY_MATCHES_DESCRIPTION ->
                                    Known.MERCHANDISE_QUALITY_MATCHES_DESCRIPTION
                                MERCHANDISE_RETURN_NOT_ATTEMPTED ->
                                    Known.MERCHANDISE_RETURN_NOT_ATTEMPTED
                                MERCHANT_NOT_NOTIFIED_OF_CLOSED_ACCOUNT ->
                                    Known.MERCHANT_NOT_NOTIFIED_OF_CLOSED_ACCOUNT
                                NAME_ON_FLIGHT_MANIFEST_MATCHES_PURCHASE ->
                                    Known.NAME_ON_FLIGHT_MANIFEST_MATCHES_PURCHASE
                                NO_CREDIT_RECEIPT_PROVIDED -> Known.NO_CREDIT_RECEIPT_PROVIDED
                                OTHER -> Known.OTHER
                                PROCESSING_ERROR_INCORRECT -> Known.PROCESSING_ERROR_INCORRECT
                                RETURNED_MECHANDISE_HELD_AT_CUSTOMS_AGENCY_OUTSIDE_MERCHANT_COUNTRY ->
                                    Known
                                        .RETURNED_MECHANDISE_HELD_AT_CUSTOMS_AGENCY_OUTSIDE_MERCHANT_COUNTRY
                                SERVICES_MATCH_DESCRIPTION -> Known.SERVICES_MATCH_DESCRIPTION
                                SERVICES_PROVIDED_PRIOR_TO_CANCELLATION_DATE ->
                                    Known.SERVICES_PROVIDED_PRIOR_TO_CANCELLATION_DATE
                                SERVICES_USED_AFTER_CANCELLATION_DATE ->
                                    Known.SERVICES_USED_AFTER_CANCELLATION_DATE
                                TERMS_OF_SERVICE_NOT_MISREPRESENTED ->
                                    Known.TERMS_OF_SERVICE_NOT_MISREPRESENTED
                                TRANSACTION_CODE_CORRECT -> Known.TRANSACTION_CODE_CORRECT
                                else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): Reason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Reason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is InvalidDispute &&
                            explanation == other.explanation &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "InvalidDispute{explanation=$explanation, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /**
                 * Non-fiat currency or non-fungible token received details. Present if and only if
                 * `reason` is `non_fiat_currency_or_non_fungible_token_received`.
                 */
                class NonFiatCurrencyOrNonFungibleTokenReceived
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val blockchainTransactionHash: JsonField<String>,
                    private val destinationWalletAddress: JsonField<String>,
                    private val priorApprovedTransactions: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("blockchain_transaction_hash")
                        @ExcludeMissing
                        blockchainTransactionHash: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("destination_wallet_address")
                        @ExcludeMissing
                        destinationWalletAddress: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("prior_approved_transactions")
                        @ExcludeMissing
                        priorApprovedTransactions: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        blockchainTransactionHash,
                        destinationWalletAddress,
                        priorApprovedTransactions,
                        mutableMapOf(),
                    )

                    /**
                     * Blockchain transaction hash.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun blockchainTransactionHash(): String =
                        blockchainTransactionHash.getRequired("blockchain_transaction_hash")

                    /**
                     * Destination wallet address.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun destinationWalletAddress(): String =
                        destinationWalletAddress.getRequired("destination_wallet_address")

                    /**
                     * Prior approved transactions.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun priorApprovedTransactions(): String? =
                        priorApprovedTransactions.getNullable("prior_approved_transactions")

                    /**
                     * Returns the raw JSON value of [blockchainTransactionHash].
                     *
                     * Unlike [blockchainTransactionHash], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("blockchain_transaction_hash")
                    @ExcludeMissing
                    fun _blockchainTransactionHash(): JsonField<String> = blockchainTransactionHash

                    /**
                     * Returns the raw JSON value of [destinationWalletAddress].
                     *
                     * Unlike [destinationWalletAddress], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("destination_wallet_address")
                    @ExcludeMissing
                    fun _destinationWalletAddress(): JsonField<String> = destinationWalletAddress

                    /**
                     * Returns the raw JSON value of [priorApprovedTransactions].
                     *
                     * Unlike [priorApprovedTransactions], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("prior_approved_transactions")
                    @ExcludeMissing
                    fun _priorApprovedTransactions(): JsonField<String> = priorApprovedTransactions

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [NonFiatCurrencyOrNonFungibleTokenReceived].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .blockchainTransactionHash()
                         * .destinationWalletAddress()
                         * .priorApprovedTransactions()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [NonFiatCurrencyOrNonFungibleTokenReceived]. */
                    class Builder internal constructor() {

                        private var blockchainTransactionHash: JsonField<String>? = null
                        private var destinationWalletAddress: JsonField<String>? = null
                        private var priorApprovedTransactions: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            nonFiatCurrencyOrNonFungibleTokenReceived:
                                NonFiatCurrencyOrNonFungibleTokenReceived
                        ) = apply {
                            blockchainTransactionHash =
                                nonFiatCurrencyOrNonFungibleTokenReceived.blockchainTransactionHash
                            destinationWalletAddress =
                                nonFiatCurrencyOrNonFungibleTokenReceived.destinationWalletAddress
                            priorApprovedTransactions =
                                nonFiatCurrencyOrNonFungibleTokenReceived.priorApprovedTransactions
                            additionalProperties =
                                nonFiatCurrencyOrNonFungibleTokenReceived.additionalProperties
                                    .toMutableMap()
                        }

                        /** Blockchain transaction hash. */
                        fun blockchainTransactionHash(blockchainTransactionHash: String) =
                            blockchainTransactionHash(JsonField.of(blockchainTransactionHash))

                        /**
                         * Sets [Builder.blockchainTransactionHash] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.blockchainTransactionHash] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun blockchainTransactionHash(
                            blockchainTransactionHash: JsonField<String>
                        ) = apply { this.blockchainTransactionHash = blockchainTransactionHash }

                        /** Destination wallet address. */
                        fun destinationWalletAddress(destinationWalletAddress: String) =
                            destinationWalletAddress(JsonField.of(destinationWalletAddress))

                        /**
                         * Sets [Builder.destinationWalletAddress] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.destinationWalletAddress] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun destinationWalletAddress(destinationWalletAddress: JsonField<String>) =
                            apply {
                                this.destinationWalletAddress = destinationWalletAddress
                            }

                        /** Prior approved transactions. */
                        fun priorApprovedTransactions(priorApprovedTransactions: String?) =
                            priorApprovedTransactions(
                                JsonField.ofNullable(priorApprovedTransactions)
                            )

                        /**
                         * Sets [Builder.priorApprovedTransactions] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.priorApprovedTransactions] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun priorApprovedTransactions(
                            priorApprovedTransactions: JsonField<String>
                        ) = apply { this.priorApprovedTransactions = priorApprovedTransactions }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of
                         * [NonFiatCurrencyOrNonFungibleTokenReceived].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .blockchainTransactionHash()
                         * .destinationWalletAddress()
                         * .priorApprovedTransactions()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): NonFiatCurrencyOrNonFungibleTokenReceived =
                            NonFiatCurrencyOrNonFungibleTokenReceived(
                                checkRequired(
                                    "blockchainTransactionHash",
                                    blockchainTransactionHash,
                                ),
                                checkRequired("destinationWalletAddress", destinationWalletAddress),
                                checkRequired(
                                    "priorApprovedTransactions",
                                    priorApprovedTransactions,
                                ),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): NonFiatCurrencyOrNonFungibleTokenReceived = apply {
                        if (validated) {
                            return@apply
                        }

                        blockchainTransactionHash()
                        destinationWalletAddress()
                        priorApprovedTransactions()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (blockchainTransactionHash.asKnown() == null) 0 else 1) +
                            (if (destinationWalletAddress.asKnown() == null) 0 else 1) +
                            (if (priorApprovedTransactions.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is NonFiatCurrencyOrNonFungibleTokenReceived &&
                            blockchainTransactionHash == other.blockchainTransactionHash &&
                            destinationWalletAddress == other.destinationWalletAddress &&
                            priorApprovedTransactions == other.priorApprovedTransactions &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            blockchainTransactionHash,
                            destinationWalletAddress,
                            priorApprovedTransactions,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "NonFiatCurrencyOrNonFungibleTokenReceived{blockchainTransactionHash=$blockchainTransactionHash, destinationWalletAddress=$destinationWalletAddress, priorApprovedTransactions=$priorApprovedTransactions, additionalProperties=$additionalProperties}"
                }

                /**
                 * Proof of cash disbursement details. Present if and only if `reason` is
                 * `proof_of_cash_disbursement`.
                 */
                class ProofOfCashDisbursement
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Explanation for why the merchant believes the evidence provides proof of cash
                     * disbursement.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ProofOfCashDisbursement].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ProofOfCashDisbursement]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(proofOfCashDisbursement: ProofOfCashDisbursement) =
                            apply {
                                explanation = proofOfCashDisbursement.explanation
                                additionalProperties =
                                    proofOfCashDisbursement.additionalProperties.toMutableMap()
                            }

                        /**
                         * Explanation for why the merchant believes the evidence provides proof of
                         * cash disbursement.
                         */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ProofOfCashDisbursement].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ProofOfCashDisbursement =
                            ProofOfCashDisbursement(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ProofOfCashDisbursement = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (explanation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ProofOfCashDisbursement &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ProofOfCashDisbursement{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                /** The reason the merchant re-presented the dispute. */
                class Reason
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Cardholder no longer disputes the transaction. */
                        val CARDHOLDER_NO_LONGER_DISPUTES = of("cardholder_no_longer_disputes")

                        /** Credit or reversal was processed. */
                        val CREDIT_OR_REVERSAL_PROCESSED = of("credit_or_reversal_processed")

                        /** Invalid dispute. */
                        val INVALID_DISPUTE = of("invalid_dispute")

                        /**
                         * Non-fiat currency or non-fungible token is as described by the merchant.
                         */
                        val NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_AS_DESCRIBED =
                            of("non_fiat_currency_or_non_fungible_token_as_described")

                        /**
                         * Non-fiat currency or non-fungible token was received by the cardholder.
                         */
                        val NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED =
                            of("non_fiat_currency_or_non_fungible_token_received")

                        /** Proof of cash disbursement provided. */
                        val PROOF_OF_CASH_DISBURSEMENT = of("proof_of_cash_disbursement")

                        /** Reversal issued by merchant. */
                        val REVERSAL_ISSUED = of("reversal_issued")

                        fun of(value: String) = Reason(JsonField.of(value))
                    }

                    /** An enum containing [Reason]'s known values. */
                    enum class Known {
                        /** Cardholder no longer disputes the transaction. */
                        CARDHOLDER_NO_LONGER_DISPUTES,
                        /** Credit or reversal was processed. */
                        CREDIT_OR_REVERSAL_PROCESSED,
                        /** Invalid dispute. */
                        INVALID_DISPUTE,
                        /**
                         * Non-fiat currency or non-fungible token is as described by the merchant.
                         */
                        NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_AS_DESCRIBED,
                        /**
                         * Non-fiat currency or non-fungible token was received by the cardholder.
                         */
                        NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED,
                        /** Proof of cash disbursement provided. */
                        PROOF_OF_CASH_DISBURSEMENT,
                        /** Reversal issued by merchant. */
                        REVERSAL_ISSUED,
                    }

                    /**
                     * An enum containing [Reason]'s known values, as well as an [_UNKNOWN] member.
                     *
                     * An instance of [Reason] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Cardholder no longer disputes the transaction. */
                        CARDHOLDER_NO_LONGER_DISPUTES,
                        /** Credit or reversal was processed. */
                        CREDIT_OR_REVERSAL_PROCESSED,
                        /** Invalid dispute. */
                        INVALID_DISPUTE,
                        /**
                         * Non-fiat currency or non-fungible token is as described by the merchant.
                         */
                        NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_AS_DESCRIBED,
                        /**
                         * Non-fiat currency or non-fungible token was received by the cardholder.
                         */
                        NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED,
                        /** Proof of cash disbursement provided. */
                        PROOF_OF_CASH_DISBURSEMENT,
                        /** Reversal issued by merchant. */
                        REVERSAL_ISSUED,
                        /**
                         * An enum member indicating that [Reason] was instantiated with an unknown
                         * value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            CARDHOLDER_NO_LONGER_DISPUTES -> Value.CARDHOLDER_NO_LONGER_DISPUTES
                            CREDIT_OR_REVERSAL_PROCESSED -> Value.CREDIT_OR_REVERSAL_PROCESSED
                            INVALID_DISPUTE -> Value.INVALID_DISPUTE
                            NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_AS_DESCRIBED ->
                                Value.NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_AS_DESCRIBED
                            NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED ->
                                Value.NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED
                            PROOF_OF_CASH_DISBURSEMENT -> Value.PROOF_OF_CASH_DISBURSEMENT
                            REVERSAL_ISSUED -> Value.REVERSAL_ISSUED
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            CARDHOLDER_NO_LONGER_DISPUTES -> Known.CARDHOLDER_NO_LONGER_DISPUTES
                            CREDIT_OR_REVERSAL_PROCESSED -> Known.CREDIT_OR_REVERSAL_PROCESSED
                            INVALID_DISPUTE -> Known.INVALID_DISPUTE
                            NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_AS_DESCRIBED ->
                                Known.NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_AS_DESCRIBED
                            NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED ->
                                Known.NON_FIAT_CURRENCY_OR_NON_FUNGIBLE_TOKEN_RECEIVED
                            PROOF_OF_CASH_DISBURSEMENT -> Known.PROOF_OF_CASH_DISBURSEMENT
                            REVERSAL_ISSUED -> Known.REVERSAL_ISSUED
                            else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Reason = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Reason && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Reversal issued by merchant details. Present if and only if `reason` is
                 * `reversal_issued`.
                 */
                class ReversalIssued
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of()
                    ) : this(explanation, mutableMapOf())

                    /**
                     * Explanation of the reversal issued by the merchant.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun explanation(): String? = explanation.getNullable("explanation")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ReversalIssued].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ReversalIssued]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(reversalIssued: ReversalIssued) = apply {
                            explanation = reversalIssued.explanation
                            additionalProperties =
                                reversalIssued.additionalProperties.toMutableMap()
                        }

                        /** Explanation of the reversal issued by the merchant. */
                        fun explanation(explanation: String?) =
                            explanation(JsonField.ofNullable(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ReversalIssued].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ReversalIssued =
                            ReversalIssued(
                                checkRequired("explanation", explanation),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ReversalIssued = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (if (explanation.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ReversalIssued &&
                            explanation == other.explanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ReversalIssued{explanation=$explanation, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Represented &&
                        cardholderNoLongerDisputes == other.cardholderNoLongerDisputes &&
                        creditOrReversalProcessed == other.creditOrReversalProcessed &&
                        invalidDispute == other.invalidDispute &&
                        nonFiatCurrencyOrNonFungibleTokenAsDescribed ==
                            other.nonFiatCurrencyOrNonFungibleTokenAsDescribed &&
                        nonFiatCurrencyOrNonFungibleTokenReceived ==
                            other.nonFiatCurrencyOrNonFungibleTokenReceived &&
                        proofOfCashDisbursement == other.proofOfCashDisbursement &&
                        reason == other.reason &&
                        reversalIssued == other.reversalIssued &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        cardholderNoLongerDisputes,
                        creditOrReversalProcessed,
                        invalidDispute,
                        nonFiatCurrencyOrNonFungibleTokenAsDescribed,
                        nonFiatCurrencyOrNonFungibleTokenReceived,
                        proofOfCashDisbursement,
                        reason,
                        reversalIssued,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Represented{cardholderNoLongerDisputes=$cardholderNoLongerDisputes, creditOrReversalProcessed=$creditOrReversalProcessed, invalidDispute=$invalidDispute, nonFiatCurrencyOrNonFungibleTokenAsDescribed=$nonFiatCurrencyOrNonFungibleTokenAsDescribed, nonFiatCurrencyOrNonFungibleTokenReceived=$nonFiatCurrencyOrNonFungibleTokenReceived, proofOfCashDisbursement=$proofOfCashDisbursement, reason=$reason, reversalIssued=$reversalIssued, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is NetworkEvent &&
                    attachmentFiles == other.attachmentFiles &&
                    category == other.category &&
                    chargebackAccepted == other.chargebackAccepted &&
                    chargebackSubmitted == other.chargebackSubmitted &&
                    chargebackTimedOut == other.chargebackTimedOut &&
                    createdAt == other.createdAt &&
                    disputeFinancialTransactionId == other.disputeFinancialTransactionId &&
                    merchantPrearbitrationDeclineSubmitted ==
                        other.merchantPrearbitrationDeclineSubmitted &&
                    merchantPrearbitrationReceived == other.merchantPrearbitrationReceived &&
                    merchantPrearbitrationTimedOut == other.merchantPrearbitrationTimedOut &&
                    represented == other.represented &&
                    representmentTimedOut == other.representmentTimedOut &&
                    userPrearbitrationAccepted == other.userPrearbitrationAccepted &&
                    userPrearbitrationDeclined == other.userPrearbitrationDeclined &&
                    userPrearbitrationSubmitted == other.userPrearbitrationSubmitted &&
                    userPrearbitrationTimedOut == other.userPrearbitrationTimedOut &&
                    userWithdrawalSubmitted == other.userWithdrawalSubmitted &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    attachmentFiles,
                    category,
                    chargebackAccepted,
                    chargebackSubmitted,
                    chargebackTimedOut,
                    createdAt,
                    disputeFinancialTransactionId,
                    merchantPrearbitrationDeclineSubmitted,
                    merchantPrearbitrationReceived,
                    merchantPrearbitrationTimedOut,
                    represented,
                    representmentTimedOut,
                    userPrearbitrationAccepted,
                    userPrearbitrationDeclined,
                    userPrearbitrationSubmitted,
                    userPrearbitrationTimedOut,
                    userWithdrawalSubmitted,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "NetworkEvent{attachmentFiles=$attachmentFiles, category=$category, chargebackAccepted=$chargebackAccepted, chargebackSubmitted=$chargebackSubmitted, chargebackTimedOut=$chargebackTimedOut, createdAt=$createdAt, disputeFinancialTransactionId=$disputeFinancialTransactionId, merchantPrearbitrationDeclineSubmitted=$merchantPrearbitrationDeclineSubmitted, merchantPrearbitrationReceived=$merchantPrearbitrationReceived, merchantPrearbitrationTimedOut=$merchantPrearbitrationTimedOut, represented=$represented, representmentTimedOut=$representmentTimedOut, userPrearbitrationAccepted=$userPrearbitrationAccepted, userPrearbitrationDeclined=$userPrearbitrationDeclined, userPrearbitrationSubmitted=$userPrearbitrationSubmitted, userPrearbitrationTimedOut=$userPrearbitrationTimedOut, userWithdrawalSubmitted=$userWithdrawalSubmitted, additionalProperties=$additionalProperties}"
        }

        /**
         * The category of the currently required user submission if the user wishes to proceed with
         * the dispute. Present if and only if status is `user_submission_required`. Otherwise, this
         * will be `nil`.
         */
        class RequiredUserSubmissionCategory
        @JsonCreator
        private constructor(private val value: JsonField<String>) : Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                /** A Chargeback User Submission is required. */
                val CHARGEBACK = of("chargeback")

                /** A Merchant Pre Arbitration Decline User Submission is required. */
                val MERCHANT_PREARBITRATION_DECLINE = of("merchant_prearbitration_decline")

                /** A User Initiated Pre Arbitration User Submission is required. */
                val USER_PREARBITRATION = of("user_prearbitration")

                fun of(value: String) = RequiredUserSubmissionCategory(JsonField.of(value))
            }

            /** An enum containing [RequiredUserSubmissionCategory]'s known values. */
            enum class Known {
                /** A Chargeback User Submission is required. */
                CHARGEBACK,
                /** A Merchant Pre Arbitration Decline User Submission is required. */
                MERCHANT_PREARBITRATION_DECLINE,
                /** A User Initiated Pre Arbitration User Submission is required. */
                USER_PREARBITRATION,
            }

            /**
             * An enum containing [RequiredUserSubmissionCategory]'s known values, as well as an
             * [_UNKNOWN] member.
             *
             * An instance of [RequiredUserSubmissionCategory] can contain an unknown value in a
             * couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                /** A Chargeback User Submission is required. */
                CHARGEBACK,
                /** A Merchant Pre Arbitration Decline User Submission is required. */
                MERCHANT_PREARBITRATION_DECLINE,
                /** A User Initiated Pre Arbitration User Submission is required. */
                USER_PREARBITRATION,
                /**
                 * An enum member indicating that [RequiredUserSubmissionCategory] was instantiated
                 * with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    CHARGEBACK -> Value.CHARGEBACK
                    MERCHANT_PREARBITRATION_DECLINE -> Value.MERCHANT_PREARBITRATION_DECLINE
                    USER_PREARBITRATION -> Value.USER_PREARBITRATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws IncreaseInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    CHARGEBACK -> Known.CHARGEBACK
                    MERCHANT_PREARBITRATION_DECLINE -> Known.MERCHANT_PREARBITRATION_DECLINE
                    USER_PREARBITRATION -> Known.USER_PREARBITRATION
                    else ->
                        throw IncreaseInvalidDataException(
                            "Unknown RequiredUserSubmissionCategory: $value"
                        )
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws IncreaseInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString() ?: throw IncreaseInvalidDataException("Value is not a String")

            private var validated: Boolean = false

            fun validate(): RequiredUserSubmissionCategory = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is RequiredUserSubmissionCategory && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class UserSubmission
        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
        private constructor(
            private val acceptedAt: JsonField<OffsetDateTime>,
            private val amount: JsonField<Long>,
            private val attachmentFiles: JsonField<List<AttachmentFile>>,
            private val category: JsonField<Category>,
            private val chargeback: JsonField<Chargeback>,
            private val createdAt: JsonField<OffsetDateTime>,
            private val furtherInformationRequestedAt: JsonField<OffsetDateTime>,
            private val furtherInformationRequestedReason: JsonField<String>,
            private val merchantPrearbitrationDecline: JsonField<MerchantPrearbitrationDecline>,
            private val status: JsonField<Status>,
            private val updatedAt: JsonField<OffsetDateTime>,
            private val userPrearbitration: JsonField<UserPrearbitration>,
            private val additionalProperties: MutableMap<String, JsonValue>,
        ) {

            @JsonCreator
            private constructor(
                @JsonProperty("accepted_at")
                @ExcludeMissing
                acceptedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("amount") @ExcludeMissing amount: JsonField<Long> = JsonMissing.of(),
                @JsonProperty("attachment_files")
                @ExcludeMissing
                attachmentFiles: JsonField<List<AttachmentFile>> = JsonMissing.of(),
                @JsonProperty("category")
                @ExcludeMissing
                category: JsonField<Category> = JsonMissing.of(),
                @JsonProperty("chargeback")
                @ExcludeMissing
                chargeback: JsonField<Chargeback> = JsonMissing.of(),
                @JsonProperty("created_at")
                @ExcludeMissing
                createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("further_information_requested_at")
                @ExcludeMissing
                furtherInformationRequestedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("further_information_requested_reason")
                @ExcludeMissing
                furtherInformationRequestedReason: JsonField<String> = JsonMissing.of(),
                @JsonProperty("merchant_prearbitration_decline")
                @ExcludeMissing
                merchantPrearbitrationDecline: JsonField<MerchantPrearbitrationDecline> =
                    JsonMissing.of(),
                @JsonProperty("status")
                @ExcludeMissing
                status: JsonField<Status> = JsonMissing.of(),
                @JsonProperty("updated_at")
                @ExcludeMissing
                updatedAt: JsonField<OffsetDateTime> = JsonMissing.of(),
                @JsonProperty("user_prearbitration")
                @ExcludeMissing
                userPrearbitration: JsonField<UserPrearbitration> = JsonMissing.of(),
            ) : this(
                acceptedAt,
                amount,
                attachmentFiles,
                category,
                chargeback,
                createdAt,
                furtherInformationRequestedAt,
                furtherInformationRequestedReason,
                merchantPrearbitrationDecline,
                status,
                updatedAt,
                userPrearbitration,
                mutableMapOf(),
            )

            /**
             * The date and time at which the Visa Card Dispute User Submission was reviewed and
             * accepted.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun acceptedAt(): OffsetDateTime? = acceptedAt.getNullable("accepted_at")

            /**
             * The amount of the dispute if it is different from the amount of a prior user
             * submission or the disputed transaction.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun amount(): Long? = amount.getNullable("amount")

            /**
             * The files attached to the Visa Card Dispute User Submission.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun attachmentFiles(): List<AttachmentFile> =
                attachmentFiles.getRequired("attachment_files")

            /**
             * The category of the user submission. We may add additional possible values for this
             * enum over time; your application should be able to handle such additions gracefully.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun category(): Category = category.getRequired("category")

            /**
             * A Visa Card Dispute Chargeback User Submission Chargeback Details object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `chargeback`. Contains the details specific to a Visa chargeback User Submission for
             * a Card Dispute.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun chargeback(): Chargeback? = chargeback.getNullable("chargeback")

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * Visa Card Dispute User Submission was created.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

            /**
             * The date and time at which Increase requested further information from the user for
             * the Visa Card Dispute.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun furtherInformationRequestedAt(): OffsetDateTime? =
                furtherInformationRequestedAt.getNullable("further_information_requested_at")

            /**
             * The reason for Increase requesting further information from the user for the Visa
             * Card Dispute.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun furtherInformationRequestedReason(): String? =
                furtherInformationRequestedReason.getNullable(
                    "further_information_requested_reason"
                )

            /**
             * A Visa Card Dispute Merchant Pre-Arbitration Decline User Submission object. This
             * field will be present in the JSON response if and only if `category` is equal to
             * `merchant_prearbitration_decline`. Contains the details specific to a merchant
             * prearbitration decline Visa Card Dispute User Submission.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun merchantPrearbitrationDecline(): MerchantPrearbitrationDecline? =
                merchantPrearbitrationDecline.getNullable("merchant_prearbitration_decline")

            /**
             * The status of the Visa Card Dispute User Submission.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun status(): Status = status.getRequired("status")

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * Visa Card Dispute User Submission was updated.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun updatedAt(): OffsetDateTime = updatedAt.getRequired("updated_at")

            /**
             * A Visa Card Dispute User-Initiated Pre-Arbitration User Submission object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `user_prearbitration`. Contains the details specific to a user-initiated
             * pre-arbitration Visa Card Dispute User Submission.
             *
             * @throws IncreaseInvalidDataException if the JSON field has an unexpected type (e.g.
             *   if the server responded with an unexpected value).
             */
            fun userPrearbitration(): UserPrearbitration? =
                userPrearbitration.getNullable("user_prearbitration")

            /**
             * Returns the raw JSON value of [acceptedAt].
             *
             * Unlike [acceptedAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("accepted_at")
            @ExcludeMissing
            fun _acceptedAt(): JsonField<OffsetDateTime> = acceptedAt

            /**
             * Returns the raw JSON value of [amount].
             *
             * Unlike [amount], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("amount") @ExcludeMissing fun _amount(): JsonField<Long> = amount

            /**
             * Returns the raw JSON value of [attachmentFiles].
             *
             * Unlike [attachmentFiles], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("attachment_files")
            @ExcludeMissing
            fun _attachmentFiles(): JsonField<List<AttachmentFile>> = attachmentFiles

            /**
             * Returns the raw JSON value of [category].
             *
             * Unlike [category], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("category")
            @ExcludeMissing
            fun _category(): JsonField<Category> = category

            /**
             * Returns the raw JSON value of [chargeback].
             *
             * Unlike [chargeback], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("chargeback")
            @ExcludeMissing
            fun _chargeback(): JsonField<Chargeback> = chargeback

            /**
             * Returns the raw JSON value of [createdAt].
             *
             * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("created_at")
            @ExcludeMissing
            fun _createdAt(): JsonField<OffsetDateTime> = createdAt

            /**
             * Returns the raw JSON value of [furtherInformationRequestedAt].
             *
             * Unlike [furtherInformationRequestedAt], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("further_information_requested_at")
            @ExcludeMissing
            fun _furtherInformationRequestedAt(): JsonField<OffsetDateTime> =
                furtherInformationRequestedAt

            /**
             * Returns the raw JSON value of [furtherInformationRequestedReason].
             *
             * Unlike [furtherInformationRequestedReason], this method doesn't throw if the JSON
             * field has an unexpected type.
             */
            @JsonProperty("further_information_requested_reason")
            @ExcludeMissing
            fun _furtherInformationRequestedReason(): JsonField<String> =
                furtherInformationRequestedReason

            /**
             * Returns the raw JSON value of [merchantPrearbitrationDecline].
             *
             * Unlike [merchantPrearbitrationDecline], this method doesn't throw if the JSON field
             * has an unexpected type.
             */
            @JsonProperty("merchant_prearbitration_decline")
            @ExcludeMissing
            fun _merchantPrearbitrationDecline(): JsonField<MerchantPrearbitrationDecline> =
                merchantPrearbitrationDecline

            /**
             * Returns the raw JSON value of [status].
             *
             * Unlike [status], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("status") @ExcludeMissing fun _status(): JsonField<Status> = status

            /**
             * Returns the raw JSON value of [updatedAt].
             *
             * Unlike [updatedAt], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("updated_at")
            @ExcludeMissing
            fun _updatedAt(): JsonField<OffsetDateTime> = updatedAt

            /**
             * Returns the raw JSON value of [userPrearbitration].
             *
             * Unlike [userPrearbitration], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("user_prearbitration")
            @ExcludeMissing
            fun _userPrearbitration(): JsonField<UserPrearbitration> = userPrearbitration

            @JsonAnySetter
            private fun putAdditionalProperty(key: String, value: JsonValue) {
                additionalProperties.put(key, value)
            }

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> =
                Collections.unmodifiableMap(additionalProperties)

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [UserSubmission].
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .acceptedAt()
                 * .amount()
                 * .attachmentFiles()
                 * .category()
                 * .chargeback()
                 * .createdAt()
                 * .furtherInformationRequestedAt()
                 * .furtherInformationRequestedReason()
                 * .merchantPrearbitrationDecline()
                 * .status()
                 * .updatedAt()
                 * .userPrearbitration()
                 * ```
                 */
                fun builder() = Builder()
            }

            /** A builder for [UserSubmission]. */
            class Builder internal constructor() {

                private var acceptedAt: JsonField<OffsetDateTime>? = null
                private var amount: JsonField<Long>? = null
                private var attachmentFiles: JsonField<MutableList<AttachmentFile>>? = null
                private var category: JsonField<Category>? = null
                private var chargeback: JsonField<Chargeback>? = null
                private var createdAt: JsonField<OffsetDateTime>? = null
                private var furtherInformationRequestedAt: JsonField<OffsetDateTime>? = null
                private var furtherInformationRequestedReason: JsonField<String>? = null
                private var merchantPrearbitrationDecline:
                    JsonField<MerchantPrearbitrationDecline>? =
                    null
                private var status: JsonField<Status>? = null
                private var updatedAt: JsonField<OffsetDateTime>? = null
                private var userPrearbitration: JsonField<UserPrearbitration>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                internal fun from(userSubmission: UserSubmission) = apply {
                    acceptedAt = userSubmission.acceptedAt
                    amount = userSubmission.amount
                    attachmentFiles = userSubmission.attachmentFiles.map { it.toMutableList() }
                    category = userSubmission.category
                    chargeback = userSubmission.chargeback
                    createdAt = userSubmission.createdAt
                    furtherInformationRequestedAt = userSubmission.furtherInformationRequestedAt
                    furtherInformationRequestedReason =
                        userSubmission.furtherInformationRequestedReason
                    merchantPrearbitrationDecline = userSubmission.merchantPrearbitrationDecline
                    status = userSubmission.status
                    updatedAt = userSubmission.updatedAt
                    userPrearbitration = userSubmission.userPrearbitration
                    additionalProperties = userSubmission.additionalProperties.toMutableMap()
                }

                /**
                 * The date and time at which the Visa Card Dispute User Submission was reviewed and
                 * accepted.
                 */
                fun acceptedAt(acceptedAt: OffsetDateTime?) =
                    acceptedAt(JsonField.ofNullable(acceptedAt))

                /**
                 * Sets [Builder.acceptedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.acceptedAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun acceptedAt(acceptedAt: JsonField<OffsetDateTime>) = apply {
                    this.acceptedAt = acceptedAt
                }

                /**
                 * The amount of the dispute if it is different from the amount of a prior user
                 * submission or the disputed transaction.
                 */
                fun amount(amount: Long?) = amount(JsonField.ofNullable(amount))

                /**
                 * Alias for [Builder.amount].
                 *
                 * This unboxed primitive overload exists for backwards compatibility.
                 */
                fun amount(amount: Long) = amount(amount as Long?)

                /**
                 * Sets [Builder.amount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.amount] with a well-typed [Long] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun amount(amount: JsonField<Long>) = apply { this.amount = amount }

                /** The files attached to the Visa Card Dispute User Submission. */
                fun attachmentFiles(attachmentFiles: List<AttachmentFile>) =
                    attachmentFiles(JsonField.of(attachmentFiles))

                /**
                 * Sets [Builder.attachmentFiles] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.attachmentFiles] with a well-typed
                 * `List<AttachmentFile>` value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun attachmentFiles(attachmentFiles: JsonField<List<AttachmentFile>>) = apply {
                    this.attachmentFiles = attachmentFiles.map { it.toMutableList() }
                }

                /**
                 * Adds a single [AttachmentFile] to [attachmentFiles].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAttachmentFile(attachmentFile: AttachmentFile) = apply {
                    attachmentFiles =
                        (attachmentFiles ?: JsonField.of(mutableListOf())).also {
                            checkKnown("attachmentFiles", it).add(attachmentFile)
                        }
                }

                /**
                 * The category of the user submission. We may add additional possible values for
                 * this enum over time; your application should be able to handle such additions
                 * gracefully.
                 */
                fun category(category: Category) = category(JsonField.of(category))

                /**
                 * Sets [Builder.category] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.category] with a well-typed [Category] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun category(category: JsonField<Category>) = apply { this.category = category }

                /**
                 * A Visa Card Dispute Chargeback User Submission Chargeback Details object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `chargeback`. Contains the details specific to a Visa chargeback User Submission
                 * for a Card Dispute.
                 */
                fun chargeback(chargeback: Chargeback?) =
                    chargeback(JsonField.ofNullable(chargeback))

                /**
                 * Sets [Builder.chargeback] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.chargeback] with a well-typed [Chargeback] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun chargeback(chargeback: JsonField<Chargeback>) = apply {
                    this.chargeback = chargeback
                }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * Visa Card Dispute User Submission was created.
                 */
                fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

                /**
                 * Sets [Builder.createdAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                    this.createdAt = createdAt
                }

                /**
                 * The date and time at which Increase requested further information from the user
                 * for the Visa Card Dispute.
                 */
                fun furtherInformationRequestedAt(furtherInformationRequestedAt: OffsetDateTime?) =
                    furtherInformationRequestedAt(
                        JsonField.ofNullable(furtherInformationRequestedAt)
                    )

                /**
                 * Sets [Builder.furtherInformationRequestedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.furtherInformationRequestedAt] with a well-typed
                 * [OffsetDateTime] value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun furtherInformationRequestedAt(
                    furtherInformationRequestedAt: JsonField<OffsetDateTime>
                ) = apply { this.furtherInformationRequestedAt = furtherInformationRequestedAt }

                /**
                 * The reason for Increase requesting further information from the user for the Visa
                 * Card Dispute.
                 */
                fun furtherInformationRequestedReason(furtherInformationRequestedReason: String?) =
                    furtherInformationRequestedReason(
                        JsonField.ofNullable(furtherInformationRequestedReason)
                    )

                /**
                 * Sets [Builder.furtherInformationRequestedReason] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.furtherInformationRequestedReason] with a
                 * well-typed [String] value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun furtherInformationRequestedReason(
                    furtherInformationRequestedReason: JsonField<String>
                ) = apply {
                    this.furtherInformationRequestedReason = furtherInformationRequestedReason
                }

                /**
                 * A Visa Card Dispute Merchant Pre-Arbitration Decline User Submission object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `merchant_prearbitration_decline`. Contains the details specific to a merchant
                 * prearbitration decline Visa Card Dispute User Submission.
                 */
                fun merchantPrearbitrationDecline(
                    merchantPrearbitrationDecline: MerchantPrearbitrationDecline?
                ) =
                    merchantPrearbitrationDecline(
                        JsonField.ofNullable(merchantPrearbitrationDecline)
                    )

                /**
                 * Sets [Builder.merchantPrearbitrationDecline] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.merchantPrearbitrationDecline] with a well-typed
                 * [MerchantPrearbitrationDecline] value instead. This method is primarily for
                 * setting the field to an undocumented or not yet supported value.
                 */
                fun merchantPrearbitrationDecline(
                    merchantPrearbitrationDecline: JsonField<MerchantPrearbitrationDecline>
                ) = apply { this.merchantPrearbitrationDecline = merchantPrearbitrationDecline }

                /** The status of the Visa Card Dispute User Submission. */
                fun status(status: Status) = status(JsonField.of(status))

                /**
                 * Sets [Builder.status] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.status] with a well-typed [Status] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun status(status: JsonField<Status>) = apply { this.status = status }

                /**
                 * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
                 * Visa Card Dispute User Submission was updated.
                 */
                fun updatedAt(updatedAt: OffsetDateTime) = updatedAt(JsonField.of(updatedAt))

                /**
                 * Sets [Builder.updatedAt] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.updatedAt] with a well-typed [OffsetDateTime]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun updatedAt(updatedAt: JsonField<OffsetDateTime>) = apply {
                    this.updatedAt = updatedAt
                }

                /**
                 * A Visa Card Dispute User-Initiated Pre-Arbitration User Submission object. This
                 * field will be present in the JSON response if and only if `category` is equal to
                 * `user_prearbitration`. Contains the details specific to a user-initiated
                 * pre-arbitration Visa Card Dispute User Submission.
                 */
                fun userPrearbitration(userPrearbitration: UserPrearbitration?) =
                    userPrearbitration(JsonField.ofNullable(userPrearbitration))

                /**
                 * Sets [Builder.userPrearbitration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.userPrearbitration] with a well-typed
                 * [UserPrearbitration] value instead. This method is primarily for setting the
                 * field to an undocumented or not yet supported value.
                 */
                fun userPrearbitration(userPrearbitration: JsonField<UserPrearbitration>) = apply {
                    this.userPrearbitration = userPrearbitration
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [UserSubmission].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 *
                 * The following fields are required:
                 * ```kotlin
                 * .acceptedAt()
                 * .amount()
                 * .attachmentFiles()
                 * .category()
                 * .chargeback()
                 * .createdAt()
                 * .furtherInformationRequestedAt()
                 * .furtherInformationRequestedReason()
                 * .merchantPrearbitrationDecline()
                 * .status()
                 * .updatedAt()
                 * .userPrearbitration()
                 * ```
                 *
                 * @throws IllegalStateException if any required field is unset.
                 */
                fun build(): UserSubmission =
                    UserSubmission(
                        checkRequired("acceptedAt", acceptedAt),
                        checkRequired("amount", amount),
                        checkRequired("attachmentFiles", attachmentFiles).map { it.toImmutable() },
                        checkRequired("category", category),
                        checkRequired("chargeback", chargeback),
                        checkRequired("createdAt", createdAt),
                        checkRequired(
                            "furtherInformationRequestedAt",
                            furtherInformationRequestedAt,
                        ),
                        checkRequired(
                            "furtherInformationRequestedReason",
                            furtherInformationRequestedReason,
                        ),
                        checkRequired(
                            "merchantPrearbitrationDecline",
                            merchantPrearbitrationDecline,
                        ),
                        checkRequired("status", status),
                        checkRequired("updatedAt", updatedAt),
                        checkRequired("userPrearbitration", userPrearbitration),
                        additionalProperties.toMutableMap(),
                    )
            }

            private var validated: Boolean = false

            fun validate(): UserSubmission = apply {
                if (validated) {
                    return@apply
                }

                acceptedAt()
                amount()
                attachmentFiles().forEach { it.validate() }
                category().validate()
                chargeback()?.validate()
                createdAt()
                furtherInformationRequestedAt()
                furtherInformationRequestedReason()
                merchantPrearbitrationDecline()?.validate()
                status().validate()
                updatedAt()
                userPrearbitration()?.validate()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: IncreaseInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            internal fun validity(): Int =
                (if (acceptedAt.asKnown() == null) 0 else 1) +
                    (if (amount.asKnown() == null) 0 else 1) +
                    (attachmentFiles.asKnown()?.sumOf { it.validity().toInt() } ?: 0) +
                    (category.asKnown()?.validity() ?: 0) +
                    (chargeback.asKnown()?.validity() ?: 0) +
                    (if (createdAt.asKnown() == null) 0 else 1) +
                    (if (furtherInformationRequestedAt.asKnown() == null) 0 else 1) +
                    (if (furtherInformationRequestedReason.asKnown() == null) 0 else 1) +
                    (merchantPrearbitrationDecline.asKnown()?.validity() ?: 0) +
                    (status.asKnown()?.validity() ?: 0) +
                    (if (updatedAt.asKnown() == null) 0 else 1) +
                    (userPrearbitration.asKnown()?.validity() ?: 0)

            class AttachmentFile
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val fileId: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("file_id")
                    @ExcludeMissing
                    fileId: JsonField<String> = JsonMissing.of()
                ) : this(fileId, mutableMapOf())

                /**
                 * The ID of the file attached to the Card Dispute.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun fileId(): String = fileId.getRequired("file_id")

                /**
                 * Returns the raw JSON value of [fileId].
                 *
                 * Unlike [fileId], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("file_id") @ExcludeMissing fun _fileId(): JsonField<String> = fileId

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [AttachmentFile].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .fileId()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [AttachmentFile]. */
                class Builder internal constructor() {

                    private var fileId: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(attachmentFile: AttachmentFile) = apply {
                        fileId = attachmentFile.fileId
                        additionalProperties = attachmentFile.additionalProperties.toMutableMap()
                    }

                    /** The ID of the file attached to the Card Dispute. */
                    fun fileId(fileId: String) = fileId(JsonField.of(fileId))

                    /**
                     * Sets [Builder.fileId] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.fileId] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun fileId(fileId: JsonField<String>) = apply { this.fileId = fileId }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [AttachmentFile].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .fileId()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): AttachmentFile =
                        AttachmentFile(
                            checkRequired("fileId", fileId),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): AttachmentFile = apply {
                    if (validated) {
                        return@apply
                    }

                    fileId()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = (if (fileId.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is AttachmentFile &&
                        fileId == other.fileId &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy { Objects.hash(fileId, additionalProperties) }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "AttachmentFile{fileId=$fileId, additionalProperties=$additionalProperties}"
            }

            /**
             * The category of the user submission. We may add additional possible values for this
             * enum over time; your application should be able to handle such additions gracefully.
             */
            class Category @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /**
                     * Visa Card Dispute Chargeback User Submission Chargeback Details: details will
                     * be under the `chargeback` object.
                     */
                    val CHARGEBACK = of("chargeback")

                    /**
                     * Visa Card Dispute Merchant Pre-Arbitration Decline User Submission: details
                     * will be under the `merchant_prearbitration_decline` object.
                     */
                    val MERCHANT_PREARBITRATION_DECLINE = of("merchant_prearbitration_decline")

                    /**
                     * Visa Card Dispute User-Initiated Pre-Arbitration User Submission: details
                     * will be under the `user_prearbitration` object.
                     */
                    val USER_PREARBITRATION = of("user_prearbitration")

                    fun of(value: String) = Category(JsonField.of(value))
                }

                /** An enum containing [Category]'s known values. */
                enum class Known {
                    /**
                     * Visa Card Dispute Chargeback User Submission Chargeback Details: details will
                     * be under the `chargeback` object.
                     */
                    CHARGEBACK,
                    /**
                     * Visa Card Dispute Merchant Pre-Arbitration Decline User Submission: details
                     * will be under the `merchant_prearbitration_decline` object.
                     */
                    MERCHANT_PREARBITRATION_DECLINE,
                    /**
                     * Visa Card Dispute User-Initiated Pre-Arbitration User Submission: details
                     * will be under the `user_prearbitration` object.
                     */
                    USER_PREARBITRATION,
                }

                /**
                 * An enum containing [Category]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Category] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /**
                     * Visa Card Dispute Chargeback User Submission Chargeback Details: details will
                     * be under the `chargeback` object.
                     */
                    CHARGEBACK,
                    /**
                     * Visa Card Dispute Merchant Pre-Arbitration Decline User Submission: details
                     * will be under the `merchant_prearbitration_decline` object.
                     */
                    MERCHANT_PREARBITRATION_DECLINE,
                    /**
                     * Visa Card Dispute User-Initiated Pre-Arbitration User Submission: details
                     * will be under the `user_prearbitration` object.
                     */
                    USER_PREARBITRATION,
                    /**
                     * An enum member indicating that [Category] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        CHARGEBACK -> Value.CHARGEBACK
                        MERCHANT_PREARBITRATION_DECLINE -> Value.MERCHANT_PREARBITRATION_DECLINE
                        USER_PREARBITRATION -> Value.USER_PREARBITRATION
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        CHARGEBACK -> Known.CHARGEBACK
                        MERCHANT_PREARBITRATION_DECLINE -> Known.MERCHANT_PREARBITRATION_DECLINE
                        USER_PREARBITRATION -> Known.USER_PREARBITRATION
                        else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Category = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Category && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * A Visa Card Dispute Chargeback User Submission Chargeback Details object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `chargeback`. Contains the details specific to a Visa chargeback User Submission for
             * a Card Dispute.
             */
            class Chargeback
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val authorization: JsonField<Authorization>,
                private val category: JsonField<Category>,
                private val consumerCanceledMerchandise: JsonField<ConsumerCanceledMerchandise>,
                private val consumerCanceledRecurringTransaction:
                    JsonField<ConsumerCanceledRecurringTransaction>,
                private val consumerCanceledServices: JsonField<ConsumerCanceledServices>,
                private val consumerCounterfeitMerchandise:
                    JsonField<ConsumerCounterfeitMerchandise>,
                private val consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed>,
                private val consumerDamagedOrDefectiveMerchandise:
                    JsonField<ConsumerDamagedOrDefectiveMerchandise>,
                private val consumerMerchandiseMisrepresentation:
                    JsonField<ConsumerMerchandiseMisrepresentation>,
                private val consumerMerchandiseNotAsDescribed:
                    JsonField<ConsumerMerchandiseNotAsDescribed>,
                private val consumerMerchandiseNotReceived:
                    JsonField<ConsumerMerchandiseNotReceived>,
                private val consumerNonReceiptOfCash: JsonValue,
                private val consumerOriginalCreditTransactionNotAccepted:
                    JsonField<ConsumerOriginalCreditTransactionNotAccepted>,
                private val consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise>,
                private val consumerQualityServices: JsonField<ConsumerQualityServices>,
                private val consumerServicesMisrepresentation:
                    JsonField<ConsumerServicesMisrepresentation>,
                private val consumerServicesNotAsDescribed:
                    JsonField<ConsumerServicesNotAsDescribed>,
                private val consumerServicesNotReceived: JsonField<ConsumerServicesNotReceived>,
                private val fraud: JsonField<Fraud>,
                private val processingError: JsonField<ProcessingError>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("authorization")
                    @ExcludeMissing
                    authorization: JsonField<Authorization> = JsonMissing.of(),
                    @JsonProperty("category")
                    @ExcludeMissing
                    category: JsonField<Category> = JsonMissing.of(),
                    @JsonProperty("consumer_canceled_merchandise")
                    @ExcludeMissing
                    consumerCanceledMerchandise: JsonField<ConsumerCanceledMerchandise> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_canceled_recurring_transaction")
                    @ExcludeMissing
                    consumerCanceledRecurringTransaction:
                        JsonField<ConsumerCanceledRecurringTransaction> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_canceled_services")
                    @ExcludeMissing
                    consumerCanceledServices: JsonField<ConsumerCanceledServices> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_counterfeit_merchandise")
                    @ExcludeMissing
                    consumerCounterfeitMerchandise: JsonField<ConsumerCounterfeitMerchandise> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_credit_not_processed")
                    @ExcludeMissing
                    consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_damaged_or_defective_merchandise")
                    @ExcludeMissing
                    consumerDamagedOrDefectiveMerchandise:
                        JsonField<ConsumerDamagedOrDefectiveMerchandise> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_merchandise_misrepresentation")
                    @ExcludeMissing
                    consumerMerchandiseMisrepresentation:
                        JsonField<ConsumerMerchandiseMisrepresentation> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_merchandise_not_as_described")
                    @ExcludeMissing
                    consumerMerchandiseNotAsDescribed:
                        JsonField<ConsumerMerchandiseNotAsDescribed> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_merchandise_not_received")
                    @ExcludeMissing
                    consumerMerchandiseNotReceived: JsonField<ConsumerMerchandiseNotReceived> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_non_receipt_of_cash")
                    @ExcludeMissing
                    consumerNonReceiptOfCash: JsonValue = JsonMissing.of(),
                    @JsonProperty("consumer_original_credit_transaction_not_accepted")
                    @ExcludeMissing
                    consumerOriginalCreditTransactionNotAccepted:
                        JsonField<ConsumerOriginalCreditTransactionNotAccepted> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_quality_merchandise")
                    @ExcludeMissing
                    consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_quality_services")
                    @ExcludeMissing
                    consumerQualityServices: JsonField<ConsumerQualityServices> = JsonMissing.of(),
                    @JsonProperty("consumer_services_misrepresentation")
                    @ExcludeMissing
                    consumerServicesMisrepresentation:
                        JsonField<ConsumerServicesMisrepresentation> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_services_not_as_described")
                    @ExcludeMissing
                    consumerServicesNotAsDescribed: JsonField<ConsumerServicesNotAsDescribed> =
                        JsonMissing.of(),
                    @JsonProperty("consumer_services_not_received")
                    @ExcludeMissing
                    consumerServicesNotReceived: JsonField<ConsumerServicesNotReceived> =
                        JsonMissing.of(),
                    @JsonProperty("fraud")
                    @ExcludeMissing
                    fraud: JsonField<Fraud> = JsonMissing.of(),
                    @JsonProperty("processing_error")
                    @ExcludeMissing
                    processingError: JsonField<ProcessingError> = JsonMissing.of(),
                ) : this(
                    authorization,
                    category,
                    consumerCanceledMerchandise,
                    consumerCanceledRecurringTransaction,
                    consumerCanceledServices,
                    consumerCounterfeitMerchandise,
                    consumerCreditNotProcessed,
                    consumerDamagedOrDefectiveMerchandise,
                    consumerMerchandiseMisrepresentation,
                    consumerMerchandiseNotAsDescribed,
                    consumerMerchandiseNotReceived,
                    consumerNonReceiptOfCash,
                    consumerOriginalCreditTransactionNotAccepted,
                    consumerQualityMerchandise,
                    consumerQualityServices,
                    consumerServicesMisrepresentation,
                    consumerServicesNotAsDescribed,
                    consumerServicesNotReceived,
                    fraud,
                    processingError,
                    mutableMapOf(),
                )

                /**
                 * Authorization. Present if and only if `category` is `authorization`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun authorization(): Authorization? = authorization.getNullable("authorization")

                /**
                 * Category.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun category(): Category = category.getRequired("category")

                /**
                 * Canceled merchandise. Present if and only if `category` is
                 * `consumer_canceled_merchandise`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerCanceledMerchandise(): ConsumerCanceledMerchandise? =
                    consumerCanceledMerchandise.getNullable("consumer_canceled_merchandise")

                /**
                 * Canceled recurring transaction. Present if and only if `category` is
                 * `consumer_canceled_recurring_transaction`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerCanceledRecurringTransaction(): ConsumerCanceledRecurringTransaction? =
                    consumerCanceledRecurringTransaction.getNullable(
                        "consumer_canceled_recurring_transaction"
                    )

                /**
                 * Canceled services. Present if and only if `category` is
                 * `consumer_canceled_services`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerCanceledServices(): ConsumerCanceledServices? =
                    consumerCanceledServices.getNullable("consumer_canceled_services")

                /**
                 * Counterfeit merchandise. Present if and only if `category` is
                 * `consumer_counterfeit_merchandise`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerCounterfeitMerchandise(): ConsumerCounterfeitMerchandise? =
                    consumerCounterfeitMerchandise.getNullable("consumer_counterfeit_merchandise")

                /**
                 * Credit not processed. Present if and only if `category` is
                 * `consumer_credit_not_processed`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerCreditNotProcessed(): ConsumerCreditNotProcessed? =
                    consumerCreditNotProcessed.getNullable("consumer_credit_not_processed")

                /**
                 * Damaged or defective merchandise. Present if and only if `category` is
                 * `consumer_damaged_or_defective_merchandise`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerDamagedOrDefectiveMerchandise():
                    ConsumerDamagedOrDefectiveMerchandise? =
                    consumerDamagedOrDefectiveMerchandise.getNullable(
                        "consumer_damaged_or_defective_merchandise"
                    )

                /**
                 * Merchandise misrepresentation. Present if and only if `category` is
                 * `consumer_merchandise_misrepresentation`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerMerchandiseMisrepresentation(): ConsumerMerchandiseMisrepresentation? =
                    consumerMerchandiseMisrepresentation.getNullable(
                        "consumer_merchandise_misrepresentation"
                    )

                /**
                 * Merchandise not as described. Present if and only if `category` is
                 * `consumer_merchandise_not_as_described`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerMerchandiseNotAsDescribed(): ConsumerMerchandiseNotAsDescribed? =
                    consumerMerchandiseNotAsDescribed.getNullable(
                        "consumer_merchandise_not_as_described"
                    )

                /**
                 * Merchandise not received. Present if and only if `category` is
                 * `consumer_merchandise_not_received`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerMerchandiseNotReceived(): ConsumerMerchandiseNotReceived? =
                    consumerMerchandiseNotReceived.getNullable("consumer_merchandise_not_received")

                /**
                 * Non-receipt of cash. Present if and only if `category` is
                 * `consumer_non_receipt_of_cash`.
                 */
                @JsonProperty("consumer_non_receipt_of_cash")
                @ExcludeMissing
                fun _consumerNonReceiptOfCash(): JsonValue = consumerNonReceiptOfCash

                /**
                 * Original Credit Transaction (OCT) not accepted. Present if and only if `category`
                 * is `consumer_original_credit_transaction_not_accepted`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerOriginalCreditTransactionNotAccepted():
                    ConsumerOriginalCreditTransactionNotAccepted? =
                    consumerOriginalCreditTransactionNotAccepted.getNullable(
                        "consumer_original_credit_transaction_not_accepted"
                    )

                /**
                 * Merchandise quality issue. Present if and only if `category` is
                 * `consumer_quality_merchandise`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerQualityMerchandise(): ConsumerQualityMerchandise? =
                    consumerQualityMerchandise.getNullable("consumer_quality_merchandise")

                /**
                 * Services quality issue. Present if and only if `category` is
                 * `consumer_quality_services`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerQualityServices(): ConsumerQualityServices? =
                    consumerQualityServices.getNullable("consumer_quality_services")

                /**
                 * Services misrepresentation. Present if and only if `category` is
                 * `consumer_services_misrepresentation`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerServicesMisrepresentation(): ConsumerServicesMisrepresentation? =
                    consumerServicesMisrepresentation.getNullable(
                        "consumer_services_misrepresentation"
                    )

                /**
                 * Services not as described. Present if and only if `category` is
                 * `consumer_services_not_as_described`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerServicesNotAsDescribed(): ConsumerServicesNotAsDescribed? =
                    consumerServicesNotAsDescribed.getNullable("consumer_services_not_as_described")

                /**
                 * Services not received. Present if and only if `category` is
                 * `consumer_services_not_received`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun consumerServicesNotReceived(): ConsumerServicesNotReceived? =
                    consumerServicesNotReceived.getNullable("consumer_services_not_received")

                /**
                 * Fraud. Present if and only if `category` is `fraud`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun fraud(): Fraud? = fraud.getNullable("fraud")

                /**
                 * Processing error. Present if and only if `category` is `processing_error`.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun processingError(): ProcessingError? =
                    processingError.getNullable("processing_error")

                /**
                 * Returns the raw JSON value of [authorization].
                 *
                 * Unlike [authorization], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("authorization")
                @ExcludeMissing
                fun _authorization(): JsonField<Authorization> = authorization

                /**
                 * Returns the raw JSON value of [category].
                 *
                 * Unlike [category], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("category")
                @ExcludeMissing
                fun _category(): JsonField<Category> = category

                /**
                 * Returns the raw JSON value of [consumerCanceledMerchandise].
                 *
                 * Unlike [consumerCanceledMerchandise], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("consumer_canceled_merchandise")
                @ExcludeMissing
                fun _consumerCanceledMerchandise(): JsonField<ConsumerCanceledMerchandise> =
                    consumerCanceledMerchandise

                /**
                 * Returns the raw JSON value of [consumerCanceledRecurringTransaction].
                 *
                 * Unlike [consumerCanceledRecurringTransaction], this method doesn't throw if the
                 * JSON field has an unexpected type.
                 */
                @JsonProperty("consumer_canceled_recurring_transaction")
                @ExcludeMissing
                fun _consumerCanceledRecurringTransaction():
                    JsonField<ConsumerCanceledRecurringTransaction> =
                    consumerCanceledRecurringTransaction

                /**
                 * Returns the raw JSON value of [consumerCanceledServices].
                 *
                 * Unlike [consumerCanceledServices], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("consumer_canceled_services")
                @ExcludeMissing
                fun _consumerCanceledServices(): JsonField<ConsumerCanceledServices> =
                    consumerCanceledServices

                /**
                 * Returns the raw JSON value of [consumerCounterfeitMerchandise].
                 *
                 * Unlike [consumerCounterfeitMerchandise], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("consumer_counterfeit_merchandise")
                @ExcludeMissing
                fun _consumerCounterfeitMerchandise(): JsonField<ConsumerCounterfeitMerchandise> =
                    consumerCounterfeitMerchandise

                /**
                 * Returns the raw JSON value of [consumerCreditNotProcessed].
                 *
                 * Unlike [consumerCreditNotProcessed], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("consumer_credit_not_processed")
                @ExcludeMissing
                fun _consumerCreditNotProcessed(): JsonField<ConsumerCreditNotProcessed> =
                    consumerCreditNotProcessed

                /**
                 * Returns the raw JSON value of [consumerDamagedOrDefectiveMerchandise].
                 *
                 * Unlike [consumerDamagedOrDefectiveMerchandise], this method doesn't throw if the
                 * JSON field has an unexpected type.
                 */
                @JsonProperty("consumer_damaged_or_defective_merchandise")
                @ExcludeMissing
                fun _consumerDamagedOrDefectiveMerchandise():
                    JsonField<ConsumerDamagedOrDefectiveMerchandise> =
                    consumerDamagedOrDefectiveMerchandise

                /**
                 * Returns the raw JSON value of [consumerMerchandiseMisrepresentation].
                 *
                 * Unlike [consumerMerchandiseMisrepresentation], this method doesn't throw if the
                 * JSON field has an unexpected type.
                 */
                @JsonProperty("consumer_merchandise_misrepresentation")
                @ExcludeMissing
                fun _consumerMerchandiseMisrepresentation():
                    JsonField<ConsumerMerchandiseMisrepresentation> =
                    consumerMerchandiseMisrepresentation

                /**
                 * Returns the raw JSON value of [consumerMerchandiseNotAsDescribed].
                 *
                 * Unlike [consumerMerchandiseNotAsDescribed], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("consumer_merchandise_not_as_described")
                @ExcludeMissing
                fun _consumerMerchandiseNotAsDescribed():
                    JsonField<ConsumerMerchandiseNotAsDescribed> = consumerMerchandiseNotAsDescribed

                /**
                 * Returns the raw JSON value of [consumerMerchandiseNotReceived].
                 *
                 * Unlike [consumerMerchandiseNotReceived], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("consumer_merchandise_not_received")
                @ExcludeMissing
                fun _consumerMerchandiseNotReceived(): JsonField<ConsumerMerchandiseNotReceived> =
                    consumerMerchandiseNotReceived

                /**
                 * Returns the raw JSON value of [consumerOriginalCreditTransactionNotAccepted].
                 *
                 * Unlike [consumerOriginalCreditTransactionNotAccepted], this method doesn't throw
                 * if the JSON field has an unexpected type.
                 */
                @JsonProperty("consumer_original_credit_transaction_not_accepted")
                @ExcludeMissing
                fun _consumerOriginalCreditTransactionNotAccepted():
                    JsonField<ConsumerOriginalCreditTransactionNotAccepted> =
                    consumerOriginalCreditTransactionNotAccepted

                /**
                 * Returns the raw JSON value of [consumerQualityMerchandise].
                 *
                 * Unlike [consumerQualityMerchandise], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("consumer_quality_merchandise")
                @ExcludeMissing
                fun _consumerQualityMerchandise(): JsonField<ConsumerQualityMerchandise> =
                    consumerQualityMerchandise

                /**
                 * Returns the raw JSON value of [consumerQualityServices].
                 *
                 * Unlike [consumerQualityServices], this method doesn't throw if the JSON field has
                 * an unexpected type.
                 */
                @JsonProperty("consumer_quality_services")
                @ExcludeMissing
                fun _consumerQualityServices(): JsonField<ConsumerQualityServices> =
                    consumerQualityServices

                /**
                 * Returns the raw JSON value of [consumerServicesMisrepresentation].
                 *
                 * Unlike [consumerServicesMisrepresentation], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("consumer_services_misrepresentation")
                @ExcludeMissing
                fun _consumerServicesMisrepresentation():
                    JsonField<ConsumerServicesMisrepresentation> = consumerServicesMisrepresentation

                /**
                 * Returns the raw JSON value of [consumerServicesNotAsDescribed].
                 *
                 * Unlike [consumerServicesNotAsDescribed], this method doesn't throw if the JSON
                 * field has an unexpected type.
                 */
                @JsonProperty("consumer_services_not_as_described")
                @ExcludeMissing
                fun _consumerServicesNotAsDescribed(): JsonField<ConsumerServicesNotAsDescribed> =
                    consumerServicesNotAsDescribed

                /**
                 * Returns the raw JSON value of [consumerServicesNotReceived].
                 *
                 * Unlike [consumerServicesNotReceived], this method doesn't throw if the JSON field
                 * has an unexpected type.
                 */
                @JsonProperty("consumer_services_not_received")
                @ExcludeMissing
                fun _consumerServicesNotReceived(): JsonField<ConsumerServicesNotReceived> =
                    consumerServicesNotReceived

                /**
                 * Returns the raw JSON value of [fraud].
                 *
                 * Unlike [fraud], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("fraud") @ExcludeMissing fun _fraud(): JsonField<Fraud> = fraud

                /**
                 * Returns the raw JSON value of [processingError].
                 *
                 * Unlike [processingError], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("processing_error")
                @ExcludeMissing
                fun _processingError(): JsonField<ProcessingError> = processingError

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Chargeback].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .authorization()
                     * .category()
                     * .consumerCanceledMerchandise()
                     * .consumerCanceledRecurringTransaction()
                     * .consumerCanceledServices()
                     * .consumerCounterfeitMerchandise()
                     * .consumerCreditNotProcessed()
                     * .consumerDamagedOrDefectiveMerchandise()
                     * .consumerMerchandiseMisrepresentation()
                     * .consumerMerchandiseNotAsDescribed()
                     * .consumerMerchandiseNotReceived()
                     * .consumerNonReceiptOfCash()
                     * .consumerOriginalCreditTransactionNotAccepted()
                     * .consumerQualityMerchandise()
                     * .consumerQualityServices()
                     * .consumerServicesMisrepresentation()
                     * .consumerServicesNotAsDescribed()
                     * .consumerServicesNotReceived()
                     * .fraud()
                     * .processingError()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [Chargeback]. */
                class Builder internal constructor() {

                    private var authorization: JsonField<Authorization>? = null
                    private var category: JsonField<Category>? = null
                    private var consumerCanceledMerchandise:
                        JsonField<ConsumerCanceledMerchandise>? =
                        null
                    private var consumerCanceledRecurringTransaction:
                        JsonField<ConsumerCanceledRecurringTransaction>? =
                        null
                    private var consumerCanceledServices: JsonField<ConsumerCanceledServices>? =
                        null
                    private var consumerCounterfeitMerchandise:
                        JsonField<ConsumerCounterfeitMerchandise>? =
                        null
                    private var consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed>? =
                        null
                    private var consumerDamagedOrDefectiveMerchandise:
                        JsonField<ConsumerDamagedOrDefectiveMerchandise>? =
                        null
                    private var consumerMerchandiseMisrepresentation:
                        JsonField<ConsumerMerchandiseMisrepresentation>? =
                        null
                    private var consumerMerchandiseNotAsDescribed:
                        JsonField<ConsumerMerchandiseNotAsDescribed>? =
                        null
                    private var consumerMerchandiseNotReceived:
                        JsonField<ConsumerMerchandiseNotReceived>? =
                        null
                    private var consumerNonReceiptOfCash: JsonValue? = null
                    private var consumerOriginalCreditTransactionNotAccepted:
                        JsonField<ConsumerOriginalCreditTransactionNotAccepted>? =
                        null
                    private var consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise>? =
                        null
                    private var consumerQualityServices: JsonField<ConsumerQualityServices>? = null
                    private var consumerServicesMisrepresentation:
                        JsonField<ConsumerServicesMisrepresentation>? =
                        null
                    private var consumerServicesNotAsDescribed:
                        JsonField<ConsumerServicesNotAsDescribed>? =
                        null
                    private var consumerServicesNotReceived:
                        JsonField<ConsumerServicesNotReceived>? =
                        null
                    private var fraud: JsonField<Fraud>? = null
                    private var processingError: JsonField<ProcessingError>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(chargeback: Chargeback) = apply {
                        authorization = chargeback.authorization
                        category = chargeback.category
                        consumerCanceledMerchandise = chargeback.consumerCanceledMerchandise
                        consumerCanceledRecurringTransaction =
                            chargeback.consumerCanceledRecurringTransaction
                        consumerCanceledServices = chargeback.consumerCanceledServices
                        consumerCounterfeitMerchandise = chargeback.consumerCounterfeitMerchandise
                        consumerCreditNotProcessed = chargeback.consumerCreditNotProcessed
                        consumerDamagedOrDefectiveMerchandise =
                            chargeback.consumerDamagedOrDefectiveMerchandise
                        consumerMerchandiseMisrepresentation =
                            chargeback.consumerMerchandiseMisrepresentation
                        consumerMerchandiseNotAsDescribed =
                            chargeback.consumerMerchandiseNotAsDescribed
                        consumerMerchandiseNotReceived = chargeback.consumerMerchandiseNotReceived
                        consumerNonReceiptOfCash = chargeback.consumerNonReceiptOfCash
                        consumerOriginalCreditTransactionNotAccepted =
                            chargeback.consumerOriginalCreditTransactionNotAccepted
                        consumerQualityMerchandise = chargeback.consumerQualityMerchandise
                        consumerQualityServices = chargeback.consumerQualityServices
                        consumerServicesMisrepresentation =
                            chargeback.consumerServicesMisrepresentation
                        consumerServicesNotAsDescribed = chargeback.consumerServicesNotAsDescribed
                        consumerServicesNotReceived = chargeback.consumerServicesNotReceived
                        fraud = chargeback.fraud
                        processingError = chargeback.processingError
                        additionalProperties = chargeback.additionalProperties.toMutableMap()
                    }

                    /** Authorization. Present if and only if `category` is `authorization`. */
                    fun authorization(authorization: Authorization?) =
                        authorization(JsonField.ofNullable(authorization))

                    /**
                     * Sets [Builder.authorization] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.authorization] with a well-typed
                     * [Authorization] value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun authorization(authorization: JsonField<Authorization>) = apply {
                        this.authorization = authorization
                    }

                    /** Category. */
                    fun category(category: Category) = category(JsonField.of(category))

                    /**
                     * Sets [Builder.category] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.category] with a well-typed [Category] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun category(category: JsonField<Category>) = apply { this.category = category }

                    /**
                     * Canceled merchandise. Present if and only if `category` is
                     * `consumer_canceled_merchandise`.
                     */
                    fun consumerCanceledMerchandise(
                        consumerCanceledMerchandise: ConsumerCanceledMerchandise?
                    ) =
                        consumerCanceledMerchandise(
                            JsonField.ofNullable(consumerCanceledMerchandise)
                        )

                    /**
                     * Sets [Builder.consumerCanceledMerchandise] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerCanceledMerchandise] with a
                     * well-typed [ConsumerCanceledMerchandise] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerCanceledMerchandise(
                        consumerCanceledMerchandise: JsonField<ConsumerCanceledMerchandise>
                    ) = apply { this.consumerCanceledMerchandise = consumerCanceledMerchandise }

                    /**
                     * Canceled recurring transaction. Present if and only if `category` is
                     * `consumer_canceled_recurring_transaction`.
                     */
                    fun consumerCanceledRecurringTransaction(
                        consumerCanceledRecurringTransaction: ConsumerCanceledRecurringTransaction?
                    ) =
                        consumerCanceledRecurringTransaction(
                            JsonField.ofNullable(consumerCanceledRecurringTransaction)
                        )

                    /**
                     * Sets [Builder.consumerCanceledRecurringTransaction] to an arbitrary JSON
                     * value.
                     *
                     * You should usually call [Builder.consumerCanceledRecurringTransaction] with a
                     * well-typed [ConsumerCanceledRecurringTransaction] value instead. This method
                     * is primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerCanceledRecurringTransaction(
                        consumerCanceledRecurringTransaction:
                            JsonField<ConsumerCanceledRecurringTransaction>
                    ) = apply {
                        this.consumerCanceledRecurringTransaction =
                            consumerCanceledRecurringTransaction
                    }

                    /**
                     * Canceled services. Present if and only if `category` is
                     * `consumer_canceled_services`.
                     */
                    fun consumerCanceledServices(
                        consumerCanceledServices: ConsumerCanceledServices?
                    ) = consumerCanceledServices(JsonField.ofNullable(consumerCanceledServices))

                    /**
                     * Sets [Builder.consumerCanceledServices] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerCanceledServices] with a well-typed
                     * [ConsumerCanceledServices] value instead. This method is primarily for
                     * setting the field to an undocumented or not yet supported value.
                     */
                    fun consumerCanceledServices(
                        consumerCanceledServices: JsonField<ConsumerCanceledServices>
                    ) = apply { this.consumerCanceledServices = consumerCanceledServices }

                    /**
                     * Counterfeit merchandise. Present if and only if `category` is
                     * `consumer_counterfeit_merchandise`.
                     */
                    fun consumerCounterfeitMerchandise(
                        consumerCounterfeitMerchandise: ConsumerCounterfeitMerchandise?
                    ) =
                        consumerCounterfeitMerchandise(
                            JsonField.ofNullable(consumerCounterfeitMerchandise)
                        )

                    /**
                     * Sets [Builder.consumerCounterfeitMerchandise] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerCounterfeitMerchandise] with a
                     * well-typed [ConsumerCounterfeitMerchandise] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerCounterfeitMerchandise(
                        consumerCounterfeitMerchandise: JsonField<ConsumerCounterfeitMerchandise>
                    ) = apply {
                        this.consumerCounterfeitMerchandise = consumerCounterfeitMerchandise
                    }

                    /**
                     * Credit not processed. Present if and only if `category` is
                     * `consumer_credit_not_processed`.
                     */
                    fun consumerCreditNotProcessed(
                        consumerCreditNotProcessed: ConsumerCreditNotProcessed?
                    ) = consumerCreditNotProcessed(JsonField.ofNullable(consumerCreditNotProcessed))

                    /**
                     * Sets [Builder.consumerCreditNotProcessed] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerCreditNotProcessed] with a
                     * well-typed [ConsumerCreditNotProcessed] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerCreditNotProcessed(
                        consumerCreditNotProcessed: JsonField<ConsumerCreditNotProcessed>
                    ) = apply { this.consumerCreditNotProcessed = consumerCreditNotProcessed }

                    /**
                     * Damaged or defective merchandise. Present if and only if `category` is
                     * `consumer_damaged_or_defective_merchandise`.
                     */
                    fun consumerDamagedOrDefectiveMerchandise(
                        consumerDamagedOrDefectiveMerchandise:
                            ConsumerDamagedOrDefectiveMerchandise?
                    ) =
                        consumerDamagedOrDefectiveMerchandise(
                            JsonField.ofNullable(consumerDamagedOrDefectiveMerchandise)
                        )

                    /**
                     * Sets [Builder.consumerDamagedOrDefectiveMerchandise] to an arbitrary JSON
                     * value.
                     *
                     * You should usually call [Builder.consumerDamagedOrDefectiveMerchandise] with
                     * a well-typed [ConsumerDamagedOrDefectiveMerchandise] value instead. This
                     * method is primarily for setting the field to an undocumented or not yet
                     * supported value.
                     */
                    fun consumerDamagedOrDefectiveMerchandise(
                        consumerDamagedOrDefectiveMerchandise:
                            JsonField<ConsumerDamagedOrDefectiveMerchandise>
                    ) = apply {
                        this.consumerDamagedOrDefectiveMerchandise =
                            consumerDamagedOrDefectiveMerchandise
                    }

                    /**
                     * Merchandise misrepresentation. Present if and only if `category` is
                     * `consumer_merchandise_misrepresentation`.
                     */
                    fun consumerMerchandiseMisrepresentation(
                        consumerMerchandiseMisrepresentation: ConsumerMerchandiseMisrepresentation?
                    ) =
                        consumerMerchandiseMisrepresentation(
                            JsonField.ofNullable(consumerMerchandiseMisrepresentation)
                        )

                    /**
                     * Sets [Builder.consumerMerchandiseMisrepresentation] to an arbitrary JSON
                     * value.
                     *
                     * You should usually call [Builder.consumerMerchandiseMisrepresentation] with a
                     * well-typed [ConsumerMerchandiseMisrepresentation] value instead. This method
                     * is primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerMerchandiseMisrepresentation(
                        consumerMerchandiseMisrepresentation:
                            JsonField<ConsumerMerchandiseMisrepresentation>
                    ) = apply {
                        this.consumerMerchandiseMisrepresentation =
                            consumerMerchandiseMisrepresentation
                    }

                    /**
                     * Merchandise not as described. Present if and only if `category` is
                     * `consumer_merchandise_not_as_described`.
                     */
                    fun consumerMerchandiseNotAsDescribed(
                        consumerMerchandiseNotAsDescribed: ConsumerMerchandiseNotAsDescribed?
                    ) =
                        consumerMerchandiseNotAsDescribed(
                            JsonField.ofNullable(consumerMerchandiseNotAsDescribed)
                        )

                    /**
                     * Sets [Builder.consumerMerchandiseNotAsDescribed] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerMerchandiseNotAsDescribed] with a
                     * well-typed [ConsumerMerchandiseNotAsDescribed] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerMerchandiseNotAsDescribed(
                        consumerMerchandiseNotAsDescribed:
                            JsonField<ConsumerMerchandiseNotAsDescribed>
                    ) = apply {
                        this.consumerMerchandiseNotAsDescribed = consumerMerchandiseNotAsDescribed
                    }

                    /**
                     * Merchandise not received. Present if and only if `category` is
                     * `consumer_merchandise_not_received`.
                     */
                    fun consumerMerchandiseNotReceived(
                        consumerMerchandiseNotReceived: ConsumerMerchandiseNotReceived?
                    ) =
                        consumerMerchandiseNotReceived(
                            JsonField.ofNullable(consumerMerchandiseNotReceived)
                        )

                    /**
                     * Sets [Builder.consumerMerchandiseNotReceived] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerMerchandiseNotReceived] with a
                     * well-typed [ConsumerMerchandiseNotReceived] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerMerchandiseNotReceived(
                        consumerMerchandiseNotReceived: JsonField<ConsumerMerchandiseNotReceived>
                    ) = apply {
                        this.consumerMerchandiseNotReceived = consumerMerchandiseNotReceived
                    }

                    /**
                     * Non-receipt of cash. Present if and only if `category` is
                     * `consumer_non_receipt_of_cash`.
                     */
                    fun consumerNonReceiptOfCash(consumerNonReceiptOfCash: JsonValue) = apply {
                        this.consumerNonReceiptOfCash = consumerNonReceiptOfCash
                    }

                    /**
                     * Original Credit Transaction (OCT) not accepted. Present if and only if
                     * `category` is `consumer_original_credit_transaction_not_accepted`.
                     */
                    fun consumerOriginalCreditTransactionNotAccepted(
                        consumerOriginalCreditTransactionNotAccepted:
                            ConsumerOriginalCreditTransactionNotAccepted?
                    ) =
                        consumerOriginalCreditTransactionNotAccepted(
                            JsonField.ofNullable(consumerOriginalCreditTransactionNotAccepted)
                        )

                    /**
                     * Sets [Builder.consumerOriginalCreditTransactionNotAccepted] to an arbitrary
                     * JSON value.
                     *
                     * You should usually call
                     * [Builder.consumerOriginalCreditTransactionNotAccepted] with a well-typed
                     * [ConsumerOriginalCreditTransactionNotAccepted] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerOriginalCreditTransactionNotAccepted(
                        consumerOriginalCreditTransactionNotAccepted:
                            JsonField<ConsumerOriginalCreditTransactionNotAccepted>
                    ) = apply {
                        this.consumerOriginalCreditTransactionNotAccepted =
                            consumerOriginalCreditTransactionNotAccepted
                    }

                    /**
                     * Merchandise quality issue. Present if and only if `category` is
                     * `consumer_quality_merchandise`.
                     */
                    fun consumerQualityMerchandise(
                        consumerQualityMerchandise: ConsumerQualityMerchandise?
                    ) = consumerQualityMerchandise(JsonField.ofNullable(consumerQualityMerchandise))

                    /**
                     * Sets [Builder.consumerQualityMerchandise] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerQualityMerchandise] with a
                     * well-typed [ConsumerQualityMerchandise] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerQualityMerchandise(
                        consumerQualityMerchandise: JsonField<ConsumerQualityMerchandise>
                    ) = apply { this.consumerQualityMerchandise = consumerQualityMerchandise }

                    /**
                     * Services quality issue. Present if and only if `category` is
                     * `consumer_quality_services`.
                     */
                    fun consumerQualityServices(consumerQualityServices: ConsumerQualityServices?) =
                        consumerQualityServices(JsonField.ofNullable(consumerQualityServices))

                    /**
                     * Sets [Builder.consumerQualityServices] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerQualityServices] with a well-typed
                     * [ConsumerQualityServices] value instead. This method is primarily for setting
                     * the field to an undocumented or not yet supported value.
                     */
                    fun consumerQualityServices(
                        consumerQualityServices: JsonField<ConsumerQualityServices>
                    ) = apply { this.consumerQualityServices = consumerQualityServices }

                    /**
                     * Services misrepresentation. Present if and only if `category` is
                     * `consumer_services_misrepresentation`.
                     */
                    fun consumerServicesMisrepresentation(
                        consumerServicesMisrepresentation: ConsumerServicesMisrepresentation?
                    ) =
                        consumerServicesMisrepresentation(
                            JsonField.ofNullable(consumerServicesMisrepresentation)
                        )

                    /**
                     * Sets [Builder.consumerServicesMisrepresentation] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerServicesMisrepresentation] with a
                     * well-typed [ConsumerServicesMisrepresentation] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerServicesMisrepresentation(
                        consumerServicesMisrepresentation:
                            JsonField<ConsumerServicesMisrepresentation>
                    ) = apply {
                        this.consumerServicesMisrepresentation = consumerServicesMisrepresentation
                    }

                    /**
                     * Services not as described. Present if and only if `category` is
                     * `consumer_services_not_as_described`.
                     */
                    fun consumerServicesNotAsDescribed(
                        consumerServicesNotAsDescribed: ConsumerServicesNotAsDescribed?
                    ) =
                        consumerServicesNotAsDescribed(
                            JsonField.ofNullable(consumerServicesNotAsDescribed)
                        )

                    /**
                     * Sets [Builder.consumerServicesNotAsDescribed] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerServicesNotAsDescribed] with a
                     * well-typed [ConsumerServicesNotAsDescribed] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerServicesNotAsDescribed(
                        consumerServicesNotAsDescribed: JsonField<ConsumerServicesNotAsDescribed>
                    ) = apply {
                        this.consumerServicesNotAsDescribed = consumerServicesNotAsDescribed
                    }

                    /**
                     * Services not received. Present if and only if `category` is
                     * `consumer_services_not_received`.
                     */
                    fun consumerServicesNotReceived(
                        consumerServicesNotReceived: ConsumerServicesNotReceived?
                    ) =
                        consumerServicesNotReceived(
                            JsonField.ofNullable(consumerServicesNotReceived)
                        )

                    /**
                     * Sets [Builder.consumerServicesNotReceived] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.consumerServicesNotReceived] with a
                     * well-typed [ConsumerServicesNotReceived] value instead. This method is
                     * primarily for setting the field to an undocumented or not yet supported
                     * value.
                     */
                    fun consumerServicesNotReceived(
                        consumerServicesNotReceived: JsonField<ConsumerServicesNotReceived>
                    ) = apply { this.consumerServicesNotReceived = consumerServicesNotReceived }

                    /** Fraud. Present if and only if `category` is `fraud`. */
                    fun fraud(fraud: Fraud?) = fraud(JsonField.ofNullable(fraud))

                    /**
                     * Sets [Builder.fraud] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.fraud] with a well-typed [Fraud] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun fraud(fraud: JsonField<Fraud>) = apply { this.fraud = fraud }

                    /**
                     * Processing error. Present if and only if `category` is `processing_error`.
                     */
                    fun processingError(processingError: ProcessingError?) =
                        processingError(JsonField.ofNullable(processingError))

                    /**
                     * Sets [Builder.processingError] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.processingError] with a well-typed
                     * [ProcessingError] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun processingError(processingError: JsonField<ProcessingError>) = apply {
                        this.processingError = processingError
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [Chargeback].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .authorization()
                     * .category()
                     * .consumerCanceledMerchandise()
                     * .consumerCanceledRecurringTransaction()
                     * .consumerCanceledServices()
                     * .consumerCounterfeitMerchandise()
                     * .consumerCreditNotProcessed()
                     * .consumerDamagedOrDefectiveMerchandise()
                     * .consumerMerchandiseMisrepresentation()
                     * .consumerMerchandiseNotAsDescribed()
                     * .consumerMerchandiseNotReceived()
                     * .consumerNonReceiptOfCash()
                     * .consumerOriginalCreditTransactionNotAccepted()
                     * .consumerQualityMerchandise()
                     * .consumerQualityServices()
                     * .consumerServicesMisrepresentation()
                     * .consumerServicesNotAsDescribed()
                     * .consumerServicesNotReceived()
                     * .fraud()
                     * .processingError()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): Chargeback =
                        Chargeback(
                            checkRequired("authorization", authorization),
                            checkRequired("category", category),
                            checkRequired(
                                "consumerCanceledMerchandise",
                                consumerCanceledMerchandise,
                            ),
                            checkRequired(
                                "consumerCanceledRecurringTransaction",
                                consumerCanceledRecurringTransaction,
                            ),
                            checkRequired("consumerCanceledServices", consumerCanceledServices),
                            checkRequired(
                                "consumerCounterfeitMerchandise",
                                consumerCounterfeitMerchandise,
                            ),
                            checkRequired("consumerCreditNotProcessed", consumerCreditNotProcessed),
                            checkRequired(
                                "consumerDamagedOrDefectiveMerchandise",
                                consumerDamagedOrDefectiveMerchandise,
                            ),
                            checkRequired(
                                "consumerMerchandiseMisrepresentation",
                                consumerMerchandiseMisrepresentation,
                            ),
                            checkRequired(
                                "consumerMerchandiseNotAsDescribed",
                                consumerMerchandiseNotAsDescribed,
                            ),
                            checkRequired(
                                "consumerMerchandiseNotReceived",
                                consumerMerchandiseNotReceived,
                            ),
                            checkRequired("consumerNonReceiptOfCash", consumerNonReceiptOfCash),
                            checkRequired(
                                "consumerOriginalCreditTransactionNotAccepted",
                                consumerOriginalCreditTransactionNotAccepted,
                            ),
                            checkRequired("consumerQualityMerchandise", consumerQualityMerchandise),
                            checkRequired("consumerQualityServices", consumerQualityServices),
                            checkRequired(
                                "consumerServicesMisrepresentation",
                                consumerServicesMisrepresentation,
                            ),
                            checkRequired(
                                "consumerServicesNotAsDescribed",
                                consumerServicesNotAsDescribed,
                            ),
                            checkRequired(
                                "consumerServicesNotReceived",
                                consumerServicesNotReceived,
                            ),
                            checkRequired("fraud", fraud),
                            checkRequired("processingError", processingError),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): Chargeback = apply {
                    if (validated) {
                        return@apply
                    }

                    authorization()?.validate()
                    category().validate()
                    consumerCanceledMerchandise()?.validate()
                    consumerCanceledRecurringTransaction()?.validate()
                    consumerCanceledServices()?.validate()
                    consumerCounterfeitMerchandise()?.validate()
                    consumerCreditNotProcessed()?.validate()
                    consumerDamagedOrDefectiveMerchandise()?.validate()
                    consumerMerchandiseMisrepresentation()?.validate()
                    consumerMerchandiseNotAsDescribed()?.validate()
                    consumerMerchandiseNotReceived()?.validate()
                    consumerOriginalCreditTransactionNotAccepted()?.validate()
                    consumerQualityMerchandise()?.validate()
                    consumerQualityServices()?.validate()
                    consumerServicesMisrepresentation()?.validate()
                    consumerServicesNotAsDescribed()?.validate()
                    consumerServicesNotReceived()?.validate()
                    fraud()?.validate()
                    processingError()?.validate()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (authorization.asKnown()?.validity() ?: 0) +
                        (category.asKnown()?.validity() ?: 0) +
                        (consumerCanceledMerchandise.asKnown()?.validity() ?: 0) +
                        (consumerCanceledRecurringTransaction.asKnown()?.validity() ?: 0) +
                        (consumerCanceledServices.asKnown()?.validity() ?: 0) +
                        (consumerCounterfeitMerchandise.asKnown()?.validity() ?: 0) +
                        (consumerCreditNotProcessed.asKnown()?.validity() ?: 0) +
                        (consumerDamagedOrDefectiveMerchandise.asKnown()?.validity() ?: 0) +
                        (consumerMerchandiseMisrepresentation.asKnown()?.validity() ?: 0) +
                        (consumerMerchandiseNotAsDescribed.asKnown()?.validity() ?: 0) +
                        (consumerMerchandiseNotReceived.asKnown()?.validity() ?: 0) +
                        (consumerOriginalCreditTransactionNotAccepted.asKnown()?.validity() ?: 0) +
                        (consumerQualityMerchandise.asKnown()?.validity() ?: 0) +
                        (consumerQualityServices.asKnown()?.validity() ?: 0) +
                        (consumerServicesMisrepresentation.asKnown()?.validity() ?: 0) +
                        (consumerServicesNotAsDescribed.asKnown()?.validity() ?: 0) +
                        (consumerServicesNotReceived.asKnown()?.validity() ?: 0) +
                        (fraud.asKnown()?.validity() ?: 0) +
                        (processingError.asKnown()?.validity() ?: 0)

                /** Authorization. Present if and only if `category` is `authorization`. */
                class Authorization
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val accountStatus: JsonField<AccountStatus>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("account_status")
                        @ExcludeMissing
                        accountStatus: JsonField<AccountStatus> = JsonMissing.of()
                    ) : this(accountStatus, mutableMapOf())

                    /**
                     * Account status.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun accountStatus(): AccountStatus = accountStatus.getRequired("account_status")

                    /**
                     * Returns the raw JSON value of [accountStatus].
                     *
                     * Unlike [accountStatus], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("account_status")
                    @ExcludeMissing
                    fun _accountStatus(): JsonField<AccountStatus> = accountStatus

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [Authorization].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .accountStatus()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Authorization]. */
                    class Builder internal constructor() {

                        private var accountStatus: JsonField<AccountStatus>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(authorization: Authorization) = apply {
                            accountStatus = authorization.accountStatus
                            additionalProperties = authorization.additionalProperties.toMutableMap()
                        }

                        /** Account status. */
                        fun accountStatus(accountStatus: AccountStatus) =
                            accountStatus(JsonField.of(accountStatus))

                        /**
                         * Sets [Builder.accountStatus] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.accountStatus] with a well-typed
                         * [AccountStatus] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun accountStatus(accountStatus: JsonField<AccountStatus>) = apply {
                            this.accountStatus = accountStatus
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Authorization].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .accountStatus()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Authorization =
                            Authorization(
                                checkRequired("accountStatus", accountStatus),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Authorization = apply {
                        if (validated) {
                            return@apply
                        }

                        accountStatus().validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (accountStatus.asKnown()?.validity() ?: 0)

                    /** Account status. */
                    class AccountStatus
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Account closed. */
                            val ACCOUNT_CLOSED = of("account_closed")

                            /** Credit problem. */
                            val CREDIT_PROBLEM = of("credit_problem")

                            /** Fraud. */
                            val FRAUD = of("fraud")

                            fun of(value: String) = AccountStatus(JsonField.of(value))
                        }

                        /** An enum containing [AccountStatus]'s known values. */
                        enum class Known {
                            /** Account closed. */
                            ACCOUNT_CLOSED,
                            /** Credit problem. */
                            CREDIT_PROBLEM,
                            /** Fraud. */
                            FRAUD,
                        }

                        /**
                         * An enum containing [AccountStatus]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [AccountStatus] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Account closed. */
                            ACCOUNT_CLOSED,
                            /** Credit problem. */
                            CREDIT_PROBLEM,
                            /** Fraud. */
                            FRAUD,
                            /**
                             * An enum member indicating that [AccountStatus] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ACCOUNT_CLOSED -> Value.ACCOUNT_CLOSED
                                CREDIT_PROBLEM -> Value.CREDIT_PROBLEM
                                FRAUD -> Value.FRAUD
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ACCOUNT_CLOSED -> Known.ACCOUNT_CLOSED
                                CREDIT_PROBLEM -> Known.CREDIT_PROBLEM
                                FRAUD -> Known.FRAUD
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown AccountStatus: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): AccountStatus = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is AccountStatus && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Authorization &&
                            accountStatus == other.accountStatus &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(accountStatus, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Authorization{accountStatus=$accountStatus, additionalProperties=$additionalProperties}"
                }

                /** Category. */
                class Category
                @JsonCreator
                private constructor(private val value: JsonField<String>) : Enum {

                    /**
                     * Returns this class instance's raw value.
                     *
                     * This is usually only useful if this instance was deserialized from data that
                     * doesn't match any known member, and you want to know that value. For example,
                     * if the SDK is on an older version than the API, then the API may respond with
                     * new members that the SDK is unaware of.
                     */
                    @com.fasterxml.jackson.annotation.JsonValue
                    fun _value(): JsonField<String> = value

                    companion object {

                        /** Authorization. */
                        val AUTHORIZATION = of("authorization")

                        /** Consumer: canceled merchandise. */
                        val CONSUMER_CANCELED_MERCHANDISE = of("consumer_canceled_merchandise")

                        /** Consumer: canceled recurring transaction. */
                        val CONSUMER_CANCELED_RECURRING_TRANSACTION =
                            of("consumer_canceled_recurring_transaction")

                        /** Consumer: canceled services. */
                        val CONSUMER_CANCELED_SERVICES = of("consumer_canceled_services")

                        /** Consumer: counterfeit merchandise. */
                        val CONSUMER_COUNTERFEIT_MERCHANDISE =
                            of("consumer_counterfeit_merchandise")

                        /** Consumer: credit not processed. */
                        val CONSUMER_CREDIT_NOT_PROCESSED = of("consumer_credit_not_processed")

                        /** Consumer: damaged or defective merchandise. */
                        val CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE =
                            of("consumer_damaged_or_defective_merchandise")

                        /** Consumer: merchandise misrepresentation. */
                        val CONSUMER_MERCHANDISE_MISREPRESENTATION =
                            of("consumer_merchandise_misrepresentation")

                        /** Consumer: merchandise not as described. */
                        val CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED =
                            of("consumer_merchandise_not_as_described")

                        /** Consumer: merchandise not received. */
                        val CONSUMER_MERCHANDISE_NOT_RECEIVED =
                            of("consumer_merchandise_not_received")

                        /** Consumer: non-receipt of cash. */
                        val CONSUMER_NON_RECEIPT_OF_CASH = of("consumer_non_receipt_of_cash")

                        /** Consumer: Original Credit Transaction (OCT) not accepted. */
                        val CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED =
                            of("consumer_original_credit_transaction_not_accepted")

                        /** Consumer: merchandise quality issue. */
                        val CONSUMER_QUALITY_MERCHANDISE = of("consumer_quality_merchandise")

                        /** Consumer: services quality issue. */
                        val CONSUMER_QUALITY_SERVICES = of("consumer_quality_services")

                        /** Consumer: services misrepresentation. */
                        val CONSUMER_SERVICES_MISREPRESENTATION =
                            of("consumer_services_misrepresentation")

                        /** Consumer: services not as described. */
                        val CONSUMER_SERVICES_NOT_AS_DESCRIBED =
                            of("consumer_services_not_as_described")

                        /** Consumer: services not received. */
                        val CONSUMER_SERVICES_NOT_RECEIVED = of("consumer_services_not_received")

                        /** Fraud. */
                        val FRAUD = of("fraud")

                        /** Processing error. */
                        val PROCESSING_ERROR = of("processing_error")

                        fun of(value: String) = Category(JsonField.of(value))
                    }

                    /** An enum containing [Category]'s known values. */
                    enum class Known {
                        /** Authorization. */
                        AUTHORIZATION,
                        /** Consumer: canceled merchandise. */
                        CONSUMER_CANCELED_MERCHANDISE,
                        /** Consumer: canceled recurring transaction. */
                        CONSUMER_CANCELED_RECURRING_TRANSACTION,
                        /** Consumer: canceled services. */
                        CONSUMER_CANCELED_SERVICES,
                        /** Consumer: counterfeit merchandise. */
                        CONSUMER_COUNTERFEIT_MERCHANDISE,
                        /** Consumer: credit not processed. */
                        CONSUMER_CREDIT_NOT_PROCESSED,
                        /** Consumer: damaged or defective merchandise. */
                        CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                        /** Consumer: merchandise misrepresentation. */
                        CONSUMER_MERCHANDISE_MISREPRESENTATION,
                        /** Consumer: merchandise not as described. */
                        CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                        /** Consumer: merchandise not received. */
                        CONSUMER_MERCHANDISE_NOT_RECEIVED,
                        /** Consumer: non-receipt of cash. */
                        CONSUMER_NON_RECEIPT_OF_CASH,
                        /** Consumer: Original Credit Transaction (OCT) not accepted. */
                        CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                        /** Consumer: merchandise quality issue. */
                        CONSUMER_QUALITY_MERCHANDISE,
                        /** Consumer: services quality issue. */
                        CONSUMER_QUALITY_SERVICES,
                        /** Consumer: services misrepresentation. */
                        CONSUMER_SERVICES_MISREPRESENTATION,
                        /** Consumer: services not as described. */
                        CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                        /** Consumer: services not received. */
                        CONSUMER_SERVICES_NOT_RECEIVED,
                        /** Fraud. */
                        FRAUD,
                        /** Processing error. */
                        PROCESSING_ERROR,
                    }

                    /**
                     * An enum containing [Category]'s known values, as well as an [_UNKNOWN]
                     * member.
                     *
                     * An instance of [Category] can contain an unknown value in a couple of cases:
                     * - It was deserialized from data that doesn't match any known member. For
                     *   example, if the SDK is on an older version than the API, then the API may
                     *   respond with new members that the SDK is unaware of.
                     * - It was constructed with an arbitrary value using the [of] method.
                     */
                    enum class Value {
                        /** Authorization. */
                        AUTHORIZATION,
                        /** Consumer: canceled merchandise. */
                        CONSUMER_CANCELED_MERCHANDISE,
                        /** Consumer: canceled recurring transaction. */
                        CONSUMER_CANCELED_RECURRING_TRANSACTION,
                        /** Consumer: canceled services. */
                        CONSUMER_CANCELED_SERVICES,
                        /** Consumer: counterfeit merchandise. */
                        CONSUMER_COUNTERFEIT_MERCHANDISE,
                        /** Consumer: credit not processed. */
                        CONSUMER_CREDIT_NOT_PROCESSED,
                        /** Consumer: damaged or defective merchandise. */
                        CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                        /** Consumer: merchandise misrepresentation. */
                        CONSUMER_MERCHANDISE_MISREPRESENTATION,
                        /** Consumer: merchandise not as described. */
                        CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                        /** Consumer: merchandise not received. */
                        CONSUMER_MERCHANDISE_NOT_RECEIVED,
                        /** Consumer: non-receipt of cash. */
                        CONSUMER_NON_RECEIPT_OF_CASH,
                        /** Consumer: Original Credit Transaction (OCT) not accepted. */
                        CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                        /** Consumer: merchandise quality issue. */
                        CONSUMER_QUALITY_MERCHANDISE,
                        /** Consumer: services quality issue. */
                        CONSUMER_QUALITY_SERVICES,
                        /** Consumer: services misrepresentation. */
                        CONSUMER_SERVICES_MISREPRESENTATION,
                        /** Consumer: services not as described. */
                        CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                        /** Consumer: services not received. */
                        CONSUMER_SERVICES_NOT_RECEIVED,
                        /** Fraud. */
                        FRAUD,
                        /** Processing error. */
                        PROCESSING_ERROR,
                        /**
                         * An enum member indicating that [Category] was instantiated with an
                         * unknown value.
                         */
                        _UNKNOWN,
                    }

                    /**
                     * Returns an enum member corresponding to this class instance's value, or
                     * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                     *
                     * Use the [known] method instead if you're certain the value is always known or
                     * if you want to throw for the unknown case.
                     */
                    fun value(): Value =
                        when (this) {
                            AUTHORIZATION -> Value.AUTHORIZATION
                            CONSUMER_CANCELED_MERCHANDISE -> Value.CONSUMER_CANCELED_MERCHANDISE
                            CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                                Value.CONSUMER_CANCELED_RECURRING_TRANSACTION
                            CONSUMER_CANCELED_SERVICES -> Value.CONSUMER_CANCELED_SERVICES
                            CONSUMER_COUNTERFEIT_MERCHANDISE ->
                                Value.CONSUMER_COUNTERFEIT_MERCHANDISE
                            CONSUMER_CREDIT_NOT_PROCESSED -> Value.CONSUMER_CREDIT_NOT_PROCESSED
                            CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                                Value.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                            CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                                Value.CONSUMER_MERCHANDISE_MISREPRESENTATION
                            CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                                Value.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                            CONSUMER_MERCHANDISE_NOT_RECEIVED ->
                                Value.CONSUMER_MERCHANDISE_NOT_RECEIVED
                            CONSUMER_NON_RECEIPT_OF_CASH -> Value.CONSUMER_NON_RECEIPT_OF_CASH
                            CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                                Value.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                            CONSUMER_QUALITY_MERCHANDISE -> Value.CONSUMER_QUALITY_MERCHANDISE
                            CONSUMER_QUALITY_SERVICES -> Value.CONSUMER_QUALITY_SERVICES
                            CONSUMER_SERVICES_MISREPRESENTATION ->
                                Value.CONSUMER_SERVICES_MISREPRESENTATION
                            CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                                Value.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                            CONSUMER_SERVICES_NOT_RECEIVED -> Value.CONSUMER_SERVICES_NOT_RECEIVED
                            FRAUD -> Value.FRAUD
                            PROCESSING_ERROR -> Value.PROCESSING_ERROR
                            else -> Value._UNKNOWN
                        }

                    /**
                     * Returns an enum member corresponding to this class instance's value.
                     *
                     * Use the [value] method instead if you're uncertain the value is always known
                     * and don't want to throw for the unknown case.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value is a not
                     *   a known member.
                     */
                    fun known(): Known =
                        when (this) {
                            AUTHORIZATION -> Known.AUTHORIZATION
                            CONSUMER_CANCELED_MERCHANDISE -> Known.CONSUMER_CANCELED_MERCHANDISE
                            CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                                Known.CONSUMER_CANCELED_RECURRING_TRANSACTION
                            CONSUMER_CANCELED_SERVICES -> Known.CONSUMER_CANCELED_SERVICES
                            CONSUMER_COUNTERFEIT_MERCHANDISE ->
                                Known.CONSUMER_COUNTERFEIT_MERCHANDISE
                            CONSUMER_CREDIT_NOT_PROCESSED -> Known.CONSUMER_CREDIT_NOT_PROCESSED
                            CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                                Known.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                            CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                                Known.CONSUMER_MERCHANDISE_MISREPRESENTATION
                            CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                                Known.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                            CONSUMER_MERCHANDISE_NOT_RECEIVED ->
                                Known.CONSUMER_MERCHANDISE_NOT_RECEIVED
                            CONSUMER_NON_RECEIPT_OF_CASH -> Known.CONSUMER_NON_RECEIPT_OF_CASH
                            CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                                Known.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                            CONSUMER_QUALITY_MERCHANDISE -> Known.CONSUMER_QUALITY_MERCHANDISE
                            CONSUMER_QUALITY_SERVICES -> Known.CONSUMER_QUALITY_SERVICES
                            CONSUMER_SERVICES_MISREPRESENTATION ->
                                Known.CONSUMER_SERVICES_MISREPRESENTATION
                            CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                                Known.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                            CONSUMER_SERVICES_NOT_RECEIVED -> Known.CONSUMER_SERVICES_NOT_RECEIVED
                            FRAUD -> Known.FRAUD
                            PROCESSING_ERROR -> Known.PROCESSING_ERROR
                            else -> throw IncreaseInvalidDataException("Unknown Category: $value")
                        }

                    /**
                     * Returns this class instance's primitive wire representation.
                     *
                     * This differs from the [toString] method because that method is primarily for
                     * debugging and generally doesn't throw.
                     *
                     * @throws IncreaseInvalidDataException if this class instance's value does not
                     *   have the expected primitive type.
                     */
                    fun asString(): String =
                        _value().asString()
                            ?: throw IncreaseInvalidDataException("Value is not a String")

                    private var validated: Boolean = false

                    fun validate(): Category = apply {
                        if (validated) {
                            return@apply
                        }

                        known()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Category && value == other.value
                    }

                    override fun hashCode() = value.hashCode()

                    override fun toString() = value.toString()
                }

                /**
                 * Canceled merchandise. Present if and only if `category` is
                 * `consumer_canceled_merchandise`.
                 */
                class ConsumerCanceledMerchandise
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cardholderCancellation: JsonField<CardholderCancellation>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val notReturned: JsonValue,
                    private val purchaseExplanation: JsonField<String>,
                    private val receivedOrExpectedAt: JsonField<LocalDate>,
                    private val returnAttempted: JsonField<ReturnAttempted>,
                    private val returnOutcome: JsonField<ReturnOutcome>,
                    private val returned: JsonField<Returned>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cardholder_cancellation")
                        @ExcludeMissing
                        cardholderCancellation: JsonField<CardholderCancellation> =
                            JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("not_returned")
                        @ExcludeMissing
                        notReturned: JsonValue = JsonMissing.of(),
                        @JsonProperty("purchase_explanation")
                        @ExcludeMissing
                        purchaseExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("received_or_expected_at")
                        @ExcludeMissing
                        receivedOrExpectedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("return_attempted")
                        @ExcludeMissing
                        returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                        @JsonProperty("return_outcome")
                        @ExcludeMissing
                        returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                        @JsonProperty("returned")
                        @ExcludeMissing
                        returned: JsonField<Returned> = JsonMissing.of(),
                    ) : this(
                        cardholderCancellation,
                        merchantResolutionAttempted,
                        notReturned,
                        purchaseExplanation,
                        receivedOrExpectedAt,
                        returnAttempted,
                        returnOutcome,
                        returned,
                        mutableMapOf(),
                    )

                    /**
                     * Cardholder cancellation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun cardholderCancellation(): CardholderCancellation? =
                        cardholderCancellation.getNullable("cardholder_cancellation")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /** Not returned. Present if and only if `return_outcome` is `not_returned`. */
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    fun _notReturned(): JsonValue = notReturned

                    /**
                     * Purchase explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseExplanation(): String =
                        purchaseExplanation.getRequired("purchase_explanation")

                    /**
                     * Received or expected at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedOrExpectedAt(): LocalDate =
                        receivedOrExpectedAt.getRequired("received_or_expected_at")

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returnAttempted(): ReturnAttempted? =
                        returnAttempted.getNullable("return_attempted")

                    /**
                     * Return outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                    /**
                     * Returned. Present if and only if `return_outcome` is `returned`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returned(): Returned? = returned.getNullable("returned")

                    /**
                     * Returns the raw JSON value of [cardholderCancellation].
                     *
                     * Unlike [cardholderCancellation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                        cardholderCancellation

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [purchaseExplanation].
                     *
                     * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                    /**
                     * Returns the raw JSON value of [receivedOrExpectedAt].
                     *
                     * Unlike [receivedOrExpectedAt], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("received_or_expected_at")
                    @ExcludeMissing
                    fun _receivedOrExpectedAt(): JsonField<LocalDate> = receivedOrExpectedAt

                    /**
                     * Returns the raw JSON value of [returnAttempted].
                     *
                     * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                    /**
                     * Returns the raw JSON value of [returnOutcome].
                     *
                     * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                    /**
                     * Returns the raw JSON value of [returned].
                     *
                     * Unlike [returned], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned")
                    @ExcludeMissing
                    fun _returned(): JsonField<Returned> = returned

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerCanceledMerchandise].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .merchantResolutionAttempted()
                         * .notReturned()
                         * .purchaseExplanation()
                         * .receivedOrExpectedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerCanceledMerchandise]. */
                    class Builder internal constructor() {

                        private var cardholderCancellation: JsonField<CardholderCancellation>? =
                            null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var notReturned: JsonValue? = null
                        private var purchaseExplanation: JsonField<String>? = null
                        private var receivedOrExpectedAt: JsonField<LocalDate>? = null
                        private var returnAttempted: JsonField<ReturnAttempted>? = null
                        private var returnOutcome: JsonField<ReturnOutcome>? = null
                        private var returned: JsonField<Returned>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerCanceledMerchandise: ConsumerCanceledMerchandise
                        ) = apply {
                            cardholderCancellation =
                                consumerCanceledMerchandise.cardholderCancellation
                            merchantResolutionAttempted =
                                consumerCanceledMerchandise.merchantResolutionAttempted
                            notReturned = consumerCanceledMerchandise.notReturned
                            purchaseExplanation = consumerCanceledMerchandise.purchaseExplanation
                            receivedOrExpectedAt = consumerCanceledMerchandise.receivedOrExpectedAt
                            returnAttempted = consumerCanceledMerchandise.returnAttempted
                            returnOutcome = consumerCanceledMerchandise.returnOutcome
                            returned = consumerCanceledMerchandise.returned
                            additionalProperties =
                                consumerCanceledMerchandise.additionalProperties.toMutableMap()
                        }

                        /** Cardholder cancellation. */
                        fun cardholderCancellation(
                            cardholderCancellation: CardholderCancellation?
                        ) = cardholderCancellation(JsonField.ofNullable(cardholderCancellation))

                        /**
                         * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cardholderCancellation] with a
                         * well-typed [CardholderCancellation] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cardholderCancellation(
                            cardholderCancellation: JsonField<CardholderCancellation>
                        ) = apply { this.cardholderCancellation = cardholderCancellation }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /**
                         * Not returned. Present if and only if `return_outcome` is `not_returned`.
                         */
                        fun notReturned(notReturned: JsonValue) = apply {
                            this.notReturned = notReturned
                        }

                        /** Purchase explanation. */
                        fun purchaseExplanation(purchaseExplanation: String) =
                            purchaseExplanation(JsonField.of(purchaseExplanation))

                        /**
                         * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                            this.purchaseExplanation = purchaseExplanation
                        }

                        /** Received or expected at. */
                        fun receivedOrExpectedAt(receivedOrExpectedAt: LocalDate) =
                            receivedOrExpectedAt(JsonField.of(receivedOrExpectedAt))

                        /**
                         * Sets [Builder.receivedOrExpectedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedOrExpectedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedOrExpectedAt(receivedOrExpectedAt: JsonField<LocalDate>) =
                            apply {
                                this.receivedOrExpectedAt = receivedOrExpectedAt
                            }

                        /**
                         * Return attempted. Present if and only if `return_outcome` is
                         * `return_attempted`.
                         */
                        fun returnAttempted(returnAttempted: ReturnAttempted?) =
                            returnAttempted(JsonField.ofNullable(returnAttempted))

                        /**
                         * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnAttempted] with a well-typed
                         * [ReturnAttempted] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                            this.returnAttempted = returnAttempted
                        }

                        /** Return outcome. */
                        fun returnOutcome(returnOutcome: ReturnOutcome) =
                            returnOutcome(JsonField.of(returnOutcome))

                        /**
                         * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnOutcome] with a well-typed
                         * [ReturnOutcome] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                            this.returnOutcome = returnOutcome
                        }

                        /** Returned. Present if and only if `return_outcome` is `returned`. */
                        fun returned(returned: Returned?) = returned(JsonField.ofNullable(returned))

                        /**
                         * Sets [Builder.returned] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returned] with a well-typed [Returned]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun returned(returned: JsonField<Returned>) = apply {
                            this.returned = returned
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerCanceledMerchandise].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .merchantResolutionAttempted()
                         * .notReturned()
                         * .purchaseExplanation()
                         * .receivedOrExpectedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerCanceledMerchandise =
                            ConsumerCanceledMerchandise(
                                checkRequired("cardholderCancellation", cardholderCancellation),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("notReturned", notReturned),
                                checkRequired("purchaseExplanation", purchaseExplanation),
                                checkRequired("receivedOrExpectedAt", receivedOrExpectedAt),
                                checkRequired("returnAttempted", returnAttempted),
                                checkRequired("returnOutcome", returnOutcome),
                                checkRequired("returned", returned),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerCanceledMerchandise = apply {
                        if (validated) {
                            return@apply
                        }

                        cardholderCancellation()?.validate()
                        merchantResolutionAttempted().validate()
                        purchaseExplanation()
                        receivedOrExpectedAt()
                        returnAttempted()?.validate()
                        returnOutcome().validate()
                        returned()?.validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cardholderCancellation.asKnown()?.validity() ?: 0) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                            (if (receivedOrExpectedAt.asKnown() == null) 0 else 1) +
                            (returnAttempted.asKnown()?.validity() ?: 0) +
                            (returnOutcome.asKnown()?.validity() ?: 0) +
                            (returned.asKnown()?.validity() ?: 0)

                    /** Cardholder cancellation. */
                    class CardholderCancellation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val canceledAt: JsonField<LocalDate>,
                        private val canceledPriorToShipDate: JsonField<CanceledPriorToShipDate>,
                        private val cancellationPolicyProvided:
                            JsonField<CancellationPolicyProvided>,
                        private val reason: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("canceled_prior_to_ship_date")
                            @ExcludeMissing
                            canceledPriorToShipDate: JsonField<CanceledPriorToShipDate> =
                                JsonMissing.of(),
                            @JsonProperty("cancellation_policy_provided")
                            @ExcludeMissing
                            cancellationPolicyProvided: JsonField<CancellationPolicyProvided> =
                                JsonMissing.of(),
                            @JsonProperty("reason")
                            @ExcludeMissing
                            reason: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            canceledAt,
                            canceledPriorToShipDate,
                            cancellationPolicyProvided,
                            reason,
                            mutableMapOf(),
                        )

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Canceled prior to ship date.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledPriorToShipDate(): CanceledPriorToShipDate =
                            canceledPriorToShipDate.getRequired("canceled_prior_to_ship_date")

                        /**
                         * Cancellation policy provided.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun cancellationPolicyProvided(): CancellationPolicyProvided =
                            cancellationPolicyProvided.getRequired("cancellation_policy_provided")

                        /**
                         * Reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun reason(): String = reason.getRequired("reason")

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        /**
                         * Returns the raw JSON value of [canceledPriorToShipDate].
                         *
                         * Unlike [canceledPriorToShipDate], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("canceled_prior_to_ship_date")
                        @ExcludeMissing
                        fun _canceledPriorToShipDate(): JsonField<CanceledPriorToShipDate> =
                            canceledPriorToShipDate

                        /**
                         * Returns the raw JSON value of [cancellationPolicyProvided].
                         *
                         * Unlike [cancellationPolicyProvided], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("cancellation_policy_provided")
                        @ExcludeMissing
                        fun _cancellationPolicyProvided(): JsonField<CancellationPolicyProvided> =
                            cancellationPolicyProvided

                        /**
                         * Returns the raw JSON value of [reason].
                         *
                         * Unlike [reason], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("reason")
                        @ExcludeMissing
                        fun _reason(): JsonField<String> = reason

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [CardholderCancellation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .canceledPriorToShipDate()
                             * .cancellationPolicyProvided()
                             * .reason()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [CardholderCancellation]. */
                        class Builder internal constructor() {

                            private var canceledAt: JsonField<LocalDate>? = null
                            private var canceledPriorToShipDate:
                                JsonField<CanceledPriorToShipDate>? =
                                null
                            private var cancellationPolicyProvided:
                                JsonField<CancellationPolicyProvided>? =
                                null
                            private var reason: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(cardholderCancellation: CardholderCancellation) =
                                apply {
                                    canceledAt = cardholderCancellation.canceledAt
                                    canceledPriorToShipDate =
                                        cardholderCancellation.canceledPriorToShipDate
                                    cancellationPolicyProvided =
                                        cardholderCancellation.cancellationPolicyProvided
                                    reason = cardholderCancellation.reason
                                    additionalProperties =
                                        cardholderCancellation.additionalProperties.toMutableMap()
                                }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            /** Canceled prior to ship date. */
                            fun canceledPriorToShipDate(
                                canceledPriorToShipDate: CanceledPriorToShipDate
                            ) = canceledPriorToShipDate(JsonField.of(canceledPriorToShipDate))

                            /**
                             * Sets [Builder.canceledPriorToShipDate] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledPriorToShipDate] with a
                             * well-typed [CanceledPriorToShipDate] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun canceledPriorToShipDate(
                                canceledPriorToShipDate: JsonField<CanceledPriorToShipDate>
                            ) = apply { this.canceledPriorToShipDate = canceledPriorToShipDate }

                            /** Cancellation policy provided. */
                            fun cancellationPolicyProvided(
                                cancellationPolicyProvided: CancellationPolicyProvided
                            ) = cancellationPolicyProvided(JsonField.of(cancellationPolicyProvided))

                            /**
                             * Sets [Builder.cancellationPolicyProvided] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.cancellationPolicyProvided] with a
                             * well-typed [CancellationPolicyProvided] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun cancellationPolicyProvided(
                                cancellationPolicyProvided: JsonField<CancellationPolicyProvided>
                            ) = apply {
                                this.cancellationPolicyProvided = cancellationPolicyProvided
                            }

                            /** Reason. */
                            fun reason(reason: String) = reason(JsonField.of(reason))

                            /**
                             * Sets [Builder.reason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.reason] with a well-typed [String]
                             * value instead. This method is primarily for setting the field to an
                             * undocumented or not yet supported value.
                             */
                            fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [CardholderCancellation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .canceledPriorToShipDate()
                             * .cancellationPolicyProvided()
                             * .reason()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): CardholderCancellation =
                                CardholderCancellation(
                                    checkRequired("canceledAt", canceledAt),
                                    checkRequired(
                                        "canceledPriorToShipDate",
                                        canceledPriorToShipDate,
                                    ),
                                    checkRequired(
                                        "cancellationPolicyProvided",
                                        cancellationPolicyProvided,
                                    ),
                                    checkRequired("reason", reason),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): CardholderCancellation = apply {
                            if (validated) {
                                return@apply
                            }

                            canceledAt()
                            canceledPriorToShipDate().validate()
                            cancellationPolicyProvided().validate()
                            reason()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (canceledAt.asKnown() == null) 0 else 1) +
                                (canceledPriorToShipDate.asKnown()?.validity() ?: 0) +
                                (cancellationPolicyProvided.asKnown()?.validity() ?: 0) +
                                (if (reason.asKnown() == null) 0 else 1)

                        /** Canceled prior to ship date. */
                        class CanceledPriorToShipDate
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Canceled prior to ship date. */
                                val CANCELED_PRIOR_TO_SHIP_DATE = of("canceled_prior_to_ship_date")

                                /** Not canceled prior to ship date. */
                                val NOT_CANCELED_PRIOR_TO_SHIP_DATE =
                                    of("not_canceled_prior_to_ship_date")

                                fun of(value: String) = CanceledPriorToShipDate(JsonField.of(value))
                            }

                            /** An enum containing [CanceledPriorToShipDate]'s known values. */
                            enum class Known {
                                /** Canceled prior to ship date. */
                                CANCELED_PRIOR_TO_SHIP_DATE,
                                /** Not canceled prior to ship date. */
                                NOT_CANCELED_PRIOR_TO_SHIP_DATE,
                            }

                            /**
                             * An enum containing [CanceledPriorToShipDate]'s known values, as well
                             * as an [_UNKNOWN] member.
                             *
                             * An instance of [CanceledPriorToShipDate] can contain an unknown value
                             * in a couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Canceled prior to ship date. */
                                CANCELED_PRIOR_TO_SHIP_DATE,
                                /** Not canceled prior to ship date. */
                                NOT_CANCELED_PRIOR_TO_SHIP_DATE,
                                /**
                                 * An enum member indicating that [CanceledPriorToShipDate] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    CANCELED_PRIOR_TO_SHIP_DATE -> Value.CANCELED_PRIOR_TO_SHIP_DATE
                                    NOT_CANCELED_PRIOR_TO_SHIP_DATE ->
                                        Value.NOT_CANCELED_PRIOR_TO_SHIP_DATE
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    CANCELED_PRIOR_TO_SHIP_DATE -> Known.CANCELED_PRIOR_TO_SHIP_DATE
                                    NOT_CANCELED_PRIOR_TO_SHIP_DATE ->
                                        Known.NOT_CANCELED_PRIOR_TO_SHIP_DATE
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown CanceledPriorToShipDate: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): CanceledPriorToShipDate = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is CanceledPriorToShipDate && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        /** Cancellation policy provided. */
                        class CancellationPolicyProvided
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Not provided. */
                                val NOT_PROVIDED = of("not_provided")

                                /** Provided. */
                                val PROVIDED = of("provided")

                                fun of(value: String) =
                                    CancellationPolicyProvided(JsonField.of(value))
                            }

                            /** An enum containing [CancellationPolicyProvided]'s known values. */
                            enum class Known {
                                /** Not provided. */
                                NOT_PROVIDED,
                                /** Provided. */
                                PROVIDED,
                            }

                            /**
                             * An enum containing [CancellationPolicyProvided]'s known values, as
                             * well as an [_UNKNOWN] member.
                             *
                             * An instance of [CancellationPolicyProvided] can contain an unknown
                             * value in a couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Not provided. */
                                NOT_PROVIDED,
                                /** Provided. */
                                PROVIDED,
                                /**
                                 * An enum member indicating that [CancellationPolicyProvided] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    NOT_PROVIDED -> Value.NOT_PROVIDED
                                    PROVIDED -> Value.PROVIDED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    NOT_PROVIDED -> Known.NOT_PROVIDED
                                    PROVIDED -> Known.PROVIDED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown CancellationPolicyProvided: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): CancellationPolicyProvided = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is CancellationPolicyProvided && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderCancellation &&
                                canceledAt == other.canceledAt &&
                                canceledPriorToShipDate == other.canceledPriorToShipDate &&
                                cancellationPolicyProvided == other.cancellationPolicyProvided &&
                                reason == other.reason &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                canceledAt,
                                canceledPriorToShipDate,
                                cancellationPolicyProvided,
                                reason,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "CardholderCancellation{canceledAt=$canceledAt, canceledPriorToShipDate=$canceledPriorToShipDate, cancellationPolicyProvided=$cancellationPolicyProvided, reason=$reason, additionalProperties=$additionalProperties}"
                    }

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    class ReturnAttempted
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val attemptExplanation: JsonField<String>,
                        private val attemptReason: JsonField<AttemptReason>,
                        private val attemptedAt: JsonField<LocalDate>,
                        private val merchandiseDisposition: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("attempt_explanation")
                            @ExcludeMissing
                            attemptExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("attempt_reason")
                            @ExcludeMissing
                            attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                            @JsonProperty("attempted_at")
                            @ExcludeMissing
                            attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("merchandise_disposition")
                            @ExcludeMissing
                            merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            mutableMapOf(),
                        )

                        /**
                         * Attempt explanation.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptExplanation(): String =
                            attemptExplanation.getRequired("attempt_explanation")

                        /**
                         * Attempt reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptReason(): AttemptReason =
                            attemptReason.getRequired("attempt_reason")

                        /**
                         * Attempted at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                        /**
                         * Merchandise disposition.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun merchandiseDisposition(): String =
                            merchandiseDisposition.getRequired("merchandise_disposition")

                        /**
                         * Returns the raw JSON value of [attemptExplanation].
                         *
                         * Unlike [attemptExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        fun _attemptExplanation(): JsonField<String> = attemptExplanation

                        /**
                         * Returns the raw JSON value of [attemptReason].
                         *
                         * Unlike [attemptReason], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                        /**
                         * Returns the raw JSON value of [attemptedAt].
                         *
                         * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                        /**
                         * Returns the raw JSON value of [merchandiseDisposition].
                         *
                         * Unlike [merchandiseDisposition], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [ReturnAttempted].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [ReturnAttempted]. */
                        class Builder internal constructor() {

                            private var attemptExplanation: JsonField<String>? = null
                            private var attemptReason: JsonField<AttemptReason>? = null
                            private var attemptedAt: JsonField<LocalDate>? = null
                            private var merchandiseDisposition: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returnAttempted: ReturnAttempted) = apply {
                                attemptExplanation = returnAttempted.attemptExplanation
                                attemptReason = returnAttempted.attemptReason
                                attemptedAt = returnAttempted.attemptedAt
                                merchandiseDisposition = returnAttempted.merchandiseDisposition
                                additionalProperties =
                                    returnAttempted.additionalProperties.toMutableMap()
                            }

                            /** Attempt explanation. */
                            fun attemptExplanation(attemptExplanation: String) =
                                attemptExplanation(JsonField.of(attemptExplanation))

                            /**
                             * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptExplanation] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                                this.attemptExplanation = attemptExplanation
                            }

                            /** Attempt reason. */
                            fun attemptReason(attemptReason: AttemptReason) =
                                attemptReason(JsonField.of(attemptReason))

                            /**
                             * Sets [Builder.attemptReason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptReason] with a well-typed
                             * [AttemptReason] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                                this.attemptReason = attemptReason
                            }

                            /** Attempted at. */
                            fun attemptedAt(attemptedAt: LocalDate) =
                                attemptedAt(JsonField.of(attemptedAt))

                            /**
                             * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                                this.attemptedAt = attemptedAt
                            }

                            /** Merchandise disposition. */
                            fun merchandiseDisposition(merchandiseDisposition: String) =
                                merchandiseDisposition(JsonField.of(merchandiseDisposition))

                            /**
                             * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchandiseDisposition] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                                apply {
                                    this.merchandiseDisposition = merchandiseDisposition
                                }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [ReturnAttempted].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): ReturnAttempted =
                                ReturnAttempted(
                                    checkRequired("attemptExplanation", attemptExplanation),
                                    checkRequired("attemptReason", attemptReason),
                                    checkRequired("attemptedAt", attemptedAt),
                                    checkRequired("merchandiseDisposition", merchandiseDisposition),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): ReturnAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            attemptExplanation()
                            attemptReason().validate()
                            attemptedAt()
                            merchandiseDisposition()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (attemptExplanation.asKnown() == null) 0 else 1) +
                                (attemptReason.asKnown()?.validity() ?: 0) +
                                (if (attemptedAt.asKnown() == null) 0 else 1) +
                                (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                        /** Attempt reason. */
                        class AttemptReason
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Merchant not responding. */
                                val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                                /** No return authorization provided. */
                                val NO_RETURN_AUTHORIZATION_PROVIDED =
                                    of("no_return_authorization_provided")

                                /** No return instructions. */
                                val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                                /** Requested not to return. */
                                val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                                /** Return not accepted. */
                                val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                                fun of(value: String) = AttemptReason(JsonField.of(value))
                            }

                            /** An enum containing [AttemptReason]'s known values. */
                            enum class Known {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AttemptReason]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AttemptReason] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AttemptReason] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AttemptReason: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AttemptReason = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AttemptReason && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnAttempted &&
                                attemptExplanation == other.attemptExplanation &&
                                attemptReason == other.attemptReason &&
                                attemptedAt == other.attemptedAt &&
                                merchandiseDisposition == other.merchandiseDisposition &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                attemptExplanation,
                                attemptReason,
                                attemptedAt,
                                merchandiseDisposition,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                    }

                    /** Return outcome. */
                    class ReturnOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not returned. */
                            val NOT_RETURNED = of("not_returned")

                            /** Returned. */
                            val RETURNED = of("returned")

                            /** Return attempted. */
                            val RETURN_ATTEMPTED = of("return_attempted")

                            fun of(value: String) = ReturnOutcome(JsonField.of(value))
                        }

                        /** An enum containing [ReturnOutcome]'s known values. */
                        enum class Known {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                        }

                        /**
                         * An enum containing [ReturnOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnOutcome] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                            /**
                             * An enum member indicating that [ReturnOutcome] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_RETURNED -> Value.NOT_RETURNED
                                RETURNED -> Value.RETURNED
                                RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_RETURNED -> Known.NOT_RETURNED
                                RETURNED -> Known.RETURNED
                                RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Returned. Present if and only if `return_outcome` is `returned`. */
                    class Returned
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val merchantReceivedReturnAt: JsonField<LocalDate>,
                        private val otherExplanation: JsonField<String>,
                        private val returnMethod: JsonField<ReturnMethod>,
                        private val returnedAt: JsonField<LocalDate>,
                        private val trackingNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("merchant_received_return_at")
                            @ExcludeMissing
                            merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("other_explanation")
                            @ExcludeMissing
                            otherExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("return_method")
                            @ExcludeMissing
                            returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                            @JsonProperty("returned_at")
                            @ExcludeMissing
                            returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("tracking_number")
                            @ExcludeMissing
                            trackingNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            merchantReceivedReturnAt,
                            otherExplanation,
                            returnMethod,
                            returnedAt,
                            trackingNumber,
                            mutableMapOf(),
                        )

                        /**
                         * Merchant received return at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun merchantReceivedReturnAt(): LocalDate? =
                            merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun otherExplanation(): String? =
                            otherExplanation.getNullable("other_explanation")

                        /**
                         * Return method.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                        /**
                         * Returned at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                        /**
                         * Tracking number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun trackingNumber(): String? =
                            trackingNumber.getNullable("tracking_number")

                        /**
                         * Returns the raw JSON value of [merchantReceivedReturnAt].
                         *
                         * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        fun _merchantReceivedReturnAt(): JsonField<LocalDate> =
                            merchantReceivedReturnAt

                        /**
                         * Returns the raw JSON value of [otherExplanation].
                         *
                         * Unlike [otherExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        fun _otherExplanation(): JsonField<String> = otherExplanation

                        /**
                         * Returns the raw JSON value of [returnMethod].
                         *
                         * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                        /**
                         * Returns the raw JSON value of [returnedAt].
                         *
                         * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        fun _returnedAt(): JsonField<LocalDate> = returnedAt

                        /**
                         * Returns the raw JSON value of [trackingNumber].
                         *
                         * Unlike [trackingNumber], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        fun _trackingNumber(): JsonField<String> = trackingNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Returned].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Returned]. */
                        class Builder internal constructor() {

                            private var merchantReceivedReturnAt: JsonField<LocalDate>? = null
                            private var otherExplanation: JsonField<String>? = null
                            private var returnMethod: JsonField<ReturnMethod>? = null
                            private var returnedAt: JsonField<LocalDate>? = null
                            private var trackingNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returned: Returned) = apply {
                                merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                                otherExplanation = returned.otherExplanation
                                returnMethod = returned.returnMethod
                                returnedAt = returned.returnedAt
                                trackingNumber = returned.trackingNumber
                                additionalProperties = returned.additionalProperties.toMutableMap()
                            }

                            /** Merchant received return at. */
                            fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate?) =
                                merchantReceivedReturnAt(
                                    JsonField.ofNullable(merchantReceivedReturnAt)
                                )

                            /**
                             * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchantReceivedReturnAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchantReceivedReturnAt(
                                merchantReceivedReturnAt: JsonField<LocalDate>
                            ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                            /**
                             * Other explanation. Required if and only if the return method is
                             * `other`.
                             */
                            fun otherExplanation(otherExplanation: String?) =
                                otherExplanation(JsonField.ofNullable(otherExplanation))

                            /**
                             * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherExplanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                                this.otherExplanation = otherExplanation
                            }

                            /** Return method. */
                            fun returnMethod(returnMethod: ReturnMethod) =
                                returnMethod(JsonField.of(returnMethod))

                            /**
                             * Sets [Builder.returnMethod] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnMethod] with a well-typed
                             * [ReturnMethod] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                                this.returnMethod = returnMethod
                            }

                            /** Returned at. */
                            fun returnedAt(returnedAt: LocalDate) =
                                returnedAt(JsonField.of(returnedAt))

                            /**
                             * Sets [Builder.returnedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                                this.returnedAt = returnedAt
                            }

                            /** Tracking number. */
                            fun trackingNumber(trackingNumber: String?) =
                                trackingNumber(JsonField.ofNullable(trackingNumber))

                            /**
                             * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.trackingNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                                this.trackingNumber = trackingNumber
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Returned].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Returned =
                                Returned(
                                    checkRequired(
                                        "merchantReceivedReturnAt",
                                        merchantReceivedReturnAt,
                                    ),
                                    checkRequired("otherExplanation", otherExplanation),
                                    checkRequired("returnMethod", returnMethod),
                                    checkRequired("returnedAt", returnedAt),
                                    checkRequired("trackingNumber", trackingNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Returned = apply {
                            if (validated) {
                                return@apply
                            }

                            merchantReceivedReturnAt()
                            otherExplanation()
                            returnMethod().validate()
                            returnedAt()
                            trackingNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                                (if (otherExplanation.asKnown() == null) 0 else 1) +
                                (returnMethod.asKnown()?.validity() ?: 0) +
                                (if (returnedAt.asKnown() == null) 0 else 1) +
                                (if (trackingNumber.asKnown() == null) 0 else 1)

                        /** Return method. */
                        class ReturnMethod
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** DHL. */
                                val DHL = of("dhl")

                                /** Face-to-face. */
                                val FACE_TO_FACE = of("face_to_face")

                                /** FedEx. */
                                val FEDEX = of("fedex")

                                /** Other. */
                                val OTHER = of("other")

                                /** Postal service. */
                                val POSTAL_SERVICE = of("postal_service")

                                /** UPS. */
                                val UPS = of("ups")

                                fun of(value: String) = ReturnMethod(JsonField.of(value))
                            }

                            /** An enum containing [ReturnMethod]'s known values. */
                            enum class Known {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                            }

                            /**
                             * An enum containing [ReturnMethod]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [ReturnMethod] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                                /**
                                 * An enum member indicating that [ReturnMethod] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    DHL -> Value.DHL
                                    FACE_TO_FACE -> Value.FACE_TO_FACE
                                    FEDEX -> Value.FEDEX
                                    OTHER -> Value.OTHER
                                    POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                    UPS -> Value.UPS
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    DHL -> Known.DHL
                                    FACE_TO_FACE -> Known.FACE_TO_FACE
                                    FEDEX -> Known.FEDEX
                                    OTHER -> Known.OTHER
                                    POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                    UPS -> Known.UPS
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown ReturnMethod: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): ReturnMethod = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is ReturnMethod && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Returned &&
                                merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                                otherExplanation == other.otherExplanation &&
                                returnMethod == other.returnMethod &&
                                returnedAt == other.returnedAt &&
                                trackingNumber == other.trackingNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                merchantReceivedReturnAt,
                                otherExplanation,
                                returnMethod,
                                returnedAt,
                                trackingNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Returned{merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, returnMethod=$returnMethod, returnedAt=$returnedAt, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerCanceledMerchandise &&
                            cardholderCancellation == other.cardholderCancellation &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            notReturned == other.notReturned &&
                            purchaseExplanation == other.purchaseExplanation &&
                            receivedOrExpectedAt == other.receivedOrExpectedAt &&
                            returnAttempted == other.returnAttempted &&
                            returnOutcome == other.returnOutcome &&
                            returned == other.returned &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cardholderCancellation,
                            merchantResolutionAttempted,
                            notReturned,
                            purchaseExplanation,
                            receivedOrExpectedAt,
                            returnAttempted,
                            returnOutcome,
                            returned,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerCanceledMerchandise{cardholderCancellation=$cardholderCancellation, merchantResolutionAttempted=$merchantResolutionAttempted, notReturned=$notReturned, purchaseExplanation=$purchaseExplanation, receivedOrExpectedAt=$receivedOrExpectedAt, returnAttempted=$returnAttempted, returnOutcome=$returnOutcome, returned=$returned, additionalProperties=$additionalProperties}"
                }

                /**
                 * Canceled recurring transaction. Present if and only if `category` is
                 * `consumer_canceled_recurring_transaction`.
                 */
                class ConsumerCanceledRecurringTransaction
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cancellationTarget: JsonField<CancellationTarget>,
                    private val merchantContactMethods: JsonField<MerchantContactMethods>,
                    private val otherFormOfPaymentExplanation: JsonField<String>,
                    private val transactionOrAccountCanceledAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cancellation_target")
                        @ExcludeMissing
                        cancellationTarget: JsonField<CancellationTarget> = JsonMissing.of(),
                        @JsonProperty("merchant_contact_methods")
                        @ExcludeMissing
                        merchantContactMethods: JsonField<MerchantContactMethods> =
                            JsonMissing.of(),
                        @JsonProperty("other_form_of_payment_explanation")
                        @ExcludeMissing
                        otherFormOfPaymentExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("transaction_or_account_canceled_at")
                        @ExcludeMissing
                        transactionOrAccountCanceledAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(
                        cancellationTarget,
                        merchantContactMethods,
                        otherFormOfPaymentExplanation,
                        transactionOrAccountCanceledAt,
                        mutableMapOf(),
                    )

                    /**
                     * Cancellation target.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cancellationTarget(): CancellationTarget =
                        cancellationTarget.getRequired("cancellation_target")

                    /**
                     * Merchant contact methods.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantContactMethods(): MerchantContactMethods =
                        merchantContactMethods.getRequired("merchant_contact_methods")

                    /**
                     * Other form of payment explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun otherFormOfPaymentExplanation(): String? =
                        otherFormOfPaymentExplanation.getNullable(
                            "other_form_of_payment_explanation"
                        )

                    /**
                     * Transaction or account canceled at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun transactionOrAccountCanceledAt(): LocalDate =
                        transactionOrAccountCanceledAt.getRequired(
                            "transaction_or_account_canceled_at"
                        )

                    /**
                     * Returns the raw JSON value of [cancellationTarget].
                     *
                     * Unlike [cancellationTarget], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("cancellation_target")
                    @ExcludeMissing
                    fun _cancellationTarget(): JsonField<CancellationTarget> = cancellationTarget

                    /**
                     * Returns the raw JSON value of [merchantContactMethods].
                     *
                     * Unlike [merchantContactMethods], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchant_contact_methods")
                    @ExcludeMissing
                    fun _merchantContactMethods(): JsonField<MerchantContactMethods> =
                        merchantContactMethods

                    /**
                     * Returns the raw JSON value of [otherFormOfPaymentExplanation].
                     *
                     * Unlike [otherFormOfPaymentExplanation], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("other_form_of_payment_explanation")
                    @ExcludeMissing
                    fun _otherFormOfPaymentExplanation(): JsonField<String> =
                        otherFormOfPaymentExplanation

                    /**
                     * Returns the raw JSON value of [transactionOrAccountCanceledAt].
                     *
                     * Unlike [transactionOrAccountCanceledAt], this method doesn't throw if the
                     * JSON field has an unexpected type.
                     */
                    @JsonProperty("transaction_or_account_canceled_at")
                    @ExcludeMissing
                    fun _transactionOrAccountCanceledAt(): JsonField<LocalDate> =
                        transactionOrAccountCanceledAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerCanceledRecurringTransaction].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cancellationTarget()
                         * .merchantContactMethods()
                         * .otherFormOfPaymentExplanation()
                         * .transactionOrAccountCanceledAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerCanceledRecurringTransaction]. */
                    class Builder internal constructor() {

                        private var cancellationTarget: JsonField<CancellationTarget>? = null
                        private var merchantContactMethods: JsonField<MerchantContactMethods>? =
                            null
                        private var otherFormOfPaymentExplanation: JsonField<String>? = null
                        private var transactionOrAccountCanceledAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerCanceledRecurringTransaction:
                                ConsumerCanceledRecurringTransaction
                        ) = apply {
                            cancellationTarget =
                                consumerCanceledRecurringTransaction.cancellationTarget
                            merchantContactMethods =
                                consumerCanceledRecurringTransaction.merchantContactMethods
                            otherFormOfPaymentExplanation =
                                consumerCanceledRecurringTransaction.otherFormOfPaymentExplanation
                            transactionOrAccountCanceledAt =
                                consumerCanceledRecurringTransaction.transactionOrAccountCanceledAt
                            additionalProperties =
                                consumerCanceledRecurringTransaction.additionalProperties
                                    .toMutableMap()
                        }

                        /** Cancellation target. */
                        fun cancellationTarget(cancellationTarget: CancellationTarget) =
                            cancellationTarget(JsonField.of(cancellationTarget))

                        /**
                         * Sets [Builder.cancellationTarget] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cancellationTarget] with a well-typed
                         * [CancellationTarget] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun cancellationTarget(cancellationTarget: JsonField<CancellationTarget>) =
                            apply {
                                this.cancellationTarget = cancellationTarget
                            }

                        /** Merchant contact methods. */
                        fun merchantContactMethods(merchantContactMethods: MerchantContactMethods) =
                            merchantContactMethods(JsonField.of(merchantContactMethods))

                        /**
                         * Sets [Builder.merchantContactMethods] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantContactMethods] with a
                         * well-typed [MerchantContactMethods] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantContactMethods(
                            merchantContactMethods: JsonField<MerchantContactMethods>
                        ) = apply { this.merchantContactMethods = merchantContactMethods }

                        /** Other form of payment explanation. */
                        fun otherFormOfPaymentExplanation(otherFormOfPaymentExplanation: String?) =
                            otherFormOfPaymentExplanation(
                                JsonField.ofNullable(otherFormOfPaymentExplanation)
                            )

                        /**
                         * Sets [Builder.otherFormOfPaymentExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.otherFormOfPaymentExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun otherFormOfPaymentExplanation(
                            otherFormOfPaymentExplanation: JsonField<String>
                        ) = apply {
                            this.otherFormOfPaymentExplanation = otherFormOfPaymentExplanation
                        }

                        /** Transaction or account canceled at. */
                        fun transactionOrAccountCanceledAt(
                            transactionOrAccountCanceledAt: LocalDate
                        ) =
                            transactionOrAccountCanceledAt(
                                JsonField.of(transactionOrAccountCanceledAt)
                            )

                        /**
                         * Sets [Builder.transactionOrAccountCanceledAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.transactionOrAccountCanceledAt] with a
                         * well-typed [LocalDate] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun transactionOrAccountCanceledAt(
                            transactionOrAccountCanceledAt: JsonField<LocalDate>
                        ) = apply {
                            this.transactionOrAccountCanceledAt = transactionOrAccountCanceledAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerCanceledRecurringTransaction].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cancellationTarget()
                         * .merchantContactMethods()
                         * .otherFormOfPaymentExplanation()
                         * .transactionOrAccountCanceledAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerCanceledRecurringTransaction =
                            ConsumerCanceledRecurringTransaction(
                                checkRequired("cancellationTarget", cancellationTarget),
                                checkRequired("merchantContactMethods", merchantContactMethods),
                                checkRequired(
                                    "otherFormOfPaymentExplanation",
                                    otherFormOfPaymentExplanation,
                                ),
                                checkRequired(
                                    "transactionOrAccountCanceledAt",
                                    transactionOrAccountCanceledAt,
                                ),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerCanceledRecurringTransaction = apply {
                        if (validated) {
                            return@apply
                        }

                        cancellationTarget().validate()
                        merchantContactMethods().validate()
                        otherFormOfPaymentExplanation()
                        transactionOrAccountCanceledAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cancellationTarget.asKnown()?.validity() ?: 0) +
                            (merchantContactMethods.asKnown()?.validity() ?: 0) +
                            (if (otherFormOfPaymentExplanation.asKnown() == null) 0 else 1) +
                            (if (transactionOrAccountCanceledAt.asKnown() == null) 0 else 1)

                    /** Cancellation target. */
                    class CancellationTarget
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Account. */
                            val ACCOUNT = of("account")

                            /** Transaction. */
                            val TRANSACTION = of("transaction")

                            fun of(value: String) = CancellationTarget(JsonField.of(value))
                        }

                        /** An enum containing [CancellationTarget]'s known values. */
                        enum class Known {
                            /** Account. */
                            ACCOUNT,
                            /** Transaction. */
                            TRANSACTION,
                        }

                        /**
                         * An enum containing [CancellationTarget]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [CancellationTarget] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Account. */
                            ACCOUNT,
                            /** Transaction. */
                            TRANSACTION,
                            /**
                             * An enum member indicating that [CancellationTarget] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ACCOUNT -> Value.ACCOUNT
                                TRANSACTION -> Value.TRANSACTION
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ACCOUNT -> Known.ACCOUNT
                                TRANSACTION -> Known.TRANSACTION
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CancellationTarget: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CancellationTarget = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CancellationTarget && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Merchant contact methods. */
                    class MerchantContactMethods
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val applicationName: JsonField<String>,
                        private val callCenterPhoneNumber: JsonField<String>,
                        private val emailAddress: JsonField<String>,
                        private val inPersonAddress: JsonField<String>,
                        private val mailingAddress: JsonField<String>,
                        private val textPhoneNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("application_name")
                            @ExcludeMissing
                            applicationName: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("call_center_phone_number")
                            @ExcludeMissing
                            callCenterPhoneNumber: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("email_address")
                            @ExcludeMissing
                            emailAddress: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("in_person_address")
                            @ExcludeMissing
                            inPersonAddress: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("mailing_address")
                            @ExcludeMissing
                            mailingAddress: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("text_phone_number")
                            @ExcludeMissing
                            textPhoneNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            applicationName,
                            callCenterPhoneNumber,
                            emailAddress,
                            inPersonAddress,
                            mailingAddress,
                            textPhoneNumber,
                            mutableMapOf(),
                        )

                        /**
                         * Application name.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun applicationName(): String? =
                            applicationName.getNullable("application_name")

                        /**
                         * Call center phone number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun callCenterPhoneNumber(): String? =
                            callCenterPhoneNumber.getNullable("call_center_phone_number")

                        /**
                         * Email address.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun emailAddress(): String? = emailAddress.getNullable("email_address")

                        /**
                         * In person address.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun inPersonAddress(): String? =
                            inPersonAddress.getNullable("in_person_address")

                        /**
                         * Mailing address.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun mailingAddress(): String? =
                            mailingAddress.getNullable("mailing_address")

                        /**
                         * Text phone number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun textPhoneNumber(): String? =
                            textPhoneNumber.getNullable("text_phone_number")

                        /**
                         * Returns the raw JSON value of [applicationName].
                         *
                         * Unlike [applicationName], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("application_name")
                        @ExcludeMissing
                        fun _applicationName(): JsonField<String> = applicationName

                        /**
                         * Returns the raw JSON value of [callCenterPhoneNumber].
                         *
                         * Unlike [callCenterPhoneNumber], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("call_center_phone_number")
                        @ExcludeMissing
                        fun _callCenterPhoneNumber(): JsonField<String> = callCenterPhoneNumber

                        /**
                         * Returns the raw JSON value of [emailAddress].
                         *
                         * Unlike [emailAddress], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("email_address")
                        @ExcludeMissing
                        fun _emailAddress(): JsonField<String> = emailAddress

                        /**
                         * Returns the raw JSON value of [inPersonAddress].
                         *
                         * Unlike [inPersonAddress], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("in_person_address")
                        @ExcludeMissing
                        fun _inPersonAddress(): JsonField<String> = inPersonAddress

                        /**
                         * Returns the raw JSON value of [mailingAddress].
                         *
                         * Unlike [mailingAddress], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("mailing_address")
                        @ExcludeMissing
                        fun _mailingAddress(): JsonField<String> = mailingAddress

                        /**
                         * Returns the raw JSON value of [textPhoneNumber].
                         *
                         * Unlike [textPhoneNumber], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("text_phone_number")
                        @ExcludeMissing
                        fun _textPhoneNumber(): JsonField<String> = textPhoneNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [MerchantContactMethods].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .applicationName()
                             * .callCenterPhoneNumber()
                             * .emailAddress()
                             * .inPersonAddress()
                             * .mailingAddress()
                             * .textPhoneNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [MerchantContactMethods]. */
                        class Builder internal constructor() {

                            private var applicationName: JsonField<String>? = null
                            private var callCenterPhoneNumber: JsonField<String>? = null
                            private var emailAddress: JsonField<String>? = null
                            private var inPersonAddress: JsonField<String>? = null
                            private var mailingAddress: JsonField<String>? = null
                            private var textPhoneNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(merchantContactMethods: MerchantContactMethods) =
                                apply {
                                    applicationName = merchantContactMethods.applicationName
                                    callCenterPhoneNumber =
                                        merchantContactMethods.callCenterPhoneNumber
                                    emailAddress = merchantContactMethods.emailAddress
                                    inPersonAddress = merchantContactMethods.inPersonAddress
                                    mailingAddress = merchantContactMethods.mailingAddress
                                    textPhoneNumber = merchantContactMethods.textPhoneNumber
                                    additionalProperties =
                                        merchantContactMethods.additionalProperties.toMutableMap()
                                }

                            /** Application name. */
                            fun applicationName(applicationName: String?) =
                                applicationName(JsonField.ofNullable(applicationName))

                            /**
                             * Sets [Builder.applicationName] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.applicationName] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun applicationName(applicationName: JsonField<String>) = apply {
                                this.applicationName = applicationName
                            }

                            /** Call center phone number. */
                            fun callCenterPhoneNumber(callCenterPhoneNumber: String?) =
                                callCenterPhoneNumber(JsonField.ofNullable(callCenterPhoneNumber))

                            /**
                             * Sets [Builder.callCenterPhoneNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.callCenterPhoneNumber] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun callCenterPhoneNumber(callCenterPhoneNumber: JsonField<String>) =
                                apply {
                                    this.callCenterPhoneNumber = callCenterPhoneNumber
                                }

                            /** Email address. */
                            fun emailAddress(emailAddress: String?) =
                                emailAddress(JsonField.ofNullable(emailAddress))

                            /**
                             * Sets [Builder.emailAddress] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.emailAddress] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun emailAddress(emailAddress: JsonField<String>) = apply {
                                this.emailAddress = emailAddress
                            }

                            /** In person address. */
                            fun inPersonAddress(inPersonAddress: String?) =
                                inPersonAddress(JsonField.ofNullable(inPersonAddress))

                            /**
                             * Sets [Builder.inPersonAddress] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.inPersonAddress] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun inPersonAddress(inPersonAddress: JsonField<String>) = apply {
                                this.inPersonAddress = inPersonAddress
                            }

                            /** Mailing address. */
                            fun mailingAddress(mailingAddress: String?) =
                                mailingAddress(JsonField.ofNullable(mailingAddress))

                            /**
                             * Sets [Builder.mailingAddress] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.mailingAddress] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun mailingAddress(mailingAddress: JsonField<String>) = apply {
                                this.mailingAddress = mailingAddress
                            }

                            /** Text phone number. */
                            fun textPhoneNumber(textPhoneNumber: String?) =
                                textPhoneNumber(JsonField.ofNullable(textPhoneNumber))

                            /**
                             * Sets [Builder.textPhoneNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.textPhoneNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun textPhoneNumber(textPhoneNumber: JsonField<String>) = apply {
                                this.textPhoneNumber = textPhoneNumber
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [MerchantContactMethods].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .applicationName()
                             * .callCenterPhoneNumber()
                             * .emailAddress()
                             * .inPersonAddress()
                             * .mailingAddress()
                             * .textPhoneNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): MerchantContactMethods =
                                MerchantContactMethods(
                                    checkRequired("applicationName", applicationName),
                                    checkRequired("callCenterPhoneNumber", callCenterPhoneNumber),
                                    checkRequired("emailAddress", emailAddress),
                                    checkRequired("inPersonAddress", inPersonAddress),
                                    checkRequired("mailingAddress", mailingAddress),
                                    checkRequired("textPhoneNumber", textPhoneNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): MerchantContactMethods = apply {
                            if (validated) {
                                return@apply
                            }

                            applicationName()
                            callCenterPhoneNumber()
                            emailAddress()
                            inPersonAddress()
                            mailingAddress()
                            textPhoneNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (applicationName.asKnown() == null) 0 else 1) +
                                (if (callCenterPhoneNumber.asKnown() == null) 0 else 1) +
                                (if (emailAddress.asKnown() == null) 0 else 1) +
                                (if (inPersonAddress.asKnown() == null) 0 else 1) +
                                (if (mailingAddress.asKnown() == null) 0 else 1) +
                                (if (textPhoneNumber.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantContactMethods &&
                                applicationName == other.applicationName &&
                                callCenterPhoneNumber == other.callCenterPhoneNumber &&
                                emailAddress == other.emailAddress &&
                                inPersonAddress == other.inPersonAddress &&
                                mailingAddress == other.mailingAddress &&
                                textPhoneNumber == other.textPhoneNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                applicationName,
                                callCenterPhoneNumber,
                                emailAddress,
                                inPersonAddress,
                                mailingAddress,
                                textPhoneNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "MerchantContactMethods{applicationName=$applicationName, callCenterPhoneNumber=$callCenterPhoneNumber, emailAddress=$emailAddress, inPersonAddress=$inPersonAddress, mailingAddress=$mailingAddress, textPhoneNumber=$textPhoneNumber, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerCanceledRecurringTransaction &&
                            cancellationTarget == other.cancellationTarget &&
                            merchantContactMethods == other.merchantContactMethods &&
                            otherFormOfPaymentExplanation == other.otherFormOfPaymentExplanation &&
                            transactionOrAccountCanceledAt ==
                                other.transactionOrAccountCanceledAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cancellationTarget,
                            merchantContactMethods,
                            otherFormOfPaymentExplanation,
                            transactionOrAccountCanceledAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerCanceledRecurringTransaction{cancellationTarget=$cancellationTarget, merchantContactMethods=$merchantContactMethods, otherFormOfPaymentExplanation=$otherFormOfPaymentExplanation, transactionOrAccountCanceledAt=$transactionOrAccountCanceledAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Canceled services. Present if and only if `category` is
                 * `consumer_canceled_services`.
                 */
                class ConsumerCanceledServices
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cardholderCancellation: JsonField<CardholderCancellation>,
                    private val contractedAt: JsonField<LocalDate>,
                    private val guaranteedReservation: JsonField<GuaranteedReservation>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val other: JsonValue,
                    private val purchaseExplanation: JsonField<String>,
                    private val serviceType: JsonField<ServiceType>,
                    private val timeshare: JsonValue,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cardholder_cancellation")
                        @ExcludeMissing
                        cardholderCancellation: JsonField<CardholderCancellation> =
                            JsonMissing.of(),
                        @JsonProperty("contracted_at")
                        @ExcludeMissing
                        contractedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("guaranteed_reservation")
                        @ExcludeMissing
                        guaranteedReservation: JsonField<GuaranteedReservation> = JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("other") @ExcludeMissing other: JsonValue = JsonMissing.of(),
                        @JsonProperty("purchase_explanation")
                        @ExcludeMissing
                        purchaseExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("service_type")
                        @ExcludeMissing
                        serviceType: JsonField<ServiceType> = JsonMissing.of(),
                        @JsonProperty("timeshare")
                        @ExcludeMissing
                        timeshare: JsonValue = JsonMissing.of(),
                    ) : this(
                        cardholderCancellation,
                        contractedAt,
                        guaranteedReservation,
                        merchantResolutionAttempted,
                        other,
                        purchaseExplanation,
                        serviceType,
                        timeshare,
                        mutableMapOf(),
                    )

                    /**
                     * Cardholder cancellation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cardholderCancellation(): CardholderCancellation =
                        cardholderCancellation.getRequired("cardholder_cancellation")

                    /**
                     * Contracted at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun contractedAt(): LocalDate = contractedAt.getRequired("contracted_at")

                    /**
                     * Guaranteed reservation explanation. Present if and only if `service_type` is
                     * `guaranteed_reservation`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun guaranteedReservation(): GuaranteedReservation? =
                        guaranteedReservation.getNullable("guaranteed_reservation")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * Other service type explanation. Present if and only if `service_type` is
                     * `other`.
                     */
                    @JsonProperty("other") @ExcludeMissing fun _other(): JsonValue = other

                    /**
                     * Purchase explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseExplanation(): String =
                        purchaseExplanation.getRequired("purchase_explanation")

                    /**
                     * Service type.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun serviceType(): ServiceType = serviceType.getRequired("service_type")

                    /**
                     * Timeshare explanation. Present if and only if `service_type` is `timeshare`.
                     */
                    @JsonProperty("timeshare")
                    @ExcludeMissing
                    fun _timeshare(): JsonValue = timeshare

                    /**
                     * Returns the raw JSON value of [cardholderCancellation].
                     *
                     * Unlike [cardholderCancellation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                        cardholderCancellation

                    /**
                     * Returns the raw JSON value of [contractedAt].
                     *
                     * Unlike [contractedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("contracted_at")
                    @ExcludeMissing
                    fun _contractedAt(): JsonField<LocalDate> = contractedAt

                    /**
                     * Returns the raw JSON value of [guaranteedReservation].
                     *
                     * Unlike [guaranteedReservation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("guaranteed_reservation")
                    @ExcludeMissing
                    fun _guaranteedReservation(): JsonField<GuaranteedReservation> =
                        guaranteedReservation

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [purchaseExplanation].
                     *
                     * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                    /**
                     * Returns the raw JSON value of [serviceType].
                     *
                     * Unlike [serviceType], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("service_type")
                    @ExcludeMissing
                    fun _serviceType(): JsonField<ServiceType> = serviceType

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerCanceledServices].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .contractedAt()
                         * .guaranteedReservation()
                         * .merchantResolutionAttempted()
                         * .other()
                         * .purchaseExplanation()
                         * .serviceType()
                         * .timeshare()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerCanceledServices]. */
                    class Builder internal constructor() {

                        private var cardholderCancellation: JsonField<CardholderCancellation>? =
                            null
                        private var contractedAt: JsonField<LocalDate>? = null
                        private var guaranteedReservation: JsonField<GuaranteedReservation>? = null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var other: JsonValue? = null
                        private var purchaseExplanation: JsonField<String>? = null
                        private var serviceType: JsonField<ServiceType>? = null
                        private var timeshare: JsonValue? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(consumerCanceledServices: ConsumerCanceledServices) =
                            apply {
                                cardholderCancellation =
                                    consumerCanceledServices.cardholderCancellation
                                contractedAt = consumerCanceledServices.contractedAt
                                guaranteedReservation =
                                    consumerCanceledServices.guaranteedReservation
                                merchantResolutionAttempted =
                                    consumerCanceledServices.merchantResolutionAttempted
                                other = consumerCanceledServices.other
                                purchaseExplanation = consumerCanceledServices.purchaseExplanation
                                serviceType = consumerCanceledServices.serviceType
                                timeshare = consumerCanceledServices.timeshare
                                additionalProperties =
                                    consumerCanceledServices.additionalProperties.toMutableMap()
                            }

                        /** Cardholder cancellation. */
                        fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                            cardholderCancellation(JsonField.of(cardholderCancellation))

                        /**
                         * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cardholderCancellation] with a
                         * well-typed [CardholderCancellation] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cardholderCancellation(
                            cardholderCancellation: JsonField<CardholderCancellation>
                        ) = apply { this.cardholderCancellation = cardholderCancellation }

                        /** Contracted at. */
                        fun contractedAt(contractedAt: LocalDate) =
                            contractedAt(JsonField.of(contractedAt))

                        /**
                         * Sets [Builder.contractedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.contractedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun contractedAt(contractedAt: JsonField<LocalDate>) = apply {
                            this.contractedAt = contractedAt
                        }

                        /**
                         * Guaranteed reservation explanation. Present if and only if `service_type`
                         * is `guaranteed_reservation`.
                         */
                        fun guaranteedReservation(guaranteedReservation: GuaranteedReservation?) =
                            guaranteedReservation(JsonField.ofNullable(guaranteedReservation))

                        /**
                         * Sets [Builder.guaranteedReservation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.guaranteedReservation] with a well-typed
                         * [GuaranteedReservation] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun guaranteedReservation(
                            guaranteedReservation: JsonField<GuaranteedReservation>
                        ) = apply { this.guaranteedReservation = guaranteedReservation }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /**
                         * Other service type explanation. Present if and only if `service_type` is
                         * `other`.
                         */
                        fun other(other: JsonValue) = apply { this.other = other }

                        /** Purchase explanation. */
                        fun purchaseExplanation(purchaseExplanation: String) =
                            purchaseExplanation(JsonField.of(purchaseExplanation))

                        /**
                         * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                            this.purchaseExplanation = purchaseExplanation
                        }

                        /** Service type. */
                        fun serviceType(serviceType: ServiceType) =
                            serviceType(JsonField.of(serviceType))

                        /**
                         * Sets [Builder.serviceType] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.serviceType] with a well-typed
                         * [ServiceType] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun serviceType(serviceType: JsonField<ServiceType>) = apply {
                            this.serviceType = serviceType
                        }

                        /**
                         * Timeshare explanation. Present if and only if `service_type` is
                         * `timeshare`.
                         */
                        fun timeshare(timeshare: JsonValue) = apply { this.timeshare = timeshare }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerCanceledServices].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .contractedAt()
                         * .guaranteedReservation()
                         * .merchantResolutionAttempted()
                         * .other()
                         * .purchaseExplanation()
                         * .serviceType()
                         * .timeshare()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerCanceledServices =
                            ConsumerCanceledServices(
                                checkRequired("cardholderCancellation", cardholderCancellation),
                                checkRequired("contractedAt", contractedAt),
                                checkRequired("guaranteedReservation", guaranteedReservation),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("other", other),
                                checkRequired("purchaseExplanation", purchaseExplanation),
                                checkRequired("serviceType", serviceType),
                                checkRequired("timeshare", timeshare),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerCanceledServices = apply {
                        if (validated) {
                            return@apply
                        }

                        cardholderCancellation().validate()
                        contractedAt()
                        guaranteedReservation()?.validate()
                        merchantResolutionAttempted().validate()
                        purchaseExplanation()
                        serviceType().validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cardholderCancellation.asKnown()?.validity() ?: 0) +
                            (if (contractedAt.asKnown() == null) 0 else 1) +
                            (guaranteedReservation.asKnown()?.validity() ?: 0) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                            (serviceType.asKnown()?.validity() ?: 0)

                    /** Cardholder cancellation. */
                    class CardholderCancellation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val canceledAt: JsonField<LocalDate>,
                        private val cancellationPolicyProvided:
                            JsonField<CancellationPolicyProvided>,
                        private val reason: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("cancellation_policy_provided")
                            @ExcludeMissing
                            cancellationPolicyProvided: JsonField<CancellationPolicyProvided> =
                                JsonMissing.of(),
                            @JsonProperty("reason")
                            @ExcludeMissing
                            reason: JsonField<String> = JsonMissing.of(),
                        ) : this(canceledAt, cancellationPolicyProvided, reason, mutableMapOf())

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Cancellation policy provided.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun cancellationPolicyProvided(): CancellationPolicyProvided =
                            cancellationPolicyProvided.getRequired("cancellation_policy_provided")

                        /**
                         * Reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun reason(): String = reason.getRequired("reason")

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        /**
                         * Returns the raw JSON value of [cancellationPolicyProvided].
                         *
                         * Unlike [cancellationPolicyProvided], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("cancellation_policy_provided")
                        @ExcludeMissing
                        fun _cancellationPolicyProvided(): JsonField<CancellationPolicyProvided> =
                            cancellationPolicyProvided

                        /**
                         * Returns the raw JSON value of [reason].
                         *
                         * Unlike [reason], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("reason")
                        @ExcludeMissing
                        fun _reason(): JsonField<String> = reason

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [CardholderCancellation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .cancellationPolicyProvided()
                             * .reason()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [CardholderCancellation]. */
                        class Builder internal constructor() {

                            private var canceledAt: JsonField<LocalDate>? = null
                            private var cancellationPolicyProvided:
                                JsonField<CancellationPolicyProvided>? =
                                null
                            private var reason: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(cardholderCancellation: CardholderCancellation) =
                                apply {
                                    canceledAt = cardholderCancellation.canceledAt
                                    cancellationPolicyProvided =
                                        cardholderCancellation.cancellationPolicyProvided
                                    reason = cardholderCancellation.reason
                                    additionalProperties =
                                        cardholderCancellation.additionalProperties.toMutableMap()
                                }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            /** Cancellation policy provided. */
                            fun cancellationPolicyProvided(
                                cancellationPolicyProvided: CancellationPolicyProvided
                            ) = cancellationPolicyProvided(JsonField.of(cancellationPolicyProvided))

                            /**
                             * Sets [Builder.cancellationPolicyProvided] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.cancellationPolicyProvided] with a
                             * well-typed [CancellationPolicyProvided] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun cancellationPolicyProvided(
                                cancellationPolicyProvided: JsonField<CancellationPolicyProvided>
                            ) = apply {
                                this.cancellationPolicyProvided = cancellationPolicyProvided
                            }

                            /** Reason. */
                            fun reason(reason: String) = reason(JsonField.of(reason))

                            /**
                             * Sets [Builder.reason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.reason] with a well-typed [String]
                             * value instead. This method is primarily for setting the field to an
                             * undocumented or not yet supported value.
                             */
                            fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [CardholderCancellation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .cancellationPolicyProvided()
                             * .reason()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): CardholderCancellation =
                                CardholderCancellation(
                                    checkRequired("canceledAt", canceledAt),
                                    checkRequired(
                                        "cancellationPolicyProvided",
                                        cancellationPolicyProvided,
                                    ),
                                    checkRequired("reason", reason),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): CardholderCancellation = apply {
                            if (validated) {
                                return@apply
                            }

                            canceledAt()
                            cancellationPolicyProvided().validate()
                            reason()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (canceledAt.asKnown() == null) 0 else 1) +
                                (cancellationPolicyProvided.asKnown()?.validity() ?: 0) +
                                (if (reason.asKnown() == null) 0 else 1)

                        /** Cancellation policy provided. */
                        class CancellationPolicyProvided
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Not provided. */
                                val NOT_PROVIDED = of("not_provided")

                                /** Provided. */
                                val PROVIDED = of("provided")

                                fun of(value: String) =
                                    CancellationPolicyProvided(JsonField.of(value))
                            }

                            /** An enum containing [CancellationPolicyProvided]'s known values. */
                            enum class Known {
                                /** Not provided. */
                                NOT_PROVIDED,
                                /** Provided. */
                                PROVIDED,
                            }

                            /**
                             * An enum containing [CancellationPolicyProvided]'s known values, as
                             * well as an [_UNKNOWN] member.
                             *
                             * An instance of [CancellationPolicyProvided] can contain an unknown
                             * value in a couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Not provided. */
                                NOT_PROVIDED,
                                /** Provided. */
                                PROVIDED,
                                /**
                                 * An enum member indicating that [CancellationPolicyProvided] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    NOT_PROVIDED -> Value.NOT_PROVIDED
                                    PROVIDED -> Value.PROVIDED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    NOT_PROVIDED -> Known.NOT_PROVIDED
                                    PROVIDED -> Known.PROVIDED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown CancellationPolicyProvided: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): CancellationPolicyProvided = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is CancellationPolicyProvided && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderCancellation &&
                                canceledAt == other.canceledAt &&
                                cancellationPolicyProvided == other.cancellationPolicyProvided &&
                                reason == other.reason &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                canceledAt,
                                cancellationPolicyProvided,
                                reason,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "CardholderCancellation{canceledAt=$canceledAt, cancellationPolicyProvided=$cancellationPolicyProvided, reason=$reason, additionalProperties=$additionalProperties}"
                    }

                    /**
                     * Guaranteed reservation explanation. Present if and only if `service_type` is
                     * `guaranteed_reservation`.
                     */
                    class GuaranteedReservation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val explanation: JsonField<Explanation>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("explanation")
                            @ExcludeMissing
                            explanation: JsonField<Explanation> = JsonMissing.of()
                        ) : this(explanation, mutableMapOf())

                        /**
                         * Explanation.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun explanation(): Explanation = explanation.getRequired("explanation")

                        /**
                         * Returns the raw JSON value of [explanation].
                         *
                         * Unlike [explanation], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        fun _explanation(): JsonField<Explanation> = explanation

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [GuaranteedReservation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [GuaranteedReservation]. */
                        class Builder internal constructor() {

                            private var explanation: JsonField<Explanation>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(guaranteedReservation: GuaranteedReservation) =
                                apply {
                                    explanation = guaranteedReservation.explanation
                                    additionalProperties =
                                        guaranteedReservation.additionalProperties.toMutableMap()
                                }

                            /** Explanation. */
                            fun explanation(explanation: Explanation) =
                                explanation(JsonField.of(explanation))

                            /**
                             * Sets [Builder.explanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.explanation] with a well-typed
                             * [Explanation] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun explanation(explanation: JsonField<Explanation>) = apply {
                                this.explanation = explanation
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [GuaranteedReservation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): GuaranteedReservation =
                                GuaranteedReservation(
                                    checkRequired("explanation", explanation),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): GuaranteedReservation = apply {
                            if (validated) {
                                return@apply
                            }

                            explanation().validate()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = (explanation.asKnown()?.validity() ?: 0)

                        /** Explanation. */
                        class Explanation
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Cardholder canceled prior to service. */
                                val CARDHOLDER_CANCELED_PRIOR_TO_SERVICE =
                                    of("cardholder_canceled_prior_to_service")

                                /**
                                 * Cardholder cancellation attempt within 24 hours of confirmation.
                                 */
                                val CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION =
                                    of(
                                        "cardholder_cancellation_attempt_within_24_hours_of_confirmation"
                                    )

                                /** Merchant billed for no-show. */
                                val MERCHANT_BILLED_NO_SHOW = of("merchant_billed_no_show")

                                fun of(value: String) = Explanation(JsonField.of(value))
                            }

                            /** An enum containing [Explanation]'s known values. */
                            enum class Known {
                                /** Cardholder canceled prior to service. */
                                CARDHOLDER_CANCELED_PRIOR_TO_SERVICE,
                                /**
                                 * Cardholder cancellation attempt within 24 hours of confirmation.
                                 */
                                CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION,
                                /** Merchant billed for no-show. */
                                MERCHANT_BILLED_NO_SHOW,
                            }

                            /**
                             * An enum containing [Explanation]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [Explanation] can contain an unknown value in a couple
                             * of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Cardholder canceled prior to service. */
                                CARDHOLDER_CANCELED_PRIOR_TO_SERVICE,
                                /**
                                 * Cardholder cancellation attempt within 24 hours of confirmation.
                                 */
                                CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION,
                                /** Merchant billed for no-show. */
                                MERCHANT_BILLED_NO_SHOW,
                                /**
                                 * An enum member indicating that [Explanation] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    CARDHOLDER_CANCELED_PRIOR_TO_SERVICE ->
                                        Value.CARDHOLDER_CANCELED_PRIOR_TO_SERVICE
                                    CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION ->
                                        Value
                                            .CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION
                                    MERCHANT_BILLED_NO_SHOW -> Value.MERCHANT_BILLED_NO_SHOW
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    CARDHOLDER_CANCELED_PRIOR_TO_SERVICE ->
                                        Known.CARDHOLDER_CANCELED_PRIOR_TO_SERVICE
                                    CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION ->
                                        Known
                                            .CARDHOLDER_CANCELLATION_ATTEMPT_WITHIN_24_HOURS_OF_CONFIRMATION
                                    MERCHANT_BILLED_NO_SHOW -> Known.MERCHANT_BILLED_NO_SHOW
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown Explanation: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): Explanation = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is Explanation && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is GuaranteedReservation &&
                                explanation == other.explanation &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(explanation, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "GuaranteedReservation{explanation=$explanation, additionalProperties=$additionalProperties}"
                    }

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Service type. */
                    class ServiceType
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Guaranteed reservation. */
                            val GUARANTEED_RESERVATION = of("guaranteed_reservation")

                            /** Other. */
                            val OTHER = of("other")

                            /** Timeshare. */
                            val TIMESHARE = of("timeshare")

                            fun of(value: String) = ServiceType(JsonField.of(value))
                        }

                        /** An enum containing [ServiceType]'s known values. */
                        enum class Known {
                            /** Guaranteed reservation. */
                            GUARANTEED_RESERVATION,
                            /** Other. */
                            OTHER,
                            /** Timeshare. */
                            TIMESHARE,
                        }

                        /**
                         * An enum containing [ServiceType]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [ServiceType] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Guaranteed reservation. */
                            GUARANTEED_RESERVATION,
                            /** Other. */
                            OTHER,
                            /** Timeshare. */
                            TIMESHARE,
                            /**
                             * An enum member indicating that [ServiceType] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                GUARANTEED_RESERVATION -> Value.GUARANTEED_RESERVATION
                                OTHER -> Value.OTHER
                                TIMESHARE -> Value.TIMESHARE
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                GUARANTEED_RESERVATION -> Known.GUARANTEED_RESERVATION
                                OTHER -> Known.OTHER
                                TIMESHARE -> Known.TIMESHARE
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ServiceType: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ServiceType = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ServiceType && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerCanceledServices &&
                            cardholderCancellation == other.cardholderCancellation &&
                            contractedAt == other.contractedAt &&
                            guaranteedReservation == other.guaranteedReservation &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            this.other == other.other &&
                            purchaseExplanation == other.purchaseExplanation &&
                            serviceType == other.serviceType &&
                            timeshare == other.timeshare &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cardholderCancellation,
                            contractedAt,
                            guaranteedReservation,
                            merchantResolutionAttempted,
                            other,
                            purchaseExplanation,
                            serviceType,
                            timeshare,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerCanceledServices{cardholderCancellation=$cardholderCancellation, contractedAt=$contractedAt, guaranteedReservation=$guaranteedReservation, merchantResolutionAttempted=$merchantResolutionAttempted, other=$other, purchaseExplanation=$purchaseExplanation, serviceType=$serviceType, timeshare=$timeshare, additionalProperties=$additionalProperties}"
                }

                /**
                 * Counterfeit merchandise. Present if and only if `category` is
                 * `consumer_counterfeit_merchandise`.
                 */
                class ConsumerCounterfeitMerchandise
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val counterfeitExplanation: JsonField<String>,
                    private val dispositionExplanation: JsonField<String>,
                    private val orderExplanation: JsonField<String>,
                    private val receivedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("counterfeit_explanation")
                        @ExcludeMissing
                        counterfeitExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("disposition_explanation")
                        @ExcludeMissing
                        dispositionExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("order_explanation")
                        @ExcludeMissing
                        orderExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("received_at")
                        @ExcludeMissing
                        receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(
                        counterfeitExplanation,
                        dispositionExplanation,
                        orderExplanation,
                        receivedAt,
                        mutableMapOf(),
                    )

                    /**
                     * Counterfeit explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun counterfeitExplanation(): String =
                        counterfeitExplanation.getRequired("counterfeit_explanation")

                    /**
                     * Disposition explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun dispositionExplanation(): String =
                        dispositionExplanation.getRequired("disposition_explanation")

                    /**
                     * Order explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun orderExplanation(): String =
                        orderExplanation.getRequired("order_explanation")

                    /**
                     * Received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                    /**
                     * Returns the raw JSON value of [counterfeitExplanation].
                     *
                     * Unlike [counterfeitExplanation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("counterfeit_explanation")
                    @ExcludeMissing
                    fun _counterfeitExplanation(): JsonField<String> = counterfeitExplanation

                    /**
                     * Returns the raw JSON value of [dispositionExplanation].
                     *
                     * Unlike [dispositionExplanation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("disposition_explanation")
                    @ExcludeMissing
                    fun _dispositionExplanation(): JsonField<String> = dispositionExplanation

                    /**
                     * Returns the raw JSON value of [orderExplanation].
                     *
                     * Unlike [orderExplanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("order_explanation")
                    @ExcludeMissing
                    fun _orderExplanation(): JsonField<String> = orderExplanation

                    /**
                     * Returns the raw JSON value of [receivedAt].
                     *
                     * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    fun _receivedAt(): JsonField<LocalDate> = receivedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerCounterfeitMerchandise].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .counterfeitExplanation()
                         * .dispositionExplanation()
                         * .orderExplanation()
                         * .receivedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerCounterfeitMerchandise]. */
                    class Builder internal constructor() {

                        private var counterfeitExplanation: JsonField<String>? = null
                        private var dispositionExplanation: JsonField<String>? = null
                        private var orderExplanation: JsonField<String>? = null
                        private var receivedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerCounterfeitMerchandise: ConsumerCounterfeitMerchandise
                        ) = apply {
                            counterfeitExplanation =
                                consumerCounterfeitMerchandise.counterfeitExplanation
                            dispositionExplanation =
                                consumerCounterfeitMerchandise.dispositionExplanation
                            orderExplanation = consumerCounterfeitMerchandise.orderExplanation
                            receivedAt = consumerCounterfeitMerchandise.receivedAt
                            additionalProperties =
                                consumerCounterfeitMerchandise.additionalProperties.toMutableMap()
                        }

                        /** Counterfeit explanation. */
                        fun counterfeitExplanation(counterfeitExplanation: String) =
                            counterfeitExplanation(JsonField.of(counterfeitExplanation))

                        /**
                         * Sets [Builder.counterfeitExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.counterfeitExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun counterfeitExplanation(counterfeitExplanation: JsonField<String>) =
                            apply {
                                this.counterfeitExplanation = counterfeitExplanation
                            }

                        /** Disposition explanation. */
                        fun dispositionExplanation(dispositionExplanation: String) =
                            dispositionExplanation(JsonField.of(dispositionExplanation))

                        /**
                         * Sets [Builder.dispositionExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.dispositionExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun dispositionExplanation(dispositionExplanation: JsonField<String>) =
                            apply {
                                this.dispositionExplanation = dispositionExplanation
                            }

                        /** Order explanation. */
                        fun orderExplanation(orderExplanation: String) =
                            orderExplanation(JsonField.of(orderExplanation))

                        /**
                         * Sets [Builder.orderExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.orderExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun orderExplanation(orderExplanation: JsonField<String>) = apply {
                            this.orderExplanation = orderExplanation
                        }

                        /** Received at. */
                        fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                        /**
                         * Sets [Builder.receivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                            this.receivedAt = receivedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerCounterfeitMerchandise].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .counterfeitExplanation()
                         * .dispositionExplanation()
                         * .orderExplanation()
                         * .receivedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerCounterfeitMerchandise =
                            ConsumerCounterfeitMerchandise(
                                checkRequired("counterfeitExplanation", counterfeitExplanation),
                                checkRequired("dispositionExplanation", dispositionExplanation),
                                checkRequired("orderExplanation", orderExplanation),
                                checkRequired("receivedAt", receivedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerCounterfeitMerchandise = apply {
                        if (validated) {
                            return@apply
                        }

                        counterfeitExplanation()
                        dispositionExplanation()
                        orderExplanation()
                        receivedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (counterfeitExplanation.asKnown() == null) 0 else 1) +
                            (if (dispositionExplanation.asKnown() == null) 0 else 1) +
                            (if (orderExplanation.asKnown() == null) 0 else 1) +
                            (if (receivedAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerCounterfeitMerchandise &&
                            counterfeitExplanation == other.counterfeitExplanation &&
                            dispositionExplanation == other.dispositionExplanation &&
                            orderExplanation == other.orderExplanation &&
                            receivedAt == other.receivedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            counterfeitExplanation,
                            dispositionExplanation,
                            orderExplanation,
                            receivedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerCounterfeitMerchandise{counterfeitExplanation=$counterfeitExplanation, dispositionExplanation=$dispositionExplanation, orderExplanation=$orderExplanation, receivedAt=$receivedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Credit not processed. Present if and only if `category` is
                 * `consumer_credit_not_processed`.
                 */
                class ConsumerCreditNotProcessed
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val canceledOrReturnedAt: JsonField<LocalDate>,
                    private val creditExpectedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("canceled_or_returned_at")
                        @ExcludeMissing
                        canceledOrReturnedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("credit_expected_at")
                        @ExcludeMissing
                        creditExpectedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(canceledOrReturnedAt, creditExpectedAt, mutableMapOf())

                    /**
                     * Canceled or returned at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun canceledOrReturnedAt(): LocalDate? =
                        canceledOrReturnedAt.getNullable("canceled_or_returned_at")

                    /**
                     * Credit expected at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun creditExpectedAt(): LocalDate? =
                        creditExpectedAt.getNullable("credit_expected_at")

                    /**
                     * Returns the raw JSON value of [canceledOrReturnedAt].
                     *
                     * Unlike [canceledOrReturnedAt], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("canceled_or_returned_at")
                    @ExcludeMissing
                    fun _canceledOrReturnedAt(): JsonField<LocalDate> = canceledOrReturnedAt

                    /**
                     * Returns the raw JSON value of [creditExpectedAt].
                     *
                     * Unlike [creditExpectedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("credit_expected_at")
                    @ExcludeMissing
                    fun _creditExpectedAt(): JsonField<LocalDate> = creditExpectedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerCreditNotProcessed].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledOrReturnedAt()
                         * .creditExpectedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerCreditNotProcessed]. */
                    class Builder internal constructor() {

                        private var canceledOrReturnedAt: JsonField<LocalDate>? = null
                        private var creditExpectedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(consumerCreditNotProcessed: ConsumerCreditNotProcessed) =
                            apply {
                                canceledOrReturnedAt =
                                    consumerCreditNotProcessed.canceledOrReturnedAt
                                creditExpectedAt = consumerCreditNotProcessed.creditExpectedAt
                                additionalProperties =
                                    consumerCreditNotProcessed.additionalProperties.toMutableMap()
                            }

                        /** Canceled or returned at. */
                        fun canceledOrReturnedAt(canceledOrReturnedAt: LocalDate?) =
                            canceledOrReturnedAt(JsonField.ofNullable(canceledOrReturnedAt))

                        /**
                         * Sets [Builder.canceledOrReturnedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.canceledOrReturnedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun canceledOrReturnedAt(canceledOrReturnedAt: JsonField<LocalDate>) =
                            apply {
                                this.canceledOrReturnedAt = canceledOrReturnedAt
                            }

                        /** Credit expected at. */
                        fun creditExpectedAt(creditExpectedAt: LocalDate?) =
                            creditExpectedAt(JsonField.ofNullable(creditExpectedAt))

                        /**
                         * Sets [Builder.creditExpectedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.creditExpectedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun creditExpectedAt(creditExpectedAt: JsonField<LocalDate>) = apply {
                            this.creditExpectedAt = creditExpectedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerCreditNotProcessed].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .canceledOrReturnedAt()
                         * .creditExpectedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerCreditNotProcessed =
                            ConsumerCreditNotProcessed(
                                checkRequired("canceledOrReturnedAt", canceledOrReturnedAt),
                                checkRequired("creditExpectedAt", creditExpectedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerCreditNotProcessed = apply {
                        if (validated) {
                            return@apply
                        }

                        canceledOrReturnedAt()
                        creditExpectedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (canceledOrReturnedAt.asKnown() == null) 0 else 1) +
                            (if (creditExpectedAt.asKnown() == null) 0 else 1)

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerCreditNotProcessed &&
                            canceledOrReturnedAt == other.canceledOrReturnedAt &&
                            creditExpectedAt == other.creditExpectedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(canceledOrReturnedAt, creditExpectedAt, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerCreditNotProcessed{canceledOrReturnedAt=$canceledOrReturnedAt, creditExpectedAt=$creditExpectedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Damaged or defective merchandise. Present if and only if `category` is
                 * `consumer_damaged_or_defective_merchandise`.
                 */
                class ConsumerDamagedOrDefectiveMerchandise
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val notReturned: JsonValue,
                    private val orderAndIssueExplanation: JsonField<String>,
                    private val receivedAt: JsonField<LocalDate>,
                    private val returnAttempted: JsonField<ReturnAttempted>,
                    private val returnOutcome: JsonField<ReturnOutcome>,
                    private val returned: JsonField<Returned>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("not_returned")
                        @ExcludeMissing
                        notReturned: JsonValue = JsonMissing.of(),
                        @JsonProperty("order_and_issue_explanation")
                        @ExcludeMissing
                        orderAndIssueExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("received_at")
                        @ExcludeMissing
                        receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("return_attempted")
                        @ExcludeMissing
                        returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                        @JsonProperty("return_outcome")
                        @ExcludeMissing
                        returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                        @JsonProperty("returned")
                        @ExcludeMissing
                        returned: JsonField<Returned> = JsonMissing.of(),
                    ) : this(
                        merchantResolutionAttempted,
                        notReturned,
                        orderAndIssueExplanation,
                        receivedAt,
                        returnAttempted,
                        returnOutcome,
                        returned,
                        mutableMapOf(),
                    )

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /** Not returned. Present if and only if `return_outcome` is `not_returned`. */
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    fun _notReturned(): JsonValue = notReturned

                    /**
                     * Order and issue explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun orderAndIssueExplanation(): String =
                        orderAndIssueExplanation.getRequired("order_and_issue_explanation")

                    /**
                     * Received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returnAttempted(): ReturnAttempted? =
                        returnAttempted.getNullable("return_attempted")

                    /**
                     * Return outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                    /**
                     * Returned. Present if and only if `return_outcome` is `returned`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returned(): Returned? = returned.getNullable("returned")

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [orderAndIssueExplanation].
                     *
                     * Unlike [orderAndIssueExplanation], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("order_and_issue_explanation")
                    @ExcludeMissing
                    fun _orderAndIssueExplanation(): JsonField<String> = orderAndIssueExplanation

                    /**
                     * Returns the raw JSON value of [receivedAt].
                     *
                     * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    fun _receivedAt(): JsonField<LocalDate> = receivedAt

                    /**
                     * Returns the raw JSON value of [returnAttempted].
                     *
                     * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                    /**
                     * Returns the raw JSON value of [returnOutcome].
                     *
                     * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                    /**
                     * Returns the raw JSON value of [returned].
                     *
                     * Unlike [returned], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned")
                    @ExcludeMissing
                    fun _returned(): JsonField<Returned> = returned

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerDamagedOrDefectiveMerchandise].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .merchantResolutionAttempted()
                         * .notReturned()
                         * .orderAndIssueExplanation()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerDamagedOrDefectiveMerchandise]. */
                    class Builder internal constructor() {

                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var notReturned: JsonValue? = null
                        private var orderAndIssueExplanation: JsonField<String>? = null
                        private var receivedAt: JsonField<LocalDate>? = null
                        private var returnAttempted: JsonField<ReturnAttempted>? = null
                        private var returnOutcome: JsonField<ReturnOutcome>? = null
                        private var returned: JsonField<Returned>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerDamagedOrDefectiveMerchandise:
                                ConsumerDamagedOrDefectiveMerchandise
                        ) = apply {
                            merchantResolutionAttempted =
                                consumerDamagedOrDefectiveMerchandise.merchantResolutionAttempted
                            notReturned = consumerDamagedOrDefectiveMerchandise.notReturned
                            orderAndIssueExplanation =
                                consumerDamagedOrDefectiveMerchandise.orderAndIssueExplanation
                            receivedAt = consumerDamagedOrDefectiveMerchandise.receivedAt
                            returnAttempted = consumerDamagedOrDefectiveMerchandise.returnAttempted
                            returnOutcome = consumerDamagedOrDefectiveMerchandise.returnOutcome
                            returned = consumerDamagedOrDefectiveMerchandise.returned
                            additionalProperties =
                                consumerDamagedOrDefectiveMerchandise.additionalProperties
                                    .toMutableMap()
                        }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /**
                         * Not returned. Present if and only if `return_outcome` is `not_returned`.
                         */
                        fun notReturned(notReturned: JsonValue) = apply {
                            this.notReturned = notReturned
                        }

                        /** Order and issue explanation. */
                        fun orderAndIssueExplanation(orderAndIssueExplanation: String) =
                            orderAndIssueExplanation(JsonField.of(orderAndIssueExplanation))

                        /**
                         * Sets [Builder.orderAndIssueExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.orderAndIssueExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun orderAndIssueExplanation(orderAndIssueExplanation: JsonField<String>) =
                            apply {
                                this.orderAndIssueExplanation = orderAndIssueExplanation
                            }

                        /** Received at. */
                        fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                        /**
                         * Sets [Builder.receivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                            this.receivedAt = receivedAt
                        }

                        /**
                         * Return attempted. Present if and only if `return_outcome` is
                         * `return_attempted`.
                         */
                        fun returnAttempted(returnAttempted: ReturnAttempted?) =
                            returnAttempted(JsonField.ofNullable(returnAttempted))

                        /**
                         * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnAttempted] with a well-typed
                         * [ReturnAttempted] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                            this.returnAttempted = returnAttempted
                        }

                        /** Return outcome. */
                        fun returnOutcome(returnOutcome: ReturnOutcome) =
                            returnOutcome(JsonField.of(returnOutcome))

                        /**
                         * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnOutcome] with a well-typed
                         * [ReturnOutcome] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                            this.returnOutcome = returnOutcome
                        }

                        /** Returned. Present if and only if `return_outcome` is `returned`. */
                        fun returned(returned: Returned?) = returned(JsonField.ofNullable(returned))

                        /**
                         * Sets [Builder.returned] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returned] with a well-typed [Returned]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun returned(returned: JsonField<Returned>) = apply {
                            this.returned = returned
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerDamagedOrDefectiveMerchandise].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .merchantResolutionAttempted()
                         * .notReturned()
                         * .orderAndIssueExplanation()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerDamagedOrDefectiveMerchandise =
                            ConsumerDamagedOrDefectiveMerchandise(
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("notReturned", notReturned),
                                checkRequired("orderAndIssueExplanation", orderAndIssueExplanation),
                                checkRequired("receivedAt", receivedAt),
                                checkRequired("returnAttempted", returnAttempted),
                                checkRequired("returnOutcome", returnOutcome),
                                checkRequired("returned", returned),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerDamagedOrDefectiveMerchandise = apply {
                        if (validated) {
                            return@apply
                        }

                        merchantResolutionAttempted().validate()
                        orderAndIssueExplanation()
                        receivedAt()
                        returnAttempted()?.validate()
                        returnOutcome().validate()
                        returned()?.validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (orderAndIssueExplanation.asKnown() == null) 0 else 1) +
                            (if (receivedAt.asKnown() == null) 0 else 1) +
                            (returnAttempted.asKnown()?.validity() ?: 0) +
                            (returnOutcome.asKnown()?.validity() ?: 0) +
                            (returned.asKnown()?.validity() ?: 0)

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    class ReturnAttempted
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val attemptExplanation: JsonField<String>,
                        private val attemptReason: JsonField<AttemptReason>,
                        private val attemptedAt: JsonField<LocalDate>,
                        private val merchandiseDisposition: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("attempt_explanation")
                            @ExcludeMissing
                            attemptExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("attempt_reason")
                            @ExcludeMissing
                            attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                            @JsonProperty("attempted_at")
                            @ExcludeMissing
                            attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("merchandise_disposition")
                            @ExcludeMissing
                            merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            mutableMapOf(),
                        )

                        /**
                         * Attempt explanation.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptExplanation(): String =
                            attemptExplanation.getRequired("attempt_explanation")

                        /**
                         * Attempt reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptReason(): AttemptReason =
                            attemptReason.getRequired("attempt_reason")

                        /**
                         * Attempted at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                        /**
                         * Merchandise disposition.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun merchandiseDisposition(): String =
                            merchandiseDisposition.getRequired("merchandise_disposition")

                        /**
                         * Returns the raw JSON value of [attemptExplanation].
                         *
                         * Unlike [attemptExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        fun _attemptExplanation(): JsonField<String> = attemptExplanation

                        /**
                         * Returns the raw JSON value of [attemptReason].
                         *
                         * Unlike [attemptReason], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                        /**
                         * Returns the raw JSON value of [attemptedAt].
                         *
                         * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                        /**
                         * Returns the raw JSON value of [merchandiseDisposition].
                         *
                         * Unlike [merchandiseDisposition], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [ReturnAttempted].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [ReturnAttempted]. */
                        class Builder internal constructor() {

                            private var attemptExplanation: JsonField<String>? = null
                            private var attemptReason: JsonField<AttemptReason>? = null
                            private var attemptedAt: JsonField<LocalDate>? = null
                            private var merchandiseDisposition: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returnAttempted: ReturnAttempted) = apply {
                                attemptExplanation = returnAttempted.attemptExplanation
                                attemptReason = returnAttempted.attemptReason
                                attemptedAt = returnAttempted.attemptedAt
                                merchandiseDisposition = returnAttempted.merchandiseDisposition
                                additionalProperties =
                                    returnAttempted.additionalProperties.toMutableMap()
                            }

                            /** Attempt explanation. */
                            fun attemptExplanation(attemptExplanation: String) =
                                attemptExplanation(JsonField.of(attemptExplanation))

                            /**
                             * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptExplanation] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                                this.attemptExplanation = attemptExplanation
                            }

                            /** Attempt reason. */
                            fun attemptReason(attemptReason: AttemptReason) =
                                attemptReason(JsonField.of(attemptReason))

                            /**
                             * Sets [Builder.attemptReason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptReason] with a well-typed
                             * [AttemptReason] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                                this.attemptReason = attemptReason
                            }

                            /** Attempted at. */
                            fun attemptedAt(attemptedAt: LocalDate) =
                                attemptedAt(JsonField.of(attemptedAt))

                            /**
                             * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                                this.attemptedAt = attemptedAt
                            }

                            /** Merchandise disposition. */
                            fun merchandiseDisposition(merchandiseDisposition: String) =
                                merchandiseDisposition(JsonField.of(merchandiseDisposition))

                            /**
                             * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchandiseDisposition] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                                apply {
                                    this.merchandiseDisposition = merchandiseDisposition
                                }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [ReturnAttempted].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): ReturnAttempted =
                                ReturnAttempted(
                                    checkRequired("attemptExplanation", attemptExplanation),
                                    checkRequired("attemptReason", attemptReason),
                                    checkRequired("attemptedAt", attemptedAt),
                                    checkRequired("merchandiseDisposition", merchandiseDisposition),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): ReturnAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            attemptExplanation()
                            attemptReason().validate()
                            attemptedAt()
                            merchandiseDisposition()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (attemptExplanation.asKnown() == null) 0 else 1) +
                                (attemptReason.asKnown()?.validity() ?: 0) +
                                (if (attemptedAt.asKnown() == null) 0 else 1) +
                                (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                        /** Attempt reason. */
                        class AttemptReason
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Merchant not responding. */
                                val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                                /** No return authorization provided. */
                                val NO_RETURN_AUTHORIZATION_PROVIDED =
                                    of("no_return_authorization_provided")

                                /** No return instructions. */
                                val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                                /** Requested not to return. */
                                val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                                /** Return not accepted. */
                                val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                                fun of(value: String) = AttemptReason(JsonField.of(value))
                            }

                            /** An enum containing [AttemptReason]'s known values. */
                            enum class Known {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AttemptReason]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AttemptReason] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AttemptReason] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AttemptReason: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AttemptReason = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AttemptReason && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnAttempted &&
                                attemptExplanation == other.attemptExplanation &&
                                attemptReason == other.attemptReason &&
                                attemptedAt == other.attemptedAt &&
                                merchandiseDisposition == other.merchandiseDisposition &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                attemptExplanation,
                                attemptReason,
                                attemptedAt,
                                merchandiseDisposition,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                    }

                    /** Return outcome. */
                    class ReturnOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not returned. */
                            val NOT_RETURNED = of("not_returned")

                            /** Returned. */
                            val RETURNED = of("returned")

                            /** Return attempted. */
                            val RETURN_ATTEMPTED = of("return_attempted")

                            fun of(value: String) = ReturnOutcome(JsonField.of(value))
                        }

                        /** An enum containing [ReturnOutcome]'s known values. */
                        enum class Known {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                        }

                        /**
                         * An enum containing [ReturnOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnOutcome] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                            /**
                             * An enum member indicating that [ReturnOutcome] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_RETURNED -> Value.NOT_RETURNED
                                RETURNED -> Value.RETURNED
                                RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_RETURNED -> Known.NOT_RETURNED
                                RETURNED -> Known.RETURNED
                                RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Returned. Present if and only if `return_outcome` is `returned`. */
                    class Returned
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val merchantReceivedReturnAt: JsonField<LocalDate>,
                        private val otherExplanation: JsonField<String>,
                        private val returnMethod: JsonField<ReturnMethod>,
                        private val returnedAt: JsonField<LocalDate>,
                        private val trackingNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("merchant_received_return_at")
                            @ExcludeMissing
                            merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("other_explanation")
                            @ExcludeMissing
                            otherExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("return_method")
                            @ExcludeMissing
                            returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                            @JsonProperty("returned_at")
                            @ExcludeMissing
                            returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("tracking_number")
                            @ExcludeMissing
                            trackingNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            merchantReceivedReturnAt,
                            otherExplanation,
                            returnMethod,
                            returnedAt,
                            trackingNumber,
                            mutableMapOf(),
                        )

                        /**
                         * Merchant received return at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun merchantReceivedReturnAt(): LocalDate? =
                            merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun otherExplanation(): String? =
                            otherExplanation.getNullable("other_explanation")

                        /**
                         * Return method.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                        /**
                         * Returned at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                        /**
                         * Tracking number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun trackingNumber(): String? =
                            trackingNumber.getNullable("tracking_number")

                        /**
                         * Returns the raw JSON value of [merchantReceivedReturnAt].
                         *
                         * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        fun _merchantReceivedReturnAt(): JsonField<LocalDate> =
                            merchantReceivedReturnAt

                        /**
                         * Returns the raw JSON value of [otherExplanation].
                         *
                         * Unlike [otherExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        fun _otherExplanation(): JsonField<String> = otherExplanation

                        /**
                         * Returns the raw JSON value of [returnMethod].
                         *
                         * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                        /**
                         * Returns the raw JSON value of [returnedAt].
                         *
                         * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        fun _returnedAt(): JsonField<LocalDate> = returnedAt

                        /**
                         * Returns the raw JSON value of [trackingNumber].
                         *
                         * Unlike [trackingNumber], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        fun _trackingNumber(): JsonField<String> = trackingNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Returned].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Returned]. */
                        class Builder internal constructor() {

                            private var merchantReceivedReturnAt: JsonField<LocalDate>? = null
                            private var otherExplanation: JsonField<String>? = null
                            private var returnMethod: JsonField<ReturnMethod>? = null
                            private var returnedAt: JsonField<LocalDate>? = null
                            private var trackingNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returned: Returned) = apply {
                                merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                                otherExplanation = returned.otherExplanation
                                returnMethod = returned.returnMethod
                                returnedAt = returned.returnedAt
                                trackingNumber = returned.trackingNumber
                                additionalProperties = returned.additionalProperties.toMutableMap()
                            }

                            /** Merchant received return at. */
                            fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate?) =
                                merchantReceivedReturnAt(
                                    JsonField.ofNullable(merchantReceivedReturnAt)
                                )

                            /**
                             * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchantReceivedReturnAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchantReceivedReturnAt(
                                merchantReceivedReturnAt: JsonField<LocalDate>
                            ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                            /**
                             * Other explanation. Required if and only if the return method is
                             * `other`.
                             */
                            fun otherExplanation(otherExplanation: String?) =
                                otherExplanation(JsonField.ofNullable(otherExplanation))

                            /**
                             * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherExplanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                                this.otherExplanation = otherExplanation
                            }

                            /** Return method. */
                            fun returnMethod(returnMethod: ReturnMethod) =
                                returnMethod(JsonField.of(returnMethod))

                            /**
                             * Sets [Builder.returnMethod] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnMethod] with a well-typed
                             * [ReturnMethod] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                                this.returnMethod = returnMethod
                            }

                            /** Returned at. */
                            fun returnedAt(returnedAt: LocalDate) =
                                returnedAt(JsonField.of(returnedAt))

                            /**
                             * Sets [Builder.returnedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                                this.returnedAt = returnedAt
                            }

                            /** Tracking number. */
                            fun trackingNumber(trackingNumber: String?) =
                                trackingNumber(JsonField.ofNullable(trackingNumber))

                            /**
                             * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.trackingNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                                this.trackingNumber = trackingNumber
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Returned].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Returned =
                                Returned(
                                    checkRequired(
                                        "merchantReceivedReturnAt",
                                        merchantReceivedReturnAt,
                                    ),
                                    checkRequired("otherExplanation", otherExplanation),
                                    checkRequired("returnMethod", returnMethod),
                                    checkRequired("returnedAt", returnedAt),
                                    checkRequired("trackingNumber", trackingNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Returned = apply {
                            if (validated) {
                                return@apply
                            }

                            merchantReceivedReturnAt()
                            otherExplanation()
                            returnMethod().validate()
                            returnedAt()
                            trackingNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                                (if (otherExplanation.asKnown() == null) 0 else 1) +
                                (returnMethod.asKnown()?.validity() ?: 0) +
                                (if (returnedAt.asKnown() == null) 0 else 1) +
                                (if (trackingNumber.asKnown() == null) 0 else 1)

                        /** Return method. */
                        class ReturnMethod
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** DHL. */
                                val DHL = of("dhl")

                                /** Face-to-face. */
                                val FACE_TO_FACE = of("face_to_face")

                                /** FedEx. */
                                val FEDEX = of("fedex")

                                /** Other. */
                                val OTHER = of("other")

                                /** Postal service. */
                                val POSTAL_SERVICE = of("postal_service")

                                /** UPS. */
                                val UPS = of("ups")

                                fun of(value: String) = ReturnMethod(JsonField.of(value))
                            }

                            /** An enum containing [ReturnMethod]'s known values. */
                            enum class Known {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                            }

                            /**
                             * An enum containing [ReturnMethod]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [ReturnMethod] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                                /**
                                 * An enum member indicating that [ReturnMethod] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    DHL -> Value.DHL
                                    FACE_TO_FACE -> Value.FACE_TO_FACE
                                    FEDEX -> Value.FEDEX
                                    OTHER -> Value.OTHER
                                    POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                    UPS -> Value.UPS
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    DHL -> Known.DHL
                                    FACE_TO_FACE -> Known.FACE_TO_FACE
                                    FEDEX -> Known.FEDEX
                                    OTHER -> Known.OTHER
                                    POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                    UPS -> Known.UPS
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown ReturnMethod: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): ReturnMethod = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is ReturnMethod && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Returned &&
                                merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                                otherExplanation == other.otherExplanation &&
                                returnMethod == other.returnMethod &&
                                returnedAt == other.returnedAt &&
                                trackingNumber == other.trackingNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                merchantReceivedReturnAt,
                                otherExplanation,
                                returnMethod,
                                returnedAt,
                                trackingNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Returned{merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, returnMethod=$returnMethod, returnedAt=$returnedAt, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerDamagedOrDefectiveMerchandise &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            notReturned == other.notReturned &&
                            orderAndIssueExplanation == other.orderAndIssueExplanation &&
                            receivedAt == other.receivedAt &&
                            returnAttempted == other.returnAttempted &&
                            returnOutcome == other.returnOutcome &&
                            returned == other.returned &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            merchantResolutionAttempted,
                            notReturned,
                            orderAndIssueExplanation,
                            receivedAt,
                            returnAttempted,
                            returnOutcome,
                            returned,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerDamagedOrDefectiveMerchandise{merchantResolutionAttempted=$merchantResolutionAttempted, notReturned=$notReturned, orderAndIssueExplanation=$orderAndIssueExplanation, receivedAt=$receivedAt, returnAttempted=$returnAttempted, returnOutcome=$returnOutcome, returned=$returned, additionalProperties=$additionalProperties}"
                }

                /**
                 * Merchandise misrepresentation. Present if and only if `category` is
                 * `consumer_merchandise_misrepresentation`.
                 */
                class ConsumerMerchandiseMisrepresentation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val misrepresentationExplanation: JsonField<String>,
                    private val notReturned: JsonValue,
                    private val purchaseExplanation: JsonField<String>,
                    private val receivedAt: JsonField<LocalDate>,
                    private val returnAttempted: JsonField<ReturnAttempted>,
                    private val returnOutcome: JsonField<ReturnOutcome>,
                    private val returned: JsonField<Returned>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("misrepresentation_explanation")
                        @ExcludeMissing
                        misrepresentationExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("not_returned")
                        @ExcludeMissing
                        notReturned: JsonValue = JsonMissing.of(),
                        @JsonProperty("purchase_explanation")
                        @ExcludeMissing
                        purchaseExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("received_at")
                        @ExcludeMissing
                        receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("return_attempted")
                        @ExcludeMissing
                        returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                        @JsonProperty("return_outcome")
                        @ExcludeMissing
                        returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                        @JsonProperty("returned")
                        @ExcludeMissing
                        returned: JsonField<Returned> = JsonMissing.of(),
                    ) : this(
                        merchantResolutionAttempted,
                        misrepresentationExplanation,
                        notReturned,
                        purchaseExplanation,
                        receivedAt,
                        returnAttempted,
                        returnOutcome,
                        returned,
                        mutableMapOf(),
                    )

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * Misrepresentation explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun misrepresentationExplanation(): String =
                        misrepresentationExplanation.getRequired("misrepresentation_explanation")

                    /** Not returned. Present if and only if `return_outcome` is `not_returned`. */
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    fun _notReturned(): JsonValue = notReturned

                    /**
                     * Purchase explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseExplanation(): String =
                        purchaseExplanation.getRequired("purchase_explanation")

                    /**
                     * Received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returnAttempted(): ReturnAttempted? =
                        returnAttempted.getNullable("return_attempted")

                    /**
                     * Return outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                    /**
                     * Returned. Present if and only if `return_outcome` is `returned`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returned(): Returned? = returned.getNullable("returned")

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [misrepresentationExplanation].
                     *
                     * Unlike [misrepresentationExplanation], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("misrepresentation_explanation")
                    @ExcludeMissing
                    fun _misrepresentationExplanation(): JsonField<String> =
                        misrepresentationExplanation

                    /**
                     * Returns the raw JSON value of [purchaseExplanation].
                     *
                     * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                    /**
                     * Returns the raw JSON value of [receivedAt].
                     *
                     * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    fun _receivedAt(): JsonField<LocalDate> = receivedAt

                    /**
                     * Returns the raw JSON value of [returnAttempted].
                     *
                     * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                    /**
                     * Returns the raw JSON value of [returnOutcome].
                     *
                     * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                    /**
                     * Returns the raw JSON value of [returned].
                     *
                     * Unlike [returned], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned")
                    @ExcludeMissing
                    fun _returned(): JsonField<Returned> = returned

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerMerchandiseMisrepresentation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .merchantResolutionAttempted()
                         * .misrepresentationExplanation()
                         * .notReturned()
                         * .purchaseExplanation()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerMerchandiseMisrepresentation]. */
                    class Builder internal constructor() {

                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var misrepresentationExplanation: JsonField<String>? = null
                        private var notReturned: JsonValue? = null
                        private var purchaseExplanation: JsonField<String>? = null
                        private var receivedAt: JsonField<LocalDate>? = null
                        private var returnAttempted: JsonField<ReturnAttempted>? = null
                        private var returnOutcome: JsonField<ReturnOutcome>? = null
                        private var returned: JsonField<Returned>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerMerchandiseMisrepresentation:
                                ConsumerMerchandiseMisrepresentation
                        ) = apply {
                            merchantResolutionAttempted =
                                consumerMerchandiseMisrepresentation.merchantResolutionAttempted
                            misrepresentationExplanation =
                                consumerMerchandiseMisrepresentation.misrepresentationExplanation
                            notReturned = consumerMerchandiseMisrepresentation.notReturned
                            purchaseExplanation =
                                consumerMerchandiseMisrepresentation.purchaseExplanation
                            receivedAt = consumerMerchandiseMisrepresentation.receivedAt
                            returnAttempted = consumerMerchandiseMisrepresentation.returnAttempted
                            returnOutcome = consumerMerchandiseMisrepresentation.returnOutcome
                            returned = consumerMerchandiseMisrepresentation.returned
                            additionalProperties =
                                consumerMerchandiseMisrepresentation.additionalProperties
                                    .toMutableMap()
                        }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /** Misrepresentation explanation. */
                        fun misrepresentationExplanation(misrepresentationExplanation: String) =
                            misrepresentationExplanation(JsonField.of(misrepresentationExplanation))

                        /**
                         * Sets [Builder.misrepresentationExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.misrepresentationExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun misrepresentationExplanation(
                            misrepresentationExplanation: JsonField<String>
                        ) = apply {
                            this.misrepresentationExplanation = misrepresentationExplanation
                        }

                        /**
                         * Not returned. Present if and only if `return_outcome` is `not_returned`.
                         */
                        fun notReturned(notReturned: JsonValue) = apply {
                            this.notReturned = notReturned
                        }

                        /** Purchase explanation. */
                        fun purchaseExplanation(purchaseExplanation: String) =
                            purchaseExplanation(JsonField.of(purchaseExplanation))

                        /**
                         * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                            this.purchaseExplanation = purchaseExplanation
                        }

                        /** Received at. */
                        fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                        /**
                         * Sets [Builder.receivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                            this.receivedAt = receivedAt
                        }

                        /**
                         * Return attempted. Present if and only if `return_outcome` is
                         * `return_attempted`.
                         */
                        fun returnAttempted(returnAttempted: ReturnAttempted?) =
                            returnAttempted(JsonField.ofNullable(returnAttempted))

                        /**
                         * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnAttempted] with a well-typed
                         * [ReturnAttempted] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                            this.returnAttempted = returnAttempted
                        }

                        /** Return outcome. */
                        fun returnOutcome(returnOutcome: ReturnOutcome) =
                            returnOutcome(JsonField.of(returnOutcome))

                        /**
                         * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnOutcome] with a well-typed
                         * [ReturnOutcome] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                            this.returnOutcome = returnOutcome
                        }

                        /** Returned. Present if and only if `return_outcome` is `returned`. */
                        fun returned(returned: Returned?) = returned(JsonField.ofNullable(returned))

                        /**
                         * Sets [Builder.returned] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returned] with a well-typed [Returned]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun returned(returned: JsonField<Returned>) = apply {
                            this.returned = returned
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerMerchandiseMisrepresentation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .merchantResolutionAttempted()
                         * .misrepresentationExplanation()
                         * .notReturned()
                         * .purchaseExplanation()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerMerchandiseMisrepresentation =
                            ConsumerMerchandiseMisrepresentation(
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired(
                                    "misrepresentationExplanation",
                                    misrepresentationExplanation,
                                ),
                                checkRequired("notReturned", notReturned),
                                checkRequired("purchaseExplanation", purchaseExplanation),
                                checkRequired("receivedAt", receivedAt),
                                checkRequired("returnAttempted", returnAttempted),
                                checkRequired("returnOutcome", returnOutcome),
                                checkRequired("returned", returned),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerMerchandiseMisrepresentation = apply {
                        if (validated) {
                            return@apply
                        }

                        merchantResolutionAttempted().validate()
                        misrepresentationExplanation()
                        purchaseExplanation()
                        receivedAt()
                        returnAttempted()?.validate()
                        returnOutcome().validate()
                        returned()?.validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (misrepresentationExplanation.asKnown() == null) 0 else 1) +
                            (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                            (if (receivedAt.asKnown() == null) 0 else 1) +
                            (returnAttempted.asKnown()?.validity() ?: 0) +
                            (returnOutcome.asKnown()?.validity() ?: 0) +
                            (returned.asKnown()?.validity() ?: 0)

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    class ReturnAttempted
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val attemptExplanation: JsonField<String>,
                        private val attemptReason: JsonField<AttemptReason>,
                        private val attemptedAt: JsonField<LocalDate>,
                        private val merchandiseDisposition: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("attempt_explanation")
                            @ExcludeMissing
                            attemptExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("attempt_reason")
                            @ExcludeMissing
                            attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                            @JsonProperty("attempted_at")
                            @ExcludeMissing
                            attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("merchandise_disposition")
                            @ExcludeMissing
                            merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            mutableMapOf(),
                        )

                        /**
                         * Attempt explanation.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptExplanation(): String =
                            attemptExplanation.getRequired("attempt_explanation")

                        /**
                         * Attempt reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptReason(): AttemptReason =
                            attemptReason.getRequired("attempt_reason")

                        /**
                         * Attempted at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                        /**
                         * Merchandise disposition.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun merchandiseDisposition(): String =
                            merchandiseDisposition.getRequired("merchandise_disposition")

                        /**
                         * Returns the raw JSON value of [attemptExplanation].
                         *
                         * Unlike [attemptExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        fun _attemptExplanation(): JsonField<String> = attemptExplanation

                        /**
                         * Returns the raw JSON value of [attemptReason].
                         *
                         * Unlike [attemptReason], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                        /**
                         * Returns the raw JSON value of [attemptedAt].
                         *
                         * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                        /**
                         * Returns the raw JSON value of [merchandiseDisposition].
                         *
                         * Unlike [merchandiseDisposition], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [ReturnAttempted].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [ReturnAttempted]. */
                        class Builder internal constructor() {

                            private var attemptExplanation: JsonField<String>? = null
                            private var attemptReason: JsonField<AttemptReason>? = null
                            private var attemptedAt: JsonField<LocalDate>? = null
                            private var merchandiseDisposition: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returnAttempted: ReturnAttempted) = apply {
                                attemptExplanation = returnAttempted.attemptExplanation
                                attemptReason = returnAttempted.attemptReason
                                attemptedAt = returnAttempted.attemptedAt
                                merchandiseDisposition = returnAttempted.merchandiseDisposition
                                additionalProperties =
                                    returnAttempted.additionalProperties.toMutableMap()
                            }

                            /** Attempt explanation. */
                            fun attemptExplanation(attemptExplanation: String) =
                                attemptExplanation(JsonField.of(attemptExplanation))

                            /**
                             * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptExplanation] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                                this.attemptExplanation = attemptExplanation
                            }

                            /** Attempt reason. */
                            fun attemptReason(attemptReason: AttemptReason) =
                                attemptReason(JsonField.of(attemptReason))

                            /**
                             * Sets [Builder.attemptReason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptReason] with a well-typed
                             * [AttemptReason] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                                this.attemptReason = attemptReason
                            }

                            /** Attempted at. */
                            fun attemptedAt(attemptedAt: LocalDate) =
                                attemptedAt(JsonField.of(attemptedAt))

                            /**
                             * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                                this.attemptedAt = attemptedAt
                            }

                            /** Merchandise disposition. */
                            fun merchandiseDisposition(merchandiseDisposition: String) =
                                merchandiseDisposition(JsonField.of(merchandiseDisposition))

                            /**
                             * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchandiseDisposition] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                                apply {
                                    this.merchandiseDisposition = merchandiseDisposition
                                }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [ReturnAttempted].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): ReturnAttempted =
                                ReturnAttempted(
                                    checkRequired("attemptExplanation", attemptExplanation),
                                    checkRequired("attemptReason", attemptReason),
                                    checkRequired("attemptedAt", attemptedAt),
                                    checkRequired("merchandiseDisposition", merchandiseDisposition),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): ReturnAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            attemptExplanation()
                            attemptReason().validate()
                            attemptedAt()
                            merchandiseDisposition()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (attemptExplanation.asKnown() == null) 0 else 1) +
                                (attemptReason.asKnown()?.validity() ?: 0) +
                                (if (attemptedAt.asKnown() == null) 0 else 1) +
                                (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                        /** Attempt reason. */
                        class AttemptReason
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Merchant not responding. */
                                val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                                /** No return authorization provided. */
                                val NO_RETURN_AUTHORIZATION_PROVIDED =
                                    of("no_return_authorization_provided")

                                /** No return instructions. */
                                val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                                /** Requested not to return. */
                                val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                                /** Return not accepted. */
                                val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                                fun of(value: String) = AttemptReason(JsonField.of(value))
                            }

                            /** An enum containing [AttemptReason]'s known values. */
                            enum class Known {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AttemptReason]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AttemptReason] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AttemptReason] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AttemptReason: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AttemptReason = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AttemptReason && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnAttempted &&
                                attemptExplanation == other.attemptExplanation &&
                                attemptReason == other.attemptReason &&
                                attemptedAt == other.attemptedAt &&
                                merchandiseDisposition == other.merchandiseDisposition &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                attemptExplanation,
                                attemptReason,
                                attemptedAt,
                                merchandiseDisposition,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                    }

                    /** Return outcome. */
                    class ReturnOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not returned. */
                            val NOT_RETURNED = of("not_returned")

                            /** Returned. */
                            val RETURNED = of("returned")

                            /** Return attempted. */
                            val RETURN_ATTEMPTED = of("return_attempted")

                            fun of(value: String) = ReturnOutcome(JsonField.of(value))
                        }

                        /** An enum containing [ReturnOutcome]'s known values. */
                        enum class Known {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                        }

                        /**
                         * An enum containing [ReturnOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnOutcome] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                            /**
                             * An enum member indicating that [ReturnOutcome] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_RETURNED -> Value.NOT_RETURNED
                                RETURNED -> Value.RETURNED
                                RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_RETURNED -> Known.NOT_RETURNED
                                RETURNED -> Known.RETURNED
                                RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Returned. Present if and only if `return_outcome` is `returned`. */
                    class Returned
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val merchantReceivedReturnAt: JsonField<LocalDate>,
                        private val otherExplanation: JsonField<String>,
                        private val returnMethod: JsonField<ReturnMethod>,
                        private val returnedAt: JsonField<LocalDate>,
                        private val trackingNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("merchant_received_return_at")
                            @ExcludeMissing
                            merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("other_explanation")
                            @ExcludeMissing
                            otherExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("return_method")
                            @ExcludeMissing
                            returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                            @JsonProperty("returned_at")
                            @ExcludeMissing
                            returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("tracking_number")
                            @ExcludeMissing
                            trackingNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            merchantReceivedReturnAt,
                            otherExplanation,
                            returnMethod,
                            returnedAt,
                            trackingNumber,
                            mutableMapOf(),
                        )

                        /**
                         * Merchant received return at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun merchantReceivedReturnAt(): LocalDate? =
                            merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun otherExplanation(): String? =
                            otherExplanation.getNullable("other_explanation")

                        /**
                         * Return method.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                        /**
                         * Returned at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                        /**
                         * Tracking number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun trackingNumber(): String? =
                            trackingNumber.getNullable("tracking_number")

                        /**
                         * Returns the raw JSON value of [merchantReceivedReturnAt].
                         *
                         * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        fun _merchantReceivedReturnAt(): JsonField<LocalDate> =
                            merchantReceivedReturnAt

                        /**
                         * Returns the raw JSON value of [otherExplanation].
                         *
                         * Unlike [otherExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        fun _otherExplanation(): JsonField<String> = otherExplanation

                        /**
                         * Returns the raw JSON value of [returnMethod].
                         *
                         * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                        /**
                         * Returns the raw JSON value of [returnedAt].
                         *
                         * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        fun _returnedAt(): JsonField<LocalDate> = returnedAt

                        /**
                         * Returns the raw JSON value of [trackingNumber].
                         *
                         * Unlike [trackingNumber], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        fun _trackingNumber(): JsonField<String> = trackingNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Returned].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Returned]. */
                        class Builder internal constructor() {

                            private var merchantReceivedReturnAt: JsonField<LocalDate>? = null
                            private var otherExplanation: JsonField<String>? = null
                            private var returnMethod: JsonField<ReturnMethod>? = null
                            private var returnedAt: JsonField<LocalDate>? = null
                            private var trackingNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returned: Returned) = apply {
                                merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                                otherExplanation = returned.otherExplanation
                                returnMethod = returned.returnMethod
                                returnedAt = returned.returnedAt
                                trackingNumber = returned.trackingNumber
                                additionalProperties = returned.additionalProperties.toMutableMap()
                            }

                            /** Merchant received return at. */
                            fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate?) =
                                merchantReceivedReturnAt(
                                    JsonField.ofNullable(merchantReceivedReturnAt)
                                )

                            /**
                             * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchantReceivedReturnAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchantReceivedReturnAt(
                                merchantReceivedReturnAt: JsonField<LocalDate>
                            ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                            /**
                             * Other explanation. Required if and only if the return method is
                             * `other`.
                             */
                            fun otherExplanation(otherExplanation: String?) =
                                otherExplanation(JsonField.ofNullable(otherExplanation))

                            /**
                             * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherExplanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                                this.otherExplanation = otherExplanation
                            }

                            /** Return method. */
                            fun returnMethod(returnMethod: ReturnMethod) =
                                returnMethod(JsonField.of(returnMethod))

                            /**
                             * Sets [Builder.returnMethod] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnMethod] with a well-typed
                             * [ReturnMethod] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                                this.returnMethod = returnMethod
                            }

                            /** Returned at. */
                            fun returnedAt(returnedAt: LocalDate) =
                                returnedAt(JsonField.of(returnedAt))

                            /**
                             * Sets [Builder.returnedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                                this.returnedAt = returnedAt
                            }

                            /** Tracking number. */
                            fun trackingNumber(trackingNumber: String?) =
                                trackingNumber(JsonField.ofNullable(trackingNumber))

                            /**
                             * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.trackingNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                                this.trackingNumber = trackingNumber
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Returned].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Returned =
                                Returned(
                                    checkRequired(
                                        "merchantReceivedReturnAt",
                                        merchantReceivedReturnAt,
                                    ),
                                    checkRequired("otherExplanation", otherExplanation),
                                    checkRequired("returnMethod", returnMethod),
                                    checkRequired("returnedAt", returnedAt),
                                    checkRequired("trackingNumber", trackingNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Returned = apply {
                            if (validated) {
                                return@apply
                            }

                            merchantReceivedReturnAt()
                            otherExplanation()
                            returnMethod().validate()
                            returnedAt()
                            trackingNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                                (if (otherExplanation.asKnown() == null) 0 else 1) +
                                (returnMethod.asKnown()?.validity() ?: 0) +
                                (if (returnedAt.asKnown() == null) 0 else 1) +
                                (if (trackingNumber.asKnown() == null) 0 else 1)

                        /** Return method. */
                        class ReturnMethod
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** DHL. */
                                val DHL = of("dhl")

                                /** Face-to-face. */
                                val FACE_TO_FACE = of("face_to_face")

                                /** FedEx. */
                                val FEDEX = of("fedex")

                                /** Other. */
                                val OTHER = of("other")

                                /** Postal service. */
                                val POSTAL_SERVICE = of("postal_service")

                                /** UPS. */
                                val UPS = of("ups")

                                fun of(value: String) = ReturnMethod(JsonField.of(value))
                            }

                            /** An enum containing [ReturnMethod]'s known values. */
                            enum class Known {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                            }

                            /**
                             * An enum containing [ReturnMethod]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [ReturnMethod] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                                /**
                                 * An enum member indicating that [ReturnMethod] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    DHL -> Value.DHL
                                    FACE_TO_FACE -> Value.FACE_TO_FACE
                                    FEDEX -> Value.FEDEX
                                    OTHER -> Value.OTHER
                                    POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                    UPS -> Value.UPS
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    DHL -> Known.DHL
                                    FACE_TO_FACE -> Known.FACE_TO_FACE
                                    FEDEX -> Known.FEDEX
                                    OTHER -> Known.OTHER
                                    POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                    UPS -> Known.UPS
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown ReturnMethod: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): ReturnMethod = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is ReturnMethod && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Returned &&
                                merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                                otherExplanation == other.otherExplanation &&
                                returnMethod == other.returnMethod &&
                                returnedAt == other.returnedAt &&
                                trackingNumber == other.trackingNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                merchantReceivedReturnAt,
                                otherExplanation,
                                returnMethod,
                                returnedAt,
                                trackingNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Returned{merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, returnMethod=$returnMethod, returnedAt=$returnedAt, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerMerchandiseMisrepresentation &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            misrepresentationExplanation == other.misrepresentationExplanation &&
                            notReturned == other.notReturned &&
                            purchaseExplanation == other.purchaseExplanation &&
                            receivedAt == other.receivedAt &&
                            returnAttempted == other.returnAttempted &&
                            returnOutcome == other.returnOutcome &&
                            returned == other.returned &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            merchantResolutionAttempted,
                            misrepresentationExplanation,
                            notReturned,
                            purchaseExplanation,
                            receivedAt,
                            returnAttempted,
                            returnOutcome,
                            returned,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerMerchandiseMisrepresentation{merchantResolutionAttempted=$merchantResolutionAttempted, misrepresentationExplanation=$misrepresentationExplanation, notReturned=$notReturned, purchaseExplanation=$purchaseExplanation, receivedAt=$receivedAt, returnAttempted=$returnAttempted, returnOutcome=$returnOutcome, returned=$returned, additionalProperties=$additionalProperties}"
                }

                /**
                 * Merchandise not as described. Present if and only if `category` is
                 * `consumer_merchandise_not_as_described`.
                 */
                class ConsumerMerchandiseNotAsDescribed
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val receivedAt: JsonField<LocalDate>,
                    private val returnAttempted: JsonField<ReturnAttempted>,
                    private val returnOutcome: JsonField<ReturnOutcome>,
                    private val returned: JsonField<Returned>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("received_at")
                        @ExcludeMissing
                        receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("return_attempted")
                        @ExcludeMissing
                        returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                        @JsonProperty("return_outcome")
                        @ExcludeMissing
                        returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                        @JsonProperty("returned")
                        @ExcludeMissing
                        returned: JsonField<Returned> = JsonMissing.of(),
                    ) : this(
                        merchantResolutionAttempted,
                        receivedAt,
                        returnAttempted,
                        returnOutcome,
                        returned,
                        mutableMapOf(),
                    )

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * Received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returnAttempted(): ReturnAttempted? =
                        returnAttempted.getNullable("return_attempted")

                    /**
                     * Return outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                    /**
                     * Returned. Present if and only if `return_outcome` is `returned`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returned(): Returned? = returned.getNullable("returned")

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [receivedAt].
                     *
                     * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    fun _receivedAt(): JsonField<LocalDate> = receivedAt

                    /**
                     * Returns the raw JSON value of [returnAttempted].
                     *
                     * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                    /**
                     * Returns the raw JSON value of [returnOutcome].
                     *
                     * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                    /**
                     * Returns the raw JSON value of [returned].
                     *
                     * Unlike [returned], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned")
                    @ExcludeMissing
                    fun _returned(): JsonField<Returned> = returned

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerMerchandiseNotAsDescribed].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .merchantResolutionAttempted()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerMerchandiseNotAsDescribed]. */
                    class Builder internal constructor() {

                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var receivedAt: JsonField<LocalDate>? = null
                        private var returnAttempted: JsonField<ReturnAttempted>? = null
                        private var returnOutcome: JsonField<ReturnOutcome>? = null
                        private var returned: JsonField<Returned>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerMerchandiseNotAsDescribed: ConsumerMerchandiseNotAsDescribed
                        ) = apply {
                            merchantResolutionAttempted =
                                consumerMerchandiseNotAsDescribed.merchantResolutionAttempted
                            receivedAt = consumerMerchandiseNotAsDescribed.receivedAt
                            returnAttempted = consumerMerchandiseNotAsDescribed.returnAttempted
                            returnOutcome = consumerMerchandiseNotAsDescribed.returnOutcome
                            returned = consumerMerchandiseNotAsDescribed.returned
                            additionalProperties =
                                consumerMerchandiseNotAsDescribed.additionalProperties
                                    .toMutableMap()
                        }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /** Received at. */
                        fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                        /**
                         * Sets [Builder.receivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                            this.receivedAt = receivedAt
                        }

                        /**
                         * Return attempted. Present if and only if `return_outcome` is
                         * `return_attempted`.
                         */
                        fun returnAttempted(returnAttempted: ReturnAttempted?) =
                            returnAttempted(JsonField.ofNullable(returnAttempted))

                        /**
                         * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnAttempted] with a well-typed
                         * [ReturnAttempted] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                            this.returnAttempted = returnAttempted
                        }

                        /** Return outcome. */
                        fun returnOutcome(returnOutcome: ReturnOutcome) =
                            returnOutcome(JsonField.of(returnOutcome))

                        /**
                         * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnOutcome] with a well-typed
                         * [ReturnOutcome] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                            this.returnOutcome = returnOutcome
                        }

                        /** Returned. Present if and only if `return_outcome` is `returned`. */
                        fun returned(returned: Returned?) = returned(JsonField.ofNullable(returned))

                        /**
                         * Sets [Builder.returned] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returned] with a well-typed [Returned]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun returned(returned: JsonField<Returned>) = apply {
                            this.returned = returned
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerMerchandiseNotAsDescribed].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .merchantResolutionAttempted()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerMerchandiseNotAsDescribed =
                            ConsumerMerchandiseNotAsDescribed(
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("receivedAt", receivedAt),
                                checkRequired("returnAttempted", returnAttempted),
                                checkRequired("returnOutcome", returnOutcome),
                                checkRequired("returned", returned),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerMerchandiseNotAsDescribed = apply {
                        if (validated) {
                            return@apply
                        }

                        merchantResolutionAttempted().validate()
                        receivedAt()
                        returnAttempted()?.validate()
                        returnOutcome().validate()
                        returned()?.validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (receivedAt.asKnown() == null) 0 else 1) +
                            (returnAttempted.asKnown()?.validity() ?: 0) +
                            (returnOutcome.asKnown()?.validity() ?: 0) +
                            (returned.asKnown()?.validity() ?: 0)

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    class ReturnAttempted
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val attemptExplanation: JsonField<String>,
                        private val attemptReason: JsonField<AttemptReason>,
                        private val attemptedAt: JsonField<LocalDate>,
                        private val merchandiseDisposition: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("attempt_explanation")
                            @ExcludeMissing
                            attemptExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("attempt_reason")
                            @ExcludeMissing
                            attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                            @JsonProperty("attempted_at")
                            @ExcludeMissing
                            attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("merchandise_disposition")
                            @ExcludeMissing
                            merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            mutableMapOf(),
                        )

                        /**
                         * Attempt explanation.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptExplanation(): String =
                            attemptExplanation.getRequired("attempt_explanation")

                        /**
                         * Attempt reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptReason(): AttemptReason =
                            attemptReason.getRequired("attempt_reason")

                        /**
                         * Attempted at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                        /**
                         * Merchandise disposition.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun merchandiseDisposition(): String =
                            merchandiseDisposition.getRequired("merchandise_disposition")

                        /**
                         * Returns the raw JSON value of [attemptExplanation].
                         *
                         * Unlike [attemptExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        fun _attemptExplanation(): JsonField<String> = attemptExplanation

                        /**
                         * Returns the raw JSON value of [attemptReason].
                         *
                         * Unlike [attemptReason], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                        /**
                         * Returns the raw JSON value of [attemptedAt].
                         *
                         * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                        /**
                         * Returns the raw JSON value of [merchandiseDisposition].
                         *
                         * Unlike [merchandiseDisposition], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [ReturnAttempted].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [ReturnAttempted]. */
                        class Builder internal constructor() {

                            private var attemptExplanation: JsonField<String>? = null
                            private var attemptReason: JsonField<AttemptReason>? = null
                            private var attemptedAt: JsonField<LocalDate>? = null
                            private var merchandiseDisposition: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returnAttempted: ReturnAttempted) = apply {
                                attemptExplanation = returnAttempted.attemptExplanation
                                attemptReason = returnAttempted.attemptReason
                                attemptedAt = returnAttempted.attemptedAt
                                merchandiseDisposition = returnAttempted.merchandiseDisposition
                                additionalProperties =
                                    returnAttempted.additionalProperties.toMutableMap()
                            }

                            /** Attempt explanation. */
                            fun attemptExplanation(attemptExplanation: String) =
                                attemptExplanation(JsonField.of(attemptExplanation))

                            /**
                             * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptExplanation] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                                this.attemptExplanation = attemptExplanation
                            }

                            /** Attempt reason. */
                            fun attemptReason(attemptReason: AttemptReason) =
                                attemptReason(JsonField.of(attemptReason))

                            /**
                             * Sets [Builder.attemptReason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptReason] with a well-typed
                             * [AttemptReason] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                                this.attemptReason = attemptReason
                            }

                            /** Attempted at. */
                            fun attemptedAt(attemptedAt: LocalDate) =
                                attemptedAt(JsonField.of(attemptedAt))

                            /**
                             * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                                this.attemptedAt = attemptedAt
                            }

                            /** Merchandise disposition. */
                            fun merchandiseDisposition(merchandiseDisposition: String) =
                                merchandiseDisposition(JsonField.of(merchandiseDisposition))

                            /**
                             * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchandiseDisposition] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                                apply {
                                    this.merchandiseDisposition = merchandiseDisposition
                                }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [ReturnAttempted].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): ReturnAttempted =
                                ReturnAttempted(
                                    checkRequired("attemptExplanation", attemptExplanation),
                                    checkRequired("attemptReason", attemptReason),
                                    checkRequired("attemptedAt", attemptedAt),
                                    checkRequired("merchandiseDisposition", merchandiseDisposition),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): ReturnAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            attemptExplanation()
                            attemptReason().validate()
                            attemptedAt()
                            merchandiseDisposition()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (attemptExplanation.asKnown() == null) 0 else 1) +
                                (attemptReason.asKnown()?.validity() ?: 0) +
                                (if (attemptedAt.asKnown() == null) 0 else 1) +
                                (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                        /** Attempt reason. */
                        class AttemptReason
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Merchant not responding. */
                                val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                                /** No return authorization provided. */
                                val NO_RETURN_AUTHORIZATION_PROVIDED =
                                    of("no_return_authorization_provided")

                                /** No return instructions. */
                                val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                                /** Requested not to return. */
                                val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                                /** Return not accepted. */
                                val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                                fun of(value: String) = AttemptReason(JsonField.of(value))
                            }

                            /** An enum containing [AttemptReason]'s known values. */
                            enum class Known {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AttemptReason]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AttemptReason] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AttemptReason] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AttemptReason: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AttemptReason = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AttemptReason && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnAttempted &&
                                attemptExplanation == other.attemptExplanation &&
                                attemptReason == other.attemptReason &&
                                attemptedAt == other.attemptedAt &&
                                merchandiseDisposition == other.merchandiseDisposition &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                attemptExplanation,
                                attemptReason,
                                attemptedAt,
                                merchandiseDisposition,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                    }

                    /** Return outcome. */
                    class ReturnOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Returned. */
                            val RETURNED = of("returned")

                            /** Return attempted. */
                            val RETURN_ATTEMPTED = of("return_attempted")

                            fun of(value: String) = ReturnOutcome(JsonField.of(value))
                        }

                        /** An enum containing [ReturnOutcome]'s known values. */
                        enum class Known {
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                        }

                        /**
                         * An enum containing [ReturnOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnOutcome] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                            /**
                             * An enum member indicating that [ReturnOutcome] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                RETURNED -> Value.RETURNED
                                RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                RETURNED -> Known.RETURNED
                                RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Returned. Present if and only if `return_outcome` is `returned`. */
                    class Returned
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val merchantReceivedReturnAt: JsonField<LocalDate>,
                        private val otherExplanation: JsonField<String>,
                        private val returnMethod: JsonField<ReturnMethod>,
                        private val returnedAt: JsonField<LocalDate>,
                        private val trackingNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("merchant_received_return_at")
                            @ExcludeMissing
                            merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("other_explanation")
                            @ExcludeMissing
                            otherExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("return_method")
                            @ExcludeMissing
                            returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                            @JsonProperty("returned_at")
                            @ExcludeMissing
                            returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("tracking_number")
                            @ExcludeMissing
                            trackingNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            merchantReceivedReturnAt,
                            otherExplanation,
                            returnMethod,
                            returnedAt,
                            trackingNumber,
                            mutableMapOf(),
                        )

                        /**
                         * Merchant received return at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun merchantReceivedReturnAt(): LocalDate? =
                            merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun otherExplanation(): String? =
                            otherExplanation.getNullable("other_explanation")

                        /**
                         * Return method.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                        /**
                         * Returned at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                        /**
                         * Tracking number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun trackingNumber(): String? =
                            trackingNumber.getNullable("tracking_number")

                        /**
                         * Returns the raw JSON value of [merchantReceivedReturnAt].
                         *
                         * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        fun _merchantReceivedReturnAt(): JsonField<LocalDate> =
                            merchantReceivedReturnAt

                        /**
                         * Returns the raw JSON value of [otherExplanation].
                         *
                         * Unlike [otherExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        fun _otherExplanation(): JsonField<String> = otherExplanation

                        /**
                         * Returns the raw JSON value of [returnMethod].
                         *
                         * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                        /**
                         * Returns the raw JSON value of [returnedAt].
                         *
                         * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        fun _returnedAt(): JsonField<LocalDate> = returnedAt

                        /**
                         * Returns the raw JSON value of [trackingNumber].
                         *
                         * Unlike [trackingNumber], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        fun _trackingNumber(): JsonField<String> = trackingNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Returned].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Returned]. */
                        class Builder internal constructor() {

                            private var merchantReceivedReturnAt: JsonField<LocalDate>? = null
                            private var otherExplanation: JsonField<String>? = null
                            private var returnMethod: JsonField<ReturnMethod>? = null
                            private var returnedAt: JsonField<LocalDate>? = null
                            private var trackingNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returned: Returned) = apply {
                                merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                                otherExplanation = returned.otherExplanation
                                returnMethod = returned.returnMethod
                                returnedAt = returned.returnedAt
                                trackingNumber = returned.trackingNumber
                                additionalProperties = returned.additionalProperties.toMutableMap()
                            }

                            /** Merchant received return at. */
                            fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate?) =
                                merchantReceivedReturnAt(
                                    JsonField.ofNullable(merchantReceivedReturnAt)
                                )

                            /**
                             * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchantReceivedReturnAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchantReceivedReturnAt(
                                merchantReceivedReturnAt: JsonField<LocalDate>
                            ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                            /**
                             * Other explanation. Required if and only if the return method is
                             * `other`.
                             */
                            fun otherExplanation(otherExplanation: String?) =
                                otherExplanation(JsonField.ofNullable(otherExplanation))

                            /**
                             * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherExplanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                                this.otherExplanation = otherExplanation
                            }

                            /** Return method. */
                            fun returnMethod(returnMethod: ReturnMethod) =
                                returnMethod(JsonField.of(returnMethod))

                            /**
                             * Sets [Builder.returnMethod] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnMethod] with a well-typed
                             * [ReturnMethod] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                                this.returnMethod = returnMethod
                            }

                            /** Returned at. */
                            fun returnedAt(returnedAt: LocalDate) =
                                returnedAt(JsonField.of(returnedAt))

                            /**
                             * Sets [Builder.returnedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                                this.returnedAt = returnedAt
                            }

                            /** Tracking number. */
                            fun trackingNumber(trackingNumber: String?) =
                                trackingNumber(JsonField.ofNullable(trackingNumber))

                            /**
                             * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.trackingNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                                this.trackingNumber = trackingNumber
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Returned].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Returned =
                                Returned(
                                    checkRequired(
                                        "merchantReceivedReturnAt",
                                        merchantReceivedReturnAt,
                                    ),
                                    checkRequired("otherExplanation", otherExplanation),
                                    checkRequired("returnMethod", returnMethod),
                                    checkRequired("returnedAt", returnedAt),
                                    checkRequired("trackingNumber", trackingNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Returned = apply {
                            if (validated) {
                                return@apply
                            }

                            merchantReceivedReturnAt()
                            otherExplanation()
                            returnMethod().validate()
                            returnedAt()
                            trackingNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                                (if (otherExplanation.asKnown() == null) 0 else 1) +
                                (returnMethod.asKnown()?.validity() ?: 0) +
                                (if (returnedAt.asKnown() == null) 0 else 1) +
                                (if (trackingNumber.asKnown() == null) 0 else 1)

                        /** Return method. */
                        class ReturnMethod
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** DHL. */
                                val DHL = of("dhl")

                                /** Face-to-face. */
                                val FACE_TO_FACE = of("face_to_face")

                                /** FedEx. */
                                val FEDEX = of("fedex")

                                /** Other. */
                                val OTHER = of("other")

                                /** Postal service. */
                                val POSTAL_SERVICE = of("postal_service")

                                /** UPS. */
                                val UPS = of("ups")

                                fun of(value: String) = ReturnMethod(JsonField.of(value))
                            }

                            /** An enum containing [ReturnMethod]'s known values. */
                            enum class Known {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                            }

                            /**
                             * An enum containing [ReturnMethod]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [ReturnMethod] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                                /**
                                 * An enum member indicating that [ReturnMethod] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    DHL -> Value.DHL
                                    FACE_TO_FACE -> Value.FACE_TO_FACE
                                    FEDEX -> Value.FEDEX
                                    OTHER -> Value.OTHER
                                    POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                    UPS -> Value.UPS
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    DHL -> Known.DHL
                                    FACE_TO_FACE -> Known.FACE_TO_FACE
                                    FEDEX -> Known.FEDEX
                                    OTHER -> Known.OTHER
                                    POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                    UPS -> Known.UPS
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown ReturnMethod: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): ReturnMethod = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is ReturnMethod && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Returned &&
                                merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                                otherExplanation == other.otherExplanation &&
                                returnMethod == other.returnMethod &&
                                returnedAt == other.returnedAt &&
                                trackingNumber == other.trackingNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                merchantReceivedReturnAt,
                                otherExplanation,
                                returnMethod,
                                returnedAt,
                                trackingNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Returned{merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, returnMethod=$returnMethod, returnedAt=$returnedAt, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerMerchandiseNotAsDescribed &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            receivedAt == other.receivedAt &&
                            returnAttempted == other.returnAttempted &&
                            returnOutcome == other.returnOutcome &&
                            returned == other.returned &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            merchantResolutionAttempted,
                            receivedAt,
                            returnAttempted,
                            returnOutcome,
                            returned,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerMerchandiseNotAsDescribed{merchantResolutionAttempted=$merchantResolutionAttempted, receivedAt=$receivedAt, returnAttempted=$returnAttempted, returnOutcome=$returnOutcome, returned=$returned, additionalProperties=$additionalProperties}"
                }

                /**
                 * Merchandise not received. Present if and only if `category` is
                 * `consumer_merchandise_not_received`.
                 */
                class ConsumerMerchandiseNotReceived
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cancellationOutcome: JsonField<CancellationOutcome>,
                    private val cardholderCancellationPriorToExpectedReceipt:
                        JsonField<CardholderCancellationPriorToExpectedReceipt>,
                    private val delayed: JsonField<Delayed>,
                    private val deliveredToWrongLocation: JsonField<DeliveredToWrongLocation>,
                    private val deliveryIssue: JsonField<DeliveryIssue>,
                    private val lastExpectedReceiptAt: JsonField<LocalDate>,
                    private val merchantCancellation: JsonField<MerchantCancellation>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val noCancellation: JsonValue,
                    private val purchaseInfoAndExplanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cancellation_outcome")
                        @ExcludeMissing
                        cancellationOutcome: JsonField<CancellationOutcome> = JsonMissing.of(),
                        @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                        @ExcludeMissing
                        cardholderCancellationPriorToExpectedReceipt:
                            JsonField<CardholderCancellationPriorToExpectedReceipt> =
                            JsonMissing.of(),
                        @JsonProperty("delayed")
                        @ExcludeMissing
                        delayed: JsonField<Delayed> = JsonMissing.of(),
                        @JsonProperty("delivered_to_wrong_location")
                        @ExcludeMissing
                        deliveredToWrongLocation: JsonField<DeliveredToWrongLocation> =
                            JsonMissing.of(),
                        @JsonProperty("delivery_issue")
                        @ExcludeMissing
                        deliveryIssue: JsonField<DeliveryIssue> = JsonMissing.of(),
                        @JsonProperty("last_expected_receipt_at")
                        @ExcludeMissing
                        lastExpectedReceiptAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_cancellation")
                        @ExcludeMissing
                        merchantCancellation: JsonField<MerchantCancellation> = JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("no_cancellation")
                        @ExcludeMissing
                        noCancellation: JsonValue = JsonMissing.of(),
                        @JsonProperty("purchase_info_and_explanation")
                        @ExcludeMissing
                        purchaseInfoAndExplanation: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        cancellationOutcome,
                        cardholderCancellationPriorToExpectedReceipt,
                        delayed,
                        deliveredToWrongLocation,
                        deliveryIssue,
                        lastExpectedReceiptAt,
                        merchantCancellation,
                        merchantResolutionAttempted,
                        noCancellation,
                        purchaseInfoAndExplanation,
                        mutableMapOf(),
                    )

                    /**
                     * Cancellation outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cancellationOutcome(): CancellationOutcome =
                        cancellationOutcome.getRequired("cancellation_outcome")

                    /**
                     * Cardholder cancellation prior to expected receipt. Present if and only if
                     * `cancellation_outcome` is
                     * `cardholder_cancellation_prior_to_expected_receipt`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun cardholderCancellationPriorToExpectedReceipt():
                        CardholderCancellationPriorToExpectedReceipt? =
                        cardholderCancellationPriorToExpectedReceipt.getNullable(
                            "cardholder_cancellation_prior_to_expected_receipt"
                        )

                    /**
                     * Delayed. Present if and only if `delivery_issue` is `delayed`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun delayed(): Delayed? = delayed.getNullable("delayed")

                    /**
                     * Delivered to wrong location. Present if and only if `delivery_issue` is
                     * `delivered_to_wrong_location`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun deliveredToWrongLocation(): DeliveredToWrongLocation? =
                        deliveredToWrongLocation.getNullable("delivered_to_wrong_location")

                    /**
                     * Delivery issue.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun deliveryIssue(): DeliveryIssue = deliveryIssue.getRequired("delivery_issue")

                    /**
                     * Last expected receipt at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun lastExpectedReceiptAt(): LocalDate =
                        lastExpectedReceiptAt.getRequired("last_expected_receipt_at")

                    /**
                     * Merchant cancellation. Present if and only if `cancellation_outcome` is
                     * `merchant_cancellation`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun merchantCancellation(): MerchantCancellation? =
                        merchantCancellation.getNullable("merchant_cancellation")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * No cancellation. Present if and only if `cancellation_outcome` is
                     * `no_cancellation`.
                     */
                    @JsonProperty("no_cancellation")
                    @ExcludeMissing
                    fun _noCancellation(): JsonValue = noCancellation

                    /**
                     * Purchase information and explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseInfoAndExplanation(): String =
                        purchaseInfoAndExplanation.getRequired("purchase_info_and_explanation")

                    /**
                     * Returns the raw JSON value of [cancellationOutcome].
                     *
                     * Unlike [cancellationOutcome], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("cancellation_outcome")
                    @ExcludeMissing
                    fun _cancellationOutcome(): JsonField<CancellationOutcome> = cancellationOutcome

                    /**
                     * Returns the raw JSON value of [cardholderCancellationPriorToExpectedReceipt].
                     *
                     * Unlike [cardholderCancellationPriorToExpectedReceipt], this method doesn't
                     * throw if the JSON field has an unexpected type.
                     */
                    @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                    @ExcludeMissing
                    fun _cardholderCancellationPriorToExpectedReceipt():
                        JsonField<CardholderCancellationPriorToExpectedReceipt> =
                        cardholderCancellationPriorToExpectedReceipt

                    /**
                     * Returns the raw JSON value of [delayed].
                     *
                     * Unlike [delayed], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("delayed")
                    @ExcludeMissing
                    fun _delayed(): JsonField<Delayed> = delayed

                    /**
                     * Returns the raw JSON value of [deliveredToWrongLocation].
                     *
                     * Unlike [deliveredToWrongLocation], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("delivered_to_wrong_location")
                    @ExcludeMissing
                    fun _deliveredToWrongLocation(): JsonField<DeliveredToWrongLocation> =
                        deliveredToWrongLocation

                    /**
                     * Returns the raw JSON value of [deliveryIssue].
                     *
                     * Unlike [deliveryIssue], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("delivery_issue")
                    @ExcludeMissing
                    fun _deliveryIssue(): JsonField<DeliveryIssue> = deliveryIssue

                    /**
                     * Returns the raw JSON value of [lastExpectedReceiptAt].
                     *
                     * Unlike [lastExpectedReceiptAt], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("last_expected_receipt_at")
                    @ExcludeMissing
                    fun _lastExpectedReceiptAt(): JsonField<LocalDate> = lastExpectedReceiptAt

                    /**
                     * Returns the raw JSON value of [merchantCancellation].
                     *
                     * Unlike [merchantCancellation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchant_cancellation")
                    @ExcludeMissing
                    fun _merchantCancellation(): JsonField<MerchantCancellation> =
                        merchantCancellation

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [purchaseInfoAndExplanation].
                     *
                     * Unlike [purchaseInfoAndExplanation], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("purchase_info_and_explanation")
                    @ExcludeMissing
                    fun _purchaseInfoAndExplanation(): JsonField<String> =
                        purchaseInfoAndExplanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerMerchandiseNotReceived].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cancellationOutcome()
                         * .cardholderCancellationPriorToExpectedReceipt()
                         * .delayed()
                         * .deliveredToWrongLocation()
                         * .deliveryIssue()
                         * .lastExpectedReceiptAt()
                         * .merchantCancellation()
                         * .merchantResolutionAttempted()
                         * .noCancellation()
                         * .purchaseInfoAndExplanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerMerchandiseNotReceived]. */
                    class Builder internal constructor() {

                        private var cancellationOutcome: JsonField<CancellationOutcome>? = null
                        private var cardholderCancellationPriorToExpectedReceipt:
                            JsonField<CardholderCancellationPriorToExpectedReceipt>? =
                            null
                        private var delayed: JsonField<Delayed>? = null
                        private var deliveredToWrongLocation: JsonField<DeliveredToWrongLocation>? =
                            null
                        private var deliveryIssue: JsonField<DeliveryIssue>? = null
                        private var lastExpectedReceiptAt: JsonField<LocalDate>? = null
                        private var merchantCancellation: JsonField<MerchantCancellation>? = null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var noCancellation: JsonValue? = null
                        private var purchaseInfoAndExplanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerMerchandiseNotReceived: ConsumerMerchandiseNotReceived
                        ) = apply {
                            cancellationOutcome = consumerMerchandiseNotReceived.cancellationOutcome
                            cardholderCancellationPriorToExpectedReceipt =
                                consumerMerchandiseNotReceived
                                    .cardholderCancellationPriorToExpectedReceipt
                            delayed = consumerMerchandiseNotReceived.delayed
                            deliveredToWrongLocation =
                                consumerMerchandiseNotReceived.deliveredToWrongLocation
                            deliveryIssue = consumerMerchandiseNotReceived.deliveryIssue
                            lastExpectedReceiptAt =
                                consumerMerchandiseNotReceived.lastExpectedReceiptAt
                            merchantCancellation =
                                consumerMerchandiseNotReceived.merchantCancellation
                            merchantResolutionAttempted =
                                consumerMerchandiseNotReceived.merchantResolutionAttempted
                            noCancellation = consumerMerchandiseNotReceived.noCancellation
                            purchaseInfoAndExplanation =
                                consumerMerchandiseNotReceived.purchaseInfoAndExplanation
                            additionalProperties =
                                consumerMerchandiseNotReceived.additionalProperties.toMutableMap()
                        }

                        /** Cancellation outcome. */
                        fun cancellationOutcome(cancellationOutcome: CancellationOutcome) =
                            cancellationOutcome(JsonField.of(cancellationOutcome))

                        /**
                         * Sets [Builder.cancellationOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cancellationOutcome] with a well-typed
                         * [CancellationOutcome] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun cancellationOutcome(
                            cancellationOutcome: JsonField<CancellationOutcome>
                        ) = apply { this.cancellationOutcome = cancellationOutcome }

                        /**
                         * Cardholder cancellation prior to expected receipt. Present if and only if
                         * `cancellation_outcome` is
                         * `cardholder_cancellation_prior_to_expected_receipt`.
                         */
                        fun cardholderCancellationPriorToExpectedReceipt(
                            cardholderCancellationPriorToExpectedReceipt:
                                CardholderCancellationPriorToExpectedReceipt?
                        ) =
                            cardholderCancellationPriorToExpectedReceipt(
                                JsonField.ofNullable(cardholderCancellationPriorToExpectedReceipt)
                            )

                        /**
                         * Sets [Builder.cardholderCancellationPriorToExpectedReceipt] to an
                         * arbitrary JSON value.
                         *
                         * You should usually call
                         * [Builder.cardholderCancellationPriorToExpectedReceipt] with a well-typed
                         * [CardholderCancellationPriorToExpectedReceipt] value instead. This method
                         * is primarily for setting the field to an undocumented or not yet
                         * supported value.
                         */
                        fun cardholderCancellationPriorToExpectedReceipt(
                            cardholderCancellationPriorToExpectedReceipt:
                                JsonField<CardholderCancellationPriorToExpectedReceipt>
                        ) = apply {
                            this.cardholderCancellationPriorToExpectedReceipt =
                                cardholderCancellationPriorToExpectedReceipt
                        }

                        /** Delayed. Present if and only if `delivery_issue` is `delayed`. */
                        fun delayed(delayed: Delayed?) = delayed(JsonField.ofNullable(delayed))

                        /**
                         * Sets [Builder.delayed] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.delayed] with a well-typed [Delayed]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun delayed(delayed: JsonField<Delayed>) = apply { this.delayed = delayed }

                        /**
                         * Delivered to wrong location. Present if and only if `delivery_issue` is
                         * `delivered_to_wrong_location`.
                         */
                        fun deliveredToWrongLocation(
                            deliveredToWrongLocation: DeliveredToWrongLocation?
                        ) = deliveredToWrongLocation(JsonField.ofNullable(deliveredToWrongLocation))

                        /**
                         * Sets [Builder.deliveredToWrongLocation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.deliveredToWrongLocation] with a
                         * well-typed [DeliveredToWrongLocation] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun deliveredToWrongLocation(
                            deliveredToWrongLocation: JsonField<DeliveredToWrongLocation>
                        ) = apply { this.deliveredToWrongLocation = deliveredToWrongLocation }

                        /** Delivery issue. */
                        fun deliveryIssue(deliveryIssue: DeliveryIssue) =
                            deliveryIssue(JsonField.of(deliveryIssue))

                        /**
                         * Sets [Builder.deliveryIssue] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.deliveryIssue] with a well-typed
                         * [DeliveryIssue] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun deliveryIssue(deliveryIssue: JsonField<DeliveryIssue>) = apply {
                            this.deliveryIssue = deliveryIssue
                        }

                        /** Last expected receipt at. */
                        fun lastExpectedReceiptAt(lastExpectedReceiptAt: LocalDate) =
                            lastExpectedReceiptAt(JsonField.of(lastExpectedReceiptAt))

                        /**
                         * Sets [Builder.lastExpectedReceiptAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.lastExpectedReceiptAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun lastExpectedReceiptAt(lastExpectedReceiptAt: JsonField<LocalDate>) =
                            apply {
                                this.lastExpectedReceiptAt = lastExpectedReceiptAt
                            }

                        /**
                         * Merchant cancellation. Present if and only if `cancellation_outcome` is
                         * `merchant_cancellation`.
                         */
                        fun merchantCancellation(merchantCancellation: MerchantCancellation?) =
                            merchantCancellation(JsonField.ofNullable(merchantCancellation))

                        /**
                         * Sets [Builder.merchantCancellation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantCancellation] with a well-typed
                         * [MerchantCancellation] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun merchantCancellation(
                            merchantCancellation: JsonField<MerchantCancellation>
                        ) = apply { this.merchantCancellation = merchantCancellation }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /**
                         * No cancellation. Present if and only if `cancellation_outcome` is
                         * `no_cancellation`.
                         */
                        fun noCancellation(noCancellation: JsonValue) = apply {
                            this.noCancellation = noCancellation
                        }

                        /** Purchase information and explanation. */
                        fun purchaseInfoAndExplanation(purchaseInfoAndExplanation: String) =
                            purchaseInfoAndExplanation(JsonField.of(purchaseInfoAndExplanation))

                        /**
                         * Sets [Builder.purchaseInfoAndExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseInfoAndExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun purchaseInfoAndExplanation(
                            purchaseInfoAndExplanation: JsonField<String>
                        ) = apply { this.purchaseInfoAndExplanation = purchaseInfoAndExplanation }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerMerchandiseNotReceived].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cancellationOutcome()
                         * .cardholderCancellationPriorToExpectedReceipt()
                         * .delayed()
                         * .deliveredToWrongLocation()
                         * .deliveryIssue()
                         * .lastExpectedReceiptAt()
                         * .merchantCancellation()
                         * .merchantResolutionAttempted()
                         * .noCancellation()
                         * .purchaseInfoAndExplanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerMerchandiseNotReceived =
                            ConsumerMerchandiseNotReceived(
                                checkRequired("cancellationOutcome", cancellationOutcome),
                                checkRequired(
                                    "cardholderCancellationPriorToExpectedReceipt",
                                    cardholderCancellationPriorToExpectedReceipt,
                                ),
                                checkRequired("delayed", delayed),
                                checkRequired("deliveredToWrongLocation", deliveredToWrongLocation),
                                checkRequired("deliveryIssue", deliveryIssue),
                                checkRequired("lastExpectedReceiptAt", lastExpectedReceiptAt),
                                checkRequired("merchantCancellation", merchantCancellation),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("noCancellation", noCancellation),
                                checkRequired(
                                    "purchaseInfoAndExplanation",
                                    purchaseInfoAndExplanation,
                                ),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerMerchandiseNotReceived = apply {
                        if (validated) {
                            return@apply
                        }

                        cancellationOutcome().validate()
                        cardholderCancellationPriorToExpectedReceipt()?.validate()
                        delayed()?.validate()
                        deliveredToWrongLocation()?.validate()
                        deliveryIssue().validate()
                        lastExpectedReceiptAt()
                        merchantCancellation()?.validate()
                        merchantResolutionAttempted().validate()
                        purchaseInfoAndExplanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cancellationOutcome.asKnown()?.validity() ?: 0) +
                            (cardholderCancellationPriorToExpectedReceipt.asKnown()?.validity()
                                ?: 0) +
                            (delayed.asKnown()?.validity() ?: 0) +
                            (deliveredToWrongLocation.asKnown()?.validity() ?: 0) +
                            (deliveryIssue.asKnown()?.validity() ?: 0) +
                            (if (lastExpectedReceiptAt.asKnown() == null) 0 else 1) +
                            (merchantCancellation.asKnown()?.validity() ?: 0) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (purchaseInfoAndExplanation.asKnown() == null) 0 else 1)

                    /** Cancellation outcome. */
                    class CancellationOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Cardholder cancellation prior to expected receipt. */
                            val CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT =
                                of("cardholder_cancellation_prior_to_expected_receipt")

                            /** Merchant cancellation. */
                            val MERCHANT_CANCELLATION = of("merchant_cancellation")

                            /** No cancellation. */
                            val NO_CANCELLATION = of("no_cancellation")

                            fun of(value: String) = CancellationOutcome(JsonField.of(value))
                        }

                        /** An enum containing [CancellationOutcome]'s known values. */
                        enum class Known {
                            /** Cardholder cancellation prior to expected receipt. */
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                            /** Merchant cancellation. */
                            MERCHANT_CANCELLATION,
                            /** No cancellation. */
                            NO_CANCELLATION,
                        }

                        /**
                         * An enum containing [CancellationOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [CancellationOutcome] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Cardholder cancellation prior to expected receipt. */
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                            /** Merchant cancellation. */
                            MERCHANT_CANCELLATION,
                            /** No cancellation. */
                            NO_CANCELLATION,
                            /**
                             * An enum member indicating that [CancellationOutcome] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                    Value.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                                MERCHANT_CANCELLATION -> Value.MERCHANT_CANCELLATION
                                NO_CANCELLATION -> Value.NO_CANCELLATION
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                    Known.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                                MERCHANT_CANCELLATION -> Known.MERCHANT_CANCELLATION
                                NO_CANCELLATION -> Known.NO_CANCELLATION
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CancellationOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CancellationOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CancellationOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Cardholder cancellation prior to expected receipt. Present if and only if
                     * `cancellation_outcome` is
                     * `cardholder_cancellation_prior_to_expected_receipt`.
                     */
                    class CardholderCancellationPriorToExpectedReceipt
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val canceledAt: JsonField<LocalDate>,
                        private val reason: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("reason")
                            @ExcludeMissing
                            reason: JsonField<String> = JsonMissing.of(),
                        ) : this(canceledAt, reason, mutableMapOf())

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun reason(): String? = reason.getNullable("reason")

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        /**
                         * Returns the raw JSON value of [reason].
                         *
                         * Unlike [reason], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("reason")
                        @ExcludeMissing
                        fun _reason(): JsonField<String> = reason

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [CardholderCancellationPriorToExpectedReceipt].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .reason()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [CardholderCancellationPriorToExpectedReceipt]. */
                        class Builder internal constructor() {

                            private var canceledAt: JsonField<LocalDate>? = null
                            private var reason: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(
                                cardholderCancellationPriorToExpectedReceipt:
                                    CardholderCancellationPriorToExpectedReceipt
                            ) = apply {
                                canceledAt = cardholderCancellationPriorToExpectedReceipt.canceledAt
                                reason = cardholderCancellationPriorToExpectedReceipt.reason
                                additionalProperties =
                                    cardholderCancellationPriorToExpectedReceipt
                                        .additionalProperties
                                        .toMutableMap()
                            }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            /** Reason. */
                            fun reason(reason: String?) = reason(JsonField.ofNullable(reason))

                            /**
                             * Sets [Builder.reason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.reason] with a well-typed [String]
                             * value instead. This method is primarily for setting the field to an
                             * undocumented or not yet supported value.
                             */
                            fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of
                             * [CardholderCancellationPriorToExpectedReceipt].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .reason()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): CardholderCancellationPriorToExpectedReceipt =
                                CardholderCancellationPriorToExpectedReceipt(
                                    checkRequired("canceledAt", canceledAt),
                                    checkRequired("reason", reason),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): CardholderCancellationPriorToExpectedReceipt = apply {
                            if (validated) {
                                return@apply
                            }

                            canceledAt()
                            reason()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (canceledAt.asKnown() == null) 0 else 1) +
                                (if (reason.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderCancellationPriorToExpectedReceipt &&
                                canceledAt == other.canceledAt &&
                                reason == other.reason &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(canceledAt, reason, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "CardholderCancellationPriorToExpectedReceipt{canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                    }

                    /** Delayed. Present if and only if `delivery_issue` is `delayed`. */
                    class Delayed
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val explanation: JsonField<String>,
                        private val notReturned: JsonValue,
                        private val returnAttempted: JsonField<ReturnAttempted>,
                        private val returnOutcome: JsonField<ReturnOutcome>,
                        private val returned: JsonField<Returned>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("explanation")
                            @ExcludeMissing
                            explanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("not_returned")
                            @ExcludeMissing
                            notReturned: JsonValue = JsonMissing.of(),
                            @JsonProperty("return_attempted")
                            @ExcludeMissing
                            returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                            @JsonProperty("return_outcome")
                            @ExcludeMissing
                            returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                            @JsonProperty("returned")
                            @ExcludeMissing
                            returned: JsonField<Returned> = JsonMissing.of(),
                        ) : this(
                            explanation,
                            notReturned,
                            returnAttempted,
                            returnOutcome,
                            returned,
                            mutableMapOf(),
                        )

                        /**
                         * Explanation.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun explanation(): String = explanation.getRequired("explanation")

                        /**
                         * Not returned. Present if and only if `return_outcome` is `not_returned`.
                         */
                        @JsonProperty("not_returned")
                        @ExcludeMissing
                        fun _notReturned(): JsonValue = notReturned

                        /**
                         * Return attempted. Present if and only if `return_outcome` is
                         * `return_attempted`.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun returnAttempted(): ReturnAttempted? =
                            returnAttempted.getNullable("return_attempted")

                        /**
                         * Return outcome.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnOutcome(): ReturnOutcome =
                            returnOutcome.getRequired("return_outcome")

                        /**
                         * Returned. Present if and only if `return_outcome` is `returned`.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun returned(): Returned? = returned.getNullable("returned")

                        /**
                         * Returns the raw JSON value of [explanation].
                         *
                         * Unlike [explanation], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        fun _explanation(): JsonField<String> = explanation

                        /**
                         * Returns the raw JSON value of [returnAttempted].
                         *
                         * Unlike [returnAttempted], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("return_attempted")
                        @ExcludeMissing
                        fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                        /**
                         * Returns the raw JSON value of [returnOutcome].
                         *
                         * Unlike [returnOutcome], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("return_outcome")
                        @ExcludeMissing
                        fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                        /**
                         * Returns the raw JSON value of [returned].
                         *
                         * Unlike [returned], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("returned")
                        @ExcludeMissing
                        fun _returned(): JsonField<Returned> = returned

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Delayed].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * .notReturned()
                             * .returnAttempted()
                             * .returnOutcome()
                             * .returned()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Delayed]. */
                        class Builder internal constructor() {

                            private var explanation: JsonField<String>? = null
                            private var notReturned: JsonValue? = null
                            private var returnAttempted: JsonField<ReturnAttempted>? = null
                            private var returnOutcome: JsonField<ReturnOutcome>? = null
                            private var returned: JsonField<Returned>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(delayed: Delayed) = apply {
                                explanation = delayed.explanation
                                notReturned = delayed.notReturned
                                returnAttempted = delayed.returnAttempted
                                returnOutcome = delayed.returnOutcome
                                returned = delayed.returned
                                additionalProperties = delayed.additionalProperties.toMutableMap()
                            }

                            /** Explanation. */
                            fun explanation(explanation: String) =
                                explanation(JsonField.of(explanation))

                            /**
                             * Sets [Builder.explanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.explanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun explanation(explanation: JsonField<String>) = apply {
                                this.explanation = explanation
                            }

                            /**
                             * Not returned. Present if and only if `return_outcome` is
                             * `not_returned`.
                             */
                            fun notReturned(notReturned: JsonValue) = apply {
                                this.notReturned = notReturned
                            }

                            /**
                             * Return attempted. Present if and only if `return_outcome` is
                             * `return_attempted`.
                             */
                            fun returnAttempted(returnAttempted: ReturnAttempted?) =
                                returnAttempted(JsonField.ofNullable(returnAttempted))

                            /**
                             * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnAttempted] with a well-typed
                             * [ReturnAttempted] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) =
                                apply {
                                    this.returnAttempted = returnAttempted
                                }

                            /** Return outcome. */
                            fun returnOutcome(returnOutcome: ReturnOutcome) =
                                returnOutcome(JsonField.of(returnOutcome))

                            /**
                             * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnOutcome] with a well-typed
                             * [ReturnOutcome] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                                this.returnOutcome = returnOutcome
                            }

                            /** Returned. Present if and only if `return_outcome` is `returned`. */
                            fun returned(returned: Returned?) =
                                returned(JsonField.ofNullable(returned))

                            /**
                             * Sets [Builder.returned] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returned] with a well-typed
                             * [Returned] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun returned(returned: JsonField<Returned>) = apply {
                                this.returned = returned
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Delayed].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * .notReturned()
                             * .returnAttempted()
                             * .returnOutcome()
                             * .returned()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Delayed =
                                Delayed(
                                    checkRequired("explanation", explanation),
                                    checkRequired("notReturned", notReturned),
                                    checkRequired("returnAttempted", returnAttempted),
                                    checkRequired("returnOutcome", returnOutcome),
                                    checkRequired("returned", returned),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Delayed = apply {
                            if (validated) {
                                return@apply
                            }

                            explanation()
                            returnAttempted()?.validate()
                            returnOutcome().validate()
                            returned()?.validate()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (explanation.asKnown() == null) 0 else 1) +
                                (returnAttempted.asKnown()?.validity() ?: 0) +
                                (returnOutcome.asKnown()?.validity() ?: 0) +
                                (returned.asKnown()?.validity() ?: 0)

                        /**
                         * Return attempted. Present if and only if `return_outcome` is
                         * `return_attempted`.
                         */
                        class ReturnAttempted
                        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                        private constructor(
                            private val attemptedAt: JsonField<LocalDate>,
                            private val additionalProperties: MutableMap<String, JsonValue>,
                        ) {

                            @JsonCreator
                            private constructor(
                                @JsonProperty("attempted_at")
                                @ExcludeMissing
                                attemptedAt: JsonField<LocalDate> = JsonMissing.of()
                            ) : this(attemptedAt, mutableMapOf())

                            /**
                             * Attempted at.
                             *
                             * @throws IncreaseInvalidDataException if the JSON field has an
                             *   unexpected type or is unexpectedly missing or null (e.g. if the
                             *   server responded with an unexpected value).
                             */
                            fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                            /**
                             * Returns the raw JSON value of [attemptedAt].
                             *
                             * Unlike [attemptedAt], this method doesn't throw if the JSON field has
                             * an unexpected type.
                             */
                            @JsonProperty("attempted_at")
                            @ExcludeMissing
                            fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                            @JsonAnySetter
                            private fun putAdditionalProperty(key: String, value: JsonValue) {
                                additionalProperties.put(key, value)
                            }

                            @JsonAnyGetter
                            @ExcludeMissing
                            fun _additionalProperties(): Map<String, JsonValue> =
                                Collections.unmodifiableMap(additionalProperties)

                            fun toBuilder() = Builder().from(this)

                            companion object {

                                /**
                                 * Returns a mutable builder for constructing an instance of
                                 * [ReturnAttempted].
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .attemptedAt()
                                 * ```
                                 */
                                fun builder() = Builder()
                            }

                            /** A builder for [ReturnAttempted]. */
                            class Builder internal constructor() {

                                private var attemptedAt: JsonField<LocalDate>? = null
                                private var additionalProperties: MutableMap<String, JsonValue> =
                                    mutableMapOf()

                                internal fun from(returnAttempted: ReturnAttempted) = apply {
                                    attemptedAt = returnAttempted.attemptedAt
                                    additionalProperties =
                                        returnAttempted.additionalProperties.toMutableMap()
                                }

                                /** Attempted at. */
                                fun attemptedAt(attemptedAt: LocalDate) =
                                    attemptedAt(JsonField.of(attemptedAt))

                                /**
                                 * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                                 *
                                 * You should usually call [Builder.attemptedAt] with a well-typed
                                 * [LocalDate] value instead. This method is primarily for setting
                                 * the field to an undocumented or not yet supported value.
                                 */
                                fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                                    this.attemptedAt = attemptedAt
                                }

                                fun additionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                    additionalProperties.put(key, value)
                                }

                                fun putAllAdditionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply { this.additionalProperties.putAll(additionalProperties) }

                                fun removeAdditionalProperty(key: String) = apply {
                                    additionalProperties.remove(key)
                                }

                                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                    keys.forEach(::removeAdditionalProperty)
                                }

                                /**
                                 * Returns an immutable instance of [ReturnAttempted].
                                 *
                                 * Further updates to this [Builder] will not mutate the returned
                                 * instance.
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .attemptedAt()
                                 * ```
                                 *
                                 * @throws IllegalStateException if any required field is unset.
                                 */
                                fun build(): ReturnAttempted =
                                    ReturnAttempted(
                                        checkRequired("attemptedAt", attemptedAt),
                                        additionalProperties.toMutableMap(),
                                    )
                            }

                            private var validated: Boolean = false

                            fun validate(): ReturnAttempted = apply {
                                if (validated) {
                                    return@apply
                                }

                                attemptedAt()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int =
                                (if (attemptedAt.asKnown() == null) 0 else 1)

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is ReturnAttempted &&
                                    attemptedAt == other.attemptedAt &&
                                    additionalProperties == other.additionalProperties
                            }

                            private val hashCode: Int by lazy {
                                Objects.hash(attemptedAt, additionalProperties)
                            }

                            override fun hashCode(): Int = hashCode

                            override fun toString() =
                                "ReturnAttempted{attemptedAt=$attemptedAt, additionalProperties=$additionalProperties}"
                        }

                        /** Return outcome. */
                        class ReturnOutcome
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Not returned. */
                                val NOT_RETURNED = of("not_returned")

                                /** Returned. */
                                val RETURNED = of("returned")

                                /** Return attempted. */
                                val RETURN_ATTEMPTED = of("return_attempted")

                                fun of(value: String) = ReturnOutcome(JsonField.of(value))
                            }

                            /** An enum containing [ReturnOutcome]'s known values. */
                            enum class Known {
                                /** Not returned. */
                                NOT_RETURNED,
                                /** Returned. */
                                RETURNED,
                                /** Return attempted. */
                                RETURN_ATTEMPTED,
                            }

                            /**
                             * An enum containing [ReturnOutcome]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [ReturnOutcome] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Not returned. */
                                NOT_RETURNED,
                                /** Returned. */
                                RETURNED,
                                /** Return attempted. */
                                RETURN_ATTEMPTED,
                                /**
                                 * An enum member indicating that [ReturnOutcome] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    NOT_RETURNED -> Value.NOT_RETURNED
                                    RETURNED -> Value.RETURNED
                                    RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    NOT_RETURNED -> Known.NOT_RETURNED
                                    RETURNED -> Known.RETURNED
                                    RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown ReturnOutcome: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): ReturnOutcome = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is ReturnOutcome && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        /** Returned. Present if and only if `return_outcome` is `returned`. */
                        class Returned
                        @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                        private constructor(
                            private val merchantReceivedReturnAt: JsonField<LocalDate>,
                            private val returnedAt: JsonField<LocalDate>,
                            private val additionalProperties: MutableMap<String, JsonValue>,
                        ) {

                            @JsonCreator
                            private constructor(
                                @JsonProperty("merchant_received_return_at")
                                @ExcludeMissing
                                merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                                @JsonProperty("returned_at")
                                @ExcludeMissing
                                returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                            ) : this(merchantReceivedReturnAt, returnedAt, mutableMapOf())

                            /**
                             * Merchant received return at.
                             *
                             * @throws IncreaseInvalidDataException if the JSON field has an
                             *   unexpected type or is unexpectedly missing or null (e.g. if the
                             *   server responded with an unexpected value).
                             */
                            fun merchantReceivedReturnAt(): LocalDate =
                                merchantReceivedReturnAt.getRequired("merchant_received_return_at")

                            /**
                             * Returned at.
                             *
                             * @throws IncreaseInvalidDataException if the JSON field has an
                             *   unexpected type or is unexpectedly missing or null (e.g. if the
                             *   server responded with an unexpected value).
                             */
                            fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                            /**
                             * Returns the raw JSON value of [merchantReceivedReturnAt].
                             *
                             * Unlike [merchantReceivedReturnAt], this method doesn't throw if the
                             * JSON field has an unexpected type.
                             */
                            @JsonProperty("merchant_received_return_at")
                            @ExcludeMissing
                            fun _merchantReceivedReturnAt(): JsonField<LocalDate> =
                                merchantReceivedReturnAt

                            /**
                             * Returns the raw JSON value of [returnedAt].
                             *
                             * Unlike [returnedAt], this method doesn't throw if the JSON field has
                             * an unexpected type.
                             */
                            @JsonProperty("returned_at")
                            @ExcludeMissing
                            fun _returnedAt(): JsonField<LocalDate> = returnedAt

                            @JsonAnySetter
                            private fun putAdditionalProperty(key: String, value: JsonValue) {
                                additionalProperties.put(key, value)
                            }

                            @JsonAnyGetter
                            @ExcludeMissing
                            fun _additionalProperties(): Map<String, JsonValue> =
                                Collections.unmodifiableMap(additionalProperties)

                            fun toBuilder() = Builder().from(this)

                            companion object {

                                /**
                                 * Returns a mutable builder for constructing an instance of
                                 * [Returned].
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .merchantReceivedReturnAt()
                                 * .returnedAt()
                                 * ```
                                 */
                                fun builder() = Builder()
                            }

                            /** A builder for [Returned]. */
                            class Builder internal constructor() {

                                private var merchantReceivedReturnAt: JsonField<LocalDate>? = null
                                private var returnedAt: JsonField<LocalDate>? = null
                                private var additionalProperties: MutableMap<String, JsonValue> =
                                    mutableMapOf()

                                internal fun from(returned: Returned) = apply {
                                    merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                                    returnedAt = returned.returnedAt
                                    additionalProperties =
                                        returned.additionalProperties.toMutableMap()
                                }

                                /** Merchant received return at. */
                                fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate) =
                                    merchantReceivedReturnAt(JsonField.of(merchantReceivedReturnAt))

                                /**
                                 * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON
                                 * value.
                                 *
                                 * You should usually call [Builder.merchantReceivedReturnAt] with a
                                 * well-typed [LocalDate] value instead. This method is primarily
                                 * for setting the field to an undocumented or not yet supported
                                 * value.
                                 */
                                fun merchantReceivedReturnAt(
                                    merchantReceivedReturnAt: JsonField<LocalDate>
                                ) = apply {
                                    this.merchantReceivedReturnAt = merchantReceivedReturnAt
                                }

                                /** Returned at. */
                                fun returnedAt(returnedAt: LocalDate) =
                                    returnedAt(JsonField.of(returnedAt))

                                /**
                                 * Sets [Builder.returnedAt] to an arbitrary JSON value.
                                 *
                                 * You should usually call [Builder.returnedAt] with a well-typed
                                 * [LocalDate] value instead. This method is primarily for setting
                                 * the field to an undocumented or not yet supported value.
                                 */
                                fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                                    this.returnedAt = returnedAt
                                }

                                fun additionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                    additionalProperties.put(key, value)
                                }

                                fun putAllAdditionalProperties(
                                    additionalProperties: Map<String, JsonValue>
                                ) = apply { this.additionalProperties.putAll(additionalProperties) }

                                fun removeAdditionalProperty(key: String) = apply {
                                    additionalProperties.remove(key)
                                }

                                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                    keys.forEach(::removeAdditionalProperty)
                                }

                                /**
                                 * Returns an immutable instance of [Returned].
                                 *
                                 * Further updates to this [Builder] will not mutate the returned
                                 * instance.
                                 *
                                 * The following fields are required:
                                 * ```kotlin
                                 * .merchantReceivedReturnAt()
                                 * .returnedAt()
                                 * ```
                                 *
                                 * @throws IllegalStateException if any required field is unset.
                                 */
                                fun build(): Returned =
                                    Returned(
                                        checkRequired(
                                            "merchantReceivedReturnAt",
                                            merchantReceivedReturnAt,
                                        ),
                                        checkRequired("returnedAt", returnedAt),
                                        additionalProperties.toMutableMap(),
                                    )
                            }

                            private var validated: Boolean = false

                            fun validate(): Returned = apply {
                                if (validated) {
                                    return@apply
                                }

                                merchantReceivedReturnAt()
                                returnedAt()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int =
                                (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                                    (if (returnedAt.asKnown() == null) 0 else 1)

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is Returned &&
                                    merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                                    returnedAt == other.returnedAt &&
                                    additionalProperties == other.additionalProperties
                            }

                            private val hashCode: Int by lazy {
                                Objects.hash(
                                    merchantReceivedReturnAt,
                                    returnedAt,
                                    additionalProperties,
                                )
                            }

                            override fun hashCode(): Int = hashCode

                            override fun toString() =
                                "Returned{merchantReceivedReturnAt=$merchantReceivedReturnAt, returnedAt=$returnedAt, additionalProperties=$additionalProperties}"
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Delayed &&
                                explanation == other.explanation &&
                                notReturned == other.notReturned &&
                                returnAttempted == other.returnAttempted &&
                                returnOutcome == other.returnOutcome &&
                                returned == other.returned &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                explanation,
                                notReturned,
                                returnAttempted,
                                returnOutcome,
                                returned,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Delayed{explanation=$explanation, notReturned=$notReturned, returnAttempted=$returnAttempted, returnOutcome=$returnOutcome, returned=$returned, additionalProperties=$additionalProperties}"
                    }

                    /**
                     * Delivered to wrong location. Present if and only if `delivery_issue` is
                     * `delivered_to_wrong_location`.
                     */
                    class DeliveredToWrongLocation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val agreedLocation: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("agreed_location")
                            @ExcludeMissing
                            agreedLocation: JsonField<String> = JsonMissing.of()
                        ) : this(agreedLocation, mutableMapOf())

                        /**
                         * Agreed location.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun agreedLocation(): String = agreedLocation.getRequired("agreed_location")

                        /**
                         * Returns the raw JSON value of [agreedLocation].
                         *
                         * Unlike [agreedLocation], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("agreed_location")
                        @ExcludeMissing
                        fun _agreedLocation(): JsonField<String> = agreedLocation

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [DeliveredToWrongLocation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .agreedLocation()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [DeliveredToWrongLocation]. */
                        class Builder internal constructor() {

                            private var agreedLocation: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(deliveredToWrongLocation: DeliveredToWrongLocation) =
                                apply {
                                    agreedLocation = deliveredToWrongLocation.agreedLocation
                                    additionalProperties =
                                        deliveredToWrongLocation.additionalProperties.toMutableMap()
                                }

                            /** Agreed location. */
                            fun agreedLocation(agreedLocation: String) =
                                agreedLocation(JsonField.of(agreedLocation))

                            /**
                             * Sets [Builder.agreedLocation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.agreedLocation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun agreedLocation(agreedLocation: JsonField<String>) = apply {
                                this.agreedLocation = agreedLocation
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [DeliveredToWrongLocation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .agreedLocation()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): DeliveredToWrongLocation =
                                DeliveredToWrongLocation(
                                    checkRequired("agreedLocation", agreedLocation),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): DeliveredToWrongLocation = apply {
                            if (validated) {
                                return@apply
                            }

                            agreedLocation()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (agreedLocation.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DeliveredToWrongLocation &&
                                agreedLocation == other.agreedLocation &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(agreedLocation, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "DeliveredToWrongLocation{agreedLocation=$agreedLocation, additionalProperties=$additionalProperties}"
                    }

                    /** Delivery issue. */
                    class DeliveryIssue
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Delayed. */
                            val DELAYED = of("delayed")

                            /** Delivered to wrong location. */
                            val DELIVERED_TO_WRONG_LOCATION = of("delivered_to_wrong_location")

                            fun of(value: String) = DeliveryIssue(JsonField.of(value))
                        }

                        /** An enum containing [DeliveryIssue]'s known values. */
                        enum class Known {
                            /** Delayed. */
                            DELAYED,
                            /** Delivered to wrong location. */
                            DELIVERED_TO_WRONG_LOCATION,
                        }

                        /**
                         * An enum containing [DeliveryIssue]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [DeliveryIssue] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Delayed. */
                            DELAYED,
                            /** Delivered to wrong location. */
                            DELIVERED_TO_WRONG_LOCATION,
                            /**
                             * An enum member indicating that [DeliveryIssue] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DELAYED -> Value.DELAYED
                                DELIVERED_TO_WRONG_LOCATION -> Value.DELIVERED_TO_WRONG_LOCATION
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DELAYED -> Known.DELAYED
                                DELIVERED_TO_WRONG_LOCATION -> Known.DELIVERED_TO_WRONG_LOCATION
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown DeliveryIssue: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): DeliveryIssue = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DeliveryIssue && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Merchant cancellation. Present if and only if `cancellation_outcome` is
                     * `merchant_cancellation`.
                     */
                    class MerchantCancellation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val canceledAt: JsonField<LocalDate>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of()
                        ) : this(canceledAt, mutableMapOf())

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [MerchantCancellation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [MerchantCancellation]. */
                        class Builder internal constructor() {

                            private var canceledAt: JsonField<LocalDate>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(merchantCancellation: MerchantCancellation) = apply {
                                canceledAt = merchantCancellation.canceledAt
                                additionalProperties =
                                    merchantCancellation.additionalProperties.toMutableMap()
                            }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [MerchantCancellation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): MerchantCancellation =
                                MerchantCancellation(
                                    checkRequired("canceledAt", canceledAt),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): MerchantCancellation = apply {
                            if (validated) {
                                return@apply
                            }

                            canceledAt()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = (if (canceledAt.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantCancellation &&
                                canceledAt == other.canceledAt &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(canceledAt, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "MerchantCancellation{canceledAt=$canceledAt, additionalProperties=$additionalProperties}"
                    }

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerMerchandiseNotReceived &&
                            cancellationOutcome == other.cancellationOutcome &&
                            cardholderCancellationPriorToExpectedReceipt ==
                                other.cardholderCancellationPriorToExpectedReceipt &&
                            delayed == other.delayed &&
                            deliveredToWrongLocation == other.deliveredToWrongLocation &&
                            deliveryIssue == other.deliveryIssue &&
                            lastExpectedReceiptAt == other.lastExpectedReceiptAt &&
                            merchantCancellation == other.merchantCancellation &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            noCancellation == other.noCancellation &&
                            purchaseInfoAndExplanation == other.purchaseInfoAndExplanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cancellationOutcome,
                            cardholderCancellationPriorToExpectedReceipt,
                            delayed,
                            deliveredToWrongLocation,
                            deliveryIssue,
                            lastExpectedReceiptAt,
                            merchantCancellation,
                            merchantResolutionAttempted,
                            noCancellation,
                            purchaseInfoAndExplanation,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerMerchandiseNotReceived{cancellationOutcome=$cancellationOutcome, cardholderCancellationPriorToExpectedReceipt=$cardholderCancellationPriorToExpectedReceipt, delayed=$delayed, deliveredToWrongLocation=$deliveredToWrongLocation, deliveryIssue=$deliveryIssue, lastExpectedReceiptAt=$lastExpectedReceiptAt, merchantCancellation=$merchantCancellation, merchantResolutionAttempted=$merchantResolutionAttempted, noCancellation=$noCancellation, purchaseInfoAndExplanation=$purchaseInfoAndExplanation, additionalProperties=$additionalProperties}"
                }

                /**
                 * Original Credit Transaction (OCT) not accepted. Present if and only if `category`
                 * is `consumer_original_credit_transaction_not_accepted`.
                 */
                class ConsumerOriginalCreditTransactionNotAccepted
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val explanation: JsonField<String>,
                    private val reason: JsonField<Reason>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        explanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<Reason> = JsonMissing.of(),
                    ) : this(explanation, reason, mutableMapOf())

                    /**
                     * Explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun explanation(): String = explanation.getRequired("explanation")

                    /**
                     * Reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): Reason = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [explanation].
                     *
                     * Unlike [explanation], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("explanation")
                    @ExcludeMissing
                    fun _explanation(): JsonField<String> = explanation

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<Reason> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerOriginalCreditTransactionNotAccepted].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerOriginalCreditTransactionNotAccepted]. */
                    class Builder internal constructor() {

                        private var explanation: JsonField<String>? = null
                        private var reason: JsonField<Reason>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerOriginalCreditTransactionNotAccepted:
                                ConsumerOriginalCreditTransactionNotAccepted
                        ) = apply {
                            explanation = consumerOriginalCreditTransactionNotAccepted.explanation
                            reason = consumerOriginalCreditTransactionNotAccepted.reason
                            additionalProperties =
                                consumerOriginalCreditTransactionNotAccepted.additionalProperties
                                    .toMutableMap()
                        }

                        /** Explanation. */
                        fun explanation(explanation: String) =
                            explanation(JsonField.of(explanation))

                        /**
                         * Sets [Builder.explanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.explanation] with a well-typed [String]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun explanation(explanation: JsonField<String>) = apply {
                            this.explanation = explanation
                        }

                        /** Reason. */
                        fun reason(reason: Reason) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [Reason] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<Reason>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of
                         * [ConsumerOriginalCreditTransactionNotAccepted].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .explanation()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerOriginalCreditTransactionNotAccepted =
                            ConsumerOriginalCreditTransactionNotAccepted(
                                checkRequired("explanation", explanation),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerOriginalCreditTransactionNotAccepted = apply {
                        if (validated) {
                            return@apply
                        }

                        explanation()
                        reason().validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (explanation.asKnown() == null) 0 else 1) +
                            (reason.asKnown()?.validity() ?: 0)

                    /** Reason. */
                    class Reason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Prohibited by local laws or regulation. */
                            val PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION =
                                of("prohibited_by_local_laws_or_regulation")

                            /** Recipient refused. */
                            val RECIPIENT_REFUSED = of("recipient_refused")

                            fun of(value: String) = Reason(JsonField.of(value))
                        }

                        /** An enum containing [Reason]'s known values. */
                        enum class Known {
                            /** Prohibited by local laws or regulation. */
                            PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION,
                            /** Recipient refused. */
                            RECIPIENT_REFUSED,
                        }

                        /**
                         * An enum containing [Reason]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [Reason] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Prohibited by local laws or regulation. */
                            PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION,
                            /** Recipient refused. */
                            RECIPIENT_REFUSED,
                            /**
                             * An enum member indicating that [Reason] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION ->
                                    Value.PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION
                                RECIPIENT_REFUSED -> Value.RECIPIENT_REFUSED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION ->
                                    Known.PROHIBITED_BY_LOCAL_LAWS_OR_REGULATION
                                RECIPIENT_REFUSED -> Known.RECIPIENT_REFUSED
                                else -> throw IncreaseInvalidDataException("Unknown Reason: $value")
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): Reason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Reason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerOriginalCreditTransactionNotAccepted &&
                            explanation == other.explanation &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(explanation, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerOriginalCreditTransactionNotAccepted{explanation=$explanation, reason=$reason, additionalProperties=$additionalProperties}"
                }

                /**
                 * Merchandise quality issue. Present if and only if `category` is
                 * `consumer_quality_merchandise`.
                 */
                class ConsumerQualityMerchandise
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val expectedAt: JsonField<LocalDate>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val notReturned: JsonValue,
                    private val ongoingNegotiations: JsonField<OngoingNegotiations>,
                    private val purchaseInfoAndQualityIssue: JsonField<String>,
                    private val receivedAt: JsonField<LocalDate>,
                    private val returnAttempted: JsonField<ReturnAttempted>,
                    private val returnOutcome: JsonField<ReturnOutcome>,
                    private val returned: JsonField<Returned>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("expected_at")
                        @ExcludeMissing
                        expectedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("not_returned")
                        @ExcludeMissing
                        notReturned: JsonValue = JsonMissing.of(),
                        @JsonProperty("ongoing_negotiations")
                        @ExcludeMissing
                        ongoingNegotiations: JsonField<OngoingNegotiations> = JsonMissing.of(),
                        @JsonProperty("purchase_info_and_quality_issue")
                        @ExcludeMissing
                        purchaseInfoAndQualityIssue: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("received_at")
                        @ExcludeMissing
                        receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("return_attempted")
                        @ExcludeMissing
                        returnAttempted: JsonField<ReturnAttempted> = JsonMissing.of(),
                        @JsonProperty("return_outcome")
                        @ExcludeMissing
                        returnOutcome: JsonField<ReturnOutcome> = JsonMissing.of(),
                        @JsonProperty("returned")
                        @ExcludeMissing
                        returned: JsonField<Returned> = JsonMissing.of(),
                    ) : this(
                        expectedAt,
                        merchantResolutionAttempted,
                        notReturned,
                        ongoingNegotiations,
                        purchaseInfoAndQualityIssue,
                        receivedAt,
                        returnAttempted,
                        returnOutcome,
                        returned,
                        mutableMapOf(),
                    )

                    /**
                     * Expected at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun expectedAt(): LocalDate = expectedAt.getRequired("expected_at")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /** Not returned. Present if and only if `return_outcome` is `not_returned`. */
                    @JsonProperty("not_returned")
                    @ExcludeMissing
                    fun _notReturned(): JsonValue = notReturned

                    /**
                     * Ongoing negotiations. Exclude if there is no evidence of ongoing
                     * negotiations.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ongoingNegotiations(): OngoingNegotiations? =
                        ongoingNegotiations.getNullable("ongoing_negotiations")

                    /**
                     * Purchase information and quality issue.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseInfoAndQualityIssue(): String =
                        purchaseInfoAndQualityIssue.getRequired("purchase_info_and_quality_issue")

                    /**
                     * Received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returnAttempted(): ReturnAttempted? =
                        returnAttempted.getNullable("return_attempted")

                    /**
                     * Return outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun returnOutcome(): ReturnOutcome = returnOutcome.getRequired("return_outcome")

                    /**
                     * Returned. Present if and only if `return_outcome` is `returned`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun returned(): Returned? = returned.getNullable("returned")

                    /**
                     * Returns the raw JSON value of [expectedAt].
                     *
                     * Unlike [expectedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("expected_at")
                    @ExcludeMissing
                    fun _expectedAt(): JsonField<LocalDate> = expectedAt

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [ongoingNegotiations].
                     *
                     * Unlike [ongoingNegotiations], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("ongoing_negotiations")
                    @ExcludeMissing
                    fun _ongoingNegotiations(): JsonField<OngoingNegotiations> = ongoingNegotiations

                    /**
                     * Returns the raw JSON value of [purchaseInfoAndQualityIssue].
                     *
                     * Unlike [purchaseInfoAndQualityIssue], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("purchase_info_and_quality_issue")
                    @ExcludeMissing
                    fun _purchaseInfoAndQualityIssue(): JsonField<String> =
                        purchaseInfoAndQualityIssue

                    /**
                     * Returns the raw JSON value of [receivedAt].
                     *
                     * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    fun _receivedAt(): JsonField<LocalDate> = receivedAt

                    /**
                     * Returns the raw JSON value of [returnAttempted].
                     *
                     * Unlike [returnAttempted], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_attempted")
                    @ExcludeMissing
                    fun _returnAttempted(): JsonField<ReturnAttempted> = returnAttempted

                    /**
                     * Returns the raw JSON value of [returnOutcome].
                     *
                     * Unlike [returnOutcome], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("return_outcome")
                    @ExcludeMissing
                    fun _returnOutcome(): JsonField<ReturnOutcome> = returnOutcome

                    /**
                     * Returns the raw JSON value of [returned].
                     *
                     * Unlike [returned], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("returned")
                    @ExcludeMissing
                    fun _returned(): JsonField<Returned> = returned

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerQualityMerchandise].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .expectedAt()
                         * .merchantResolutionAttempted()
                         * .notReturned()
                         * .ongoingNegotiations()
                         * .purchaseInfoAndQualityIssue()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerQualityMerchandise]. */
                    class Builder internal constructor() {

                        private var expectedAt: JsonField<LocalDate>? = null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var notReturned: JsonValue? = null
                        private var ongoingNegotiations: JsonField<OngoingNegotiations>? = null
                        private var purchaseInfoAndQualityIssue: JsonField<String>? = null
                        private var receivedAt: JsonField<LocalDate>? = null
                        private var returnAttempted: JsonField<ReturnAttempted>? = null
                        private var returnOutcome: JsonField<ReturnOutcome>? = null
                        private var returned: JsonField<Returned>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(consumerQualityMerchandise: ConsumerQualityMerchandise) =
                            apply {
                                expectedAt = consumerQualityMerchandise.expectedAt
                                merchantResolutionAttempted =
                                    consumerQualityMerchandise.merchantResolutionAttempted
                                notReturned = consumerQualityMerchandise.notReturned
                                ongoingNegotiations = consumerQualityMerchandise.ongoingNegotiations
                                purchaseInfoAndQualityIssue =
                                    consumerQualityMerchandise.purchaseInfoAndQualityIssue
                                receivedAt = consumerQualityMerchandise.receivedAt
                                returnAttempted = consumerQualityMerchandise.returnAttempted
                                returnOutcome = consumerQualityMerchandise.returnOutcome
                                returned = consumerQualityMerchandise.returned
                                additionalProperties =
                                    consumerQualityMerchandise.additionalProperties.toMutableMap()
                            }

                        /** Expected at. */
                        fun expectedAt(expectedAt: LocalDate) = expectedAt(JsonField.of(expectedAt))

                        /**
                         * Sets [Builder.expectedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.expectedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun expectedAt(expectedAt: JsonField<LocalDate>) = apply {
                            this.expectedAt = expectedAt
                        }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /**
                         * Not returned. Present if and only if `return_outcome` is `not_returned`.
                         */
                        fun notReturned(notReturned: JsonValue) = apply {
                            this.notReturned = notReturned
                        }

                        /**
                         * Ongoing negotiations. Exclude if there is no evidence of ongoing
                         * negotiations.
                         */
                        fun ongoingNegotiations(ongoingNegotiations: OngoingNegotiations?) =
                            ongoingNegotiations(JsonField.ofNullable(ongoingNegotiations))

                        /**
                         * Sets [Builder.ongoingNegotiations] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ongoingNegotiations] with a well-typed
                         * [OngoingNegotiations] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun ongoingNegotiations(
                            ongoingNegotiations: JsonField<OngoingNegotiations>
                        ) = apply { this.ongoingNegotiations = ongoingNegotiations }

                        /** Purchase information and quality issue. */
                        fun purchaseInfoAndQualityIssue(purchaseInfoAndQualityIssue: String) =
                            purchaseInfoAndQualityIssue(JsonField.of(purchaseInfoAndQualityIssue))

                        /**
                         * Sets [Builder.purchaseInfoAndQualityIssue] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseInfoAndQualityIssue] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun purchaseInfoAndQualityIssue(
                            purchaseInfoAndQualityIssue: JsonField<String>
                        ) = apply { this.purchaseInfoAndQualityIssue = purchaseInfoAndQualityIssue }

                        /** Received at. */
                        fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                        /**
                         * Sets [Builder.receivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                            this.receivedAt = receivedAt
                        }

                        /**
                         * Return attempted. Present if and only if `return_outcome` is
                         * `return_attempted`.
                         */
                        fun returnAttempted(returnAttempted: ReturnAttempted?) =
                            returnAttempted(JsonField.ofNullable(returnAttempted))

                        /**
                         * Sets [Builder.returnAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnAttempted] with a well-typed
                         * [ReturnAttempted] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnAttempted(returnAttempted: JsonField<ReturnAttempted>) = apply {
                            this.returnAttempted = returnAttempted
                        }

                        /** Return outcome. */
                        fun returnOutcome(returnOutcome: ReturnOutcome) =
                            returnOutcome(JsonField.of(returnOutcome))

                        /**
                         * Sets [Builder.returnOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returnOutcome] with a well-typed
                         * [ReturnOutcome] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun returnOutcome(returnOutcome: JsonField<ReturnOutcome>) = apply {
                            this.returnOutcome = returnOutcome
                        }

                        /** Returned. Present if and only if `return_outcome` is `returned`. */
                        fun returned(returned: Returned?) = returned(JsonField.ofNullable(returned))

                        /**
                         * Sets [Builder.returned] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.returned] with a well-typed [Returned]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun returned(returned: JsonField<Returned>) = apply {
                            this.returned = returned
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerQualityMerchandise].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .expectedAt()
                         * .merchantResolutionAttempted()
                         * .notReturned()
                         * .ongoingNegotiations()
                         * .purchaseInfoAndQualityIssue()
                         * .receivedAt()
                         * .returnAttempted()
                         * .returnOutcome()
                         * .returned()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerQualityMerchandise =
                            ConsumerQualityMerchandise(
                                checkRequired("expectedAt", expectedAt),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("notReturned", notReturned),
                                checkRequired("ongoingNegotiations", ongoingNegotiations),
                                checkRequired(
                                    "purchaseInfoAndQualityIssue",
                                    purchaseInfoAndQualityIssue,
                                ),
                                checkRequired("receivedAt", receivedAt),
                                checkRequired("returnAttempted", returnAttempted),
                                checkRequired("returnOutcome", returnOutcome),
                                checkRequired("returned", returned),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerQualityMerchandise = apply {
                        if (validated) {
                            return@apply
                        }

                        expectedAt()
                        merchantResolutionAttempted().validate()
                        ongoingNegotiations()?.validate()
                        purchaseInfoAndQualityIssue()
                        receivedAt()
                        returnAttempted()?.validate()
                        returnOutcome().validate()
                        returned()?.validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (if (expectedAt.asKnown() == null) 0 else 1) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (ongoingNegotiations.asKnown()?.validity() ?: 0) +
                            (if (purchaseInfoAndQualityIssue.asKnown() == null) 0 else 1) +
                            (if (receivedAt.asKnown() == null) 0 else 1) +
                            (returnAttempted.asKnown()?.validity() ?: 0) +
                            (returnOutcome.asKnown()?.validity() ?: 0) +
                            (returned.asKnown()?.validity() ?: 0)

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Ongoing negotiations. Exclude if there is no evidence of ongoing
                     * negotiations.
                     */
                    class OngoingNegotiations
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val explanation: JsonField<String>,
                        private val issuerFirstNotifiedAt: JsonField<LocalDate>,
                        private val startedAt: JsonField<LocalDate>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("explanation")
                            @ExcludeMissing
                            explanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("issuer_first_notified_at")
                            @ExcludeMissing
                            issuerFirstNotifiedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("started_at")
                            @ExcludeMissing
                            startedAt: JsonField<LocalDate> = JsonMissing.of(),
                        ) : this(explanation, issuerFirstNotifiedAt, startedAt, mutableMapOf())

                        /**
                         * Explanation of the previous ongoing negotiations between the cardholder
                         * and merchant.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun explanation(): String = explanation.getRequired("explanation")

                        /**
                         * Date the cardholder first notified the issuer of the dispute.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun issuerFirstNotifiedAt(): LocalDate =
                            issuerFirstNotifiedAt.getRequired("issuer_first_notified_at")

                        /**
                         * Started at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun startedAt(): LocalDate = startedAt.getRequired("started_at")

                        /**
                         * Returns the raw JSON value of [explanation].
                         *
                         * Unlike [explanation], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        fun _explanation(): JsonField<String> = explanation

                        /**
                         * Returns the raw JSON value of [issuerFirstNotifiedAt].
                         *
                         * Unlike [issuerFirstNotifiedAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("issuer_first_notified_at")
                        @ExcludeMissing
                        fun _issuerFirstNotifiedAt(): JsonField<LocalDate> = issuerFirstNotifiedAt

                        /**
                         * Returns the raw JSON value of [startedAt].
                         *
                         * Unlike [startedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("started_at")
                        @ExcludeMissing
                        fun _startedAt(): JsonField<LocalDate> = startedAt

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [OngoingNegotiations].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * .issuerFirstNotifiedAt()
                             * .startedAt()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [OngoingNegotiations]. */
                        class Builder internal constructor() {

                            private var explanation: JsonField<String>? = null
                            private var issuerFirstNotifiedAt: JsonField<LocalDate>? = null
                            private var startedAt: JsonField<LocalDate>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(ongoingNegotiations: OngoingNegotiations) = apply {
                                explanation = ongoingNegotiations.explanation
                                issuerFirstNotifiedAt = ongoingNegotiations.issuerFirstNotifiedAt
                                startedAt = ongoingNegotiations.startedAt
                                additionalProperties =
                                    ongoingNegotiations.additionalProperties.toMutableMap()
                            }

                            /**
                             * Explanation of the previous ongoing negotiations between the
                             * cardholder and merchant.
                             */
                            fun explanation(explanation: String) =
                                explanation(JsonField.of(explanation))

                            /**
                             * Sets [Builder.explanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.explanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun explanation(explanation: JsonField<String>) = apply {
                                this.explanation = explanation
                            }

                            /** Date the cardholder first notified the issuer of the dispute. */
                            fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: LocalDate) =
                                issuerFirstNotifiedAt(JsonField.of(issuerFirstNotifiedAt))

                            /**
                             * Sets [Builder.issuerFirstNotifiedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.issuerFirstNotifiedAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: JsonField<LocalDate>) =
                                apply {
                                    this.issuerFirstNotifiedAt = issuerFirstNotifiedAt
                                }

                            /** Started at. */
                            fun startedAt(startedAt: LocalDate) = startedAt(JsonField.of(startedAt))

                            /**
                             * Sets [Builder.startedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.startedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun startedAt(startedAt: JsonField<LocalDate>) = apply {
                                this.startedAt = startedAt
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [OngoingNegotiations].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * .issuerFirstNotifiedAt()
                             * .startedAt()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): OngoingNegotiations =
                                OngoingNegotiations(
                                    checkRequired("explanation", explanation),
                                    checkRequired("issuerFirstNotifiedAt", issuerFirstNotifiedAt),
                                    checkRequired("startedAt", startedAt),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): OngoingNegotiations = apply {
                            if (validated) {
                                return@apply
                            }

                            explanation()
                            issuerFirstNotifiedAt()
                            startedAt()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (explanation.asKnown() == null) 0 else 1) +
                                (if (issuerFirstNotifiedAt.asKnown() == null) 0 else 1) +
                                (if (startedAt.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is OngoingNegotiations &&
                                explanation == other.explanation &&
                                issuerFirstNotifiedAt == other.issuerFirstNotifiedAt &&
                                startedAt == other.startedAt &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                explanation,
                                issuerFirstNotifiedAt,
                                startedAt,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "OngoingNegotiations{explanation=$explanation, issuerFirstNotifiedAt=$issuerFirstNotifiedAt, startedAt=$startedAt, additionalProperties=$additionalProperties}"
                    }

                    /**
                     * Return attempted. Present if and only if `return_outcome` is
                     * `return_attempted`.
                     */
                    class ReturnAttempted
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val attemptExplanation: JsonField<String>,
                        private val attemptReason: JsonField<AttemptReason>,
                        private val attemptedAt: JsonField<LocalDate>,
                        private val merchandiseDisposition: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("attempt_explanation")
                            @ExcludeMissing
                            attemptExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("attempt_reason")
                            @ExcludeMissing
                            attemptReason: JsonField<AttemptReason> = JsonMissing.of(),
                            @JsonProperty("attempted_at")
                            @ExcludeMissing
                            attemptedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("merchandise_disposition")
                            @ExcludeMissing
                            merchandiseDisposition: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            attemptExplanation,
                            attemptReason,
                            attemptedAt,
                            merchandiseDisposition,
                            mutableMapOf(),
                        )

                        /**
                         * Attempt explanation.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptExplanation(): String =
                            attemptExplanation.getRequired("attempt_explanation")

                        /**
                         * Attempt reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptReason(): AttemptReason =
                            attemptReason.getRequired("attempt_reason")

                        /**
                         * Attempted at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun attemptedAt(): LocalDate = attemptedAt.getRequired("attempted_at")

                        /**
                         * Merchandise disposition.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun merchandiseDisposition(): String =
                            merchandiseDisposition.getRequired("merchandise_disposition")

                        /**
                         * Returns the raw JSON value of [attemptExplanation].
                         *
                         * Unlike [attemptExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("attempt_explanation")
                        @ExcludeMissing
                        fun _attemptExplanation(): JsonField<String> = attemptExplanation

                        /**
                         * Returns the raw JSON value of [attemptReason].
                         *
                         * Unlike [attemptReason], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("attempt_reason")
                        @ExcludeMissing
                        fun _attemptReason(): JsonField<AttemptReason> = attemptReason

                        /**
                         * Returns the raw JSON value of [attemptedAt].
                         *
                         * Unlike [attemptedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("attempted_at")
                        @ExcludeMissing
                        fun _attemptedAt(): JsonField<LocalDate> = attemptedAt

                        /**
                         * Returns the raw JSON value of [merchandiseDisposition].
                         *
                         * Unlike [merchandiseDisposition], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchandise_disposition")
                        @ExcludeMissing
                        fun _merchandiseDisposition(): JsonField<String> = merchandiseDisposition

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [ReturnAttempted].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [ReturnAttempted]. */
                        class Builder internal constructor() {

                            private var attemptExplanation: JsonField<String>? = null
                            private var attemptReason: JsonField<AttemptReason>? = null
                            private var attemptedAt: JsonField<LocalDate>? = null
                            private var merchandiseDisposition: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returnAttempted: ReturnAttempted) = apply {
                                attemptExplanation = returnAttempted.attemptExplanation
                                attemptReason = returnAttempted.attemptReason
                                attemptedAt = returnAttempted.attemptedAt
                                merchandiseDisposition = returnAttempted.merchandiseDisposition
                                additionalProperties =
                                    returnAttempted.additionalProperties.toMutableMap()
                            }

                            /** Attempt explanation. */
                            fun attemptExplanation(attemptExplanation: String) =
                                attemptExplanation(JsonField.of(attemptExplanation))

                            /**
                             * Sets [Builder.attemptExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptExplanation] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun attemptExplanation(attemptExplanation: JsonField<String>) = apply {
                                this.attemptExplanation = attemptExplanation
                            }

                            /** Attempt reason. */
                            fun attemptReason(attemptReason: AttemptReason) =
                                attemptReason(JsonField.of(attemptReason))

                            /**
                             * Sets [Builder.attemptReason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptReason] with a well-typed
                             * [AttemptReason] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun attemptReason(attemptReason: JsonField<AttemptReason>) = apply {
                                this.attemptReason = attemptReason
                            }

                            /** Attempted at. */
                            fun attemptedAt(attemptedAt: LocalDate) =
                                attemptedAt(JsonField.of(attemptedAt))

                            /**
                             * Sets [Builder.attemptedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.attemptedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun attemptedAt(attemptedAt: JsonField<LocalDate>) = apply {
                                this.attemptedAt = attemptedAt
                            }

                            /** Merchandise disposition. */
                            fun merchandiseDisposition(merchandiseDisposition: String) =
                                merchandiseDisposition(JsonField.of(merchandiseDisposition))

                            /**
                             * Sets [Builder.merchandiseDisposition] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchandiseDisposition] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchandiseDisposition(merchandiseDisposition: JsonField<String>) =
                                apply {
                                    this.merchandiseDisposition = merchandiseDisposition
                                }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [ReturnAttempted].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .attemptExplanation()
                             * .attemptReason()
                             * .attemptedAt()
                             * .merchandiseDisposition()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): ReturnAttempted =
                                ReturnAttempted(
                                    checkRequired("attemptExplanation", attemptExplanation),
                                    checkRequired("attemptReason", attemptReason),
                                    checkRequired("attemptedAt", attemptedAt),
                                    checkRequired("merchandiseDisposition", merchandiseDisposition),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): ReturnAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            attemptExplanation()
                            attemptReason().validate()
                            attemptedAt()
                            merchandiseDisposition()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (attemptExplanation.asKnown() == null) 0 else 1) +
                                (attemptReason.asKnown()?.validity() ?: 0) +
                                (if (attemptedAt.asKnown() == null) 0 else 1) +
                                (if (merchandiseDisposition.asKnown() == null) 0 else 1)

                        /** Attempt reason. */
                        class AttemptReason
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Merchant not responding. */
                                val MERCHANT_NOT_RESPONDING = of("merchant_not_responding")

                                /** No return authorization provided. */
                                val NO_RETURN_AUTHORIZATION_PROVIDED =
                                    of("no_return_authorization_provided")

                                /** No return instructions. */
                                val NO_RETURN_INSTRUCTIONS = of("no_return_instructions")

                                /** Requested not to return. */
                                val REQUESTED_NOT_TO_RETURN = of("requested_not_to_return")

                                /** Return not accepted. */
                                val RETURN_NOT_ACCEPTED = of("return_not_accepted")

                                fun of(value: String) = AttemptReason(JsonField.of(value))
                            }

                            /** An enum containing [AttemptReason]'s known values. */
                            enum class Known {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AttemptReason]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AttemptReason] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Merchant not responding. */
                                MERCHANT_NOT_RESPONDING,
                                /** No return authorization provided. */
                                NO_RETURN_AUTHORIZATION_PROVIDED,
                                /** No return instructions. */
                                NO_RETURN_INSTRUCTIONS,
                                /** Requested not to return. */
                                REQUESTED_NOT_TO_RETURN,
                                /** Return not accepted. */
                                RETURN_NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AttemptReason] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Value.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Value.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Value.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Value.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Value.RETURN_NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    MERCHANT_NOT_RESPONDING -> Known.MERCHANT_NOT_RESPONDING
                                    NO_RETURN_AUTHORIZATION_PROVIDED ->
                                        Known.NO_RETURN_AUTHORIZATION_PROVIDED
                                    NO_RETURN_INSTRUCTIONS -> Known.NO_RETURN_INSTRUCTIONS
                                    REQUESTED_NOT_TO_RETURN -> Known.REQUESTED_NOT_TO_RETURN
                                    RETURN_NOT_ACCEPTED -> Known.RETURN_NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AttemptReason: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AttemptReason = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AttemptReason && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnAttempted &&
                                attemptExplanation == other.attemptExplanation &&
                                attemptReason == other.attemptReason &&
                                attemptedAt == other.attemptedAt &&
                                merchandiseDisposition == other.merchandiseDisposition &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                attemptExplanation,
                                attemptReason,
                                attemptedAt,
                                merchandiseDisposition,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "ReturnAttempted{attemptExplanation=$attemptExplanation, attemptReason=$attemptReason, attemptedAt=$attemptedAt, merchandiseDisposition=$merchandiseDisposition, additionalProperties=$additionalProperties}"
                    }

                    /** Return outcome. */
                    class ReturnOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not returned. */
                            val NOT_RETURNED = of("not_returned")

                            /** Returned. */
                            val RETURNED = of("returned")

                            /** Return attempted. */
                            val RETURN_ATTEMPTED = of("return_attempted")

                            fun of(value: String) = ReturnOutcome(JsonField.of(value))
                        }

                        /** An enum containing [ReturnOutcome]'s known values. */
                        enum class Known {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                        }

                        /**
                         * An enum containing [ReturnOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [ReturnOutcome] can contain an unknown value in a couple
                         * of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not returned. */
                            NOT_RETURNED,
                            /** Returned. */
                            RETURNED,
                            /** Return attempted. */
                            RETURN_ATTEMPTED,
                            /**
                             * An enum member indicating that [ReturnOutcome] was instantiated with
                             * an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_RETURNED -> Value.NOT_RETURNED
                                RETURNED -> Value.RETURNED
                                RETURN_ATTEMPTED -> Value.RETURN_ATTEMPTED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_RETURNED -> Known.NOT_RETURNED
                                RETURNED -> Known.RETURNED
                                RETURN_ATTEMPTED -> Known.RETURN_ATTEMPTED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ReturnOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ReturnOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ReturnOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /** Returned. Present if and only if `return_outcome` is `returned`. */
                    class Returned
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val merchantReceivedReturnAt: JsonField<LocalDate>,
                        private val otherExplanation: JsonField<String>,
                        private val returnMethod: JsonField<ReturnMethod>,
                        private val returnedAt: JsonField<LocalDate>,
                        private val trackingNumber: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("merchant_received_return_at")
                            @ExcludeMissing
                            merchantReceivedReturnAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("other_explanation")
                            @ExcludeMissing
                            otherExplanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("return_method")
                            @ExcludeMissing
                            returnMethod: JsonField<ReturnMethod> = JsonMissing.of(),
                            @JsonProperty("returned_at")
                            @ExcludeMissing
                            returnedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("tracking_number")
                            @ExcludeMissing
                            trackingNumber: JsonField<String> = JsonMissing.of(),
                        ) : this(
                            merchantReceivedReturnAt,
                            otherExplanation,
                            returnMethod,
                            returnedAt,
                            trackingNumber,
                            mutableMapOf(),
                        )

                        /**
                         * Merchant received return at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun merchantReceivedReturnAt(): LocalDate? =
                            merchantReceivedReturnAt.getNullable("merchant_received_return_at")

                        /**
                         * Other explanation. Required if and only if the return method is `other`.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun otherExplanation(): String? =
                            otherExplanation.getNullable("other_explanation")

                        /**
                         * Return method.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnMethod(): ReturnMethod = returnMethod.getRequired("return_method")

                        /**
                         * Returned at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun returnedAt(): LocalDate = returnedAt.getRequired("returned_at")

                        /**
                         * Tracking number.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun trackingNumber(): String? =
                            trackingNumber.getNullable("tracking_number")

                        /**
                         * Returns the raw JSON value of [merchantReceivedReturnAt].
                         *
                         * Unlike [merchantReceivedReturnAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("merchant_received_return_at")
                        @ExcludeMissing
                        fun _merchantReceivedReturnAt(): JsonField<LocalDate> =
                            merchantReceivedReturnAt

                        /**
                         * Returns the raw JSON value of [otherExplanation].
                         *
                         * Unlike [otherExplanation], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("other_explanation")
                        @ExcludeMissing
                        fun _otherExplanation(): JsonField<String> = otherExplanation

                        /**
                         * Returns the raw JSON value of [returnMethod].
                         *
                         * Unlike [returnMethod], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("return_method")
                        @ExcludeMissing
                        fun _returnMethod(): JsonField<ReturnMethod> = returnMethod

                        /**
                         * Returns the raw JSON value of [returnedAt].
                         *
                         * Unlike [returnedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("returned_at")
                        @ExcludeMissing
                        fun _returnedAt(): JsonField<LocalDate> = returnedAt

                        /**
                         * Returns the raw JSON value of [trackingNumber].
                         *
                         * Unlike [trackingNumber], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("tracking_number")
                        @ExcludeMissing
                        fun _trackingNumber(): JsonField<String> = trackingNumber

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of [Returned].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [Returned]. */
                        class Builder internal constructor() {

                            private var merchantReceivedReturnAt: JsonField<LocalDate>? = null
                            private var otherExplanation: JsonField<String>? = null
                            private var returnMethod: JsonField<ReturnMethod>? = null
                            private var returnedAt: JsonField<LocalDate>? = null
                            private var trackingNumber: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(returned: Returned) = apply {
                                merchantReceivedReturnAt = returned.merchantReceivedReturnAt
                                otherExplanation = returned.otherExplanation
                                returnMethod = returned.returnMethod
                                returnedAt = returned.returnedAt
                                trackingNumber = returned.trackingNumber
                                additionalProperties = returned.additionalProperties.toMutableMap()
                            }

                            /** Merchant received return at. */
                            fun merchantReceivedReturnAt(merchantReceivedReturnAt: LocalDate?) =
                                merchantReceivedReturnAt(
                                    JsonField.ofNullable(merchantReceivedReturnAt)
                                )

                            /**
                             * Sets [Builder.merchantReceivedReturnAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.merchantReceivedReturnAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun merchantReceivedReturnAt(
                                merchantReceivedReturnAt: JsonField<LocalDate>
                            ) = apply { this.merchantReceivedReturnAt = merchantReceivedReturnAt }

                            /**
                             * Other explanation. Required if and only if the return method is
                             * `other`.
                             */
                            fun otherExplanation(otherExplanation: String?) =
                                otherExplanation(JsonField.ofNullable(otherExplanation))

                            /**
                             * Sets [Builder.otherExplanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherExplanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun otherExplanation(otherExplanation: JsonField<String>) = apply {
                                this.otherExplanation = otherExplanation
                            }

                            /** Return method. */
                            fun returnMethod(returnMethod: ReturnMethod) =
                                returnMethod(JsonField.of(returnMethod))

                            /**
                             * Sets [Builder.returnMethod] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnMethod] with a well-typed
                             * [ReturnMethod] value instead. This method is primarily for setting
                             * the field to an undocumented or not yet supported value.
                             */
                            fun returnMethod(returnMethod: JsonField<ReturnMethod>) = apply {
                                this.returnMethod = returnMethod
                            }

                            /** Returned at. */
                            fun returnedAt(returnedAt: LocalDate) =
                                returnedAt(JsonField.of(returnedAt))

                            /**
                             * Sets [Builder.returnedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.returnedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun returnedAt(returnedAt: JsonField<LocalDate>) = apply {
                                this.returnedAt = returnedAt
                            }

                            /** Tracking number. */
                            fun trackingNumber(trackingNumber: String?) =
                                trackingNumber(JsonField.ofNullable(trackingNumber))

                            /**
                             * Sets [Builder.trackingNumber] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.trackingNumber] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun trackingNumber(trackingNumber: JsonField<String>) = apply {
                                this.trackingNumber = trackingNumber
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [Returned].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .merchantReceivedReturnAt()
                             * .otherExplanation()
                             * .returnMethod()
                             * .returnedAt()
                             * .trackingNumber()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): Returned =
                                Returned(
                                    checkRequired(
                                        "merchantReceivedReturnAt",
                                        merchantReceivedReturnAt,
                                    ),
                                    checkRequired("otherExplanation", otherExplanation),
                                    checkRequired("returnMethod", returnMethod),
                                    checkRequired("returnedAt", returnedAt),
                                    checkRequired("trackingNumber", trackingNumber),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): Returned = apply {
                            if (validated) {
                                return@apply
                            }

                            merchantReceivedReturnAt()
                            otherExplanation()
                            returnMethod().validate()
                            returnedAt()
                            trackingNumber()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (merchantReceivedReturnAt.asKnown() == null) 0 else 1) +
                                (if (otherExplanation.asKnown() == null) 0 else 1) +
                                (returnMethod.asKnown()?.validity() ?: 0) +
                                (if (returnedAt.asKnown() == null) 0 else 1) +
                                (if (trackingNumber.asKnown() == null) 0 else 1)

                        /** Return method. */
                        class ReturnMethod
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** DHL. */
                                val DHL = of("dhl")

                                /** Face-to-face. */
                                val FACE_TO_FACE = of("face_to_face")

                                /** FedEx. */
                                val FEDEX = of("fedex")

                                /** Other. */
                                val OTHER = of("other")

                                /** Postal service. */
                                val POSTAL_SERVICE = of("postal_service")

                                /** UPS. */
                                val UPS = of("ups")

                                fun of(value: String) = ReturnMethod(JsonField.of(value))
                            }

                            /** An enum containing [ReturnMethod]'s known values. */
                            enum class Known {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                            }

                            /**
                             * An enum containing [ReturnMethod]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [ReturnMethod] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** DHL. */
                                DHL,
                                /** Face-to-face. */
                                FACE_TO_FACE,
                                /** FedEx. */
                                FEDEX,
                                /** Other. */
                                OTHER,
                                /** Postal service. */
                                POSTAL_SERVICE,
                                /** UPS. */
                                UPS,
                                /**
                                 * An enum member indicating that [ReturnMethod] was instantiated
                                 * with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    DHL -> Value.DHL
                                    FACE_TO_FACE -> Value.FACE_TO_FACE
                                    FEDEX -> Value.FEDEX
                                    OTHER -> Value.OTHER
                                    POSTAL_SERVICE -> Value.POSTAL_SERVICE
                                    UPS -> Value.UPS
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    DHL -> Known.DHL
                                    FACE_TO_FACE -> Known.FACE_TO_FACE
                                    FEDEX -> Known.FEDEX
                                    OTHER -> Known.OTHER
                                    POSTAL_SERVICE -> Known.POSTAL_SERVICE
                                    UPS -> Known.UPS
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown ReturnMethod: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): ReturnMethod = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is ReturnMethod && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Returned &&
                                merchantReceivedReturnAt == other.merchantReceivedReturnAt &&
                                otherExplanation == other.otherExplanation &&
                                returnMethod == other.returnMethod &&
                                returnedAt == other.returnedAt &&
                                trackingNumber == other.trackingNumber &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                merchantReceivedReturnAt,
                                otherExplanation,
                                returnMethod,
                                returnedAt,
                                trackingNumber,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "Returned{merchantReceivedReturnAt=$merchantReceivedReturnAt, otherExplanation=$otherExplanation, returnMethod=$returnMethod, returnedAt=$returnedAt, trackingNumber=$trackingNumber, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerQualityMerchandise &&
                            expectedAt == other.expectedAt &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            notReturned == other.notReturned &&
                            ongoingNegotiations == other.ongoingNegotiations &&
                            purchaseInfoAndQualityIssue == other.purchaseInfoAndQualityIssue &&
                            receivedAt == other.receivedAt &&
                            returnAttempted == other.returnAttempted &&
                            returnOutcome == other.returnOutcome &&
                            returned == other.returned &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            expectedAt,
                            merchantResolutionAttempted,
                            notReturned,
                            ongoingNegotiations,
                            purchaseInfoAndQualityIssue,
                            receivedAt,
                            returnAttempted,
                            returnOutcome,
                            returned,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerQualityMerchandise{expectedAt=$expectedAt, merchantResolutionAttempted=$merchantResolutionAttempted, notReturned=$notReturned, ongoingNegotiations=$ongoingNegotiations, purchaseInfoAndQualityIssue=$purchaseInfoAndQualityIssue, receivedAt=$receivedAt, returnAttempted=$returnAttempted, returnOutcome=$returnOutcome, returned=$returned, additionalProperties=$additionalProperties}"
                }

                /**
                 * Services quality issue. Present if and only if `category` is
                 * `consumer_quality_services`.
                 */
                class ConsumerQualityServices
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cardholderCancellation: JsonField<CardholderCancellation>,
                    private val cardholderPaidToHaveWorkRedone:
                        JsonField<CardholderPaidToHaveWorkRedone>,
                    private val nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                        JsonField<
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                        >,
                    private val ongoingNegotiations: JsonField<OngoingNegotiations>,
                    private val purchaseInfoAndQualityIssue: JsonField<String>,
                    private val restaurantFoodRelated: JsonField<RestaurantFoodRelated>,
                    private val servicesReceivedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cardholder_cancellation")
                        @ExcludeMissing
                        cardholderCancellation: JsonField<CardholderCancellation> =
                            JsonMissing.of(),
                        @JsonProperty("cardholder_paid_to_have_work_redone")
                        @ExcludeMissing
                        cardholderPaidToHaveWorkRedone: JsonField<CardholderPaidToHaveWorkRedone> =
                            JsonMissing.of(),
                        @JsonProperty(
                            "non_fiat_currency_or_non_fungible_token_related_and_not_matching_description"
                        )
                        @ExcludeMissing
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                            JsonField<
                                NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                            > =
                            JsonMissing.of(),
                        @JsonProperty("ongoing_negotiations")
                        @ExcludeMissing
                        ongoingNegotiations: JsonField<OngoingNegotiations> = JsonMissing.of(),
                        @JsonProperty("purchase_info_and_quality_issue")
                        @ExcludeMissing
                        purchaseInfoAndQualityIssue: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("restaurant_food_related")
                        @ExcludeMissing
                        restaurantFoodRelated: JsonField<RestaurantFoodRelated> = JsonMissing.of(),
                        @JsonProperty("services_received_at")
                        @ExcludeMissing
                        servicesReceivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(
                        cardholderCancellation,
                        cardholderPaidToHaveWorkRedone,
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription,
                        ongoingNegotiations,
                        purchaseInfoAndQualityIssue,
                        restaurantFoodRelated,
                        servicesReceivedAt,
                        mutableMapOf(),
                    )

                    /**
                     * Cardholder cancellation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cardholderCancellation(): CardholderCancellation =
                        cardholderCancellation.getRequired("cardholder_cancellation")

                    /**
                     * Cardholder paid to have work redone.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun cardholderPaidToHaveWorkRedone(): CardholderPaidToHaveWorkRedone? =
                        cardholderPaidToHaveWorkRedone.getNullable(
                            "cardholder_paid_to_have_work_redone"
                        )

                    /**
                     * Non-fiat currency or non-fungible token related and not matching description.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription():
                        NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription =
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                            .getRequired(
                                "non_fiat_currency_or_non_fungible_token_related_and_not_matching_description"
                            )

                    /**
                     * Ongoing negotiations. Exclude if there is no evidence of ongoing
                     * negotiations.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun ongoingNegotiations(): OngoingNegotiations? =
                        ongoingNegotiations.getNullable("ongoing_negotiations")

                    /**
                     * Purchase information and quality issue.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseInfoAndQualityIssue(): String =
                        purchaseInfoAndQualityIssue.getRequired("purchase_info_and_quality_issue")

                    /**
                     * Whether the dispute is related to the quality of food from an eating place or
                     * restaurant. Must be provided when Merchant Category Code (MCC) is 5812, 5813
                     * or 5814.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun restaurantFoodRelated(): RestaurantFoodRelated? =
                        restaurantFoodRelated.getNullable("restaurant_food_related")

                    /**
                     * Services received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun servicesReceivedAt(): LocalDate =
                        servicesReceivedAt.getRequired("services_received_at")

                    /**
                     * Returns the raw JSON value of [cardholderCancellation].
                     *
                     * Unlike [cardholderCancellation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                        cardholderCancellation

                    /**
                     * Returns the raw JSON value of [cardholderPaidToHaveWorkRedone].
                     *
                     * Unlike [cardholderPaidToHaveWorkRedone], this method doesn't throw if the
                     * JSON field has an unexpected type.
                     */
                    @JsonProperty("cardholder_paid_to_have_work_redone")
                    @ExcludeMissing
                    fun _cardholderPaidToHaveWorkRedone():
                        JsonField<CardholderPaidToHaveWorkRedone> = cardholderPaidToHaveWorkRedone

                    /**
                     * Returns the raw JSON value of
                     * [nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription].
                     *
                     * Unlike [nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription],
                     * this method doesn't throw if the JSON field has an unexpected type.
                     */
                    @JsonProperty(
                        "non_fiat_currency_or_non_fungible_token_related_and_not_matching_description"
                    )
                    @ExcludeMissing
                    fun _nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription():
                        JsonField<
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                        > = nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription

                    /**
                     * Returns the raw JSON value of [ongoingNegotiations].
                     *
                     * Unlike [ongoingNegotiations], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("ongoing_negotiations")
                    @ExcludeMissing
                    fun _ongoingNegotiations(): JsonField<OngoingNegotiations> = ongoingNegotiations

                    /**
                     * Returns the raw JSON value of [purchaseInfoAndQualityIssue].
                     *
                     * Unlike [purchaseInfoAndQualityIssue], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("purchase_info_and_quality_issue")
                    @ExcludeMissing
                    fun _purchaseInfoAndQualityIssue(): JsonField<String> =
                        purchaseInfoAndQualityIssue

                    /**
                     * Returns the raw JSON value of [restaurantFoodRelated].
                     *
                     * Unlike [restaurantFoodRelated], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("restaurant_food_related")
                    @ExcludeMissing
                    fun _restaurantFoodRelated(): JsonField<RestaurantFoodRelated> =
                        restaurantFoodRelated

                    /**
                     * Returns the raw JSON value of [servicesReceivedAt].
                     *
                     * Unlike [servicesReceivedAt], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("services_received_at")
                    @ExcludeMissing
                    fun _servicesReceivedAt(): JsonField<LocalDate> = servicesReceivedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerQualityServices].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .cardholderPaidToHaveWorkRedone()
                         * .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription()
                         * .ongoingNegotiations()
                         * .purchaseInfoAndQualityIssue()
                         * .restaurantFoodRelated()
                         * .servicesReceivedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerQualityServices]. */
                    class Builder internal constructor() {

                        private var cardholderCancellation: JsonField<CardholderCancellation>? =
                            null
                        private var cardholderPaidToHaveWorkRedone:
                            JsonField<CardholderPaidToHaveWorkRedone>? =
                            null
                        private var nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                            JsonField<
                                NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                            >? =
                            null
                        private var ongoingNegotiations: JsonField<OngoingNegotiations>? = null
                        private var purchaseInfoAndQualityIssue: JsonField<String>? = null
                        private var restaurantFoodRelated: JsonField<RestaurantFoodRelated>? = null
                        private var servicesReceivedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(consumerQualityServices: ConsumerQualityServices) =
                            apply {
                                cardholderCancellation =
                                    consumerQualityServices.cardholderCancellation
                                cardholderPaidToHaveWorkRedone =
                                    consumerQualityServices.cardholderPaidToHaveWorkRedone
                                nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription =
                                    consumerQualityServices
                                        .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                                ongoingNegotiations = consumerQualityServices.ongoingNegotiations
                                purchaseInfoAndQualityIssue =
                                    consumerQualityServices.purchaseInfoAndQualityIssue
                                restaurantFoodRelated =
                                    consumerQualityServices.restaurantFoodRelated
                                servicesReceivedAt = consumerQualityServices.servicesReceivedAt
                                additionalProperties =
                                    consumerQualityServices.additionalProperties.toMutableMap()
                            }

                        /** Cardholder cancellation. */
                        fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                            cardholderCancellation(JsonField.of(cardholderCancellation))

                        /**
                         * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cardholderCancellation] with a
                         * well-typed [CardholderCancellation] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cardholderCancellation(
                            cardholderCancellation: JsonField<CardholderCancellation>
                        ) = apply { this.cardholderCancellation = cardholderCancellation }

                        /** Cardholder paid to have work redone. */
                        fun cardholderPaidToHaveWorkRedone(
                            cardholderPaidToHaveWorkRedone: CardholderPaidToHaveWorkRedone?
                        ) =
                            cardholderPaidToHaveWorkRedone(
                                JsonField.ofNullable(cardholderPaidToHaveWorkRedone)
                            )

                        /**
                         * Sets [Builder.cardholderPaidToHaveWorkRedone] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cardholderPaidToHaveWorkRedone] with a
                         * well-typed [CardholderPaidToHaveWorkRedone] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cardholderPaidToHaveWorkRedone(
                            cardholderPaidToHaveWorkRedone:
                                JsonField<CardholderPaidToHaveWorkRedone>
                        ) = apply {
                            this.cardholderPaidToHaveWorkRedone = cardholderPaidToHaveWorkRedone
                        }

                        /**
                         * Non-fiat currency or non-fungible token related and not matching
                         * description.
                         */
                        fun nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                            nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                                NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                        ) =
                            nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                                JsonField.of(
                                    nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                                )
                            )

                        /**
                         * Sets
                         * [Builder.nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]
                         * to an arbitrary JSON value.
                         *
                         * You should usually call
                         * [Builder.nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]
                         * with a well-typed
                         * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                            nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription:
                                JsonField<
                                    NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                                >
                        ) = apply {
                            this.nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription =
                                nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                        }

                        /**
                         * Ongoing negotiations. Exclude if there is no evidence of ongoing
                         * negotiations.
                         */
                        fun ongoingNegotiations(ongoingNegotiations: OngoingNegotiations?) =
                            ongoingNegotiations(JsonField.ofNullable(ongoingNegotiations))

                        /**
                         * Sets [Builder.ongoingNegotiations] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.ongoingNegotiations] with a well-typed
                         * [OngoingNegotiations] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun ongoingNegotiations(
                            ongoingNegotiations: JsonField<OngoingNegotiations>
                        ) = apply { this.ongoingNegotiations = ongoingNegotiations }

                        /** Purchase information and quality issue. */
                        fun purchaseInfoAndQualityIssue(purchaseInfoAndQualityIssue: String) =
                            purchaseInfoAndQualityIssue(JsonField.of(purchaseInfoAndQualityIssue))

                        /**
                         * Sets [Builder.purchaseInfoAndQualityIssue] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseInfoAndQualityIssue] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun purchaseInfoAndQualityIssue(
                            purchaseInfoAndQualityIssue: JsonField<String>
                        ) = apply { this.purchaseInfoAndQualityIssue = purchaseInfoAndQualityIssue }

                        /**
                         * Whether the dispute is related to the quality of food from an eating
                         * place or restaurant. Must be provided when Merchant Category Code (MCC)
                         * is 5812, 5813 or 5814.
                         */
                        fun restaurantFoodRelated(restaurantFoodRelated: RestaurantFoodRelated?) =
                            restaurantFoodRelated(JsonField.ofNullable(restaurantFoodRelated))

                        /**
                         * Sets [Builder.restaurantFoodRelated] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.restaurantFoodRelated] with a well-typed
                         * [RestaurantFoodRelated] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun restaurantFoodRelated(
                            restaurantFoodRelated: JsonField<RestaurantFoodRelated>
                        ) = apply { this.restaurantFoodRelated = restaurantFoodRelated }

                        /** Services received at. */
                        fun servicesReceivedAt(servicesReceivedAt: LocalDate) =
                            servicesReceivedAt(JsonField.of(servicesReceivedAt))

                        /**
                         * Sets [Builder.servicesReceivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.servicesReceivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun servicesReceivedAt(servicesReceivedAt: JsonField<LocalDate>) = apply {
                            this.servicesReceivedAt = servicesReceivedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerQualityServices].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .cardholderPaidToHaveWorkRedone()
                         * .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription()
                         * .ongoingNegotiations()
                         * .purchaseInfoAndQualityIssue()
                         * .restaurantFoodRelated()
                         * .servicesReceivedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerQualityServices =
                            ConsumerQualityServices(
                                checkRequired("cardholderCancellation", cardholderCancellation),
                                checkRequired(
                                    "cardholderPaidToHaveWorkRedone",
                                    cardholderPaidToHaveWorkRedone,
                                ),
                                checkRequired(
                                    "nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription",
                                    nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription,
                                ),
                                checkRequired("ongoingNegotiations", ongoingNegotiations),
                                checkRequired(
                                    "purchaseInfoAndQualityIssue",
                                    purchaseInfoAndQualityIssue,
                                ),
                                checkRequired("restaurantFoodRelated", restaurantFoodRelated),
                                checkRequired("servicesReceivedAt", servicesReceivedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerQualityServices = apply {
                        if (validated) {
                            return@apply
                        }

                        cardholderCancellation().validate()
                        cardholderPaidToHaveWorkRedone()?.validate()
                        nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription()
                            .validate()
                        ongoingNegotiations()?.validate()
                        purchaseInfoAndQualityIssue()
                        restaurantFoodRelated()?.validate()
                        servicesReceivedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cardholderCancellation.asKnown()?.validity() ?: 0) +
                            (cardholderPaidToHaveWorkRedone.asKnown()?.validity() ?: 0) +
                            (nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                                .asKnown()
                                ?.validity() ?: 0) +
                            (ongoingNegotiations.asKnown()?.validity() ?: 0) +
                            (if (purchaseInfoAndQualityIssue.asKnown() == null) 0 else 1) +
                            (restaurantFoodRelated.asKnown()?.validity() ?: 0) +
                            (if (servicesReceivedAt.asKnown() == null) 0 else 1)

                    /** Cardholder cancellation. */
                    class CardholderCancellation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val acceptedByMerchant: JsonField<AcceptedByMerchant>,
                        private val canceledAt: JsonField<LocalDate>,
                        private val reason: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("accepted_by_merchant")
                            @ExcludeMissing
                            acceptedByMerchant: JsonField<AcceptedByMerchant> = JsonMissing.of(),
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("reason")
                            @ExcludeMissing
                            reason: JsonField<String> = JsonMissing.of(),
                        ) : this(acceptedByMerchant, canceledAt, reason, mutableMapOf())

                        /**
                         * Accepted by merchant.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun acceptedByMerchant(): AcceptedByMerchant =
                            acceptedByMerchant.getRequired("accepted_by_merchant")

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun reason(): String = reason.getRequired("reason")

                        /**
                         * Returns the raw JSON value of [acceptedByMerchant].
                         *
                         * Unlike [acceptedByMerchant], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("accepted_by_merchant")
                        @ExcludeMissing
                        fun _acceptedByMerchant(): JsonField<AcceptedByMerchant> =
                            acceptedByMerchant

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        /**
                         * Returns the raw JSON value of [reason].
                         *
                         * Unlike [reason], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("reason")
                        @ExcludeMissing
                        fun _reason(): JsonField<String> = reason

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [CardholderCancellation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .acceptedByMerchant()
                             * .canceledAt()
                             * .reason()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [CardholderCancellation]. */
                        class Builder internal constructor() {

                            private var acceptedByMerchant: JsonField<AcceptedByMerchant>? = null
                            private var canceledAt: JsonField<LocalDate>? = null
                            private var reason: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(cardholderCancellation: CardholderCancellation) =
                                apply {
                                    acceptedByMerchant = cardholderCancellation.acceptedByMerchant
                                    canceledAt = cardholderCancellation.canceledAt
                                    reason = cardholderCancellation.reason
                                    additionalProperties =
                                        cardholderCancellation.additionalProperties.toMutableMap()
                                }

                            /** Accepted by merchant. */
                            fun acceptedByMerchant(acceptedByMerchant: AcceptedByMerchant) =
                                acceptedByMerchant(JsonField.of(acceptedByMerchant))

                            /**
                             * Sets [Builder.acceptedByMerchant] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.acceptedByMerchant] with a
                             * well-typed [AcceptedByMerchant] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun acceptedByMerchant(
                                acceptedByMerchant: JsonField<AcceptedByMerchant>
                            ) = apply { this.acceptedByMerchant = acceptedByMerchant }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            /** Reason. */
                            fun reason(reason: String) = reason(JsonField.of(reason))

                            /**
                             * Sets [Builder.reason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.reason] with a well-typed [String]
                             * value instead. This method is primarily for setting the field to an
                             * undocumented or not yet supported value.
                             */
                            fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [CardholderCancellation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .acceptedByMerchant()
                             * .canceledAt()
                             * .reason()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): CardholderCancellation =
                                CardholderCancellation(
                                    checkRequired("acceptedByMerchant", acceptedByMerchant),
                                    checkRequired("canceledAt", canceledAt),
                                    checkRequired("reason", reason),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): CardholderCancellation = apply {
                            if (validated) {
                                return@apply
                            }

                            acceptedByMerchant().validate()
                            canceledAt()
                            reason()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (acceptedByMerchant.asKnown()?.validity() ?: 0) +
                                (if (canceledAt.asKnown() == null) 0 else 1) +
                                (if (reason.asKnown() == null) 0 else 1)

                        /** Accepted by merchant. */
                        class AcceptedByMerchant
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Accepted. */
                                val ACCEPTED = of("accepted")

                                /** Not accepted. */
                                val NOT_ACCEPTED = of("not_accepted")

                                fun of(value: String) = AcceptedByMerchant(JsonField.of(value))
                            }

                            /** An enum containing [AcceptedByMerchant]'s known values. */
                            enum class Known {
                                /** Accepted. */
                                ACCEPTED,
                                /** Not accepted. */
                                NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AcceptedByMerchant]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AcceptedByMerchant] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Accepted. */
                                ACCEPTED,
                                /** Not accepted. */
                                NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AcceptedByMerchant] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    ACCEPTED -> Value.ACCEPTED
                                    NOT_ACCEPTED -> Value.NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    ACCEPTED -> Known.ACCEPTED
                                    NOT_ACCEPTED -> Known.NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AcceptedByMerchant: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AcceptedByMerchant = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AcceptedByMerchant && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderCancellation &&
                                acceptedByMerchant == other.acceptedByMerchant &&
                                canceledAt == other.canceledAt &&
                                reason == other.reason &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                acceptedByMerchant,
                                canceledAt,
                                reason,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "CardholderCancellation{acceptedByMerchant=$acceptedByMerchant, canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                    }

                    /** Cardholder paid to have work redone. */
                    class CardholderPaidToHaveWorkRedone
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Cardholder did not pay to have work redone. */
                            val DID_NOT_PAY_TO_HAVE_WORK_REDONE =
                                of("did_not_pay_to_have_work_redone")

                            /** Cardholder paid to have work redone. */
                            val PAID_TO_HAVE_WORK_REDONE = of("paid_to_have_work_redone")

                            fun of(value: String) =
                                CardholderPaidToHaveWorkRedone(JsonField.of(value))
                        }

                        /** An enum containing [CardholderPaidToHaveWorkRedone]'s known values. */
                        enum class Known {
                            /** Cardholder did not pay to have work redone. */
                            DID_NOT_PAY_TO_HAVE_WORK_REDONE,
                            /** Cardholder paid to have work redone. */
                            PAID_TO_HAVE_WORK_REDONE,
                        }

                        /**
                         * An enum containing [CardholderPaidToHaveWorkRedone]'s known values, as
                         * well as an [_UNKNOWN] member.
                         *
                         * An instance of [CardholderPaidToHaveWorkRedone] can contain an unknown
                         * value in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Cardholder did not pay to have work redone. */
                            DID_NOT_PAY_TO_HAVE_WORK_REDONE,
                            /** Cardholder paid to have work redone. */
                            PAID_TO_HAVE_WORK_REDONE,
                            /**
                             * An enum member indicating that [CardholderPaidToHaveWorkRedone] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DID_NOT_PAY_TO_HAVE_WORK_REDONE ->
                                    Value.DID_NOT_PAY_TO_HAVE_WORK_REDONE
                                PAID_TO_HAVE_WORK_REDONE -> Value.PAID_TO_HAVE_WORK_REDONE
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DID_NOT_PAY_TO_HAVE_WORK_REDONE ->
                                    Known.DID_NOT_PAY_TO_HAVE_WORK_REDONE
                                PAID_TO_HAVE_WORK_REDONE -> Known.PAID_TO_HAVE_WORK_REDONE
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CardholderPaidToHaveWorkRedone: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CardholderPaidToHaveWorkRedone = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderPaidToHaveWorkRedone && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Non-fiat currency or non-fungible token related and not matching description.
                     */
                    class NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not related. */
                            val NOT_RELATED = of("not_related")

                            /** Related. */
                            val RELATED = of("related")

                            fun of(value: String) =
                                NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription(
                                    JsonField.of(value)
                                )
                        }

                        /**
                         * An enum containing
                         * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]'s
                         * known values.
                         */
                        enum class Known {
                            /** Not related. */
                            NOT_RELATED,
                            /** Related. */
                            RELATED,
                        }

                        /**
                         * An enum containing
                         * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]'s
                         * known values, as well as an [_UNKNOWN] member.
                         *
                         * An instance of
                         * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription] can
                         * contain an unknown value in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not related. */
                            NOT_RELATED,
                            /** Related. */
                            RELATED,
                            /**
                             * An enum member indicating that
                             * [NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription]
                             * was instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_RELATED -> Value.NOT_RELATED
                                RELATED -> Value.RELATED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_RELATED -> Known.NOT_RELATED
                                RELATED -> Known.RELATED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate():
                            NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription =
                            apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is
                                NonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription &&
                                value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Ongoing negotiations. Exclude if there is no evidence of ongoing
                     * negotiations.
                     */
                    class OngoingNegotiations
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val explanation: JsonField<String>,
                        private val issuerFirstNotifiedAt: JsonField<LocalDate>,
                        private val startedAt: JsonField<LocalDate>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("explanation")
                            @ExcludeMissing
                            explanation: JsonField<String> = JsonMissing.of(),
                            @JsonProperty("issuer_first_notified_at")
                            @ExcludeMissing
                            issuerFirstNotifiedAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("started_at")
                            @ExcludeMissing
                            startedAt: JsonField<LocalDate> = JsonMissing.of(),
                        ) : this(explanation, issuerFirstNotifiedAt, startedAt, mutableMapOf())

                        /**
                         * Explanation of the previous ongoing negotiations between the cardholder
                         * and merchant.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun explanation(): String = explanation.getRequired("explanation")

                        /**
                         * Date the cardholder first notified the issuer of the dispute.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun issuerFirstNotifiedAt(): LocalDate =
                            issuerFirstNotifiedAt.getRequired("issuer_first_notified_at")

                        /**
                         * Started at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun startedAt(): LocalDate = startedAt.getRequired("started_at")

                        /**
                         * Returns the raw JSON value of [explanation].
                         *
                         * Unlike [explanation], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("explanation")
                        @ExcludeMissing
                        fun _explanation(): JsonField<String> = explanation

                        /**
                         * Returns the raw JSON value of [issuerFirstNotifiedAt].
                         *
                         * Unlike [issuerFirstNotifiedAt], this method doesn't throw if the JSON
                         * field has an unexpected type.
                         */
                        @JsonProperty("issuer_first_notified_at")
                        @ExcludeMissing
                        fun _issuerFirstNotifiedAt(): JsonField<LocalDate> = issuerFirstNotifiedAt

                        /**
                         * Returns the raw JSON value of [startedAt].
                         *
                         * Unlike [startedAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("started_at")
                        @ExcludeMissing
                        fun _startedAt(): JsonField<LocalDate> = startedAt

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [OngoingNegotiations].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * .issuerFirstNotifiedAt()
                             * .startedAt()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [OngoingNegotiations]. */
                        class Builder internal constructor() {

                            private var explanation: JsonField<String>? = null
                            private var issuerFirstNotifiedAt: JsonField<LocalDate>? = null
                            private var startedAt: JsonField<LocalDate>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(ongoingNegotiations: OngoingNegotiations) = apply {
                                explanation = ongoingNegotiations.explanation
                                issuerFirstNotifiedAt = ongoingNegotiations.issuerFirstNotifiedAt
                                startedAt = ongoingNegotiations.startedAt
                                additionalProperties =
                                    ongoingNegotiations.additionalProperties.toMutableMap()
                            }

                            /**
                             * Explanation of the previous ongoing negotiations between the
                             * cardholder and merchant.
                             */
                            fun explanation(explanation: String) =
                                explanation(JsonField.of(explanation))

                            /**
                             * Sets [Builder.explanation] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.explanation] with a well-typed
                             * [String] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun explanation(explanation: JsonField<String>) = apply {
                                this.explanation = explanation
                            }

                            /** Date the cardholder first notified the issuer of the dispute. */
                            fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: LocalDate) =
                                issuerFirstNotifiedAt(JsonField.of(issuerFirstNotifiedAt))

                            /**
                             * Sets [Builder.issuerFirstNotifiedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.issuerFirstNotifiedAt] with a
                             * well-typed [LocalDate] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun issuerFirstNotifiedAt(issuerFirstNotifiedAt: JsonField<LocalDate>) =
                                apply {
                                    this.issuerFirstNotifiedAt = issuerFirstNotifiedAt
                                }

                            /** Started at. */
                            fun startedAt(startedAt: LocalDate) = startedAt(JsonField.of(startedAt))

                            /**
                             * Sets [Builder.startedAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.startedAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun startedAt(startedAt: JsonField<LocalDate>) = apply {
                                this.startedAt = startedAt
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [OngoingNegotiations].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .explanation()
                             * .issuerFirstNotifiedAt()
                             * .startedAt()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): OngoingNegotiations =
                                OngoingNegotiations(
                                    checkRequired("explanation", explanation),
                                    checkRequired("issuerFirstNotifiedAt", issuerFirstNotifiedAt),
                                    checkRequired("startedAt", startedAt),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): OngoingNegotiations = apply {
                            if (validated) {
                                return@apply
                            }

                            explanation()
                            issuerFirstNotifiedAt()
                            startedAt()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (explanation.asKnown() == null) 0 else 1) +
                                (if (issuerFirstNotifiedAt.asKnown() == null) 0 else 1) +
                                (if (startedAt.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is OngoingNegotiations &&
                                explanation == other.explanation &&
                                issuerFirstNotifiedAt == other.issuerFirstNotifiedAt &&
                                startedAt == other.startedAt &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                explanation,
                                issuerFirstNotifiedAt,
                                startedAt,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "OngoingNegotiations{explanation=$explanation, issuerFirstNotifiedAt=$issuerFirstNotifiedAt, startedAt=$startedAt, additionalProperties=$additionalProperties}"
                    }

                    /**
                     * Whether the dispute is related to the quality of food from an eating place or
                     * restaurant. Must be provided when Merchant Category Code (MCC) is 5812, 5813
                     * or 5814.
                     */
                    class RestaurantFoodRelated
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Not related. */
                            val NOT_RELATED = of("not_related")

                            /** Related. */
                            val RELATED = of("related")

                            fun of(value: String) = RestaurantFoodRelated(JsonField.of(value))
                        }

                        /** An enum containing [RestaurantFoodRelated]'s known values. */
                        enum class Known {
                            /** Not related. */
                            NOT_RELATED,
                            /** Related. */
                            RELATED,
                        }

                        /**
                         * An enum containing [RestaurantFoodRelated]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [RestaurantFoodRelated] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Not related. */
                            NOT_RELATED,
                            /** Related. */
                            RELATED,
                            /**
                             * An enum member indicating that [RestaurantFoodRelated] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                NOT_RELATED -> Value.NOT_RELATED
                                RELATED -> Value.RELATED
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                NOT_RELATED -> Known.NOT_RELATED
                                RELATED -> Known.RELATED
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown RestaurantFoodRelated: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): RestaurantFoodRelated = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is RestaurantFoodRelated && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerQualityServices &&
                            cardholderCancellation == other.cardholderCancellation &&
                            cardholderPaidToHaveWorkRedone ==
                                other.cardholderPaidToHaveWorkRedone &&
                            nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription ==
                                other
                                    .nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription &&
                            ongoingNegotiations == other.ongoingNegotiations &&
                            purchaseInfoAndQualityIssue == other.purchaseInfoAndQualityIssue &&
                            restaurantFoodRelated == other.restaurantFoodRelated &&
                            servicesReceivedAt == other.servicesReceivedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cardholderCancellation,
                            cardholderPaidToHaveWorkRedone,
                            nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription,
                            ongoingNegotiations,
                            purchaseInfoAndQualityIssue,
                            restaurantFoodRelated,
                            servicesReceivedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerQualityServices{cardholderCancellation=$cardholderCancellation, cardholderPaidToHaveWorkRedone=$cardholderPaidToHaveWorkRedone, nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription=$nonFiatCurrencyOrNonFungibleTokenRelatedAndNotMatchingDescription, ongoingNegotiations=$ongoingNegotiations, purchaseInfoAndQualityIssue=$purchaseInfoAndQualityIssue, restaurantFoodRelated=$restaurantFoodRelated, servicesReceivedAt=$servicesReceivedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Services misrepresentation. Present if and only if `category` is
                 * `consumer_services_misrepresentation`.
                 */
                class ConsumerServicesMisrepresentation
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cardholderCancellation: JsonField<CardholderCancellation>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val misrepresentationExplanation: JsonField<String>,
                    private val purchaseExplanation: JsonField<String>,
                    private val receivedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cardholder_cancellation")
                        @ExcludeMissing
                        cardholderCancellation: JsonField<CardholderCancellation> =
                            JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("misrepresentation_explanation")
                        @ExcludeMissing
                        misrepresentationExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("purchase_explanation")
                        @ExcludeMissing
                        purchaseExplanation: JsonField<String> = JsonMissing.of(),
                        @JsonProperty("received_at")
                        @ExcludeMissing
                        receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(
                        cardholderCancellation,
                        merchantResolutionAttempted,
                        misrepresentationExplanation,
                        purchaseExplanation,
                        receivedAt,
                        mutableMapOf(),
                    )

                    /**
                     * Cardholder cancellation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cardholderCancellation(): CardholderCancellation =
                        cardholderCancellation.getRequired("cardholder_cancellation")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * Misrepresentation explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun misrepresentationExplanation(): String =
                        misrepresentationExplanation.getRequired("misrepresentation_explanation")

                    /**
                     * Purchase explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseExplanation(): String =
                        purchaseExplanation.getRequired("purchase_explanation")

                    /**
                     * Received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                    /**
                     * Returns the raw JSON value of [cardholderCancellation].
                     *
                     * Unlike [cardholderCancellation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                        cardholderCancellation

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [misrepresentationExplanation].
                     *
                     * Unlike [misrepresentationExplanation], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("misrepresentation_explanation")
                    @ExcludeMissing
                    fun _misrepresentationExplanation(): JsonField<String> =
                        misrepresentationExplanation

                    /**
                     * Returns the raw JSON value of [purchaseExplanation].
                     *
                     * Unlike [purchaseExplanation], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("purchase_explanation")
                    @ExcludeMissing
                    fun _purchaseExplanation(): JsonField<String> = purchaseExplanation

                    /**
                     * Returns the raw JSON value of [receivedAt].
                     *
                     * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    fun _receivedAt(): JsonField<LocalDate> = receivedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerServicesMisrepresentation].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .merchantResolutionAttempted()
                         * .misrepresentationExplanation()
                         * .purchaseExplanation()
                         * .receivedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerServicesMisrepresentation]. */
                    class Builder internal constructor() {

                        private var cardholderCancellation: JsonField<CardholderCancellation>? =
                            null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var misrepresentationExplanation: JsonField<String>? = null
                        private var purchaseExplanation: JsonField<String>? = null
                        private var receivedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerServicesMisrepresentation: ConsumerServicesMisrepresentation
                        ) = apply {
                            cardholderCancellation =
                                consumerServicesMisrepresentation.cardholderCancellation
                            merchantResolutionAttempted =
                                consumerServicesMisrepresentation.merchantResolutionAttempted
                            misrepresentationExplanation =
                                consumerServicesMisrepresentation.misrepresentationExplanation
                            purchaseExplanation =
                                consumerServicesMisrepresentation.purchaseExplanation
                            receivedAt = consumerServicesMisrepresentation.receivedAt
                            additionalProperties =
                                consumerServicesMisrepresentation.additionalProperties
                                    .toMutableMap()
                        }

                        /** Cardholder cancellation. */
                        fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                            cardholderCancellation(JsonField.of(cardholderCancellation))

                        /**
                         * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cardholderCancellation] with a
                         * well-typed [CardholderCancellation] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cardholderCancellation(
                            cardholderCancellation: JsonField<CardholderCancellation>
                        ) = apply { this.cardholderCancellation = cardholderCancellation }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /** Misrepresentation explanation. */
                        fun misrepresentationExplanation(misrepresentationExplanation: String) =
                            misrepresentationExplanation(JsonField.of(misrepresentationExplanation))

                        /**
                         * Sets [Builder.misrepresentationExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.misrepresentationExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun misrepresentationExplanation(
                            misrepresentationExplanation: JsonField<String>
                        ) = apply {
                            this.misrepresentationExplanation = misrepresentationExplanation
                        }

                        /** Purchase explanation. */
                        fun purchaseExplanation(purchaseExplanation: String) =
                            purchaseExplanation(JsonField.of(purchaseExplanation))

                        /**
                         * Sets [Builder.purchaseExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseExplanation] with a well-typed
                         * [String] value instead. This method is primarily for setting the field to
                         * an undocumented or not yet supported value.
                         */
                        fun purchaseExplanation(purchaseExplanation: JsonField<String>) = apply {
                            this.purchaseExplanation = purchaseExplanation
                        }

                        /** Received at. */
                        fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                        /**
                         * Sets [Builder.receivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                            this.receivedAt = receivedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerServicesMisrepresentation].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .merchantResolutionAttempted()
                         * .misrepresentationExplanation()
                         * .purchaseExplanation()
                         * .receivedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerServicesMisrepresentation =
                            ConsumerServicesMisrepresentation(
                                checkRequired("cardholderCancellation", cardholderCancellation),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired(
                                    "misrepresentationExplanation",
                                    misrepresentationExplanation,
                                ),
                                checkRequired("purchaseExplanation", purchaseExplanation),
                                checkRequired("receivedAt", receivedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerServicesMisrepresentation = apply {
                        if (validated) {
                            return@apply
                        }

                        cardholderCancellation().validate()
                        merchantResolutionAttempted().validate()
                        misrepresentationExplanation()
                        purchaseExplanation()
                        receivedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cardholderCancellation.asKnown()?.validity() ?: 0) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (misrepresentationExplanation.asKnown() == null) 0 else 1) +
                            (if (purchaseExplanation.asKnown() == null) 0 else 1) +
                            (if (receivedAt.asKnown() == null) 0 else 1)

                    /** Cardholder cancellation. */
                    class CardholderCancellation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val acceptedByMerchant: JsonField<AcceptedByMerchant>,
                        private val canceledAt: JsonField<LocalDate>,
                        private val reason: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("accepted_by_merchant")
                            @ExcludeMissing
                            acceptedByMerchant: JsonField<AcceptedByMerchant> = JsonMissing.of(),
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("reason")
                            @ExcludeMissing
                            reason: JsonField<String> = JsonMissing.of(),
                        ) : this(acceptedByMerchant, canceledAt, reason, mutableMapOf())

                        /**
                         * Accepted by merchant.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun acceptedByMerchant(): AcceptedByMerchant =
                            acceptedByMerchant.getRequired("accepted_by_merchant")

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun reason(): String = reason.getRequired("reason")

                        /**
                         * Returns the raw JSON value of [acceptedByMerchant].
                         *
                         * Unlike [acceptedByMerchant], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("accepted_by_merchant")
                        @ExcludeMissing
                        fun _acceptedByMerchant(): JsonField<AcceptedByMerchant> =
                            acceptedByMerchant

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        /**
                         * Returns the raw JSON value of [reason].
                         *
                         * Unlike [reason], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("reason")
                        @ExcludeMissing
                        fun _reason(): JsonField<String> = reason

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [CardholderCancellation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .acceptedByMerchant()
                             * .canceledAt()
                             * .reason()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [CardholderCancellation]. */
                        class Builder internal constructor() {

                            private var acceptedByMerchant: JsonField<AcceptedByMerchant>? = null
                            private var canceledAt: JsonField<LocalDate>? = null
                            private var reason: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(cardholderCancellation: CardholderCancellation) =
                                apply {
                                    acceptedByMerchant = cardholderCancellation.acceptedByMerchant
                                    canceledAt = cardholderCancellation.canceledAt
                                    reason = cardholderCancellation.reason
                                    additionalProperties =
                                        cardholderCancellation.additionalProperties.toMutableMap()
                                }

                            /** Accepted by merchant. */
                            fun acceptedByMerchant(acceptedByMerchant: AcceptedByMerchant) =
                                acceptedByMerchant(JsonField.of(acceptedByMerchant))

                            /**
                             * Sets [Builder.acceptedByMerchant] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.acceptedByMerchant] with a
                             * well-typed [AcceptedByMerchant] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun acceptedByMerchant(
                                acceptedByMerchant: JsonField<AcceptedByMerchant>
                            ) = apply { this.acceptedByMerchant = acceptedByMerchant }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            /** Reason. */
                            fun reason(reason: String) = reason(JsonField.of(reason))

                            /**
                             * Sets [Builder.reason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.reason] with a well-typed [String]
                             * value instead. This method is primarily for setting the field to an
                             * undocumented or not yet supported value.
                             */
                            fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [CardholderCancellation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .acceptedByMerchant()
                             * .canceledAt()
                             * .reason()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): CardholderCancellation =
                                CardholderCancellation(
                                    checkRequired("acceptedByMerchant", acceptedByMerchant),
                                    checkRequired("canceledAt", canceledAt),
                                    checkRequired("reason", reason),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): CardholderCancellation = apply {
                            if (validated) {
                                return@apply
                            }

                            acceptedByMerchant().validate()
                            canceledAt()
                            reason()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (acceptedByMerchant.asKnown()?.validity() ?: 0) +
                                (if (canceledAt.asKnown() == null) 0 else 1) +
                                (if (reason.asKnown() == null) 0 else 1)

                        /** Accepted by merchant. */
                        class AcceptedByMerchant
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Accepted. */
                                val ACCEPTED = of("accepted")

                                /** Not accepted. */
                                val NOT_ACCEPTED = of("not_accepted")

                                fun of(value: String) = AcceptedByMerchant(JsonField.of(value))
                            }

                            /** An enum containing [AcceptedByMerchant]'s known values. */
                            enum class Known {
                                /** Accepted. */
                                ACCEPTED,
                                /** Not accepted. */
                                NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AcceptedByMerchant]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AcceptedByMerchant] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Accepted. */
                                ACCEPTED,
                                /** Not accepted. */
                                NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AcceptedByMerchant] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    ACCEPTED -> Value.ACCEPTED
                                    NOT_ACCEPTED -> Value.NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    ACCEPTED -> Known.ACCEPTED
                                    NOT_ACCEPTED -> Known.NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AcceptedByMerchant: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AcceptedByMerchant = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AcceptedByMerchant && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderCancellation &&
                                acceptedByMerchant == other.acceptedByMerchant &&
                                canceledAt == other.canceledAt &&
                                reason == other.reason &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                acceptedByMerchant,
                                canceledAt,
                                reason,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "CardholderCancellation{acceptedByMerchant=$acceptedByMerchant, canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                    }

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerServicesMisrepresentation &&
                            cardholderCancellation == other.cardholderCancellation &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            misrepresentationExplanation == other.misrepresentationExplanation &&
                            purchaseExplanation == other.purchaseExplanation &&
                            receivedAt == other.receivedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cardholderCancellation,
                            merchantResolutionAttempted,
                            misrepresentationExplanation,
                            purchaseExplanation,
                            receivedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerServicesMisrepresentation{cardholderCancellation=$cardholderCancellation, merchantResolutionAttempted=$merchantResolutionAttempted, misrepresentationExplanation=$misrepresentationExplanation, purchaseExplanation=$purchaseExplanation, receivedAt=$receivedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Services not as described. Present if and only if `category` is
                 * `consumer_services_not_as_described`.
                 */
                class ConsumerServicesNotAsDescribed
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cardholderCancellation: JsonField<CardholderCancellation>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val receivedAt: JsonField<LocalDate>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cardholder_cancellation")
                        @ExcludeMissing
                        cardholderCancellation: JsonField<CardholderCancellation> =
                            JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("received_at")
                        @ExcludeMissing
                        receivedAt: JsonField<LocalDate> = JsonMissing.of(),
                    ) : this(
                        cardholderCancellation,
                        merchantResolutionAttempted,
                        receivedAt,
                        mutableMapOf(),
                    )

                    /**
                     * Cardholder cancellation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cardholderCancellation(): CardholderCancellation =
                        cardholderCancellation.getRequired("cardholder_cancellation")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * Received at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun receivedAt(): LocalDate = receivedAt.getRequired("received_at")

                    /**
                     * Returns the raw JSON value of [cardholderCancellation].
                     *
                     * Unlike [cardholderCancellation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("cardholder_cancellation")
                    @ExcludeMissing
                    fun _cardholderCancellation(): JsonField<CardholderCancellation> =
                        cardholderCancellation

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [receivedAt].
                     *
                     * Unlike [receivedAt], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("received_at")
                    @ExcludeMissing
                    fun _receivedAt(): JsonField<LocalDate> = receivedAt

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerServicesNotAsDescribed].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .merchantResolutionAttempted()
                         * .receivedAt()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerServicesNotAsDescribed]. */
                    class Builder internal constructor() {

                        private var cardholderCancellation: JsonField<CardholderCancellation>? =
                            null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var receivedAt: JsonField<LocalDate>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerServicesNotAsDescribed: ConsumerServicesNotAsDescribed
                        ) = apply {
                            cardholderCancellation =
                                consumerServicesNotAsDescribed.cardholderCancellation
                            merchantResolutionAttempted =
                                consumerServicesNotAsDescribed.merchantResolutionAttempted
                            receivedAt = consumerServicesNotAsDescribed.receivedAt
                            additionalProperties =
                                consumerServicesNotAsDescribed.additionalProperties.toMutableMap()
                        }

                        /** Cardholder cancellation. */
                        fun cardholderCancellation(cardholderCancellation: CardholderCancellation) =
                            cardholderCancellation(JsonField.of(cardholderCancellation))

                        /**
                         * Sets [Builder.cardholderCancellation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cardholderCancellation] with a
                         * well-typed [CardholderCancellation] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun cardholderCancellation(
                            cardholderCancellation: JsonField<CardholderCancellation>
                        ) = apply { this.cardholderCancellation = cardholderCancellation }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /** Received at. */
                        fun receivedAt(receivedAt: LocalDate) = receivedAt(JsonField.of(receivedAt))

                        /**
                         * Sets [Builder.receivedAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.receivedAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun receivedAt(receivedAt: JsonField<LocalDate>) = apply {
                            this.receivedAt = receivedAt
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerServicesNotAsDescribed].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cardholderCancellation()
                         * .merchantResolutionAttempted()
                         * .receivedAt()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerServicesNotAsDescribed =
                            ConsumerServicesNotAsDescribed(
                                checkRequired("cardholderCancellation", cardholderCancellation),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("receivedAt", receivedAt),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerServicesNotAsDescribed = apply {
                        if (validated) {
                            return@apply
                        }

                        cardholderCancellation().validate()
                        merchantResolutionAttempted().validate()
                        receivedAt()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cardholderCancellation.asKnown()?.validity() ?: 0) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (receivedAt.asKnown() == null) 0 else 1)

                    /** Cardholder cancellation. */
                    class CardholderCancellation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val acceptedByMerchant: JsonField<AcceptedByMerchant>,
                        private val canceledAt: JsonField<LocalDate>,
                        private val reason: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("accepted_by_merchant")
                            @ExcludeMissing
                            acceptedByMerchant: JsonField<AcceptedByMerchant> = JsonMissing.of(),
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("reason")
                            @ExcludeMissing
                            reason: JsonField<String> = JsonMissing.of(),
                        ) : this(acceptedByMerchant, canceledAt, reason, mutableMapOf())

                        /**
                         * Accepted by merchant.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun acceptedByMerchant(): AcceptedByMerchant =
                            acceptedByMerchant.getRequired("accepted_by_merchant")

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun reason(): String = reason.getRequired("reason")

                        /**
                         * Returns the raw JSON value of [acceptedByMerchant].
                         *
                         * Unlike [acceptedByMerchant], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("accepted_by_merchant")
                        @ExcludeMissing
                        fun _acceptedByMerchant(): JsonField<AcceptedByMerchant> =
                            acceptedByMerchant

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        /**
                         * Returns the raw JSON value of [reason].
                         *
                         * Unlike [reason], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("reason")
                        @ExcludeMissing
                        fun _reason(): JsonField<String> = reason

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [CardholderCancellation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .acceptedByMerchant()
                             * .canceledAt()
                             * .reason()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [CardholderCancellation]. */
                        class Builder internal constructor() {

                            private var acceptedByMerchant: JsonField<AcceptedByMerchant>? = null
                            private var canceledAt: JsonField<LocalDate>? = null
                            private var reason: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(cardholderCancellation: CardholderCancellation) =
                                apply {
                                    acceptedByMerchant = cardholderCancellation.acceptedByMerchant
                                    canceledAt = cardholderCancellation.canceledAt
                                    reason = cardholderCancellation.reason
                                    additionalProperties =
                                        cardholderCancellation.additionalProperties.toMutableMap()
                                }

                            /** Accepted by merchant. */
                            fun acceptedByMerchant(acceptedByMerchant: AcceptedByMerchant) =
                                acceptedByMerchant(JsonField.of(acceptedByMerchant))

                            /**
                             * Sets [Builder.acceptedByMerchant] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.acceptedByMerchant] with a
                             * well-typed [AcceptedByMerchant] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun acceptedByMerchant(
                                acceptedByMerchant: JsonField<AcceptedByMerchant>
                            ) = apply { this.acceptedByMerchant = acceptedByMerchant }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            /** Reason. */
                            fun reason(reason: String) = reason(JsonField.of(reason))

                            /**
                             * Sets [Builder.reason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.reason] with a well-typed [String]
                             * value instead. This method is primarily for setting the field to an
                             * undocumented or not yet supported value.
                             */
                            fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [CardholderCancellation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .acceptedByMerchant()
                             * .canceledAt()
                             * .reason()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): CardholderCancellation =
                                CardholderCancellation(
                                    checkRequired("acceptedByMerchant", acceptedByMerchant),
                                    checkRequired("canceledAt", canceledAt),
                                    checkRequired("reason", reason),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): CardholderCancellation = apply {
                            if (validated) {
                                return@apply
                            }

                            acceptedByMerchant().validate()
                            canceledAt()
                            reason()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (acceptedByMerchant.asKnown()?.validity() ?: 0) +
                                (if (canceledAt.asKnown() == null) 0 else 1) +
                                (if (reason.asKnown() == null) 0 else 1)

                        /** Accepted by merchant. */
                        class AcceptedByMerchant
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Accepted. */
                                val ACCEPTED = of("accepted")

                                /** Not accepted. */
                                val NOT_ACCEPTED = of("not_accepted")

                                fun of(value: String) = AcceptedByMerchant(JsonField.of(value))
                            }

                            /** An enum containing [AcceptedByMerchant]'s known values. */
                            enum class Known {
                                /** Accepted. */
                                ACCEPTED,
                                /** Not accepted. */
                                NOT_ACCEPTED,
                            }

                            /**
                             * An enum containing [AcceptedByMerchant]'s known values, as well as an
                             * [_UNKNOWN] member.
                             *
                             * An instance of [AcceptedByMerchant] can contain an unknown value in a
                             * couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Accepted. */
                                ACCEPTED,
                                /** Not accepted. */
                                NOT_ACCEPTED,
                                /**
                                 * An enum member indicating that [AcceptedByMerchant] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    ACCEPTED -> Value.ACCEPTED
                                    NOT_ACCEPTED -> Value.NOT_ACCEPTED
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    ACCEPTED -> Known.ACCEPTED
                                    NOT_ACCEPTED -> Known.NOT_ACCEPTED
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown AcceptedByMerchant: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): AcceptedByMerchant = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is AcceptedByMerchant && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderCancellation &&
                                acceptedByMerchant == other.acceptedByMerchant &&
                                canceledAt == other.canceledAt &&
                                reason == other.reason &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                acceptedByMerchant,
                                canceledAt,
                                reason,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "CardholderCancellation{acceptedByMerchant=$acceptedByMerchant, canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                    }

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerServicesNotAsDescribed &&
                            cardholderCancellation == other.cardholderCancellation &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            receivedAt == other.receivedAt &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cardholderCancellation,
                            merchantResolutionAttempted,
                            receivedAt,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerServicesNotAsDescribed{cardholderCancellation=$cardholderCancellation, merchantResolutionAttempted=$merchantResolutionAttempted, receivedAt=$receivedAt, additionalProperties=$additionalProperties}"
                }

                /**
                 * Services not received. Present if and only if `category` is
                 * `consumer_services_not_received`.
                 */
                class ConsumerServicesNotReceived
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val cancellationOutcome: JsonField<CancellationOutcome>,
                    private val cardholderCancellationPriorToExpectedReceipt:
                        JsonField<CardholderCancellationPriorToExpectedReceipt>,
                    private val lastExpectedReceiptAt: JsonField<LocalDate>,
                    private val merchantCancellation: JsonField<MerchantCancellation>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val noCancellation: JsonValue,
                    private val purchaseInfoAndExplanation: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("cancellation_outcome")
                        @ExcludeMissing
                        cancellationOutcome: JsonField<CancellationOutcome> = JsonMissing.of(),
                        @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                        @ExcludeMissing
                        cardholderCancellationPriorToExpectedReceipt:
                            JsonField<CardholderCancellationPriorToExpectedReceipt> =
                            JsonMissing.of(),
                        @JsonProperty("last_expected_receipt_at")
                        @ExcludeMissing
                        lastExpectedReceiptAt: JsonField<LocalDate> = JsonMissing.of(),
                        @JsonProperty("merchant_cancellation")
                        @ExcludeMissing
                        merchantCancellation: JsonField<MerchantCancellation> = JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("no_cancellation")
                        @ExcludeMissing
                        noCancellation: JsonValue = JsonMissing.of(),
                        @JsonProperty("purchase_info_and_explanation")
                        @ExcludeMissing
                        purchaseInfoAndExplanation: JsonField<String> = JsonMissing.of(),
                    ) : this(
                        cancellationOutcome,
                        cardholderCancellationPriorToExpectedReceipt,
                        lastExpectedReceiptAt,
                        merchantCancellation,
                        merchantResolutionAttempted,
                        noCancellation,
                        purchaseInfoAndExplanation,
                        mutableMapOf(),
                    )

                    /**
                     * Cancellation outcome.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun cancellationOutcome(): CancellationOutcome =
                        cancellationOutcome.getRequired("cancellation_outcome")

                    /**
                     * Cardholder cancellation prior to expected receipt. Present if and only if
                     * `cancellation_outcome` is
                     * `cardholder_cancellation_prior_to_expected_receipt`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun cardholderCancellationPriorToExpectedReceipt():
                        CardholderCancellationPriorToExpectedReceipt? =
                        cardholderCancellationPriorToExpectedReceipt.getNullable(
                            "cardholder_cancellation_prior_to_expected_receipt"
                        )

                    /**
                     * Last expected receipt at.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun lastExpectedReceiptAt(): LocalDate =
                        lastExpectedReceiptAt.getRequired("last_expected_receipt_at")

                    /**
                     * Merchant cancellation. Present if and only if `cancellation_outcome` is
                     * `merchant_cancellation`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun merchantCancellation(): MerchantCancellation? =
                        merchantCancellation.getNullable("merchant_cancellation")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * No cancellation. Present if and only if `cancellation_outcome` is
                     * `no_cancellation`.
                     */
                    @JsonProperty("no_cancellation")
                    @ExcludeMissing
                    fun _noCancellation(): JsonValue = noCancellation

                    /**
                     * Purchase information and explanation.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun purchaseInfoAndExplanation(): String =
                        purchaseInfoAndExplanation.getRequired("purchase_info_and_explanation")

                    /**
                     * Returns the raw JSON value of [cancellationOutcome].
                     *
                     * Unlike [cancellationOutcome], this method doesn't throw if the JSON field has
                     * an unexpected type.
                     */
                    @JsonProperty("cancellation_outcome")
                    @ExcludeMissing
                    fun _cancellationOutcome(): JsonField<CancellationOutcome> = cancellationOutcome

                    /**
                     * Returns the raw JSON value of [cardholderCancellationPriorToExpectedReceipt].
                     *
                     * Unlike [cardholderCancellationPriorToExpectedReceipt], this method doesn't
                     * throw if the JSON field has an unexpected type.
                     */
                    @JsonProperty("cardholder_cancellation_prior_to_expected_receipt")
                    @ExcludeMissing
                    fun _cardholderCancellationPriorToExpectedReceipt():
                        JsonField<CardholderCancellationPriorToExpectedReceipt> =
                        cardholderCancellationPriorToExpectedReceipt

                    /**
                     * Returns the raw JSON value of [lastExpectedReceiptAt].
                     *
                     * Unlike [lastExpectedReceiptAt], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("last_expected_receipt_at")
                    @ExcludeMissing
                    fun _lastExpectedReceiptAt(): JsonField<LocalDate> = lastExpectedReceiptAt

                    /**
                     * Returns the raw JSON value of [merchantCancellation].
                     *
                     * Unlike [merchantCancellation], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("merchant_cancellation")
                    @ExcludeMissing
                    fun _merchantCancellation(): JsonField<MerchantCancellation> =
                        merchantCancellation

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [purchaseInfoAndExplanation].
                     *
                     * Unlike [purchaseInfoAndExplanation], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("purchase_info_and_explanation")
                    @ExcludeMissing
                    fun _purchaseInfoAndExplanation(): JsonField<String> =
                        purchaseInfoAndExplanation

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ConsumerServicesNotReceived].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cancellationOutcome()
                         * .cardholderCancellationPriorToExpectedReceipt()
                         * .lastExpectedReceiptAt()
                         * .merchantCancellation()
                         * .merchantResolutionAttempted()
                         * .noCancellation()
                         * .purchaseInfoAndExplanation()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ConsumerServicesNotReceived]. */
                    class Builder internal constructor() {

                        private var cancellationOutcome: JsonField<CancellationOutcome>? = null
                        private var cardholderCancellationPriorToExpectedReceipt:
                            JsonField<CardholderCancellationPriorToExpectedReceipt>? =
                            null
                        private var lastExpectedReceiptAt: JsonField<LocalDate>? = null
                        private var merchantCancellation: JsonField<MerchantCancellation>? = null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var noCancellation: JsonValue? = null
                        private var purchaseInfoAndExplanation: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(
                            consumerServicesNotReceived: ConsumerServicesNotReceived
                        ) = apply {
                            cancellationOutcome = consumerServicesNotReceived.cancellationOutcome
                            cardholderCancellationPriorToExpectedReceipt =
                                consumerServicesNotReceived
                                    .cardholderCancellationPriorToExpectedReceipt
                            lastExpectedReceiptAt =
                                consumerServicesNotReceived.lastExpectedReceiptAt
                            merchantCancellation = consumerServicesNotReceived.merchantCancellation
                            merchantResolutionAttempted =
                                consumerServicesNotReceived.merchantResolutionAttempted
                            noCancellation = consumerServicesNotReceived.noCancellation
                            purchaseInfoAndExplanation =
                                consumerServicesNotReceived.purchaseInfoAndExplanation
                            additionalProperties =
                                consumerServicesNotReceived.additionalProperties.toMutableMap()
                        }

                        /** Cancellation outcome. */
                        fun cancellationOutcome(cancellationOutcome: CancellationOutcome) =
                            cancellationOutcome(JsonField.of(cancellationOutcome))

                        /**
                         * Sets [Builder.cancellationOutcome] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.cancellationOutcome] with a well-typed
                         * [CancellationOutcome] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun cancellationOutcome(
                            cancellationOutcome: JsonField<CancellationOutcome>
                        ) = apply { this.cancellationOutcome = cancellationOutcome }

                        /**
                         * Cardholder cancellation prior to expected receipt. Present if and only if
                         * `cancellation_outcome` is
                         * `cardholder_cancellation_prior_to_expected_receipt`.
                         */
                        fun cardholderCancellationPriorToExpectedReceipt(
                            cardholderCancellationPriorToExpectedReceipt:
                                CardholderCancellationPriorToExpectedReceipt?
                        ) =
                            cardholderCancellationPriorToExpectedReceipt(
                                JsonField.ofNullable(cardholderCancellationPriorToExpectedReceipt)
                            )

                        /**
                         * Sets [Builder.cardholderCancellationPriorToExpectedReceipt] to an
                         * arbitrary JSON value.
                         *
                         * You should usually call
                         * [Builder.cardholderCancellationPriorToExpectedReceipt] with a well-typed
                         * [CardholderCancellationPriorToExpectedReceipt] value instead. This method
                         * is primarily for setting the field to an undocumented or not yet
                         * supported value.
                         */
                        fun cardholderCancellationPriorToExpectedReceipt(
                            cardholderCancellationPriorToExpectedReceipt:
                                JsonField<CardholderCancellationPriorToExpectedReceipt>
                        ) = apply {
                            this.cardholderCancellationPriorToExpectedReceipt =
                                cardholderCancellationPriorToExpectedReceipt
                        }

                        /** Last expected receipt at. */
                        fun lastExpectedReceiptAt(lastExpectedReceiptAt: LocalDate) =
                            lastExpectedReceiptAt(JsonField.of(lastExpectedReceiptAt))

                        /**
                         * Sets [Builder.lastExpectedReceiptAt] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.lastExpectedReceiptAt] with a well-typed
                         * [LocalDate] value instead. This method is primarily for setting the field
                         * to an undocumented or not yet supported value.
                         */
                        fun lastExpectedReceiptAt(lastExpectedReceiptAt: JsonField<LocalDate>) =
                            apply {
                                this.lastExpectedReceiptAt = lastExpectedReceiptAt
                            }

                        /**
                         * Merchant cancellation. Present if and only if `cancellation_outcome` is
                         * `merchant_cancellation`.
                         */
                        fun merchantCancellation(merchantCancellation: MerchantCancellation?) =
                            merchantCancellation(JsonField.ofNullable(merchantCancellation))

                        /**
                         * Sets [Builder.merchantCancellation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantCancellation] with a well-typed
                         * [MerchantCancellation] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun merchantCancellation(
                            merchantCancellation: JsonField<MerchantCancellation>
                        ) = apply { this.merchantCancellation = merchantCancellation }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /**
                         * No cancellation. Present if and only if `cancellation_outcome` is
                         * `no_cancellation`.
                         */
                        fun noCancellation(noCancellation: JsonValue) = apply {
                            this.noCancellation = noCancellation
                        }

                        /** Purchase information and explanation. */
                        fun purchaseInfoAndExplanation(purchaseInfoAndExplanation: String) =
                            purchaseInfoAndExplanation(JsonField.of(purchaseInfoAndExplanation))

                        /**
                         * Sets [Builder.purchaseInfoAndExplanation] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.purchaseInfoAndExplanation] with a
                         * well-typed [String] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun purchaseInfoAndExplanation(
                            purchaseInfoAndExplanation: JsonField<String>
                        ) = apply { this.purchaseInfoAndExplanation = purchaseInfoAndExplanation }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ConsumerServicesNotReceived].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .cancellationOutcome()
                         * .cardholderCancellationPriorToExpectedReceipt()
                         * .lastExpectedReceiptAt()
                         * .merchantCancellation()
                         * .merchantResolutionAttempted()
                         * .noCancellation()
                         * .purchaseInfoAndExplanation()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ConsumerServicesNotReceived =
                            ConsumerServicesNotReceived(
                                checkRequired("cancellationOutcome", cancellationOutcome),
                                checkRequired(
                                    "cardholderCancellationPriorToExpectedReceipt",
                                    cardholderCancellationPriorToExpectedReceipt,
                                ),
                                checkRequired("lastExpectedReceiptAt", lastExpectedReceiptAt),
                                checkRequired("merchantCancellation", merchantCancellation),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("noCancellation", noCancellation),
                                checkRequired(
                                    "purchaseInfoAndExplanation",
                                    purchaseInfoAndExplanation,
                                ),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ConsumerServicesNotReceived = apply {
                        if (validated) {
                            return@apply
                        }

                        cancellationOutcome().validate()
                        cardholderCancellationPriorToExpectedReceipt()?.validate()
                        lastExpectedReceiptAt()
                        merchantCancellation()?.validate()
                        merchantResolutionAttempted().validate()
                        purchaseInfoAndExplanation()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (cancellationOutcome.asKnown()?.validity() ?: 0) +
                            (cardholderCancellationPriorToExpectedReceipt.asKnown()?.validity()
                                ?: 0) +
                            (if (lastExpectedReceiptAt.asKnown() == null) 0 else 1) +
                            (merchantCancellation.asKnown()?.validity() ?: 0) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (if (purchaseInfoAndExplanation.asKnown() == null) 0 else 1)

                    /** Cancellation outcome. */
                    class CancellationOutcome
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Cardholder cancellation prior to expected receipt. */
                            val CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT =
                                of("cardholder_cancellation_prior_to_expected_receipt")

                            /** Merchant cancellation. */
                            val MERCHANT_CANCELLATION = of("merchant_cancellation")

                            /** No cancellation. */
                            val NO_CANCELLATION = of("no_cancellation")

                            fun of(value: String) = CancellationOutcome(JsonField.of(value))
                        }

                        /** An enum containing [CancellationOutcome]'s known values. */
                        enum class Known {
                            /** Cardholder cancellation prior to expected receipt. */
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                            /** Merchant cancellation. */
                            MERCHANT_CANCELLATION,
                            /** No cancellation. */
                            NO_CANCELLATION,
                        }

                        /**
                         * An enum containing [CancellationOutcome]'s known values, as well as an
                         * [_UNKNOWN] member.
                         *
                         * An instance of [CancellationOutcome] can contain an unknown value in a
                         * couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Cardholder cancellation prior to expected receipt. */
                            CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT,
                            /** Merchant cancellation. */
                            MERCHANT_CANCELLATION,
                            /** No cancellation. */
                            NO_CANCELLATION,
                            /**
                             * An enum member indicating that [CancellationOutcome] was instantiated
                             * with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                    Value.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                                MERCHANT_CANCELLATION -> Value.MERCHANT_CANCELLATION
                                NO_CANCELLATION -> Value.NO_CANCELLATION
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT ->
                                    Known.CARDHOLDER_CANCELLATION_PRIOR_TO_EXPECTED_RECEIPT
                                MERCHANT_CANCELLATION -> Known.MERCHANT_CANCELLATION
                                NO_CANCELLATION -> Known.NO_CANCELLATION
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown CancellationOutcome: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): CancellationOutcome = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CancellationOutcome && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Cardholder cancellation prior to expected receipt. Present if and only if
                     * `cancellation_outcome` is
                     * `cardholder_cancellation_prior_to_expected_receipt`.
                     */
                    class CardholderCancellationPriorToExpectedReceipt
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val canceledAt: JsonField<LocalDate>,
                        private val reason: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of(),
                            @JsonProperty("reason")
                            @ExcludeMissing
                            reason: JsonField<String> = JsonMissing.of(),
                        ) : this(canceledAt, reason, mutableMapOf())

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Reason.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun reason(): String? = reason.getNullable("reason")

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        /**
                         * Returns the raw JSON value of [reason].
                         *
                         * Unlike [reason], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("reason")
                        @ExcludeMissing
                        fun _reason(): JsonField<String> = reason

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [CardholderCancellationPriorToExpectedReceipt].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .reason()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [CardholderCancellationPriorToExpectedReceipt]. */
                        class Builder internal constructor() {

                            private var canceledAt: JsonField<LocalDate>? = null
                            private var reason: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(
                                cardholderCancellationPriorToExpectedReceipt:
                                    CardholderCancellationPriorToExpectedReceipt
                            ) = apply {
                                canceledAt = cardholderCancellationPriorToExpectedReceipt.canceledAt
                                reason = cardholderCancellationPriorToExpectedReceipt.reason
                                additionalProperties =
                                    cardholderCancellationPriorToExpectedReceipt
                                        .additionalProperties
                                        .toMutableMap()
                            }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            /** Reason. */
                            fun reason(reason: String?) = reason(JsonField.ofNullable(reason))

                            /**
                             * Sets [Builder.reason] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.reason] with a well-typed [String]
                             * value instead. This method is primarily for setting the field to an
                             * undocumented or not yet supported value.
                             */
                            fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of
                             * [CardholderCancellationPriorToExpectedReceipt].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * .reason()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): CardholderCancellationPriorToExpectedReceipt =
                                CardholderCancellationPriorToExpectedReceipt(
                                    checkRequired("canceledAt", canceledAt),
                                    checkRequired("reason", reason),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): CardholderCancellationPriorToExpectedReceipt = apply {
                            if (validated) {
                                return@apply
                            }

                            canceledAt()
                            reason()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (canceledAt.asKnown() == null) 0 else 1) +
                                (if (reason.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is CardholderCancellationPriorToExpectedReceipt &&
                                canceledAt == other.canceledAt &&
                                reason == other.reason &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(canceledAt, reason, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "CardholderCancellationPriorToExpectedReceipt{canceledAt=$canceledAt, reason=$reason, additionalProperties=$additionalProperties}"
                    }

                    /**
                     * Merchant cancellation. Present if and only if `cancellation_outcome` is
                     * `merchant_cancellation`.
                     */
                    class MerchantCancellation
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val canceledAt: JsonField<LocalDate>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("canceled_at")
                            @ExcludeMissing
                            canceledAt: JsonField<LocalDate> = JsonMissing.of()
                        ) : this(canceledAt, mutableMapOf())

                        /**
                         * Canceled at.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun canceledAt(): LocalDate = canceledAt.getRequired("canceled_at")

                        /**
                         * Returns the raw JSON value of [canceledAt].
                         *
                         * Unlike [canceledAt], this method doesn't throw if the JSON field has an
                         * unexpected type.
                         */
                        @JsonProperty("canceled_at")
                        @ExcludeMissing
                        fun _canceledAt(): JsonField<LocalDate> = canceledAt

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [MerchantCancellation].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [MerchantCancellation]. */
                        class Builder internal constructor() {

                            private var canceledAt: JsonField<LocalDate>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(merchantCancellation: MerchantCancellation) = apply {
                                canceledAt = merchantCancellation.canceledAt
                                additionalProperties =
                                    merchantCancellation.additionalProperties.toMutableMap()
                            }

                            /** Canceled at. */
                            fun canceledAt(canceledAt: LocalDate) =
                                canceledAt(JsonField.of(canceledAt))

                            /**
                             * Sets [Builder.canceledAt] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.canceledAt] with a well-typed
                             * [LocalDate] value instead. This method is primarily for setting the
                             * field to an undocumented or not yet supported value.
                             */
                            fun canceledAt(canceledAt: JsonField<LocalDate>) = apply {
                                this.canceledAt = canceledAt
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [MerchantCancellation].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .canceledAt()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): MerchantCancellation =
                                MerchantCancellation(
                                    checkRequired("canceledAt", canceledAt),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): MerchantCancellation = apply {
                            if (validated) {
                                return@apply
                            }

                            canceledAt()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = (if (canceledAt.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantCancellation &&
                                canceledAt == other.canceledAt &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(canceledAt, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "MerchantCancellation{canceledAt=$canceledAt, additionalProperties=$additionalProperties}"
                    }

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ConsumerServicesNotReceived &&
                            cancellationOutcome == other.cancellationOutcome &&
                            cardholderCancellationPriorToExpectedReceipt ==
                                other.cardholderCancellationPriorToExpectedReceipt &&
                            lastExpectedReceiptAt == other.lastExpectedReceiptAt &&
                            merchantCancellation == other.merchantCancellation &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            noCancellation == other.noCancellation &&
                            purchaseInfoAndExplanation == other.purchaseInfoAndExplanation &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            cancellationOutcome,
                            cardholderCancellationPriorToExpectedReceipt,
                            lastExpectedReceiptAt,
                            merchantCancellation,
                            merchantResolutionAttempted,
                            noCancellation,
                            purchaseInfoAndExplanation,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ConsumerServicesNotReceived{cancellationOutcome=$cancellationOutcome, cardholderCancellationPriorToExpectedReceipt=$cardholderCancellationPriorToExpectedReceipt, lastExpectedReceiptAt=$lastExpectedReceiptAt, merchantCancellation=$merchantCancellation, merchantResolutionAttempted=$merchantResolutionAttempted, noCancellation=$noCancellation, purchaseInfoAndExplanation=$purchaseInfoAndExplanation, additionalProperties=$additionalProperties}"
                }

                /** Fraud. Present if and only if `category` is `fraud`. */
                class Fraud
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val fraudType: JsonField<FraudType>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("fraud_type")
                        @ExcludeMissing
                        fraudType: JsonField<FraudType> = JsonMissing.of()
                    ) : this(fraudType, mutableMapOf())

                    /**
                     * Fraud type.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun fraudType(): FraudType = fraudType.getRequired("fraud_type")

                    /**
                     * Returns the raw JSON value of [fraudType].
                     *
                     * Unlike [fraudType], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("fraud_type")
                    @ExcludeMissing
                    fun _fraudType(): JsonField<FraudType> = fraudType

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of [Fraud].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .fraudType()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [Fraud]. */
                    class Builder internal constructor() {

                        private var fraudType: JsonField<FraudType>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(fraud: Fraud) = apply {
                            fraudType = fraud.fraudType
                            additionalProperties = fraud.additionalProperties.toMutableMap()
                        }

                        /** Fraud type. */
                        fun fraudType(fraudType: FraudType) = fraudType(JsonField.of(fraudType))

                        /**
                         * Sets [Builder.fraudType] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.fraudType] with a well-typed [FraudType]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun fraudType(fraudType: JsonField<FraudType>) = apply {
                            this.fraudType = fraudType
                        }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [Fraud].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .fraudType()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): Fraud =
                            Fraud(
                                checkRequired("fraudType", fraudType),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): Fraud = apply {
                        if (validated) {
                            return@apply
                        }

                        fraudType().validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int = (fraudType.asKnown()?.validity() ?: 0)

                    /** Fraud type. */
                    class FraudType
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Account or credentials takeover. */
                            val ACCOUNT_OR_CREDENTIALS_TAKEOVER =
                                of("account_or_credentials_takeover")

                            /** Card not received as issued. */
                            val CARD_NOT_RECEIVED_AS_ISSUED = of("card_not_received_as_issued")

                            /** Fraudulent application. */
                            val FRAUDULENT_APPLICATION = of("fraudulent_application")

                            /** Fraudulent use of account number. */
                            val FRAUDULENT_USE_OF_ACCOUNT_NUMBER =
                                of("fraudulent_use_of_account_number")

                            /** Incorrect processing. */
                            val INCORRECT_PROCESSING = of("incorrect_processing")

                            /** Issuer reported counterfeit. */
                            val ISSUER_REPORTED_COUNTERFEIT = of("issuer_reported_counterfeit")

                            /** Lost. */
                            val LOST = of("lost")

                            /** Manipulation of account holder. */
                            val MANIPULATION_OF_ACCOUNT_HOLDER =
                                of("manipulation_of_account_holder")

                            /** Merchant misrepresentation. */
                            val MERCHANT_MISREPRESENTATION = of("merchant_misrepresentation")

                            /** Miscellaneous. */
                            val MISCELLANEOUS = of("miscellaneous")

                            /** Stolen. */
                            val STOLEN = of("stolen")

                            fun of(value: String) = FraudType(JsonField.of(value))
                        }

                        /** An enum containing [FraudType]'s known values. */
                        enum class Known {
                            /** Account or credentials takeover. */
                            ACCOUNT_OR_CREDENTIALS_TAKEOVER,
                            /** Card not received as issued. */
                            CARD_NOT_RECEIVED_AS_ISSUED,
                            /** Fraudulent application. */
                            FRAUDULENT_APPLICATION,
                            /** Fraudulent use of account number. */
                            FRAUDULENT_USE_OF_ACCOUNT_NUMBER,
                            /** Incorrect processing. */
                            INCORRECT_PROCESSING,
                            /** Issuer reported counterfeit. */
                            ISSUER_REPORTED_COUNTERFEIT,
                            /** Lost. */
                            LOST,
                            /** Manipulation of account holder. */
                            MANIPULATION_OF_ACCOUNT_HOLDER,
                            /** Merchant misrepresentation. */
                            MERCHANT_MISREPRESENTATION,
                            /** Miscellaneous. */
                            MISCELLANEOUS,
                            /** Stolen. */
                            STOLEN,
                        }

                        /**
                         * An enum containing [FraudType]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [FraudType] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Account or credentials takeover. */
                            ACCOUNT_OR_CREDENTIALS_TAKEOVER,
                            /** Card not received as issued. */
                            CARD_NOT_RECEIVED_AS_ISSUED,
                            /** Fraudulent application. */
                            FRAUDULENT_APPLICATION,
                            /** Fraudulent use of account number. */
                            FRAUDULENT_USE_OF_ACCOUNT_NUMBER,
                            /** Incorrect processing. */
                            INCORRECT_PROCESSING,
                            /** Issuer reported counterfeit. */
                            ISSUER_REPORTED_COUNTERFEIT,
                            /** Lost. */
                            LOST,
                            /** Manipulation of account holder. */
                            MANIPULATION_OF_ACCOUNT_HOLDER,
                            /** Merchant misrepresentation. */
                            MERCHANT_MISREPRESENTATION,
                            /** Miscellaneous. */
                            MISCELLANEOUS,
                            /** Stolen. */
                            STOLEN,
                            /**
                             * An enum member indicating that [FraudType] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ACCOUNT_OR_CREDENTIALS_TAKEOVER ->
                                    Value.ACCOUNT_OR_CREDENTIALS_TAKEOVER
                                CARD_NOT_RECEIVED_AS_ISSUED -> Value.CARD_NOT_RECEIVED_AS_ISSUED
                                FRAUDULENT_APPLICATION -> Value.FRAUDULENT_APPLICATION
                                FRAUDULENT_USE_OF_ACCOUNT_NUMBER ->
                                    Value.FRAUDULENT_USE_OF_ACCOUNT_NUMBER
                                INCORRECT_PROCESSING -> Value.INCORRECT_PROCESSING
                                ISSUER_REPORTED_COUNTERFEIT -> Value.ISSUER_REPORTED_COUNTERFEIT
                                LOST -> Value.LOST
                                MANIPULATION_OF_ACCOUNT_HOLDER ->
                                    Value.MANIPULATION_OF_ACCOUNT_HOLDER
                                MERCHANT_MISREPRESENTATION -> Value.MERCHANT_MISREPRESENTATION
                                MISCELLANEOUS -> Value.MISCELLANEOUS
                                STOLEN -> Value.STOLEN
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ACCOUNT_OR_CREDENTIALS_TAKEOVER ->
                                    Known.ACCOUNT_OR_CREDENTIALS_TAKEOVER
                                CARD_NOT_RECEIVED_AS_ISSUED -> Known.CARD_NOT_RECEIVED_AS_ISSUED
                                FRAUDULENT_APPLICATION -> Known.FRAUDULENT_APPLICATION
                                FRAUDULENT_USE_OF_ACCOUNT_NUMBER ->
                                    Known.FRAUDULENT_USE_OF_ACCOUNT_NUMBER
                                INCORRECT_PROCESSING -> Known.INCORRECT_PROCESSING
                                ISSUER_REPORTED_COUNTERFEIT -> Known.ISSUER_REPORTED_COUNTERFEIT
                                LOST -> Known.LOST
                                MANIPULATION_OF_ACCOUNT_HOLDER ->
                                    Known.MANIPULATION_OF_ACCOUNT_HOLDER
                                MERCHANT_MISREPRESENTATION -> Known.MERCHANT_MISREPRESENTATION
                                MISCELLANEOUS -> Known.MISCELLANEOUS
                                STOLEN -> Known.STOLEN
                                else ->
                                    throw IncreaseInvalidDataException("Unknown FraudType: $value")
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): FraudType = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is FraudType && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is Fraud &&
                            fraudType == other.fraudType &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(fraudType, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "Fraud{fraudType=$fraudType, additionalProperties=$additionalProperties}"
                }

                /** Processing error. Present if and only if `category` is `processing_error`. */
                class ProcessingError
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val duplicateTransaction: JsonField<DuplicateTransaction>,
                    private val errorReason: JsonField<ErrorReason>,
                    private val incorrectAmount: JsonField<IncorrectAmount>,
                    private val merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>,
                    private val paidByOtherMeans: JsonField<PaidByOtherMeans>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("duplicate_transaction")
                        @ExcludeMissing
                        duplicateTransaction: JsonField<DuplicateTransaction> = JsonMissing.of(),
                        @JsonProperty("error_reason")
                        @ExcludeMissing
                        errorReason: JsonField<ErrorReason> = JsonMissing.of(),
                        @JsonProperty("incorrect_amount")
                        @ExcludeMissing
                        incorrectAmount: JsonField<IncorrectAmount> = JsonMissing.of(),
                        @JsonProperty("merchant_resolution_attempted")
                        @ExcludeMissing
                        merchantResolutionAttempted: JsonField<MerchantResolutionAttempted> =
                            JsonMissing.of(),
                        @JsonProperty("paid_by_other_means")
                        @ExcludeMissing
                        paidByOtherMeans: JsonField<PaidByOtherMeans> = JsonMissing.of(),
                    ) : this(
                        duplicateTransaction,
                        errorReason,
                        incorrectAmount,
                        merchantResolutionAttempted,
                        paidByOtherMeans,
                        mutableMapOf(),
                    )

                    /**
                     * Duplicate transaction. Present if and only if `error_reason` is
                     * `duplicate_transaction`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun duplicateTransaction(): DuplicateTransaction? =
                        duplicateTransaction.getNullable("duplicate_transaction")

                    /**
                     * Error reason.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun errorReason(): ErrorReason = errorReason.getRequired("error_reason")

                    /**
                     * Incorrect amount. Present if and only if `error_reason` is
                     * `incorrect_amount`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun incorrectAmount(): IncorrectAmount? =
                        incorrectAmount.getNullable("incorrect_amount")

                    /**
                     * Merchant resolution attempted.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun merchantResolutionAttempted(): MerchantResolutionAttempted =
                        merchantResolutionAttempted.getRequired("merchant_resolution_attempted")

                    /**
                     * Paid by other means. Present if and only if `error_reason` is
                     * `paid_by_other_means`.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   (e.g. if the server responded with an unexpected value).
                     */
                    fun paidByOtherMeans(): PaidByOtherMeans? =
                        paidByOtherMeans.getNullable("paid_by_other_means")

                    /**
                     * Returns the raw JSON value of [duplicateTransaction].
                     *
                     * Unlike [duplicateTransaction], this method doesn't throw if the JSON field
                     * has an unexpected type.
                     */
                    @JsonProperty("duplicate_transaction")
                    @ExcludeMissing
                    fun _duplicateTransaction(): JsonField<DuplicateTransaction> =
                        duplicateTransaction

                    /**
                     * Returns the raw JSON value of [errorReason].
                     *
                     * Unlike [errorReason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("error_reason")
                    @ExcludeMissing
                    fun _errorReason(): JsonField<ErrorReason> = errorReason

                    /**
                     * Returns the raw JSON value of [incorrectAmount].
                     *
                     * Unlike [incorrectAmount], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("incorrect_amount")
                    @ExcludeMissing
                    fun _incorrectAmount(): JsonField<IncorrectAmount> = incorrectAmount

                    /**
                     * Returns the raw JSON value of [merchantResolutionAttempted].
                     *
                     * Unlike [merchantResolutionAttempted], this method doesn't throw if the JSON
                     * field has an unexpected type.
                     */
                    @JsonProperty("merchant_resolution_attempted")
                    @ExcludeMissing
                    fun _merchantResolutionAttempted(): JsonField<MerchantResolutionAttempted> =
                        merchantResolutionAttempted

                    /**
                     * Returns the raw JSON value of [paidByOtherMeans].
                     *
                     * Unlike [paidByOtherMeans], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("paid_by_other_means")
                    @ExcludeMissing
                    fun _paidByOtherMeans(): JsonField<PaidByOtherMeans> = paidByOtherMeans

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [ProcessingError].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .duplicateTransaction()
                         * .errorReason()
                         * .incorrectAmount()
                         * .merchantResolutionAttempted()
                         * .paidByOtherMeans()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [ProcessingError]. */
                    class Builder internal constructor() {

                        private var duplicateTransaction: JsonField<DuplicateTransaction>? = null
                        private var errorReason: JsonField<ErrorReason>? = null
                        private var incorrectAmount: JsonField<IncorrectAmount>? = null
                        private var merchantResolutionAttempted:
                            JsonField<MerchantResolutionAttempted>? =
                            null
                        private var paidByOtherMeans: JsonField<PaidByOtherMeans>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(processingError: ProcessingError) = apply {
                            duplicateTransaction = processingError.duplicateTransaction
                            errorReason = processingError.errorReason
                            incorrectAmount = processingError.incorrectAmount
                            merchantResolutionAttempted =
                                processingError.merchantResolutionAttempted
                            paidByOtherMeans = processingError.paidByOtherMeans
                            additionalProperties =
                                processingError.additionalProperties.toMutableMap()
                        }

                        /**
                         * Duplicate transaction. Present if and only if `error_reason` is
                         * `duplicate_transaction`.
                         */
                        fun duplicateTransaction(duplicateTransaction: DuplicateTransaction?) =
                            duplicateTransaction(JsonField.ofNullable(duplicateTransaction))

                        /**
                         * Sets [Builder.duplicateTransaction] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.duplicateTransaction] with a well-typed
                         * [DuplicateTransaction] value instead. This method is primarily for
                         * setting the field to an undocumented or not yet supported value.
                         */
                        fun duplicateTransaction(
                            duplicateTransaction: JsonField<DuplicateTransaction>
                        ) = apply { this.duplicateTransaction = duplicateTransaction }

                        /** Error reason. */
                        fun errorReason(errorReason: ErrorReason) =
                            errorReason(JsonField.of(errorReason))

                        /**
                         * Sets [Builder.errorReason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.errorReason] with a well-typed
                         * [ErrorReason] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun errorReason(errorReason: JsonField<ErrorReason>) = apply {
                            this.errorReason = errorReason
                        }

                        /**
                         * Incorrect amount. Present if and only if `error_reason` is
                         * `incorrect_amount`.
                         */
                        fun incorrectAmount(incorrectAmount: IncorrectAmount?) =
                            incorrectAmount(JsonField.ofNullable(incorrectAmount))

                        /**
                         * Sets [Builder.incorrectAmount] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.incorrectAmount] with a well-typed
                         * [IncorrectAmount] value instead. This method is primarily for setting the
                         * field to an undocumented or not yet supported value.
                         */
                        fun incorrectAmount(incorrectAmount: JsonField<IncorrectAmount>) = apply {
                            this.incorrectAmount = incorrectAmount
                        }

                        /** Merchant resolution attempted. */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: MerchantResolutionAttempted
                        ) = merchantResolutionAttempted(JsonField.of(merchantResolutionAttempted))

                        /**
                         * Sets [Builder.merchantResolutionAttempted] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.merchantResolutionAttempted] with a
                         * well-typed [MerchantResolutionAttempted] value instead. This method is
                         * primarily for setting the field to an undocumented or not yet supported
                         * value.
                         */
                        fun merchantResolutionAttempted(
                            merchantResolutionAttempted: JsonField<MerchantResolutionAttempted>
                        ) = apply { this.merchantResolutionAttempted = merchantResolutionAttempted }

                        /**
                         * Paid by other means. Present if and only if `error_reason` is
                         * `paid_by_other_means`.
                         */
                        fun paidByOtherMeans(paidByOtherMeans: PaidByOtherMeans?) =
                            paidByOtherMeans(JsonField.ofNullable(paidByOtherMeans))

                        /**
                         * Sets [Builder.paidByOtherMeans] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.paidByOtherMeans] with a well-typed
                         * [PaidByOtherMeans] value instead. This method is primarily for setting
                         * the field to an undocumented or not yet supported value.
                         */
                        fun paidByOtherMeans(paidByOtherMeans: JsonField<PaidByOtherMeans>) =
                            apply {
                                this.paidByOtherMeans = paidByOtherMeans
                            }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [ProcessingError].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .duplicateTransaction()
                         * .errorReason()
                         * .incorrectAmount()
                         * .merchantResolutionAttempted()
                         * .paidByOtherMeans()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): ProcessingError =
                            ProcessingError(
                                checkRequired("duplicateTransaction", duplicateTransaction),
                                checkRequired("errorReason", errorReason),
                                checkRequired("incorrectAmount", incorrectAmount),
                                checkRequired(
                                    "merchantResolutionAttempted",
                                    merchantResolutionAttempted,
                                ),
                                checkRequired("paidByOtherMeans", paidByOtherMeans),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): ProcessingError = apply {
                        if (validated) {
                            return@apply
                        }

                        duplicateTransaction()?.validate()
                        errorReason().validate()
                        incorrectAmount()?.validate()
                        merchantResolutionAttempted().validate()
                        paidByOtherMeans()?.validate()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (duplicateTransaction.asKnown()?.validity() ?: 0) +
                            (errorReason.asKnown()?.validity() ?: 0) +
                            (incorrectAmount.asKnown()?.validity() ?: 0) +
                            (merchantResolutionAttempted.asKnown()?.validity() ?: 0) +
                            (paidByOtherMeans.asKnown()?.validity() ?: 0)

                    /**
                     * Duplicate transaction. Present if and only if `error_reason` is
                     * `duplicate_transaction`.
                     */
                    class DuplicateTransaction
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val otherTransactionId: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("other_transaction_id")
                            @ExcludeMissing
                            otherTransactionId: JsonField<String> = JsonMissing.of()
                        ) : this(otherTransactionId, mutableMapOf())

                        /**
                         * Other transaction ID.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun otherTransactionId(): String =
                            otherTransactionId.getRequired("other_transaction_id")

                        /**
                         * Returns the raw JSON value of [otherTransactionId].
                         *
                         * Unlike [otherTransactionId], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("other_transaction_id")
                        @ExcludeMissing
                        fun _otherTransactionId(): JsonField<String> = otherTransactionId

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [DuplicateTransaction].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .otherTransactionId()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [DuplicateTransaction]. */
                        class Builder internal constructor() {

                            private var otherTransactionId: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(duplicateTransaction: DuplicateTransaction) = apply {
                                otherTransactionId = duplicateTransaction.otherTransactionId
                                additionalProperties =
                                    duplicateTransaction.additionalProperties.toMutableMap()
                            }

                            /** Other transaction ID. */
                            fun otherTransactionId(otherTransactionId: String) =
                                otherTransactionId(JsonField.of(otherTransactionId))

                            /**
                             * Sets [Builder.otherTransactionId] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherTransactionId] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun otherTransactionId(otherTransactionId: JsonField<String>) = apply {
                                this.otherTransactionId = otherTransactionId
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [DuplicateTransaction].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .otherTransactionId()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): DuplicateTransaction =
                                DuplicateTransaction(
                                    checkRequired("otherTransactionId", otherTransactionId),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): DuplicateTransaction = apply {
                            if (validated) {
                                return@apply
                            }

                            otherTransactionId()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (otherTransactionId.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is DuplicateTransaction &&
                                otherTransactionId == other.otherTransactionId &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(otherTransactionId, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "DuplicateTransaction{otherTransactionId=$otherTransactionId, additionalProperties=$additionalProperties}"
                    }

                    /** Error reason. */
                    class ErrorReason
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Duplicate transaction. */
                            val DUPLICATE_TRANSACTION = of("duplicate_transaction")

                            /** Incorrect amount. */
                            val INCORRECT_AMOUNT = of("incorrect_amount")

                            /** Paid by other means. */
                            val PAID_BY_OTHER_MEANS = of("paid_by_other_means")

                            fun of(value: String) = ErrorReason(JsonField.of(value))
                        }

                        /** An enum containing [ErrorReason]'s known values. */
                        enum class Known {
                            /** Duplicate transaction. */
                            DUPLICATE_TRANSACTION,
                            /** Incorrect amount. */
                            INCORRECT_AMOUNT,
                            /** Paid by other means. */
                            PAID_BY_OTHER_MEANS,
                        }

                        /**
                         * An enum containing [ErrorReason]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [ErrorReason] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Duplicate transaction. */
                            DUPLICATE_TRANSACTION,
                            /** Incorrect amount. */
                            INCORRECT_AMOUNT,
                            /** Paid by other means. */
                            PAID_BY_OTHER_MEANS,
                            /**
                             * An enum member indicating that [ErrorReason] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                DUPLICATE_TRANSACTION -> Value.DUPLICATE_TRANSACTION
                                INCORRECT_AMOUNT -> Value.INCORRECT_AMOUNT
                                PAID_BY_OTHER_MEANS -> Value.PAID_BY_OTHER_MEANS
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                DUPLICATE_TRANSACTION -> Known.DUPLICATE_TRANSACTION
                                INCORRECT_AMOUNT -> Known.INCORRECT_AMOUNT
                                PAID_BY_OTHER_MEANS -> Known.PAID_BY_OTHER_MEANS
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown ErrorReason: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): ErrorReason = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is ErrorReason && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Incorrect amount. Present if and only if `error_reason` is
                     * `incorrect_amount`.
                     */
                    class IncorrectAmount
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val expectedAmount: JsonField<Long>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("expected_amount")
                            @ExcludeMissing
                            expectedAmount: JsonField<Long> = JsonMissing.of()
                        ) : this(expectedAmount, mutableMapOf())

                        /**
                         * Expected amount.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun expectedAmount(): Long = expectedAmount.getRequired("expected_amount")

                        /**
                         * Returns the raw JSON value of [expectedAmount].
                         *
                         * Unlike [expectedAmount], this method doesn't throw if the JSON field has
                         * an unexpected type.
                         */
                        @JsonProperty("expected_amount")
                        @ExcludeMissing
                        fun _expectedAmount(): JsonField<Long> = expectedAmount

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [IncorrectAmount].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .expectedAmount()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [IncorrectAmount]. */
                        class Builder internal constructor() {

                            private var expectedAmount: JsonField<Long>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(incorrectAmount: IncorrectAmount) = apply {
                                expectedAmount = incorrectAmount.expectedAmount
                                additionalProperties =
                                    incorrectAmount.additionalProperties.toMutableMap()
                            }

                            /** Expected amount. */
                            fun expectedAmount(expectedAmount: Long) =
                                expectedAmount(JsonField.of(expectedAmount))

                            /**
                             * Sets [Builder.expectedAmount] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.expectedAmount] with a well-typed
                             * [Long] value instead. This method is primarily for setting the field
                             * to an undocumented or not yet supported value.
                             */
                            fun expectedAmount(expectedAmount: JsonField<Long>) = apply {
                                this.expectedAmount = expectedAmount
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [IncorrectAmount].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .expectedAmount()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): IncorrectAmount =
                                IncorrectAmount(
                                    checkRequired("expectedAmount", expectedAmount),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): IncorrectAmount = apply {
                            if (validated) {
                                return@apply
                            }

                            expectedAmount()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (if (expectedAmount.asKnown() == null) 0 else 1)

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is IncorrectAmount &&
                                expectedAmount == other.expectedAmount &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(expectedAmount, additionalProperties)
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "IncorrectAmount{expectedAmount=$expectedAmount, additionalProperties=$additionalProperties}"
                    }

                    /** Merchant resolution attempted. */
                    class MerchantResolutionAttempted
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Attempted. */
                            val ATTEMPTED = of("attempted")

                            /** Prohibited by local law. */
                            val PROHIBITED_BY_LOCAL_LAW = of("prohibited_by_local_law")

                            fun of(value: String) = MerchantResolutionAttempted(JsonField.of(value))
                        }

                        /** An enum containing [MerchantResolutionAttempted]'s known values. */
                        enum class Known {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                        }

                        /**
                         * An enum containing [MerchantResolutionAttempted]'s known values, as well
                         * as an [_UNKNOWN] member.
                         *
                         * An instance of [MerchantResolutionAttempted] can contain an unknown value
                         * in a couple of cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Attempted. */
                            ATTEMPTED,
                            /** Prohibited by local law. */
                            PROHIBITED_BY_LOCAL_LAW,
                            /**
                             * An enum member indicating that [MerchantResolutionAttempted] was
                             * instantiated with an unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                ATTEMPTED -> Value.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Value.PROHIBITED_BY_LOCAL_LAW
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                ATTEMPTED -> Known.ATTEMPTED
                                PROHIBITED_BY_LOCAL_LAW -> Known.PROHIBITED_BY_LOCAL_LAW
                                else ->
                                    throw IncreaseInvalidDataException(
                                        "Unknown MerchantResolutionAttempted: $value"
                                    )
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): MerchantResolutionAttempted = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is MerchantResolutionAttempted && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    /**
                     * Paid by other means. Present if and only if `error_reason` is
                     * `paid_by_other_means`.
                     */
                    class PaidByOtherMeans
                    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                    private constructor(
                        private val otherFormOfPaymentEvidence:
                            JsonField<OtherFormOfPaymentEvidence>,
                        private val otherTransactionId: JsonField<String>,
                        private val additionalProperties: MutableMap<String, JsonValue>,
                    ) {

                        @JsonCreator
                        private constructor(
                            @JsonProperty("other_form_of_payment_evidence")
                            @ExcludeMissing
                            otherFormOfPaymentEvidence: JsonField<OtherFormOfPaymentEvidence> =
                                JsonMissing.of(),
                            @JsonProperty("other_transaction_id")
                            @ExcludeMissing
                            otherTransactionId: JsonField<String> = JsonMissing.of(),
                        ) : this(otherFormOfPaymentEvidence, otherTransactionId, mutableMapOf())

                        /**
                         * Other form of payment evidence.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type or is unexpectedly missing or null (e.g. if the server responded
                         *   with an unexpected value).
                         */
                        fun otherFormOfPaymentEvidence(): OtherFormOfPaymentEvidence =
                            otherFormOfPaymentEvidence.getRequired("other_form_of_payment_evidence")

                        /**
                         * Other transaction ID.
                         *
                         * @throws IncreaseInvalidDataException if the JSON field has an unexpected
                         *   type (e.g. if the server responded with an unexpected value).
                         */
                        fun otherTransactionId(): String? =
                            otherTransactionId.getNullable("other_transaction_id")

                        /**
                         * Returns the raw JSON value of [otherFormOfPaymentEvidence].
                         *
                         * Unlike [otherFormOfPaymentEvidence], this method doesn't throw if the
                         * JSON field has an unexpected type.
                         */
                        @JsonProperty("other_form_of_payment_evidence")
                        @ExcludeMissing
                        fun _otherFormOfPaymentEvidence(): JsonField<OtherFormOfPaymentEvidence> =
                            otherFormOfPaymentEvidence

                        /**
                         * Returns the raw JSON value of [otherTransactionId].
                         *
                         * Unlike [otherTransactionId], this method doesn't throw if the JSON field
                         * has an unexpected type.
                         */
                        @JsonProperty("other_transaction_id")
                        @ExcludeMissing
                        fun _otherTransactionId(): JsonField<String> = otherTransactionId

                        @JsonAnySetter
                        private fun putAdditionalProperty(key: String, value: JsonValue) {
                            additionalProperties.put(key, value)
                        }

                        @JsonAnyGetter
                        @ExcludeMissing
                        fun _additionalProperties(): Map<String, JsonValue> =
                            Collections.unmodifiableMap(additionalProperties)

                        fun toBuilder() = Builder().from(this)

                        companion object {

                            /**
                             * Returns a mutable builder for constructing an instance of
                             * [PaidByOtherMeans].
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .otherFormOfPaymentEvidence()
                             * .otherTransactionId()
                             * ```
                             */
                            fun builder() = Builder()
                        }

                        /** A builder for [PaidByOtherMeans]. */
                        class Builder internal constructor() {

                            private var otherFormOfPaymentEvidence:
                                JsonField<OtherFormOfPaymentEvidence>? =
                                null
                            private var otherTransactionId: JsonField<String>? = null
                            private var additionalProperties: MutableMap<String, JsonValue> =
                                mutableMapOf()

                            internal fun from(paidByOtherMeans: PaidByOtherMeans) = apply {
                                otherFormOfPaymentEvidence =
                                    paidByOtherMeans.otherFormOfPaymentEvidence
                                otherTransactionId = paidByOtherMeans.otherTransactionId
                                additionalProperties =
                                    paidByOtherMeans.additionalProperties.toMutableMap()
                            }

                            /** Other form of payment evidence. */
                            fun otherFormOfPaymentEvidence(
                                otherFormOfPaymentEvidence: OtherFormOfPaymentEvidence
                            ) = otherFormOfPaymentEvidence(JsonField.of(otherFormOfPaymentEvidence))

                            /**
                             * Sets [Builder.otherFormOfPaymentEvidence] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherFormOfPaymentEvidence] with a
                             * well-typed [OtherFormOfPaymentEvidence] value instead. This method is
                             * primarily for setting the field to an undocumented or not yet
                             * supported value.
                             */
                            fun otherFormOfPaymentEvidence(
                                otherFormOfPaymentEvidence: JsonField<OtherFormOfPaymentEvidence>
                            ) = apply {
                                this.otherFormOfPaymentEvidence = otherFormOfPaymentEvidence
                            }

                            /** Other transaction ID. */
                            fun otherTransactionId(otherTransactionId: String?) =
                                otherTransactionId(JsonField.ofNullable(otherTransactionId))

                            /**
                             * Sets [Builder.otherTransactionId] to an arbitrary JSON value.
                             *
                             * You should usually call [Builder.otherTransactionId] with a
                             * well-typed [String] value instead. This method is primarily for
                             * setting the field to an undocumented or not yet supported value.
                             */
                            fun otherTransactionId(otherTransactionId: JsonField<String>) = apply {
                                this.otherTransactionId = otherTransactionId
                            }

                            fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                                apply {
                                    this.additionalProperties.clear()
                                    putAllAdditionalProperties(additionalProperties)
                                }

                            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                                additionalProperties.put(key, value)
                            }

                            fun putAllAdditionalProperties(
                                additionalProperties: Map<String, JsonValue>
                            ) = apply { this.additionalProperties.putAll(additionalProperties) }

                            fun removeAdditionalProperty(key: String) = apply {
                                additionalProperties.remove(key)
                            }

                            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                                keys.forEach(::removeAdditionalProperty)
                            }

                            /**
                             * Returns an immutable instance of [PaidByOtherMeans].
                             *
                             * Further updates to this [Builder] will not mutate the returned
                             * instance.
                             *
                             * The following fields are required:
                             * ```kotlin
                             * .otherFormOfPaymentEvidence()
                             * .otherTransactionId()
                             * ```
                             *
                             * @throws IllegalStateException if any required field is unset.
                             */
                            fun build(): PaidByOtherMeans =
                                PaidByOtherMeans(
                                    checkRequired(
                                        "otherFormOfPaymentEvidence",
                                        otherFormOfPaymentEvidence,
                                    ),
                                    checkRequired("otherTransactionId", otherTransactionId),
                                    additionalProperties.toMutableMap(),
                                )
                        }

                        private var validated: Boolean = false

                        fun validate(): PaidByOtherMeans = apply {
                            if (validated) {
                                return@apply
                            }

                            otherFormOfPaymentEvidence().validate()
                            otherTransactionId()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int =
                            (otherFormOfPaymentEvidence.asKnown()?.validity() ?: 0) +
                                (if (otherTransactionId.asKnown() == null) 0 else 1)

                        /** Other form of payment evidence. */
                        class OtherFormOfPaymentEvidence
                        @JsonCreator
                        private constructor(private val value: JsonField<String>) : Enum {

                            /**
                             * Returns this class instance's raw value.
                             *
                             * This is usually only useful if this instance was deserialized from
                             * data that doesn't match any known member, and you want to know that
                             * value. For example, if the SDK is on an older version than the API,
                             * then the API may respond with new members that the SDK is unaware of.
                             */
                            @com.fasterxml.jackson.annotation.JsonValue
                            fun _value(): JsonField<String> = value

                            companion object {

                                /** Canceled check. */
                                val CANCELED_CHECK = of("canceled_check")

                                /** Card transaction. */
                                val CARD_TRANSACTION = of("card_transaction")

                                /** Cash receipt. */
                                val CASH_RECEIPT = of("cash_receipt")

                                /** Other. */
                                val OTHER = of("other")

                                /** Statement. */
                                val STATEMENT = of("statement")

                                /** Voucher. */
                                val VOUCHER = of("voucher")

                                fun of(value: String) =
                                    OtherFormOfPaymentEvidence(JsonField.of(value))
                            }

                            /** An enum containing [OtherFormOfPaymentEvidence]'s known values. */
                            enum class Known {
                                /** Canceled check. */
                                CANCELED_CHECK,
                                /** Card transaction. */
                                CARD_TRANSACTION,
                                /** Cash receipt. */
                                CASH_RECEIPT,
                                /** Other. */
                                OTHER,
                                /** Statement. */
                                STATEMENT,
                                /** Voucher. */
                                VOUCHER,
                            }

                            /**
                             * An enum containing [OtherFormOfPaymentEvidence]'s known values, as
                             * well as an [_UNKNOWN] member.
                             *
                             * An instance of [OtherFormOfPaymentEvidence] can contain an unknown
                             * value in a couple of cases:
                             * - It was deserialized from data that doesn't match any known member.
                             *   For example, if the SDK is on an older version than the API, then
                             *   the API may respond with new members that the SDK is unaware of.
                             * - It was constructed with an arbitrary value using the [of] method.
                             */
                            enum class Value {
                                /** Canceled check. */
                                CANCELED_CHECK,
                                /** Card transaction. */
                                CARD_TRANSACTION,
                                /** Cash receipt. */
                                CASH_RECEIPT,
                                /** Other. */
                                OTHER,
                                /** Statement. */
                                STATEMENT,
                                /** Voucher. */
                                VOUCHER,
                                /**
                                 * An enum member indicating that [OtherFormOfPaymentEvidence] was
                                 * instantiated with an unknown value.
                                 */
                                _UNKNOWN,
                            }

                            /**
                             * Returns an enum member corresponding to this class instance's value,
                             * or [Value._UNKNOWN] if the class was instantiated with an unknown
                             * value.
                             *
                             * Use the [known] method instead if you're certain the value is always
                             * known or if you want to throw for the unknown case.
                             */
                            fun value(): Value =
                                when (this) {
                                    CANCELED_CHECK -> Value.CANCELED_CHECK
                                    CARD_TRANSACTION -> Value.CARD_TRANSACTION
                                    CASH_RECEIPT -> Value.CASH_RECEIPT
                                    OTHER -> Value.OTHER
                                    STATEMENT -> Value.STATEMENT
                                    VOUCHER -> Value.VOUCHER
                                    else -> Value._UNKNOWN
                                }

                            /**
                             * Returns an enum member corresponding to this class instance's value.
                             *
                             * Use the [value] method instead if you're uncertain the value is
                             * always known and don't want to throw for the unknown case.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   is a not a known member.
                             */
                            fun known(): Known =
                                when (this) {
                                    CANCELED_CHECK -> Known.CANCELED_CHECK
                                    CARD_TRANSACTION -> Known.CARD_TRANSACTION
                                    CASH_RECEIPT -> Known.CASH_RECEIPT
                                    OTHER -> Known.OTHER
                                    STATEMENT -> Known.STATEMENT
                                    VOUCHER -> Known.VOUCHER
                                    else ->
                                        throw IncreaseInvalidDataException(
                                            "Unknown OtherFormOfPaymentEvidence: $value"
                                        )
                                }

                            /**
                             * Returns this class instance's primitive wire representation.
                             *
                             * This differs from the [toString] method because that method is
                             * primarily for debugging and generally doesn't throw.
                             *
                             * @throws IncreaseInvalidDataException if this class instance's value
                             *   does not have the expected primitive type.
                             */
                            fun asString(): String =
                                _value().asString()
                                    ?: throw IncreaseInvalidDataException("Value is not a String")

                            private var validated: Boolean = false

                            fun validate(): OtherFormOfPaymentEvidence = apply {
                                if (validated) {
                                    return@apply
                                }

                                known()
                                validated = true
                            }

                            fun isValid(): Boolean =
                                try {
                                    validate()
                                    true
                                } catch (e: IncreaseInvalidDataException) {
                                    false
                                }

                            /**
                             * Returns a score indicating how many valid values are contained in
                             * this object recursively.
                             *
                             * Used for best match union deserialization.
                             */
                            internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                            override fun equals(other: Any?): Boolean {
                                if (this === other) {
                                    return true
                                }

                                return other is OtherFormOfPaymentEvidence && value == other.value
                            }

                            override fun hashCode() = value.hashCode()

                            override fun toString() = value.toString()
                        }

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is PaidByOtherMeans &&
                                otherFormOfPaymentEvidence == other.otherFormOfPaymentEvidence &&
                                otherTransactionId == other.otherTransactionId &&
                                additionalProperties == other.additionalProperties
                        }

                        private val hashCode: Int by lazy {
                            Objects.hash(
                                otherFormOfPaymentEvidence,
                                otherTransactionId,
                                additionalProperties,
                            )
                        }

                        override fun hashCode(): Int = hashCode

                        override fun toString() =
                            "PaidByOtherMeans{otherFormOfPaymentEvidence=$otherFormOfPaymentEvidence, otherTransactionId=$otherTransactionId, additionalProperties=$additionalProperties}"
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is ProcessingError &&
                            duplicateTransaction == other.duplicateTransaction &&
                            errorReason == other.errorReason &&
                            incorrectAmount == other.incorrectAmount &&
                            merchantResolutionAttempted == other.merchantResolutionAttempted &&
                            paidByOtherMeans == other.paidByOtherMeans &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(
                            duplicateTransaction,
                            errorReason,
                            incorrectAmount,
                            merchantResolutionAttempted,
                            paidByOtherMeans,
                            additionalProperties,
                        )
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "ProcessingError{duplicateTransaction=$duplicateTransaction, errorReason=$errorReason, incorrectAmount=$incorrectAmount, merchantResolutionAttempted=$merchantResolutionAttempted, paidByOtherMeans=$paidByOtherMeans, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Chargeback &&
                        authorization == other.authorization &&
                        category == other.category &&
                        consumerCanceledMerchandise == other.consumerCanceledMerchandise &&
                        consumerCanceledRecurringTransaction ==
                            other.consumerCanceledRecurringTransaction &&
                        consumerCanceledServices == other.consumerCanceledServices &&
                        consumerCounterfeitMerchandise == other.consumerCounterfeitMerchandise &&
                        consumerCreditNotProcessed == other.consumerCreditNotProcessed &&
                        consumerDamagedOrDefectiveMerchandise ==
                            other.consumerDamagedOrDefectiveMerchandise &&
                        consumerMerchandiseMisrepresentation ==
                            other.consumerMerchandiseMisrepresentation &&
                        consumerMerchandiseNotAsDescribed ==
                            other.consumerMerchandiseNotAsDescribed &&
                        consumerMerchandiseNotReceived == other.consumerMerchandiseNotReceived &&
                        consumerNonReceiptOfCash == other.consumerNonReceiptOfCash &&
                        consumerOriginalCreditTransactionNotAccepted ==
                            other.consumerOriginalCreditTransactionNotAccepted &&
                        consumerQualityMerchandise == other.consumerQualityMerchandise &&
                        consumerQualityServices == other.consumerQualityServices &&
                        consumerServicesMisrepresentation ==
                            other.consumerServicesMisrepresentation &&
                        consumerServicesNotAsDescribed == other.consumerServicesNotAsDescribed &&
                        consumerServicesNotReceived == other.consumerServicesNotReceived &&
                        fraud == other.fraud &&
                        processingError == other.processingError &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(
                        authorization,
                        category,
                        consumerCanceledMerchandise,
                        consumerCanceledRecurringTransaction,
                        consumerCanceledServices,
                        consumerCounterfeitMerchandise,
                        consumerCreditNotProcessed,
                        consumerDamagedOrDefectiveMerchandise,
                        consumerMerchandiseMisrepresentation,
                        consumerMerchandiseNotAsDescribed,
                        consumerMerchandiseNotReceived,
                        consumerNonReceiptOfCash,
                        consumerOriginalCreditTransactionNotAccepted,
                        consumerQualityMerchandise,
                        consumerQualityServices,
                        consumerServicesMisrepresentation,
                        consumerServicesNotAsDescribed,
                        consumerServicesNotReceived,
                        fraud,
                        processingError,
                        additionalProperties,
                    )
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Chargeback{authorization=$authorization, category=$category, consumerCanceledMerchandise=$consumerCanceledMerchandise, consumerCanceledRecurringTransaction=$consumerCanceledRecurringTransaction, consumerCanceledServices=$consumerCanceledServices, consumerCounterfeitMerchandise=$consumerCounterfeitMerchandise, consumerCreditNotProcessed=$consumerCreditNotProcessed, consumerDamagedOrDefectiveMerchandise=$consumerDamagedOrDefectiveMerchandise, consumerMerchandiseMisrepresentation=$consumerMerchandiseMisrepresentation, consumerMerchandiseNotAsDescribed=$consumerMerchandiseNotAsDescribed, consumerMerchandiseNotReceived=$consumerMerchandiseNotReceived, consumerNonReceiptOfCash=$consumerNonReceiptOfCash, consumerOriginalCreditTransactionNotAccepted=$consumerOriginalCreditTransactionNotAccepted, consumerQualityMerchandise=$consumerQualityMerchandise, consumerQualityServices=$consumerQualityServices, consumerServicesMisrepresentation=$consumerServicesMisrepresentation, consumerServicesNotAsDescribed=$consumerServicesNotAsDescribed, consumerServicesNotReceived=$consumerServicesNotReceived, fraud=$fraud, processingError=$processingError, additionalProperties=$additionalProperties}"
            }

            /**
             * A Visa Card Dispute Merchant Pre-Arbitration Decline User Submission object. This
             * field will be present in the JSON response if and only if `category` is equal to
             * `merchant_prearbitration_decline`. Contains the details specific to a merchant
             * prearbitration decline Visa Card Dispute User Submission.
             */
            class MerchantPrearbitrationDecline
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val reason: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("reason")
                    @ExcludeMissing
                    reason: JsonField<String> = JsonMissing.of()
                ) : this(reason, mutableMapOf())

                /**
                 * The reason the user declined the merchant's request for pre-arbitration in their
                 * favor.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun reason(): String = reason.getRequired("reason")

                /**
                 * Returns the raw JSON value of [reason].
                 *
                 * Unlike [reason], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<String> = reason

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [MerchantPrearbitrationDecline].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .reason()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [MerchantPrearbitrationDecline]. */
                class Builder internal constructor() {

                    private var reason: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(
                        merchantPrearbitrationDecline: MerchantPrearbitrationDecline
                    ) = apply {
                        reason = merchantPrearbitrationDecline.reason
                        additionalProperties =
                            merchantPrearbitrationDecline.additionalProperties.toMutableMap()
                    }

                    /**
                     * The reason the user declined the merchant's request for pre-arbitration in
                     * their favor.
                     */
                    fun reason(reason: String) = reason(JsonField.of(reason))

                    /**
                     * Sets [Builder.reason] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.reason] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [MerchantPrearbitrationDecline].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .reason()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): MerchantPrearbitrationDecline =
                        MerchantPrearbitrationDecline(
                            checkRequired("reason", reason),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): MerchantPrearbitrationDecline = apply {
                    if (validated) {
                        return@apply
                    }

                    reason()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = (if (reason.asKnown() == null) 0 else 1)

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is MerchantPrearbitrationDecline &&
                        reason == other.reason &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy { Objects.hash(reason, additionalProperties) }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MerchantPrearbitrationDecline{reason=$reason, additionalProperties=$additionalProperties}"
            }

            /** The status of the Visa Card Dispute User Submission. */
            class Status @JsonCreator private constructor(private val value: JsonField<String>) :
                Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    /** The User Submission was abandoned. */
                    val ABANDONED = of("abandoned")

                    /** The User Submission was accepted. */
                    val ACCEPTED = of("accepted")

                    /**
                     * Further information is requested, please resubmit with the requested
                     * information.
                     */
                    val FURTHER_INFORMATION_REQUESTED = of("further_information_requested")

                    /** The User Submission is pending review. */
                    val PENDING_REVIEWING = of("pending_reviewing")

                    fun of(value: String) = Status(JsonField.of(value))
                }

                /** An enum containing [Status]'s known values. */
                enum class Known {
                    /** The User Submission was abandoned. */
                    ABANDONED,
                    /** The User Submission was accepted. */
                    ACCEPTED,
                    /**
                     * Further information is requested, please resubmit with the requested
                     * information.
                     */
                    FURTHER_INFORMATION_REQUESTED,
                    /** The User Submission is pending review. */
                    PENDING_REVIEWING,
                }

                /**
                 * An enum containing [Status]'s known values, as well as an [_UNKNOWN] member.
                 *
                 * An instance of [Status] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    /** The User Submission was abandoned. */
                    ABANDONED,
                    /** The User Submission was accepted. */
                    ACCEPTED,
                    /**
                     * Further information is requested, please resubmit with the requested
                     * information.
                     */
                    FURTHER_INFORMATION_REQUESTED,
                    /** The User Submission is pending review. */
                    PENDING_REVIEWING,
                    /**
                     * An enum member indicating that [Status] was instantiated with an unknown
                     * value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        ABANDONED -> Value.ABANDONED
                        ACCEPTED -> Value.ACCEPTED
                        FURTHER_INFORMATION_REQUESTED -> Value.FURTHER_INFORMATION_REQUESTED
                        PENDING_REVIEWING -> Value.PENDING_REVIEWING
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value is a not a
                 *   known member.
                 */
                fun known(): Known =
                    when (this) {
                        ABANDONED -> Known.ABANDONED
                        ACCEPTED -> Known.ACCEPTED
                        FURTHER_INFORMATION_REQUESTED -> Known.FURTHER_INFORMATION_REQUESTED
                        PENDING_REVIEWING -> Known.PENDING_REVIEWING
                        else -> throw IncreaseInvalidDataException("Unknown Status: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws IncreaseInvalidDataException if this class instance's value does not have
                 *   the expected primitive type.
                 */
                fun asString(): String =
                    _value().asString()
                        ?: throw IncreaseInvalidDataException("Value is not a String")

                private var validated: Boolean = false

                fun validate(): Status = apply {
                    if (validated) {
                        return@apply
                    }

                    known()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is Status && value == other.value
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            /**
             * A Visa Card Dispute User-Initiated Pre-Arbitration User Submission object. This field
             * will be present in the JSON response if and only if `category` is equal to
             * `user_prearbitration`. Contains the details specific to a user-initiated
             * pre-arbitration Visa Card Dispute User Submission.
             */
            class UserPrearbitration
            @JsonCreator(mode = JsonCreator.Mode.DISABLED)
            private constructor(
                private val categoryChange: JsonField<CategoryChange>,
                private val reason: JsonField<String>,
                private val additionalProperties: MutableMap<String, JsonValue>,
            ) {

                @JsonCreator
                private constructor(
                    @JsonProperty("category_change")
                    @ExcludeMissing
                    categoryChange: JsonField<CategoryChange> = JsonMissing.of(),
                    @JsonProperty("reason")
                    @ExcludeMissing
                    reason: JsonField<String> = JsonMissing.of(),
                ) : this(categoryChange, reason, mutableMapOf())

                /**
                 * Category change details for the pre-arbitration request, if requested.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                 *   (e.g. if the server responded with an unexpected value).
                 */
                fun categoryChange(): CategoryChange? =
                    categoryChange.getNullable("category_change")

                /**
                 * The reason for the pre-arbitration request.
                 *
                 * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or
                 *   is unexpectedly missing or null (e.g. if the server responded with an
                 *   unexpected value).
                 */
                fun reason(): String = reason.getRequired("reason")

                /**
                 * Returns the raw JSON value of [categoryChange].
                 *
                 * Unlike [categoryChange], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("category_change")
                @ExcludeMissing
                fun _categoryChange(): JsonField<CategoryChange> = categoryChange

                /**
                 * Returns the raw JSON value of [reason].
                 *
                 * Unlike [reason], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("reason") @ExcludeMissing fun _reason(): JsonField<String> = reason

                @JsonAnySetter
                private fun putAdditionalProperty(key: String, value: JsonValue) {
                    additionalProperties.put(key, value)
                }

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> =
                    Collections.unmodifiableMap(additionalProperties)

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of
                     * [UserPrearbitration].
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .categoryChange()
                     * .reason()
                     * ```
                     */
                    fun builder() = Builder()
                }

                /** A builder for [UserPrearbitration]. */
                class Builder internal constructor() {

                    private var categoryChange: JsonField<CategoryChange>? = null
                    private var reason: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    internal fun from(userPrearbitration: UserPrearbitration) = apply {
                        categoryChange = userPrearbitration.categoryChange
                        reason = userPrearbitration.reason
                        additionalProperties =
                            userPrearbitration.additionalProperties.toMutableMap()
                    }

                    /** Category change details for the pre-arbitration request, if requested. */
                    fun categoryChange(categoryChange: CategoryChange?) =
                        categoryChange(JsonField.ofNullable(categoryChange))

                    /**
                     * Sets [Builder.categoryChange] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.categoryChange] with a well-typed
                     * [CategoryChange] value instead. This method is primarily for setting the
                     * field to an undocumented or not yet supported value.
                     */
                    fun categoryChange(categoryChange: JsonField<CategoryChange>) = apply {
                        this.categoryChange = categoryChange
                    }

                    /** The reason for the pre-arbitration request. */
                    fun reason(reason: String) = reason(JsonField.of(reason))

                    /**
                     * Sets [Builder.reason] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.reason] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    /**
                     * Returns an immutable instance of [UserPrearbitration].
                     *
                     * Further updates to this [Builder] will not mutate the returned instance.
                     *
                     * The following fields are required:
                     * ```kotlin
                     * .categoryChange()
                     * .reason()
                     * ```
                     *
                     * @throws IllegalStateException if any required field is unset.
                     */
                    fun build(): UserPrearbitration =
                        UserPrearbitration(
                            checkRequired("categoryChange", categoryChange),
                            checkRequired("reason", reason),
                            additionalProperties.toMutableMap(),
                        )
                }

                private var validated: Boolean = false

                fun validate(): UserPrearbitration = apply {
                    if (validated) {
                        return@apply
                    }

                    categoryChange()?.validate()
                    reason()
                    validated = true
                }

                fun isValid(): Boolean =
                    try {
                        validate()
                        true
                    } catch (e: IncreaseInvalidDataException) {
                        false
                    }

                /**
                 * Returns a score indicating how many valid values are contained in this object
                 * recursively.
                 *
                 * Used for best match union deserialization.
                 */
                internal fun validity(): Int =
                    (categoryChange.asKnown()?.validity() ?: 0) +
                        (if (reason.asKnown() == null) 0 else 1)

                /** Category change details for the pre-arbitration request, if requested. */
                class CategoryChange
                @JsonCreator(mode = JsonCreator.Mode.DISABLED)
                private constructor(
                    private val category: JsonField<Category>,
                    private val reason: JsonField<String>,
                    private val additionalProperties: MutableMap<String, JsonValue>,
                ) {

                    @JsonCreator
                    private constructor(
                        @JsonProperty("category")
                        @ExcludeMissing
                        category: JsonField<Category> = JsonMissing.of(),
                        @JsonProperty("reason")
                        @ExcludeMissing
                        reason: JsonField<String> = JsonMissing.of(),
                    ) : this(category, reason, mutableMapOf())

                    /**
                     * The category the dispute is being changed to.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun category(): Category = category.getRequired("category")

                    /**
                     * The reason for the pre-arbitration request.
                     *
                     * @throws IncreaseInvalidDataException if the JSON field has an unexpected type
                     *   or is unexpectedly missing or null (e.g. if the server responded with an
                     *   unexpected value).
                     */
                    fun reason(): String = reason.getRequired("reason")

                    /**
                     * Returns the raw JSON value of [category].
                     *
                     * Unlike [category], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("category")
                    @ExcludeMissing
                    fun _category(): JsonField<Category> = category

                    /**
                     * Returns the raw JSON value of [reason].
                     *
                     * Unlike [reason], this method doesn't throw if the JSON field has an
                     * unexpected type.
                     */
                    @JsonProperty("reason")
                    @ExcludeMissing
                    fun _reason(): JsonField<String> = reason

                    @JsonAnySetter
                    private fun putAdditionalProperty(key: String, value: JsonValue) {
                        additionalProperties.put(key, value)
                    }

                    @JsonAnyGetter
                    @ExcludeMissing
                    fun _additionalProperties(): Map<String, JsonValue> =
                        Collections.unmodifiableMap(additionalProperties)

                    fun toBuilder() = Builder().from(this)

                    companion object {

                        /**
                         * Returns a mutable builder for constructing an instance of
                         * [CategoryChange].
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .category()
                         * .reason()
                         * ```
                         */
                        fun builder() = Builder()
                    }

                    /** A builder for [CategoryChange]. */
                    class Builder internal constructor() {

                        private var category: JsonField<Category>? = null
                        private var reason: JsonField<String>? = null
                        private var additionalProperties: MutableMap<String, JsonValue> =
                            mutableMapOf()

                        internal fun from(categoryChange: CategoryChange) = apply {
                            category = categoryChange.category
                            reason = categoryChange.reason
                            additionalProperties =
                                categoryChange.additionalProperties.toMutableMap()
                        }

                        /** The category the dispute is being changed to. */
                        fun category(category: Category) = category(JsonField.of(category))

                        /**
                         * Sets [Builder.category] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.category] with a well-typed [Category]
                         * value instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun category(category: JsonField<Category>) = apply {
                            this.category = category
                        }

                        /** The reason for the pre-arbitration request. */
                        fun reason(reason: String) = reason(JsonField.of(reason))

                        /**
                         * Sets [Builder.reason] to an arbitrary JSON value.
                         *
                         * You should usually call [Builder.reason] with a well-typed [String] value
                         * instead. This method is primarily for setting the field to an
                         * undocumented or not yet supported value.
                         */
                        fun reason(reason: JsonField<String>) = apply { this.reason = reason }

                        fun additionalProperties(additionalProperties: Map<String, JsonValue>) =
                            apply {
                                this.additionalProperties.clear()
                                putAllAdditionalProperties(additionalProperties)
                            }

                        fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                            additionalProperties.put(key, value)
                        }

                        fun putAllAdditionalProperties(
                            additionalProperties: Map<String, JsonValue>
                        ) = apply { this.additionalProperties.putAll(additionalProperties) }

                        fun removeAdditionalProperty(key: String) = apply {
                            additionalProperties.remove(key)
                        }

                        fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                            keys.forEach(::removeAdditionalProperty)
                        }

                        /**
                         * Returns an immutable instance of [CategoryChange].
                         *
                         * Further updates to this [Builder] will not mutate the returned instance.
                         *
                         * The following fields are required:
                         * ```kotlin
                         * .category()
                         * .reason()
                         * ```
                         *
                         * @throws IllegalStateException if any required field is unset.
                         */
                        fun build(): CategoryChange =
                            CategoryChange(
                                checkRequired("category", category),
                                checkRequired("reason", reason),
                                additionalProperties.toMutableMap(),
                            )
                    }

                    private var validated: Boolean = false

                    fun validate(): CategoryChange = apply {
                        if (validated) {
                            return@apply
                        }

                        category().validate()
                        reason()
                        validated = true
                    }

                    fun isValid(): Boolean =
                        try {
                            validate()
                            true
                        } catch (e: IncreaseInvalidDataException) {
                            false
                        }

                    /**
                     * Returns a score indicating how many valid values are contained in this object
                     * recursively.
                     *
                     * Used for best match union deserialization.
                     */
                    internal fun validity(): Int =
                        (category.asKnown()?.validity() ?: 0) +
                            (if (reason.asKnown() == null) 0 else 1)

                    /** The category the dispute is being changed to. */
                    class Category
                    @JsonCreator
                    private constructor(private val value: JsonField<String>) : Enum {

                        /**
                         * Returns this class instance's raw value.
                         *
                         * This is usually only useful if this instance was deserialized from data
                         * that doesn't match any known member, and you want to know that value. For
                         * example, if the SDK is on an older version than the API, then the API may
                         * respond with new members that the SDK is unaware of.
                         */
                        @com.fasterxml.jackson.annotation.JsonValue
                        fun _value(): JsonField<String> = value

                        companion object {

                            /** Authorization. */
                            val AUTHORIZATION = of("authorization")

                            /** Consumer: canceled merchandise. */
                            val CONSUMER_CANCELED_MERCHANDISE = of("consumer_canceled_merchandise")

                            /** Consumer: canceled recurring transaction. */
                            val CONSUMER_CANCELED_RECURRING_TRANSACTION =
                                of("consumer_canceled_recurring_transaction")

                            /** Consumer: canceled services. */
                            val CONSUMER_CANCELED_SERVICES = of("consumer_canceled_services")

                            /** Consumer: counterfeit merchandise. */
                            val CONSUMER_COUNTERFEIT_MERCHANDISE =
                                of("consumer_counterfeit_merchandise")

                            /** Consumer: credit not processed. */
                            val CONSUMER_CREDIT_NOT_PROCESSED = of("consumer_credit_not_processed")

                            /** Consumer: damaged or defective merchandise. */
                            val CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE =
                                of("consumer_damaged_or_defective_merchandise")

                            /** Consumer: merchandise misrepresentation. */
                            val CONSUMER_MERCHANDISE_MISREPRESENTATION =
                                of("consumer_merchandise_misrepresentation")

                            /** Consumer: merchandise not as described. */
                            val CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED =
                                of("consumer_merchandise_not_as_described")

                            /** Consumer: merchandise not received. */
                            val CONSUMER_MERCHANDISE_NOT_RECEIVED =
                                of("consumer_merchandise_not_received")

                            /** Consumer: non-receipt of cash. */
                            val CONSUMER_NON_RECEIPT_OF_CASH = of("consumer_non_receipt_of_cash")

                            /** Consumer: Original Credit Transaction (OCT) not accepted. */
                            val CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED =
                                of("consumer_original_credit_transaction_not_accepted")

                            /** Consumer: merchandise quality issue. */
                            val CONSUMER_QUALITY_MERCHANDISE = of("consumer_quality_merchandise")

                            /** Consumer: services quality issue. */
                            val CONSUMER_QUALITY_SERVICES = of("consumer_quality_services")

                            /** Consumer: services misrepresentation. */
                            val CONSUMER_SERVICES_MISREPRESENTATION =
                                of("consumer_services_misrepresentation")

                            /** Consumer: services not as described. */
                            val CONSUMER_SERVICES_NOT_AS_DESCRIBED =
                                of("consumer_services_not_as_described")

                            /** Consumer: services not received. */
                            val CONSUMER_SERVICES_NOT_RECEIVED =
                                of("consumer_services_not_received")

                            /** Fraud. */
                            val FRAUD = of("fraud")

                            /** Processing error. */
                            val PROCESSING_ERROR = of("processing_error")

                            fun of(value: String) = Category(JsonField.of(value))
                        }

                        /** An enum containing [Category]'s known values. */
                        enum class Known {
                            /** Authorization. */
                            AUTHORIZATION,
                            /** Consumer: canceled merchandise. */
                            CONSUMER_CANCELED_MERCHANDISE,
                            /** Consumer: canceled recurring transaction. */
                            CONSUMER_CANCELED_RECURRING_TRANSACTION,
                            /** Consumer: canceled services. */
                            CONSUMER_CANCELED_SERVICES,
                            /** Consumer: counterfeit merchandise. */
                            CONSUMER_COUNTERFEIT_MERCHANDISE,
                            /** Consumer: credit not processed. */
                            CONSUMER_CREDIT_NOT_PROCESSED,
                            /** Consumer: damaged or defective merchandise. */
                            CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                            /** Consumer: merchandise misrepresentation. */
                            CONSUMER_MERCHANDISE_MISREPRESENTATION,
                            /** Consumer: merchandise not as described. */
                            CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                            /** Consumer: merchandise not received. */
                            CONSUMER_MERCHANDISE_NOT_RECEIVED,
                            /** Consumer: non-receipt of cash. */
                            CONSUMER_NON_RECEIPT_OF_CASH,
                            /** Consumer: Original Credit Transaction (OCT) not accepted. */
                            CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                            /** Consumer: merchandise quality issue. */
                            CONSUMER_QUALITY_MERCHANDISE,
                            /** Consumer: services quality issue. */
                            CONSUMER_QUALITY_SERVICES,
                            /** Consumer: services misrepresentation. */
                            CONSUMER_SERVICES_MISREPRESENTATION,
                            /** Consumer: services not as described. */
                            CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                            /** Consumer: services not received. */
                            CONSUMER_SERVICES_NOT_RECEIVED,
                            /** Fraud. */
                            FRAUD,
                            /** Processing error. */
                            PROCESSING_ERROR,
                        }

                        /**
                         * An enum containing [Category]'s known values, as well as an [_UNKNOWN]
                         * member.
                         *
                         * An instance of [Category] can contain an unknown value in a couple of
                         * cases:
                         * - It was deserialized from data that doesn't match any known member. For
                         *   example, if the SDK is on an older version than the API, then the API
                         *   may respond with new members that the SDK is unaware of.
                         * - It was constructed with an arbitrary value using the [of] method.
                         */
                        enum class Value {
                            /** Authorization. */
                            AUTHORIZATION,
                            /** Consumer: canceled merchandise. */
                            CONSUMER_CANCELED_MERCHANDISE,
                            /** Consumer: canceled recurring transaction. */
                            CONSUMER_CANCELED_RECURRING_TRANSACTION,
                            /** Consumer: canceled services. */
                            CONSUMER_CANCELED_SERVICES,
                            /** Consumer: counterfeit merchandise. */
                            CONSUMER_COUNTERFEIT_MERCHANDISE,
                            /** Consumer: credit not processed. */
                            CONSUMER_CREDIT_NOT_PROCESSED,
                            /** Consumer: damaged or defective merchandise. */
                            CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE,
                            /** Consumer: merchandise misrepresentation. */
                            CONSUMER_MERCHANDISE_MISREPRESENTATION,
                            /** Consumer: merchandise not as described. */
                            CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED,
                            /** Consumer: merchandise not received. */
                            CONSUMER_MERCHANDISE_NOT_RECEIVED,
                            /** Consumer: non-receipt of cash. */
                            CONSUMER_NON_RECEIPT_OF_CASH,
                            /** Consumer: Original Credit Transaction (OCT) not accepted. */
                            CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED,
                            /** Consumer: merchandise quality issue. */
                            CONSUMER_QUALITY_MERCHANDISE,
                            /** Consumer: services quality issue. */
                            CONSUMER_QUALITY_SERVICES,
                            /** Consumer: services misrepresentation. */
                            CONSUMER_SERVICES_MISREPRESENTATION,
                            /** Consumer: services not as described. */
                            CONSUMER_SERVICES_NOT_AS_DESCRIBED,
                            /** Consumer: services not received. */
                            CONSUMER_SERVICES_NOT_RECEIVED,
                            /** Fraud. */
                            FRAUD,
                            /** Processing error. */
                            PROCESSING_ERROR,
                            /**
                             * An enum member indicating that [Category] was instantiated with an
                             * unknown value.
                             */
                            _UNKNOWN,
                        }

                        /**
                         * Returns an enum member corresponding to this class instance's value, or
                         * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                         *
                         * Use the [known] method instead if you're certain the value is always
                         * known or if you want to throw for the unknown case.
                         */
                        fun value(): Value =
                            when (this) {
                                AUTHORIZATION -> Value.AUTHORIZATION
                                CONSUMER_CANCELED_MERCHANDISE -> Value.CONSUMER_CANCELED_MERCHANDISE
                                CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                                    Value.CONSUMER_CANCELED_RECURRING_TRANSACTION
                                CONSUMER_CANCELED_SERVICES -> Value.CONSUMER_CANCELED_SERVICES
                                CONSUMER_COUNTERFEIT_MERCHANDISE ->
                                    Value.CONSUMER_COUNTERFEIT_MERCHANDISE
                                CONSUMER_CREDIT_NOT_PROCESSED -> Value.CONSUMER_CREDIT_NOT_PROCESSED
                                CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                                    Value.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                                CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                                    Value.CONSUMER_MERCHANDISE_MISREPRESENTATION
                                CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                                    Value.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                                CONSUMER_MERCHANDISE_NOT_RECEIVED ->
                                    Value.CONSUMER_MERCHANDISE_NOT_RECEIVED
                                CONSUMER_NON_RECEIPT_OF_CASH -> Value.CONSUMER_NON_RECEIPT_OF_CASH
                                CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                                    Value.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                                CONSUMER_QUALITY_MERCHANDISE -> Value.CONSUMER_QUALITY_MERCHANDISE
                                CONSUMER_QUALITY_SERVICES -> Value.CONSUMER_QUALITY_SERVICES
                                CONSUMER_SERVICES_MISREPRESENTATION ->
                                    Value.CONSUMER_SERVICES_MISREPRESENTATION
                                CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                                    Value.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                                CONSUMER_SERVICES_NOT_RECEIVED ->
                                    Value.CONSUMER_SERVICES_NOT_RECEIVED
                                FRAUD -> Value.FRAUD
                                PROCESSING_ERROR -> Value.PROCESSING_ERROR
                                else -> Value._UNKNOWN
                            }

                        /**
                         * Returns an enum member corresponding to this class instance's value.
                         *
                         * Use the [value] method instead if you're uncertain the value is always
                         * known and don't want to throw for the unknown case.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value is a
                         *   not a known member.
                         */
                        fun known(): Known =
                            when (this) {
                                AUTHORIZATION -> Known.AUTHORIZATION
                                CONSUMER_CANCELED_MERCHANDISE -> Known.CONSUMER_CANCELED_MERCHANDISE
                                CONSUMER_CANCELED_RECURRING_TRANSACTION ->
                                    Known.CONSUMER_CANCELED_RECURRING_TRANSACTION
                                CONSUMER_CANCELED_SERVICES -> Known.CONSUMER_CANCELED_SERVICES
                                CONSUMER_COUNTERFEIT_MERCHANDISE ->
                                    Known.CONSUMER_COUNTERFEIT_MERCHANDISE
                                CONSUMER_CREDIT_NOT_PROCESSED -> Known.CONSUMER_CREDIT_NOT_PROCESSED
                                CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE ->
                                    Known.CONSUMER_DAMAGED_OR_DEFECTIVE_MERCHANDISE
                                CONSUMER_MERCHANDISE_MISREPRESENTATION ->
                                    Known.CONSUMER_MERCHANDISE_MISREPRESENTATION
                                CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED ->
                                    Known.CONSUMER_MERCHANDISE_NOT_AS_DESCRIBED
                                CONSUMER_MERCHANDISE_NOT_RECEIVED ->
                                    Known.CONSUMER_MERCHANDISE_NOT_RECEIVED
                                CONSUMER_NON_RECEIPT_OF_CASH -> Known.CONSUMER_NON_RECEIPT_OF_CASH
                                CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED ->
                                    Known.CONSUMER_ORIGINAL_CREDIT_TRANSACTION_NOT_ACCEPTED
                                CONSUMER_QUALITY_MERCHANDISE -> Known.CONSUMER_QUALITY_MERCHANDISE
                                CONSUMER_QUALITY_SERVICES -> Known.CONSUMER_QUALITY_SERVICES
                                CONSUMER_SERVICES_MISREPRESENTATION ->
                                    Known.CONSUMER_SERVICES_MISREPRESENTATION
                                CONSUMER_SERVICES_NOT_AS_DESCRIBED ->
                                    Known.CONSUMER_SERVICES_NOT_AS_DESCRIBED
                                CONSUMER_SERVICES_NOT_RECEIVED ->
                                    Known.CONSUMER_SERVICES_NOT_RECEIVED
                                FRAUD -> Known.FRAUD
                                PROCESSING_ERROR -> Known.PROCESSING_ERROR
                                else ->
                                    throw IncreaseInvalidDataException("Unknown Category: $value")
                            }

                        /**
                         * Returns this class instance's primitive wire representation.
                         *
                         * This differs from the [toString] method because that method is primarily
                         * for debugging and generally doesn't throw.
                         *
                         * @throws IncreaseInvalidDataException if this class instance's value does
                         *   not have the expected primitive type.
                         */
                        fun asString(): String =
                            _value().asString()
                                ?: throw IncreaseInvalidDataException("Value is not a String")

                        private var validated: Boolean = false

                        fun validate(): Category = apply {
                            if (validated) {
                                return@apply
                            }

                            known()
                            validated = true
                        }

                        fun isValid(): Boolean =
                            try {
                                validate()
                                true
                            } catch (e: IncreaseInvalidDataException) {
                                false
                            }

                        /**
                         * Returns a score indicating how many valid values are contained in this
                         * object recursively.
                         *
                         * Used for best match union deserialization.
                         */
                        internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

                        override fun equals(other: Any?): Boolean {
                            if (this === other) {
                                return true
                            }

                            return other is Category && value == other.value
                        }

                        override fun hashCode() = value.hashCode()

                        override fun toString() = value.toString()
                    }

                    override fun equals(other: Any?): Boolean {
                        if (this === other) {
                            return true
                        }

                        return other is CategoryChange &&
                            category == other.category &&
                            reason == other.reason &&
                            additionalProperties == other.additionalProperties
                    }

                    private val hashCode: Int by lazy {
                        Objects.hash(category, reason, additionalProperties)
                    }

                    override fun hashCode(): Int = hashCode

                    override fun toString() =
                        "CategoryChange{category=$category, reason=$reason, additionalProperties=$additionalProperties}"
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return other is UserPrearbitration &&
                        categoryChange == other.categoryChange &&
                        reason == other.reason &&
                        additionalProperties == other.additionalProperties
                }

                private val hashCode: Int by lazy {
                    Objects.hash(categoryChange, reason, additionalProperties)
                }

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "UserPrearbitration{categoryChange=$categoryChange, reason=$reason, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is UserSubmission &&
                    acceptedAt == other.acceptedAt &&
                    amount == other.amount &&
                    attachmentFiles == other.attachmentFiles &&
                    category == other.category &&
                    chargeback == other.chargeback &&
                    createdAt == other.createdAt &&
                    furtherInformationRequestedAt == other.furtherInformationRequestedAt &&
                    furtherInformationRequestedReason == other.furtherInformationRequestedReason &&
                    merchantPrearbitrationDecline == other.merchantPrearbitrationDecline &&
                    status == other.status &&
                    updatedAt == other.updatedAt &&
                    userPrearbitration == other.userPrearbitration &&
                    additionalProperties == other.additionalProperties
            }

            private val hashCode: Int by lazy {
                Objects.hash(
                    acceptedAt,
                    amount,
                    attachmentFiles,
                    category,
                    chargeback,
                    createdAt,
                    furtherInformationRequestedAt,
                    furtherInformationRequestedReason,
                    merchantPrearbitrationDecline,
                    status,
                    updatedAt,
                    userPrearbitration,
                    additionalProperties,
                )
            }

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UserSubmission{acceptedAt=$acceptedAt, amount=$amount, attachmentFiles=$attachmentFiles, category=$category, chargeback=$chargeback, createdAt=$createdAt, furtherInformationRequestedAt=$furtherInformationRequestedAt, furtherInformationRequestedReason=$furtherInformationRequestedReason, merchantPrearbitrationDecline=$merchantPrearbitrationDecline, status=$status, updatedAt=$updatedAt, userPrearbitration=$userPrearbitration, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Visa &&
                networkEvents == other.networkEvents &&
                requiredUserSubmissionCategory == other.requiredUserSubmissionCategory &&
                userSubmissions == other.userSubmissions &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                networkEvents,
                requiredUserSubmissionCategory,
                userSubmissions,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Visa{networkEvents=$networkEvents, requiredUserSubmissionCategory=$requiredUserSubmissionCategory, userSubmissions=$userSubmissions, additionalProperties=$additionalProperties}"
    }

    /** If the Card Dispute's status is `won`, this will contain details of the won dispute. */
    class Win
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val wonAt: JsonField<OffsetDateTime>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("won_at")
            @ExcludeMissing
            wonAt: JsonField<OffsetDateTime> = JsonMissing.of()
        ) : this(wonAt, mutableMapOf())

        /**
         * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the Card
         * Dispute was won.
         *
         * @throws IncreaseInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun wonAt(): OffsetDateTime = wonAt.getRequired("won_at")

        /**
         * Returns the raw JSON value of [wonAt].
         *
         * Unlike [wonAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("won_at") @ExcludeMissing fun _wonAt(): JsonField<OffsetDateTime> = wonAt

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Win].
             *
             * The following fields are required:
             * ```kotlin
             * .wonAt()
             * ```
             */
            fun builder() = Builder()
        }

        /** A builder for [Win]. */
        class Builder internal constructor() {

            private var wonAt: JsonField<OffsetDateTime>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(win: Win) = apply {
                wonAt = win.wonAt
                additionalProperties = win.additionalProperties.toMutableMap()
            }

            /**
             * The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date and time at which the
             * Card Dispute was won.
             */
            fun wonAt(wonAt: OffsetDateTime) = wonAt(JsonField.of(wonAt))

            /**
             * Sets [Builder.wonAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.wonAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun wonAt(wonAt: JsonField<OffsetDateTime>) = apply { this.wonAt = wonAt }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Win].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```kotlin
             * .wonAt()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Win =
                Win(checkRequired("wonAt", wonAt), additionalProperties.toMutableMap())
        }

        private var validated: Boolean = false

        fun validate(): Win = apply {
            if (validated) {
                return@apply
            }

            wonAt()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: IncreaseInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        internal fun validity(): Int = (if (wonAt.asKnown() == null) 0 else 1)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Win &&
                wonAt == other.wonAt &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy { Objects.hash(wonAt, additionalProperties) }

        override fun hashCode(): Int = hashCode

        override fun toString() = "Win{wonAt=$wonAt, additionalProperties=$additionalProperties}"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is CardDispute &&
            id == other.id &&
            amount == other.amount &&
            cardId == other.cardId &&
            createdAt == other.createdAt &&
            disputedTransactionId == other.disputedTransactionId &&
            idempotencyKey == other.idempotencyKey &&
            loss == other.loss &&
            network == other.network &&
            status == other.status &&
            type == other.type &&
            userSubmissionRequiredBy == other.userSubmissionRequiredBy &&
            visa == other.visa &&
            win == other.win &&
            additionalProperties == other.additionalProperties
    }

    private val hashCode: Int by lazy {
        Objects.hash(
            id,
            amount,
            cardId,
            createdAt,
            disputedTransactionId,
            idempotencyKey,
            loss,
            network,
            status,
            type,
            userSubmissionRequiredBy,
            visa,
            win,
            additionalProperties,
        )
    }

    override fun hashCode(): Int = hashCode

    override fun toString() =
        "CardDispute{id=$id, amount=$amount, cardId=$cardId, createdAt=$createdAt, disputedTransactionId=$disputedTransactionId, idempotencyKey=$idempotencyKey, loss=$loss, network=$network, status=$status, type=$type, userSubmissionRequiredBy=$userSubmissionRequiredBy, visa=$visa, win=$win, additionalProperties=$additionalProperties}"
}
