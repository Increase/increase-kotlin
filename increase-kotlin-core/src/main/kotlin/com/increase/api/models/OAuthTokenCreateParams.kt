// File generated from our OpenAPI spec by Stainless.

package com.increase.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.google.common.collect.ArrayListMultimap
import com.google.common.collect.ListMultimap
import com.increase.api.core.Enum
import com.increase.api.core.ExcludeMissing
import com.increase.api.core.JsonField
import com.increase.api.core.JsonValue
import com.increase.api.core.NoAutoDetect
import com.increase.api.core.toImmutable
import com.increase.api.errors.IncreaseInvalidDataException
import com.increase.api.models.*
import java.util.Objects

class OAuthTokenCreateParams
constructor(
    private val grantType: GrantType,
    private val clientId: String?,
    private val clientSecret: String?,
    private val code: String?,
    private val productionToken: String?,
    private val additionalHeaders: Map<String, List<String>>,
    private val additionalQueryParams: Map<String, List<String>>,
    private val additionalBodyProperties: Map<String, JsonValue>,
) {

    fun grantType(): GrantType = grantType

    fun clientId(): String? = clientId

    fun clientSecret(): String? = clientSecret

    fun code(): String? = code

    fun productionToken(): String? = productionToken

    internal fun getBody(): OAuthTokenCreateBody {
        return OAuthTokenCreateBody(
            grantType,
            clientId,
            clientSecret,
            code,
            productionToken,
            additionalBodyProperties,
        )
    }

    internal fun getHeaders(): Map<String, List<String>> = additionalHeaders

    internal fun getQueryParams(): Map<String, List<String>> = additionalQueryParams

    @JsonDeserialize(builder = OAuthTokenCreateBody.Builder::class)
    @NoAutoDetect
    class OAuthTokenCreateBody
    internal constructor(
        private val grantType: GrantType?,
        private val clientId: String?,
        private val clientSecret: String?,
        private val code: String?,
        private val productionToken: String?,
        private val additionalProperties: Map<String, JsonValue>,
    ) {

        /**
         * The credential you request in exchange for the code. In Production, this is always
         * `authorization_code`. In Sandbox, you can pass either enum value.
         */
        @JsonProperty("grant_type") fun grantType(): GrantType? = grantType

        /** The public identifier for your application. */
        @JsonProperty("client_id") fun clientId(): String? = clientId

        /**
         * The secret that confirms you own the application. This is redundent given that the
         * request is made with your API key but it's a required component of OAuth 2.0.
         */
        @JsonProperty("client_secret") fun clientSecret(): String? = clientSecret

        /** The authorization code generated by the user and given to you as a query parameter. */
        @JsonProperty("code") fun code(): String? = code

        /**
         * The production token you want to exchange for a sandbox token. This is only available in
         * Sandbox. Set `grant_type` to `production_token` to use this parameter.
         */
        @JsonProperty("production_token") fun productionToken(): String? = productionToken

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        fun toBuilder() = Builder().from(this)

        companion object {

            fun builder() = Builder()
        }

        class Builder {

            private var grantType: GrantType? = null
            private var clientId: String? = null
            private var clientSecret: String? = null
            private var code: String? = null
            private var productionToken: String? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            internal fun from(oauthTokenCreateBody: OAuthTokenCreateBody) = apply {
                this.grantType = oauthTokenCreateBody.grantType
                this.clientId = oauthTokenCreateBody.clientId
                this.clientSecret = oauthTokenCreateBody.clientSecret
                this.code = oauthTokenCreateBody.code
                this.productionToken = oauthTokenCreateBody.productionToken
                additionalProperties(oauthTokenCreateBody.additionalProperties)
            }

            /**
             * The credential you request in exchange for the code. In Production, this is always
             * `authorization_code`. In Sandbox, you can pass either enum value.
             */
            @JsonProperty("grant_type")
            fun grantType(grantType: GrantType) = apply { this.grantType = grantType }

            /** The public identifier for your application. */
            @JsonProperty("client_id")
            fun clientId(clientId: String) = apply { this.clientId = clientId }

            /**
             * The secret that confirms you own the application. This is redundent given that the
             * request is made with your API key but it's a required component of OAuth 2.0.
             */
            @JsonProperty("client_secret")
            fun clientSecret(clientSecret: String) = apply { this.clientSecret = clientSecret }

            /**
             * The authorization code generated by the user and given to you as a query parameter.
             */
            @JsonProperty("code") fun code(code: String) = apply { this.code = code }

            /**
             * The production token you want to exchange for a sandbox token. This is only available
             * in Sandbox. Set `grant_type` to `production_token` to use this parameter.
             */
            @JsonProperty("production_token")
            fun productionToken(productionToken: String) = apply {
                this.productionToken = productionToken
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                this.additionalProperties.putAll(additionalProperties)
            }

            @JsonAnySetter
            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                this.additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun build(): OAuthTokenCreateBody =
                OAuthTokenCreateBody(
                    checkNotNull(grantType) { "`grantType` is required but was not set" },
                    clientId,
                    clientSecret,
                    code,
                    productionToken,
                    additionalProperties.toImmutable(),
                )
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is OAuthTokenCreateBody && this.grantType == other.grantType && this.clientId == other.clientId && this.clientSecret == other.clientSecret && this.code == other.code && this.productionToken == other.productionToken && this.additionalProperties == other.additionalProperties /* spotless:on */
        }

        private var hashCode: Int = 0

        override fun hashCode(): Int {
            if (hashCode == 0) {
                hashCode = /* spotless:off */ Objects.hash(grantType, clientId, clientSecret, code, productionToken, additionalProperties) /* spotless:on */
            }
            return hashCode
        }

        override fun toString() =
            "OAuthTokenCreateBody{grantType=$grantType, clientId=$clientId, clientSecret=$clientSecret, code=$code, productionToken=$productionToken, additionalProperties=$additionalProperties}"
    }

    fun _additionalHeaders(): Map<String, List<String>> = additionalHeaders

    fun _additionalQueryParams(): Map<String, List<String>> = additionalQueryParams

    fun _additionalBodyProperties(): Map<String, JsonValue> = additionalBodyProperties

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is OAuthTokenCreateParams && this.grantType == other.grantType && this.clientId == other.clientId && this.clientSecret == other.clientSecret && this.code == other.code && this.productionToken == other.productionToken && this.additionalHeaders == other.additionalHeaders && this.additionalQueryParams == other.additionalQueryParams && this.additionalBodyProperties == other.additionalBodyProperties /* spotless:on */
    }

    override fun hashCode(): Int {
        return /* spotless:off */ Objects.hash(grantType, clientId, clientSecret, code, productionToken, additionalHeaders, additionalQueryParams, additionalBodyProperties) /* spotless:on */
    }

    override fun toString() =
        "OAuthTokenCreateParams{grantType=$grantType, clientId=$clientId, clientSecret=$clientSecret, code=$code, productionToken=$productionToken, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams, additionalBodyProperties=$additionalBodyProperties}"

    fun toBuilder() = Builder().from(this)

    companion object {

        fun builder() = Builder()
    }

    @NoAutoDetect
    class Builder {

        private var grantType: GrantType? = null
        private var clientId: String? = null
        private var clientSecret: String? = null
        private var code: String? = null
        private var productionToken: String? = null
        private var additionalHeaders: ListMultimap<String, String> = ArrayListMultimap.create()
        private var additionalQueryParams: ListMultimap<String, String> = ArrayListMultimap.create()
        private var additionalBodyProperties: MutableMap<String, JsonValue> = mutableMapOf()

        internal fun from(oauthTokenCreateParams: OAuthTokenCreateParams) = apply {
            this.grantType = oauthTokenCreateParams.grantType
            this.clientId = oauthTokenCreateParams.clientId
            this.clientSecret = oauthTokenCreateParams.clientSecret
            this.code = oauthTokenCreateParams.code
            this.productionToken = oauthTokenCreateParams.productionToken
            additionalHeaders(oauthTokenCreateParams.additionalHeaders)
            additionalQueryParams(oauthTokenCreateParams.additionalQueryParams)
            additionalBodyProperties(oauthTokenCreateParams.additionalBodyProperties)
        }

        /**
         * The credential you request in exchange for the code. In Production, this is always
         * `authorization_code`. In Sandbox, you can pass either enum value.
         */
        fun grantType(grantType: GrantType) = apply { this.grantType = grantType }

        /** The public identifier for your application. */
        fun clientId(clientId: String) = apply { this.clientId = clientId }

        /**
         * The secret that confirms you own the application. This is redundent given that the
         * request is made with your API key but it's a required component of OAuth 2.0.
         */
        fun clientSecret(clientSecret: String) = apply { this.clientSecret = clientSecret }

        /** The authorization code generated by the user and given to you as a query parameter. */
        fun code(code: String) = apply { this.code = code }

        /**
         * The production token you want to exchange for a sandbox token. This is only available in
         * Sandbox. Set `grant_type` to `production_token` to use this parameter.
         */
        fun productionToken(productionToken: String) = apply {
            this.productionToken = productionToken
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.putAll(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            additionalHeaders.forEach(::putAdditionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replaceValues(name, listOf(value))
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replaceValues(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            additionalHeaders.forEach(::replaceAdditionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.removeAll(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            names.forEach(::removeAdditionalHeaders)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.putAll(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                additionalQueryParams.forEach(::putAdditionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replaceValues(key, listOf(value))
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replaceValues(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                additionalQueryParams.forEach(::replaceAdditionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply {
            additionalQueryParams.removeAll(key)
        }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            keys.forEach(::removeAdditionalQueryParams)
        }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            this.additionalBodyProperties.clear()
            this.additionalBodyProperties.putAll(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            this.additionalBodyProperties.put(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                this.additionalBodyProperties.putAll(additionalBodyProperties)
            }

        fun build(): OAuthTokenCreateParams =
            OAuthTokenCreateParams(
                checkNotNull(grantType) { "`grantType` is required but was not set" },
                clientId,
                clientSecret,
                code,
                productionToken,
                additionalHeaders
                    .asMap()
                    .mapValues { it.value.toList().toImmutable() }
                    .toImmutable(),
                additionalQueryParams
                    .asMap()
                    .mapValues { it.value.toList().toImmutable() }
                    .toImmutable(),
                additionalBodyProperties.toImmutable(),
            )
    }

    class GrantType
    @JsonCreator
    private constructor(
        private val value: JsonField<String>,
    ) : Enum {

        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GrantType && this.value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()

        companion object {

            val AUTHORIZATION_CODE = GrantType(JsonField.of("authorization_code"))

            val PRODUCTION_TOKEN = GrantType(JsonField.of("production_token"))

            fun of(value: String) = GrantType(JsonField.of(value))
        }

        enum class Known {
            AUTHORIZATION_CODE,
            PRODUCTION_TOKEN,
        }

        enum class Value {
            AUTHORIZATION_CODE,
            PRODUCTION_TOKEN,
            _UNKNOWN,
        }

        fun value(): Value =
            when (this) {
                AUTHORIZATION_CODE -> Value.AUTHORIZATION_CODE
                PRODUCTION_TOKEN -> Value.PRODUCTION_TOKEN
                else -> Value._UNKNOWN
            }

        fun known(): Known =
            when (this) {
                AUTHORIZATION_CODE -> Known.AUTHORIZATION_CODE
                PRODUCTION_TOKEN -> Known.PRODUCTION_TOKEN
                else -> throw IncreaseInvalidDataException("Unknown GrantType: $value")
            }

        fun asString(): String = _value().asStringOrThrow()
    }
}
